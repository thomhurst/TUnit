using TUnit.Mock.SourceGenerator.Models;

namespace TUnit.Mock.SourceGenerator.Builders;

internal static class MockRaiseBuilder
{
    public static string Build(MockTypeModel model)
    {
        var writer = new CodeWriter();
        var safeName = MockImplBuilder.GetSafeName(model.FullyQualifiedName);

        writer.AppendLine("// <auto-generated/>");
        writer.AppendLine("#nullable enable");
        writer.AppendLine();

        using (writer.Block("namespace TUnit.Mock.Generated"))
        {
            // Data holder class implementing marker interface
            using (writer.Block($"public sealed class {safeName}_MockRaise : global::TUnit.Mock.IMockRaise<{model.FullyQualifiedName}>"))
            {
                writer.AppendLine($"internal readonly {safeName}_MockImpl Impl;");
                writer.AppendLine();
                writer.AppendLine($"internal {safeName}_MockRaise({safeName}_MockImpl impl) => Impl = impl;");
            }

            writer.AppendLine();

            // Extension methods class
            using (writer.Block($"public static class {safeName}_MockRaiseExtensions"))
            {
                bool firstMember = true;
                foreach (var evt in model.Events)
                {
                    if (!firstMember) writer.AppendLine();
                    firstMember = false;
                    GenerateRaiseMethod(writer, evt, model, safeName);
                }
            }
        }

        return writer.ToString();
    }

    private static void GenerateRaiseMethod(CodeWriter writer, MockEventModel evt, MockTypeModel model, string safeName)
    {
        var extensionParam = $"this global::TUnit.Mock.IMockRaise<{model.FullyQualifiedName}> raise";

        using (writer.Block($"public static void {evt.Name}({extensionParam}, {evt.EventArgsType} args)"))
        {
            writer.AppendLine($"var r = ({safeName}_MockRaise)raise;");
            writer.AppendLine($"r.Impl.Raise_{evt.Name}(args);");
        }
    }
}
