using TUnit.Mock.SourceGenerator.Models;

namespace TUnit.Mock.SourceGenerator.Builders;

internal static class MockImplBuilder
{
    public static string Build(MockTypeModel model)
    {
        var writer = new CodeWriter();
        var safeName = GetSafeName(model.Name);

        writer.AppendLine("// <auto-generated/>");
        writer.AppendLine("#nullable enable");
        writer.AppendLine();

        using (writer.Block("namespace TUnit.Mock.Generated"))
        {
            if (model.IsPartialMock && !model.IsInterface)
            {
                BuildPartialMockImpl(writer, model, safeName);
            }
            else
            {
                BuildInterfaceMockImpl(writer, model, safeName);
            }
        }

        return writer.ToString();
    }

    private static void BuildInterfaceMockImpl(CodeWriter writer, MockTypeModel model, string safeName)
    {
        using (writer.Block($"internal sealed class {safeName}_MockImpl : {model.FullyQualifiedName}"))
        {
            writer.AppendLine($"private readonly global::TUnit.Mock.MockEngine<{model.FullyQualifiedName}> _engine;");
            writer.AppendLine();

            // Constructor
            using (writer.Block($"internal {safeName}_MockImpl(global::TUnit.Mock.MockEngine<{model.FullyQualifiedName}> engine)"))
            {
                writer.AppendLine("_engine = engine;");
            }

            // Methods
            foreach (var method in model.Methods)
            {
                writer.AppendLine();
                GenerateInterfaceMethod(writer, method, model);
            }

            // Properties
            foreach (var prop in model.Properties)
            {
                if (prop.IsIndexer) continue;
                writer.AppendLine();
                GenerateInterfaceProperty(writer, prop, model);
            }

            // Events
            foreach (var evt in model.Events)
            {
                writer.AppendLine();
                GenerateEvent(writer, evt);
            }
        }
    }

    private static void BuildPartialMockImpl(CodeWriter writer, MockTypeModel model, string safeName)
    {
        using (writer.Block($"internal sealed class {safeName}_MockImpl : {model.FullyQualifiedName}"))
        {
            writer.AppendLine($"private readonly global::TUnit.Mock.MockEngine<{model.FullyQualifiedName}> _engine;");
            writer.AppendLine();

            // Generate constructors that pass through to base
            GeneratePartialConstructors(writer, model, safeName);

            // Methods
            foreach (var method in model.Methods)
            {
                writer.AppendLine();
                GeneratePartialMethod(writer, method, model);
            }

            // Properties
            foreach (var prop in model.Properties)
            {
                if (prop.IsIndexer) continue;
                writer.AppendLine();
                GeneratePartialProperty(writer, prop, model);
            }

            // Events - for partial mocks, events need override
            foreach (var evt in model.Events)
            {
                writer.AppendLine();
                GeneratePartialEvent(writer, evt);
            }
        }
    }

    private static void GeneratePartialConstructors(CodeWriter writer, MockTypeModel model, string safeName)
    {
        if (model.Constructors.Length == 0)
        {
            // No explicit constructors found, generate a default one
            using (writer.Block($"internal {safeName}_MockImpl(global::TUnit.Mock.MockEngine<{model.FullyQualifiedName}> engine)"))
            {
                writer.AppendLine("_engine = engine;");
            }
            return;
        }

        foreach (var ctor in model.Constructors)
        {
            if (ctor.Parameters.Length == 0)
            {
                // Parameterless constructor
                using (writer.Block($"internal {safeName}_MockImpl(global::TUnit.Mock.MockEngine<{model.FullyQualifiedName}> engine) : base()"))
                {
                    writer.AppendLine("_engine = engine;");
                }
            }
            else
            {
                // Constructor with parameters - pass them through to base
                var paramList = string.Join(", ", ctor.Parameters.Select(p => $"{p.FullyQualifiedType} {p.Name}"));
                var argList = string.Join(", ", ctor.Parameters.Select(p => p.Name));
                using (writer.Block($"internal {safeName}_MockImpl(global::TUnit.Mock.MockEngine<{model.FullyQualifiedName}> engine, {paramList}) : base({argList})"))
                {
                    writer.AppendLine("_engine = engine;");
                }
            }
        }
    }

    private static void GenerateInterfaceMethod(CodeWriter writer, MockMemberModel method, MockTypeModel model)
    {
        var signatureReturnType = (method.IsVoid && !method.IsAsync) ? "void" : method.ReturnType;
        var paramList = GetParameterList(method);
        var typeParams = GetTypeParameterList(method);
        var constraints = GetConstraintClauses(method);

        using (writer.Block($"public {signatureReturnType} {method.Name}{typeParams}({paramList}){constraints}"))
        {
            GenerateEngineDispatchBody(writer, method);
        }
    }

    private static void GeneratePartialMethod(CodeWriter writer, MockMemberModel method, MockTypeModel model)
    {
        var signatureReturnType = (method.IsVoid && !method.IsAsync) ? "void" : method.ReturnType;
        var paramList = GetParameterList(method);
        var typeParams = GetTypeParameterList(method);
        var constraints = GetConstraintClauses(method);

        // For partial mocks, all methods get "override" since we only discover virtual/abstract/override members
        using (writer.Block($"public override {signatureReturnType} {method.Name}{typeParams}({paramList}){constraints}"))
        {
            if (method.IsAbstractMember)
            {
                // Abstract methods: same as interface methods - dispatch through engine
                GenerateEngineDispatchBody(writer, method);
            }
            else
            {
                // Virtual/override methods: try engine first, fall back to base
                GeneratePartialMethodBody(writer, method);
            }
        }
    }

    private static void GeneratePartialMethodBody(CodeWriter writer, MockMemberModel method)
    {
        // Initialize out parameters
        foreach (var p in method.Parameters)
        {
            if (p.Direction == ParameterDirection.Out)
            {
                writer.AppendLine($"{p.Name} = default!;");
            }
        }

        var argsArray = GetArgsArrayExpression(method);
        var argPassList = GetArgPassList(method);

        if (method.IsVoid && !method.IsAsync)
        {
            // void virtual method
            writer.AppendLine($"if (_engine.TryHandleCall({method.MemberId}, \"{method.Name}\", {argsArray}))");
            writer.AppendLine("{");
            writer.IncreaseIndent();
            writer.AppendLine("return;");
            writer.DecreaseIndent();
            writer.AppendLine("}");
            writer.AppendLine($"base.{method.Name}({argPassList});");
        }
        else if (method.IsVoid && method.IsAsync)
        {
            // async void virtual method (Task/ValueTask)
            writer.AppendLine($"if (_engine.TryHandleCall({method.MemberId}, \"{method.Name}\", {argsArray}))");
            writer.AppendLine("{");
            writer.IncreaseIndent();
            if (method.IsValueTask)
            {
                writer.AppendLine("return default(global::System.Threading.Tasks.ValueTask);");
            }
            else
            {
                writer.AppendLine("return global::System.Threading.Tasks.Task.CompletedTask;");
            }
            writer.DecreaseIndent();
            writer.AppendLine("}");
            writer.AppendLine($"return base.{method.Name}({argPassList});");
        }
        else if (method.IsAsync)
        {
            // async method with return (Task<T>/ValueTask<T>)
            writer.AppendLine($"if (_engine.TryHandleCallWithReturn<{method.UnwrappedReturnType}>({method.MemberId}, \"{method.Name}\", {argsArray}, {method.UnwrappedSmartDefault}, out var __result))");
            writer.AppendLine("{");
            writer.IncreaseIndent();
            if (method.IsValueTask)
            {
                writer.AppendLine($"return new global::System.Threading.Tasks.ValueTask<{method.UnwrappedReturnType}>(__result);");
            }
            else
            {
                writer.AppendLine($"return global::System.Threading.Tasks.Task.FromResult<{method.UnwrappedReturnType}>(__result);");
            }
            writer.DecreaseIndent();
            writer.AppendLine("}");
            writer.AppendLine($"return base.{method.Name}({argPassList});");
        }
        else
        {
            // synchronous method with return value
            writer.AppendLine($"if (_engine.TryHandleCallWithReturn<{method.ReturnType}>({method.MemberId}, \"{method.Name}\", {argsArray}, {method.SmartDefault}, out var __result))");
            writer.AppendLine("{");
            writer.IncreaseIndent();
            writer.AppendLine("return __result;");
            writer.DecreaseIndent();
            writer.AppendLine("}");
            writer.AppendLine($"return base.{method.Name}({argPassList});");
        }
    }

    private static void GenerateEngineDispatchBody(CodeWriter writer, MockMemberModel method)
    {
        // Initialize out parameters
        foreach (var p in method.Parameters)
        {
            if (p.Direction == ParameterDirection.Out)
            {
                writer.AppendLine($"{p.Name} = default!;");
            }
        }

        var argsArray = GetArgsArrayExpression(method);

        if (method.IsVoid && !method.IsAsync)
        {
            // Pure void method
            writer.AppendLine($"_engine.HandleCall({method.MemberId}, \"{method.Name}\", {argsArray});");
        }
        else if (method.IsVoid && method.IsAsync)
        {
            // Async void method (Task or ValueTask with no generic arg)
            using (writer.Block("try"))
            {
                writer.AppendLine($"_engine.HandleCall({method.MemberId}, \"{method.Name}\", {argsArray});");
                if (method.IsValueTask)
                {
                    writer.AppendLine("return default(global::System.Threading.Tasks.ValueTask);");
                }
                else
                {
                    writer.AppendLine("return global::System.Threading.Tasks.Task.CompletedTask;");
                }
            }
            using (writer.Block("catch (global::System.Exception __ex)"))
            {
                if (method.IsValueTask)
                {
                    writer.AppendLine("return new global::System.Threading.Tasks.ValueTask(global::System.Threading.Tasks.Task.FromException(__ex));");
                }
                else
                {
                    writer.AppendLine("return global::System.Threading.Tasks.Task.FromException(__ex);");
                }
            }
        }
        else if (method.IsAsync)
        {
            // Async method with return value (Task<T> or ValueTask<T>)
            using (writer.Block("try"))
            {
                writer.AppendLine($"var __result = _engine.HandleCallWithReturn<{method.UnwrappedReturnType}>({method.MemberId}, \"{method.Name}\", {argsArray}, {method.UnwrappedSmartDefault});");
                if (method.IsValueTask)
                {
                    writer.AppendLine($"return new global::System.Threading.Tasks.ValueTask<{method.UnwrappedReturnType}>(__result);");
                }
                else
                {
                    writer.AppendLine($"return global::System.Threading.Tasks.Task.FromResult<{method.UnwrappedReturnType}>(__result);");
                }
            }
            using (writer.Block("catch (global::System.Exception __ex)"))
            {
                if (method.IsValueTask)
                {
                    writer.AppendLine($"return new global::System.Threading.Tasks.ValueTask<{method.UnwrappedReturnType}>(global::System.Threading.Tasks.Task.FromException<{method.UnwrappedReturnType}>(__ex));");
                }
                else
                {
                    writer.AppendLine($"return global::System.Threading.Tasks.Task.FromException<{method.UnwrappedReturnType}>(__ex);");
                }
            }
        }
        else
        {
            // Synchronous method with return value
            writer.AppendLine($"return _engine.HandleCallWithReturn<{method.ReturnType}>({method.MemberId}, \"{method.Name}\", {argsArray}, {method.SmartDefault});");
        }
    }

    private static void GenerateInterfaceProperty(CodeWriter writer, MockMemberModel prop, MockTypeModel model)
    {
        writer.AppendLine($"public {prop.ReturnType} {prop.Name}");
        writer.OpenBrace();

        if (prop.HasGetter)
        {
            writer.AppendLine($"get => _engine.HandleCallWithReturn<{prop.ReturnType}>({prop.MemberId}, \"get_{prop.Name}\", global::System.Array.Empty<object?>(), {prop.SmartDefault});");
        }

        if (prop.HasSetter)
        {
            writer.AppendLine($"set => _engine.HandleCall({prop.MemberId + 10000}, \"set_{prop.Name}\", new object?[] {{ value }});");
        }

        writer.CloseBrace();
    }

    private static void GeneratePartialProperty(CodeWriter writer, MockMemberModel prop, MockTypeModel model)
    {
        writer.AppendLine($"public override {prop.ReturnType} {prop.Name}");
        writer.OpenBrace();

        if (prop.HasGetter)
        {
            if (prop.IsAbstractMember)
            {
                writer.AppendLine($"get => _engine.HandleCallWithReturn<{prop.ReturnType}>({prop.MemberId}, \"get_{prop.Name}\", global::System.Array.Empty<object?>(), {prop.SmartDefault});");
            }
            else
            {
                // Virtual property getter: try engine, fall back to base
                writer.AppendLine("get");
                writer.OpenBrace();
                writer.AppendLine($"if (_engine.TryHandleCallWithReturn<{prop.ReturnType}>({prop.MemberId}, \"get_{prop.Name}\", global::System.Array.Empty<object?>(), {prop.SmartDefault}, out var __result))");
                writer.AppendLine("{");
                writer.IncreaseIndent();
                writer.AppendLine("return __result;");
                writer.DecreaseIndent();
                writer.AppendLine("}");
                writer.AppendLine($"return base.{prop.Name};");
                writer.CloseBrace();
            }
        }

        if (prop.HasSetter)
        {
            if (prop.IsAbstractMember)
            {
                writer.AppendLine($"set => _engine.HandleCall({prop.MemberId + 10000}, \"set_{prop.Name}\", new object?[] {{ value }});");
            }
            else
            {
                // Virtual property setter: try engine, fall back to base
                writer.AppendLine("set");
                writer.OpenBrace();
                writer.AppendLine($"if (!_engine.TryHandleCall({prop.MemberId + 10000}, \"set_{prop.Name}\", new object?[] {{ value }}))");
                writer.AppendLine("{");
                writer.IncreaseIndent();
                writer.AppendLine($"base.{prop.Name} = value;");
                writer.DecreaseIndent();
                writer.AppendLine("}");
                writer.CloseBrace();
            }
        }

        writer.CloseBrace();
    }

    private static void GenerateEvent(CodeWriter writer, MockEventModel evt)
    {
        // Backing delegate field
        writer.AppendLine($"private {evt.EventHandlerType}? _backing_{evt.Name};");
        writer.AppendLine();

        // Event add/remove accessors
        writer.AppendLine($"public event {evt.EventHandlerType}? {evt.Name}");
        writer.OpenBrace();
        writer.AppendLine($"add => _backing_{evt.Name} += value;");
        writer.AppendLine($"remove => _backing_{evt.Name} -= value;");
        writer.CloseBrace();
        writer.AppendLine();

        // Raise method for generated code to call
        writer.AppendLine("[global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]");
        using (writer.Block($"internal void Raise_{evt.Name}({evt.EventArgsType} args)"))
        {
            writer.AppendLine($"_backing_{evt.Name}?.Invoke(this, args);");
        }
    }

    private static void GeneratePartialEvent(CodeWriter writer, MockEventModel evt)
    {
        // Backing delegate field
        writer.AppendLine($"private {evt.EventHandlerType}? _backing_{evt.Name};");
        writer.AppendLine();

        // Event add/remove accessors with override
        writer.AppendLine($"public override event {evt.EventHandlerType}? {evt.Name}");
        writer.OpenBrace();
        writer.AppendLine($"add => _backing_{evt.Name} += value;");
        writer.AppendLine($"remove => _backing_{evt.Name} -= value;");
        writer.CloseBrace();
        writer.AppendLine();

        // Raise method for generated code to call
        writer.AppendLine("[global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]");
        using (writer.Block($"internal void Raise_{evt.Name}({evt.EventArgsType} args)"))
        {
            writer.AppendLine($"_backing_{evt.Name}?.Invoke(this, args);");
        }
    }

    private static string GetParameterList(MockMemberModel method)
    {
        return string.Join(", ", method.Parameters.Select(p =>
        {
            var direction = p.Direction switch
            {
                ParameterDirection.Out => "out ",
                ParameterDirection.Ref => "ref ",
                ParameterDirection.In_Readonly => "in ",
                _ => ""
            };
            return $"{direction}{p.FullyQualifiedType} {p.Name}";
        }));
    }

    private static string GetTypeParameterList(MockMemberModel method)
    {
        if (method.TypeParameters.Length == 0) return "";
        return "<" + string.Join(", ", method.TypeParameters.Select(tp => tp.Name)) + ">";
    }

    private static string GetConstraintClauses(MockMemberModel method)
    {
        var clauses = new List<string>();
        foreach (var tp in method.TypeParameters)
        {
            if (!string.IsNullOrEmpty(tp.Constraints))
            {
                clauses.Add($"where {tp.Name} : {tp.Constraints}");
            }
        }
        return clauses.Count > 0 ? " " + string.Join(" ", clauses) : "";
    }

    private static string GetArgsArrayExpression(MockMemberModel method)
    {
        // Only include non-out parameters in args array
        var matchableParams = method.Parameters.Where(p => p.Direction != ParameterDirection.Out).ToList();
        if (matchableParams.Count == 0) return "global::System.Array.Empty<object?>()";
        var args = string.Join(", ", matchableParams.Select(p => p.Name));
        return $"new object?[] {{ {args} }}";
    }

    /// <summary>
    /// Gets the argument pass-through list for calling base.Method(), preserving ref/out/in directions.
    /// </summary>
    private static string GetArgPassList(MockMemberModel method)
    {
        return string.Join(", ", method.Parameters.Select(p =>
        {
            var direction = p.Direction switch
            {
                ParameterDirection.Out => "out ",
                ParameterDirection.Ref => "ref ",
                ParameterDirection.In_Readonly => "in ",
                _ => ""
            };
            return $"{direction}{p.Name}";
        }));
    }

    public static string GetSafeName(string typeName)
    {
        // Remove invalid characters for a C# identifier
        return typeName.Replace(".", "_").Replace("<", "_").Replace(">", "_").Replace(",", "_").Replace(" ", "");
    }
}
