using TUnit.Mock.SourceGenerator.Models;

namespace TUnit.Mock.SourceGenerator.Builders;

internal static class MockFactoryBuilder
{
    public static string Build(MockTypeModel model)
    {
        var writer = new CodeWriter();
        var safeName = MockImplBuilder.GetCompositeSafeName(model);

        writer.AppendLine("// <auto-generated/>");
        writer.AppendLine("#nullable enable");
        writer.AppendLine();

        using (writer.Block("namespace TUnit.Mock.Generated"))
        {
            if (model.IsWrapMock)
            {
                BuildWrapFactory(writer, model, safeName);
            }
            else if (model.IsPartialMock && !model.IsInterface)
            {
                BuildPartialFactory(writer, model, safeName);
            }
            else
            {
                BuildInterfaceFactory(writer, model, safeName);
            }
        }

        return writer.ToString();
    }

    private static void BuildInterfaceFactory(CodeWriter writer, MockTypeModel model, string safeName)
    {
        var factoryClassName = model.AdditionalInterfaceNames.Length > 0
            ? $"{safeName}_Multi_MockFactory"
            : $"{safeName}_MockFactory";

        using (writer.Block($"internal static class {factoryClassName}"))
        {
            writer.AppendLine("[global::System.Runtime.CompilerServices.ModuleInitializer]");
            using (writer.Block("internal static void Register()"))
            {
                if (model.AdditionalInterfaceNames.Length > 0)
                {
                    // Register as multi-interface factory with compound key
                    var allTypes = new[] { model.FullyQualifiedName }
                        .Concat(model.AdditionalInterfaceNames)
                        .Select(t => $"typeof({t}).FullName");
                    var keyExpr = "string.Join(\"|\", new[] { " + string.Join(", ", allTypes) + " })";
                    writer.AppendLine($"global::TUnit.Mock.Mock.RegisterMultiFactory({keyExpr}, Create);");
                }
                else
                {
                    writer.AppendLine($"global::TUnit.Mock.Mock.RegisterFactory<{model.FullyQualifiedName}>(Create);");
                }
            }
            writer.AppendLine();

            using (writer.Block($"private static global::TUnit.Mock.Mock<{model.FullyQualifiedName}> Create(global::TUnit.Mock.MockBehavior behavior)"))
            {
                // For multi-interface mocks: impl uses composite name, setup/verify use primary name
                var primarySafeName = MockImplBuilder.GetSafeName(model.FullyQualifiedName);

                writer.AppendLine($"var engine = new global::TUnit.Mock.MockEngine<{model.FullyQualifiedName}>(behavior);");
                writer.AppendLine($"var impl = new {safeName}_MockImpl(engine);");
                writer.AppendLine("engine.Raisable = impl;");
                writer.AppendLine($"var setup = new {primarySafeName}_MockSetup(engine);");
                writer.AppendLine($"var verify = new {primarySafeName}_MockVerify(engine);");

                // Events: check primary type events (from the single-type model)
                // For multi-interface, we only use primary type's raise surface
                if (model.Events.Length > 0 && model.AdditionalInterfaceNames.Length == 0)
                {
                    writer.AppendLine($"var raise = new {primarySafeName}_MockRaise(impl);");
                    writer.AppendLine($"var mock = new global::TUnit.Mock.Mock<{model.FullyQualifiedName}>(impl, setup, verify, raise, engine);");
                }
                else
                {
                    writer.AppendLine($"var mock = new global::TUnit.Mock.Mock<{model.FullyQualifiedName}>(impl, setup, verify, engine);");
                }

                writer.AppendLine("return mock;");
            }
        }
    }

    private static void BuildWrapFactory(CodeWriter writer, MockTypeModel model, string safeName)
    {
        using (writer.Block($"internal static class {safeName}_WrapMockFactory"))
        {
            writer.AppendLine("[global::System.Runtime.CompilerServices.ModuleInitializer]");
            using (writer.Block("internal static void Register()"))
            {
                writer.AppendLine($"global::TUnit.Mock.Mock.RegisterWrapFactory<{model.FullyQualifiedName}>(Create);");
            }
            writer.AppendLine();

            using (writer.Block($"private static global::TUnit.Mock.Mock<{model.FullyQualifiedName}> Create(global::TUnit.Mock.MockBehavior behavior, {model.FullyQualifiedName} instance)"))
            {
                writer.AppendLine($"var engine = new global::TUnit.Mock.MockEngine<{model.FullyQualifiedName}>(behavior);");
                writer.AppendLine("engine.IsWrapMock = true;");
                writer.AppendLine($"var impl = new {safeName}_WrapMockImpl(engine, instance);");
                writer.AppendLine("engine.Raisable = impl;");
                writer.AppendLine($"var setup = new {safeName}_MockSetup(engine);");
                writer.AppendLine($"var verify = new {safeName}_MockVerify(engine);");
                if (model.Events.Length > 0)
                {
                    writer.AppendLine($"var raise = new {safeName}_MockRaise(impl);");
                    writer.AppendLine($"var mock = new global::TUnit.Mock.Mock<{model.FullyQualifiedName}>(impl, setup, verify, raise, engine);");
                }
                else
                {
                    writer.AppendLine($"var mock = new global::TUnit.Mock.Mock<{model.FullyQualifiedName}>(impl, setup, verify, engine);");
                }

                writer.AppendLine("return mock;");
            }
        }
    }

    private static void BuildPartialFactory(CodeWriter writer, MockTypeModel model, string safeName)
    {
        using (writer.Block($"internal static class {safeName}_PartialMockFactory"))
        {
            writer.AppendLine("[global::System.Runtime.CompilerServices.ModuleInitializer]");
            using (writer.Block("internal static void Register()"))
            {
                writer.AppendLine($"global::TUnit.Mock.Mock.RegisterPartialFactory<{model.FullyQualifiedName}>(Create);");
            }
            writer.AppendLine();

            using (writer.Block($"private static global::TUnit.Mock.Mock<{model.FullyQualifiedName}> Create(global::TUnit.Mock.MockBehavior behavior, object[] constructorArgs)"))
            {
                writer.AppendLine($"var engine = new global::TUnit.Mock.MockEngine<{model.FullyQualifiedName}>(behavior);");

                // Generate constructor dispatch based on available constructors
                GenerateConstructorDispatch(writer, model, safeName);

                writer.AppendLine("engine.Raisable = impl;");
                writer.AppendLine($"var setup = new {safeName}_MockSetup(engine);");
                writer.AppendLine($"var verify = new {safeName}_MockVerify(engine);");
                if (model.Events.Length > 0)
                {
                    writer.AppendLine($"var raise = new {safeName}_MockRaise(impl);");
                    writer.AppendLine($"var mock = new global::TUnit.Mock.Mock<{model.FullyQualifiedName}>(impl, setup, verify, raise, engine);");
                }
                else
                {
                    writer.AppendLine($"var mock = new global::TUnit.Mock.Mock<{model.FullyQualifiedName}>(impl, setup, verify, engine);");
                }

                writer.AppendLine("return mock;");
            }
        }
    }

    private static void GenerateConstructorDispatch(CodeWriter writer, MockTypeModel model, string safeName)
    {
        if (model.Constructors.Length == 0)
        {
            // No explicit constructors - just use parameterless
            writer.AppendLine($"var impl = new {safeName}_MockImpl(engine);");
            return;
        }

        // Check if there's a parameterless constructor
        var hasParameterless = model.Constructors.Any(c => c.Parameters.Length == 0);

        // Sort constructors by parameter count for dispatch
        var orderedCtors = model.Constructors
            .OrderBy(c => c.Parameters.Length)
            .ToList();

        // If there's only a parameterless constructor, simple case
        if (orderedCtors.Count == 1 && hasParameterless)
        {
            writer.AppendLine($"var impl = new {safeName}_MockImpl(engine);");
            return;
        }

        // Generate dispatch logic based on constructorArgs length and types
        writer.AppendLine($"{safeName}_MockImpl impl;");

        // Group constructors by arity to handle same-arity overloads
        var arityGroups = orderedCtors.GroupBy(c => c.Parameters.Length).OrderBy(g => g.Key).ToList();

        bool first = true;
        foreach (var group in arityGroups)
        {
            var keyword = first ? "if" : "else if";
            first = false;

            var ctorsInGroup = group.ToList();

            if (group.Key == 0)
            {
                using (writer.Block($"{keyword} (constructorArgs.Length == 0)"))
                {
                    writer.AppendLine($"impl = new {safeName}_MockImpl(engine);");
                }
            }
            else if (ctorsInGroup.Count == 1)
            {
                // Single constructor at this arity — simple dispatch
                var ctor = ctorsInGroup[0];
                using (writer.Block($"{keyword} (constructorArgs.Length == {group.Key})"))
                {
                    var castArgs = new List<string>();
                    for (int i = 0; i < ctor.Parameters.Length; i++)
                    {
                        var p = ctor.Parameters[i];
                        castArgs.Add($"({p.FullyQualifiedType})constructorArgs[{i}]");
                    }
                    var argList = string.Join(", ", castArgs);
                    writer.AppendLine($"impl = new {safeName}_MockImpl(engine, {argList});");
                }
            }
            else
            {
                // Multiple constructors at the same arity — type-check dispatch
                using (writer.Block($"{keyword} (constructorArgs.Length == {group.Key})"))
                {
                    bool innerFirst = true;
                    foreach (var ctor in ctorsInGroup)
                    {
                        var innerKeyword = innerFirst ? "if" : "else if";
                        innerFirst = false;

                        // Build type-check conditions for each parameter
                        var typeChecks = new List<string>();
                        var castArgs = new List<string>();
                        for (int i = 0; i < ctor.Parameters.Length; i++)
                        {
                            var p = ctor.Parameters[i];
                            typeChecks.Add($"constructorArgs[{i}] is {p.FullyQualifiedType}");
                            castArgs.Add($"({p.FullyQualifiedType})constructorArgs[{i}]");
                        }
                        var condition = string.Join(" && ", typeChecks);
                        var argList = string.Join(", ", castArgs);

                        using (writer.Block($"{innerKeyword} ({condition})"))
                        {
                            writer.AppendLine($"impl = new {safeName}_MockImpl(engine, {argList});");
                        }
                    }

                    using (writer.Block("else"))
                    {
                        writer.AppendLine($"throw new global::System.ArgumentException($\"No matching constructor found for type '{model.FullyQualifiedName}' with the provided argument types.\");");
                    }
                }
            }
        }

        using (writer.Block("else"))
        {
            writer.AppendLine($"throw new global::System.ArgumentException($\"No matching constructor found for type '{model.FullyQualifiedName}' with {{constructorArgs.Length}} argument(s).\");");
        }
    }
}
