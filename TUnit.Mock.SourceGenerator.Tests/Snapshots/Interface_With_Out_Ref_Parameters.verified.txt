// <auto-generated/>
#nullable enable

namespace TUnit.Mock.Generated
{
    internal sealed class IDictionary_MockImpl : global::IDictionary, global::TUnit.Mock.IRaisable
    {
        private readonly global::TUnit.Mock.MockEngine<global::IDictionary> _engine;

        internal IDictionary_MockImpl(global::TUnit.Mock.MockEngine<global::IDictionary> engine)
        {
            _engine = engine;
        }

        public bool TryGetValue(string key, out string value)
        {
            value = default!;
            return _engine.HandleCallWithReturn<bool>(0, "TryGetValue", new object?[] { key }, default);
        }

        public void Swap(ref int a, ref int b)
        {
            _engine.HandleCall(1, "Swap", new object?[] { a, b });
        }

        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public void RaiseEvent(string eventName, object? args)
        {
            throw new global::System.InvalidOperationException($"No event named '{eventName}' exists on this mock.");
        }
    }
}


// ===== FILE SEPARATOR =====

// <auto-generated/>
#nullable enable

namespace TUnit.Mock.Generated
{
    internal static class IDictionary_MockFactory
    {
        [global::System.Runtime.CompilerServices.ModuleInitializer]
        internal static void Register()
        {
            global::TUnit.Mock.Mock.RegisterFactory<global::IDictionary>(Create);
        }

        private static global::TUnit.Mock.Mock<global::IDictionary> Create(global::TUnit.Mock.MockBehavior behavior)
        {
            var engine = new global::TUnit.Mock.MockEngine<global::IDictionary>(behavior);
            var impl = new IDictionary_MockImpl(engine);
            engine.Raisable = impl;
            var setup = new IDictionary_MockSetup(engine);
            var verify = new IDictionary_MockVerify(engine);
            var mock = new global::TUnit.Mock.Mock<global::IDictionary>(impl, setup, verify, engine);
            return mock;
        }
    }
}


// ===== FILE SEPARATOR =====

// <auto-generated/>
#nullable enable

namespace TUnit.Mock.Generated
{
    public sealed class IDictionary_MockSetup : global::TUnit.Mock.IMockSetup<global::IDictionary>
    {
        internal readonly global::TUnit.Mock.MockEngine<global::IDictionary> Engine;

        internal IDictionary_MockSetup(global::TUnit.Mock.MockEngine<global::IDictionary> engine) => Engine = engine;
    }

    public static class IDictionary_MockSetupExtensions
    {
        public static global::TUnit.Mock.Setup.IMethodSetup<bool> TryGetValue(this global::TUnit.Mock.IMockSetup<global::IDictionary> setup, global::TUnit.Mock.Arguments.Arg<string> key)
        {
            var s = (IDictionary_MockSetup)setup;
            var matchers = new global::TUnit.Mock.Arguments.IArgumentMatcher[] { key.Matcher };
            var methodSetup = new global::TUnit.Mock.Setup.MethodSetup(0, matchers, "TryGetValue");
            s.Engine.AddSetup(methodSetup);
            return new global::TUnit.Mock.Setup.MethodSetupBuilder<bool>(methodSetup);
        }

        public static global::TUnit.Mock.Setup.IVoidMethodSetup Swap(this global::TUnit.Mock.IMockSetup<global::IDictionary> setup, global::TUnit.Mock.Arguments.Arg<int> a, global::TUnit.Mock.Arguments.Arg<int> b)
        {
            var s = (IDictionary_MockSetup)setup;
            var matchers = new global::TUnit.Mock.Arguments.IArgumentMatcher[] { a.Matcher, b.Matcher };
            var methodSetup = new global::TUnit.Mock.Setup.MethodSetup(1, matchers, "Swap");
            s.Engine.AddSetup(methodSetup);
            return new global::TUnit.Mock.Setup.VoidMethodSetupBuilder(methodSetup);
        }
    }
}


// ===== FILE SEPARATOR =====

// <auto-generated/>
#nullable enable

namespace TUnit.Mock.Generated
{
    public sealed class IDictionary_MockVerify : global::TUnit.Mock.IMockVerify<global::IDictionary>
    {
        internal readonly global::TUnit.Mock.MockEngine<global::IDictionary> Engine;

        internal IDictionary_MockVerify(global::TUnit.Mock.MockEngine<global::IDictionary> engine) => Engine = engine;
    }

    public static class IDictionary_MockVerifyExtensions
    {
        public static global::TUnit.Mock.Verification.ICallVerification TryGetValue(this global::TUnit.Mock.IMockVerify<global::IDictionary> verify, global::TUnit.Mock.Arguments.Arg<string> key)
        {
            var v = (IDictionary_MockVerify)verify;
            var matchers = new global::TUnit.Mock.Arguments.IArgumentMatcher[] { key.Matcher };
            return new global::TUnit.Mock.Verification.CallVerificationBuilder<global::IDictionary>(v.Engine, 0, "TryGetValue", matchers);
        }

        public static global::TUnit.Mock.Verification.ICallVerification Swap(this global::TUnit.Mock.IMockVerify<global::IDictionary> verify, global::TUnit.Mock.Arguments.Arg<int> a, global::TUnit.Mock.Arguments.Arg<int> b)
        {
            var v = (IDictionary_MockVerify)verify;
            var matchers = new global::TUnit.Mock.Arguments.IArgumentMatcher[] { a.Matcher, b.Matcher };
            return new global::TUnit.Mock.Verification.CallVerificationBuilder<global::IDictionary>(v.Engine, 1, "Swap", matchers);
        }
    }
}
