// <auto-generated/>
#pragma warning disable

#nullable enable
#pragma warning disable CS9113 // Parameter is unread.
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Threading.Tasks;
using global::TUnit.Core;
using global::TUnit.Core.Hooks;
using global::TUnit.Core.Interfaces.SourceGenerator;
using global::TUnit.Core.Models;
using HookType = global::TUnit.Core.HookType;
namespace TUnit.Generated.Hooks.AssemblyBase1_AfterAll1_After_Assembly_GUID;
internal static class AssemblyBase1_AfterAll1_After_Assembly_GUIDInitializer
{
    [global::System.Runtime.CompilerServices.ModuleInitializer]
    public static void Initialize()
    {
        var TestsBase`1_assembly = typeof(global::TUnit.TestProject.AfterTests.AssemblyBase1).Assembly;
        global::TUnit.Core.Sources.AfterAssemblyHooks.GetOrAdd(TestsBase`1_assembly, _ => new global::System.Collections.Concurrent.ConcurrentBag<global::TUnit.Core.Hooks.AfterAssemblyHookMethod>());
        global::TUnit.Core.Sources.AfterAssemblyHooks[TestsBase`1_assembly].Add(
            new AfterAssemblyHookMethod
            {
                MethodInfo = new global::TUnit.Core.MethodMetadata
                {
                    Type = typeof(global::TUnit.TestProject.AfterTests.AssemblyBase1),
                    TypeReference = global::TUnit.Core.TypeReference.CreateConcrete("TUnit.TestProject.AfterTests.AssemblyBase1, TestsBase`1"),
                    Name = "AfterAll1",
                    GenericTypeCount = 0,
                    ReturnType = typeof(global::System.Threading.Tasks.Task),
                    ReturnTypeReference = global::TUnit.Core.TypeReference.CreateConcrete("System.Threading.Tasks.Task, System.Private.CoreLib"),
                    Parameters = global::System.Array.Empty<global::TUnit.Core.ParameterMetadata>(),
                    Class = global::TUnit.Core.ClassMetadata.GetOrAdd("TestsBase`1:global::TUnit.TestProject.AfterTests.AssemblyBase1", () => 
                    {
                        var classMetadata = new global::TUnit.Core.ClassMetadata
                        {
                            Type = typeof(global::TUnit.TestProject.AfterTests.AssemblyBase1),
                            TypeReference = global::TUnit.Core.TypeReference.CreateConcrete("TUnit.TestProject.AfterTests.AssemblyBase1, TestsBase`1"),
                            Name = "AssemblyBase1",
                            Namespace = "TUnit.TestProject.AfterTests",
                            Assembly = global::TUnit.Core.AssemblyMetadata.GetOrAdd("TestsBase`1", () => new global::TUnit.Core.AssemblyMetadata { Name = "TestsBase`1" }),
                            Parameters = global::System.Array.Empty<global::TUnit.Core.ParameterMetadata>(),
                            Properties = global::System.Array.Empty<global::TUnit.Core.PropertyMetadata>(),
                            Parent = null
                        };
                        // Set ClassMetadata and ContainingTypeMetadata references on properties to avoid circular dependency
                        foreach (var prop in classMetadata.Properties)
                        {
                            prop.ClassMetadata = classMetadata;
                            prop.ContainingTypeMetadata = classMetadata;
                        }
                        return classMetadata;
                    })
                },
                HookExecutor = DefaultExecutor.Instance,
                Order = 0,
                RegistrationIndex = global::TUnit.Core.HookRegistrationIndices.GetNextAfterAssemblyHookIndex(),
                Body = global_TUnit_TestProject_AfterTests_AssemblyBase1_AfterAll1_0Params_Body,
                FilePath = @"",
                LineNumber = 5
            }
        );
    }
    private static async ValueTask global_TUnit_TestProject_AfterTests_AssemblyBase1_AfterAll1_0Params_Body(AssemblyHookContext context, CancellationToken cancellationToken)
    {
        await AsyncConvert.Convert(() => global::TUnit.TestProject.AfterTests.AssemblyBase1.AfterAll1());
    }
}


// ===== FILE SEPARATOR =====

// <auto-generated/>
#pragma warning disable

#nullable enable
#pragma warning disable CS9113 // Parameter is unread.
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Threading.Tasks;
using global::TUnit.Core;
using global::TUnit.Core.Hooks;
using global::TUnit.Core.Interfaces.SourceGenerator;
using global::TUnit.Core.Models;
using HookType = global::TUnit.Core.HookType;
namespace TUnit.Generated.Hooks.AssemblyBase1_AfterEach1_After_Test_GUID;
internal static class AssemblyBase1_AfterEach1_After_Test_GUIDInitializer
{
    [global::System.Runtime.CompilerServices.ModuleInitializer]
    public static void Initialize()
    {
        global::TUnit.Core.Sources.AfterTestHooks.GetOrAdd(typeof(global::TUnit.TestProject.AfterTests.AssemblyBase1), _ => new global::System.Collections.Concurrent.ConcurrentBag<global::TUnit.Core.Hooks.InstanceHookMethod>());
        global::TUnit.Core.Sources.AfterTestHooks[typeof(global::TUnit.TestProject.AfterTests.AssemblyBase1)].Add(
            new InstanceHookMethod
            {
                InitClassType = typeof(global::TUnit.TestProject.AfterTests.AssemblyBase1),
                MethodInfo = new global::TUnit.Core.MethodMetadata
                {
                    Type = typeof(global::TUnit.TestProject.AfterTests.AssemblyBase1),
                    TypeReference = global::TUnit.Core.TypeReference.CreateConcrete("TUnit.TestProject.AfterTests.AssemblyBase1, TestsBase`1"),
                    Name = "AfterEach1",
                    GenericTypeCount = 0,
                    ReturnType = typeof(global::System.Threading.Tasks.Task),
                    ReturnTypeReference = global::TUnit.Core.TypeReference.CreateConcrete("System.Threading.Tasks.Task, System.Private.CoreLib"),
                    Parameters = global::System.Array.Empty<global::TUnit.Core.ParameterMetadata>(),
                    Class = global::TUnit.Core.ClassMetadata.GetOrAdd("TestsBase`1:global::TUnit.TestProject.AfterTests.AssemblyBase1", () => 
                    {
                        var classMetadata = new global::TUnit.Core.ClassMetadata
                        {
                            Type = typeof(global::TUnit.TestProject.AfterTests.AssemblyBase1),
                            TypeReference = global::TUnit.Core.TypeReference.CreateConcrete("TUnit.TestProject.AfterTests.AssemblyBase1, TestsBase`1"),
                            Name = "AssemblyBase1",
                            Namespace = "TUnit.TestProject.AfterTests",
                            Assembly = global::TUnit.Core.AssemblyMetadata.GetOrAdd("TestsBase`1", () => new global::TUnit.Core.AssemblyMetadata { Name = "TestsBase`1" }),
                            Parameters = global::System.Array.Empty<global::TUnit.Core.ParameterMetadata>(),
                            Properties = global::System.Array.Empty<global::TUnit.Core.PropertyMetadata>(),
                            Parent = null
                        };
                        // Set ClassMetadata and ContainingTypeMetadata references on properties to avoid circular dependency
                        foreach (var prop in classMetadata.Properties)
                        {
                            prop.ClassMetadata = classMetadata;
                            prop.ContainingTypeMetadata = classMetadata;
                        }
                        return classMetadata;
                    })
                },
                HookExecutor = DefaultExecutor.Instance,
                Order = 0,
                RegistrationIndex = global::TUnit.Core.HookRegistrationIndices.GetNextAfterTestHookIndex(),
                Body = global_TUnit_TestProject_AfterTests_AssemblyBase1_AfterEach1_0Params_Body
            }
        );
    }
    private static async ValueTask global_TUnit_TestProject_AfterTests_AssemblyBase1_AfterEach1_0Params_Body(object instance, TestContext context, CancellationToken cancellationToken)
    {
        var typedInstance = (global::TUnit.TestProject.AfterTests.AssemblyBase1)instance;
        await AsyncConvert.Convert(() => typedInstance.AfterEach1());
    }
}


// ===== FILE SEPARATOR =====

// <auto-generated/>
#pragma warning disable

#nullable enable
#pragma warning disable CS9113 // Parameter is unread.
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Threading.Tasks;
using global::TUnit.Core;
using global::TUnit.Core.Hooks;
using global::TUnit.Core.Interfaces.SourceGenerator;
using global::TUnit.Core.Models;
using HookType = global::TUnit.Core.HookType;
namespace TUnit.Generated.Hooks.AssemblyBase2_AfterAll2_After_Assembly_GUID;
internal static class AssemblyBase2_AfterAll2_After_Assembly_GUIDInitializer
{
    [global::System.Runtime.CompilerServices.ModuleInitializer]
    public static void Initialize()
    {
        var TestsBase`1_assembly = typeof(global::TUnit.TestProject.AfterTests.AssemblyBase2).Assembly;
        global::TUnit.Core.Sources.AfterAssemblyHooks.GetOrAdd(TestsBase`1_assembly, _ => new global::System.Collections.Concurrent.ConcurrentBag<global::TUnit.Core.Hooks.AfterAssemblyHookMethod>());
        global::TUnit.Core.Sources.AfterAssemblyHooks[TestsBase`1_assembly].Add(
            new AfterAssemblyHookMethod
            {
                MethodInfo = new global::TUnit.Core.MethodMetadata
                {
                    Type = typeof(global::TUnit.TestProject.AfterTests.AssemblyBase2),
                    TypeReference = global::TUnit.Core.TypeReference.CreateConcrete("TUnit.TestProject.AfterTests.AssemblyBase2, TestsBase`1"),
                    Name = "AfterAll2",
                    GenericTypeCount = 0,
                    ReturnType = typeof(global::System.Threading.Tasks.Task),
                    ReturnTypeReference = global::TUnit.Core.TypeReference.CreateConcrete("System.Threading.Tasks.Task, System.Private.CoreLib"),
                    Parameters = global::System.Array.Empty<global::TUnit.Core.ParameterMetadata>(),
                    Class = global::TUnit.Core.ClassMetadata.GetOrAdd("TestsBase`1:global::TUnit.TestProject.AfterTests.AssemblyBase2", () => 
                    {
                        var classMetadata = new global::TUnit.Core.ClassMetadata
                        {
                            Type = typeof(global::TUnit.TestProject.AfterTests.AssemblyBase2),
                            TypeReference = global::TUnit.Core.TypeReference.CreateConcrete("TUnit.TestProject.AfterTests.AssemblyBase2, TestsBase`1"),
                            Name = "AssemblyBase2",
                            Namespace = "TUnit.TestProject.AfterTests",
                            Assembly = global::TUnit.Core.AssemblyMetadata.GetOrAdd("TestsBase`1", () => new global::TUnit.Core.AssemblyMetadata { Name = "TestsBase`1" }),
                            Parameters = global::System.Array.Empty<global::TUnit.Core.ParameterMetadata>(),
                            Properties = global::System.Array.Empty<global::TUnit.Core.PropertyMetadata>(),
                            Parent = null
                        };
                        // Set ClassMetadata and ContainingTypeMetadata references on properties to avoid circular dependency
                        foreach (var prop in classMetadata.Properties)
                        {
                            prop.ClassMetadata = classMetadata;
                            prop.ContainingTypeMetadata = classMetadata;
                        }
                        return classMetadata;
                    })
                },
                HookExecutor = DefaultExecutor.Instance,
                Order = 0,
                RegistrationIndex = global::TUnit.Core.HookRegistrationIndices.GetNextAfterAssemblyHookIndex(),
                Body = global_TUnit_TestProject_AfterTests_AssemblyBase2_AfterAll2_0Params_Body,
                FilePath = @"",
                LineNumber = 20
            }
        );
    }
    private static async ValueTask global_TUnit_TestProject_AfterTests_AssemblyBase2_AfterAll2_0Params_Body(AssemblyHookContext context, CancellationToken cancellationToken)
    {
        await AsyncConvert.Convert(() => global::TUnit.TestProject.AfterTests.AssemblyBase2.AfterAll2());
    }
}


// ===== FILE SEPARATOR =====

// <auto-generated/>
#pragma warning disable

#nullable enable
#pragma warning disable CS9113 // Parameter is unread.
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Threading.Tasks;
using global::TUnit.Core;
using global::TUnit.Core.Hooks;
using global::TUnit.Core.Interfaces.SourceGenerator;
using global::TUnit.Core.Models;
using HookType = global::TUnit.Core.HookType;
namespace TUnit.Generated.Hooks.AssemblyBase2_AfterEach2_After_Test_GUID;
internal static class AssemblyBase2_AfterEach2_After_Test_GUIDInitializer
{
    [global::System.Runtime.CompilerServices.ModuleInitializer]
    public static void Initialize()
    {
        global::TUnit.Core.Sources.AfterTestHooks.GetOrAdd(typeof(global::TUnit.TestProject.AfterTests.AssemblyBase2), _ => new global::System.Collections.Concurrent.ConcurrentBag<global::TUnit.Core.Hooks.InstanceHookMethod>());
        global::TUnit.Core.Sources.AfterTestHooks[typeof(global::TUnit.TestProject.AfterTests.AssemblyBase2)].Add(
            new InstanceHookMethod
            {
                InitClassType = typeof(global::TUnit.TestProject.AfterTests.AssemblyBase2),
                MethodInfo = new global::TUnit.Core.MethodMetadata
                {
                    Type = typeof(global::TUnit.TestProject.AfterTests.AssemblyBase2),
                    TypeReference = global::TUnit.Core.TypeReference.CreateConcrete("TUnit.TestProject.AfterTests.AssemblyBase2, TestsBase`1"),
                    Name = "AfterEach2",
                    GenericTypeCount = 0,
                    ReturnType = typeof(global::System.Threading.Tasks.Task),
                    ReturnTypeReference = global::TUnit.Core.TypeReference.CreateConcrete("System.Threading.Tasks.Task, System.Private.CoreLib"),
                    Parameters = global::System.Array.Empty<global::TUnit.Core.ParameterMetadata>(),
                    Class = global::TUnit.Core.ClassMetadata.GetOrAdd("TestsBase`1:global::TUnit.TestProject.AfterTests.AssemblyBase2", () => 
                    {
                        var classMetadata = new global::TUnit.Core.ClassMetadata
                        {
                            Type = typeof(global::TUnit.TestProject.AfterTests.AssemblyBase2),
                            TypeReference = global::TUnit.Core.TypeReference.CreateConcrete("TUnit.TestProject.AfterTests.AssemblyBase2, TestsBase`1"),
                            Name = "AssemblyBase2",
                            Namespace = "TUnit.TestProject.AfterTests",
                            Assembly = global::TUnit.Core.AssemblyMetadata.GetOrAdd("TestsBase`1", () => new global::TUnit.Core.AssemblyMetadata { Name = "TestsBase`1" }),
                            Parameters = global::System.Array.Empty<global::TUnit.Core.ParameterMetadata>(),
                            Properties = global::System.Array.Empty<global::TUnit.Core.PropertyMetadata>(),
                            Parent = null
                        };
                        // Set ClassMetadata and ContainingTypeMetadata references on properties to avoid circular dependency
                        foreach (var prop in classMetadata.Properties)
                        {
                            prop.ClassMetadata = classMetadata;
                            prop.ContainingTypeMetadata = classMetadata;
                        }
                        return classMetadata;
                    })
                },
                HookExecutor = DefaultExecutor.Instance,
                Order = 0,
                RegistrationIndex = global::TUnit.Core.HookRegistrationIndices.GetNextAfterTestHookIndex(),
                Body = global_TUnit_TestProject_AfterTests_AssemblyBase2_AfterEach2_0Params_Body
            }
        );
    }
    private static async ValueTask global_TUnit_TestProject_AfterTests_AssemblyBase2_AfterEach2_0Params_Body(object instance, TestContext context, CancellationToken cancellationToken)
    {
        var typedInstance = (global::TUnit.TestProject.AfterTests.AssemblyBase2)instance;
        await AsyncConvert.Convert(() => typedInstance.AfterEach2());
    }
}


// ===== FILE SEPARATOR =====

// <auto-generated/>
#pragma warning disable

#nullable enable
#pragma warning disable CS9113 // Parameter is unread.
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Threading.Tasks;
using global::TUnit.Core;
using global::TUnit.Core.Hooks;
using global::TUnit.Core.Interfaces.SourceGenerator;
using global::TUnit.Core.Models;
using HookType = global::TUnit.Core.HookType;
namespace TUnit.Generated.Hooks.AssemblyBase3_AfterAll3_After_Assembly_GUID;
internal static class AssemblyBase3_AfterAll3_After_Assembly_GUIDInitializer
{
    [global::System.Runtime.CompilerServices.ModuleInitializer]
    public static void Initialize()
    {
        var TestsBase`1_assembly = typeof(global::TUnit.TestProject.AfterTests.AssemblyBase3).Assembly;
        global::TUnit.Core.Sources.AfterAssemblyHooks.GetOrAdd(TestsBase`1_assembly, _ => new global::System.Collections.Concurrent.ConcurrentBag<global::TUnit.Core.Hooks.AfterAssemblyHookMethod>());
        global::TUnit.Core.Sources.AfterAssemblyHooks[TestsBase`1_assembly].Add(
            new AfterAssemblyHookMethod
            {
                MethodInfo = new global::TUnit.Core.MethodMetadata
                {
                    Type = typeof(global::TUnit.TestProject.AfterTests.AssemblyBase3),
                    TypeReference = global::TUnit.Core.TypeReference.CreateConcrete("TUnit.TestProject.AfterTests.AssemblyBase3, TestsBase`1"),
                    Name = "AfterAll3",
                    GenericTypeCount = 0,
                    ReturnType = typeof(global::System.Threading.Tasks.Task),
                    ReturnTypeReference = global::TUnit.Core.TypeReference.CreateConcrete("System.Threading.Tasks.Task, System.Private.CoreLib"),
                    Parameters = global::System.Array.Empty<global::TUnit.Core.ParameterMetadata>(),
                    Class = global::TUnit.Core.ClassMetadata.GetOrAdd("TestsBase`1:global::TUnit.TestProject.AfterTests.AssemblyBase3", () => 
                    {
                        var classMetadata = new global::TUnit.Core.ClassMetadata
                        {
                            Type = typeof(global::TUnit.TestProject.AfterTests.AssemblyBase3),
                            TypeReference = global::TUnit.Core.TypeReference.CreateConcrete("TUnit.TestProject.AfterTests.AssemblyBase3, TestsBase`1"),
                            Name = "AssemblyBase3",
                            Namespace = "TUnit.TestProject.AfterTests",
                            Assembly = global::TUnit.Core.AssemblyMetadata.GetOrAdd("TestsBase`1", () => new global::TUnit.Core.AssemblyMetadata { Name = "TestsBase`1" }),
                            Parameters = global::System.Array.Empty<global::TUnit.Core.ParameterMetadata>(),
                            Properties = global::System.Array.Empty<global::TUnit.Core.PropertyMetadata>(),
                            Parent = null
                        };
                        // Set ClassMetadata and ContainingTypeMetadata references on properties to avoid circular dependency
                        foreach (var prop in classMetadata.Properties)
                        {
                            prop.ClassMetadata = classMetadata;
                            prop.ContainingTypeMetadata = classMetadata;
                        }
                        return classMetadata;
                    })
                },
                HookExecutor = DefaultExecutor.Instance,
                Order = 0,
                RegistrationIndex = global::TUnit.Core.HookRegistrationIndices.GetNextAfterAssemblyHookIndex(),
                Body = global_TUnit_TestProject_AfterTests_AssemblyBase3_AfterAll3_0Params_Body,
                FilePath = @"",
                LineNumber = 35
            }
        );
    }
    private static async ValueTask global_TUnit_TestProject_AfterTests_AssemblyBase3_AfterAll3_0Params_Body(AssemblyHookContext context, CancellationToken cancellationToken)
    {
        await AsyncConvert.Convert(() => global::TUnit.TestProject.AfterTests.AssemblyBase3.AfterAll3());
    }
}


// ===== FILE SEPARATOR =====

// <auto-generated/>
#pragma warning disable

#nullable enable
#pragma warning disable CS9113 // Parameter is unread.
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Threading.Tasks;
using global::TUnit.Core;
using global::TUnit.Core.Hooks;
using global::TUnit.Core.Interfaces.SourceGenerator;
using global::TUnit.Core.Models;
using HookType = global::TUnit.Core.HookType;
namespace TUnit.Generated.Hooks.AssemblyBase3_AfterEach3_After_Test_GUID;
internal static class AssemblyBase3_AfterEach3_After_Test_GUIDInitializer
{
    [global::System.Runtime.CompilerServices.ModuleInitializer]
    public static void Initialize()
    {
        global::TUnit.Core.Sources.AfterTestHooks.GetOrAdd(typeof(global::TUnit.TestProject.AfterTests.AssemblyBase3), _ => new global::System.Collections.Concurrent.ConcurrentBag<global::TUnit.Core.Hooks.InstanceHookMethod>());
        global::TUnit.Core.Sources.AfterTestHooks[typeof(global::TUnit.TestProject.AfterTests.AssemblyBase3)].Add(
            new InstanceHookMethod
            {
                InitClassType = typeof(global::TUnit.TestProject.AfterTests.AssemblyBase3),
                MethodInfo = new global::TUnit.Core.MethodMetadata
                {
                    Type = typeof(global::TUnit.TestProject.AfterTests.AssemblyBase3),
                    TypeReference = global::TUnit.Core.TypeReference.CreateConcrete("TUnit.TestProject.AfterTests.AssemblyBase3, TestsBase`1"),
                    Name = "AfterEach3",
                    GenericTypeCount = 0,
                    ReturnType = typeof(global::System.Threading.Tasks.Task),
                    ReturnTypeReference = global::TUnit.Core.TypeReference.CreateConcrete("System.Threading.Tasks.Task, System.Private.CoreLib"),
                    Parameters = global::System.Array.Empty<global::TUnit.Core.ParameterMetadata>(),
                    Class = global::TUnit.Core.ClassMetadata.GetOrAdd("TestsBase`1:global::TUnit.TestProject.AfterTests.AssemblyBase3", () => 
                    {
                        var classMetadata = new global::TUnit.Core.ClassMetadata
                        {
                            Type = typeof(global::TUnit.TestProject.AfterTests.AssemblyBase3),
                            TypeReference = global::TUnit.Core.TypeReference.CreateConcrete("TUnit.TestProject.AfterTests.AssemblyBase3, TestsBase`1"),
                            Name = "AssemblyBase3",
                            Namespace = "TUnit.TestProject.AfterTests",
                            Assembly = global::TUnit.Core.AssemblyMetadata.GetOrAdd("TestsBase`1", () => new global::TUnit.Core.AssemblyMetadata { Name = "TestsBase`1" }),
                            Parameters = global::System.Array.Empty<global::TUnit.Core.ParameterMetadata>(),
                            Properties = global::System.Array.Empty<global::TUnit.Core.PropertyMetadata>(),
                            Parent = null
                        };
                        // Set ClassMetadata and ContainingTypeMetadata references on properties to avoid circular dependency
                        foreach (var prop in classMetadata.Properties)
                        {
                            prop.ClassMetadata = classMetadata;
                            prop.ContainingTypeMetadata = classMetadata;
                        }
                        return classMetadata;
                    })
                },
                HookExecutor = DefaultExecutor.Instance,
                Order = 0,
                RegistrationIndex = global::TUnit.Core.HookRegistrationIndices.GetNextAfterTestHookIndex(),
                Body = global_TUnit_TestProject_AfterTests_AssemblyBase3_AfterEach3_0Params_Body
            }
        );
    }
    private static async ValueTask global_TUnit_TestProject_AfterTests_AssemblyBase3_AfterEach3_0Params_Body(object instance, TestContext context, CancellationToken cancellationToken)
    {
        var typedInstance = (global::TUnit.TestProject.AfterTests.AssemblyBase3)instance;
        await AsyncConvert.Convert(() => typedInstance.AfterEach3());
    }
}


// ===== FILE SEPARATOR =====

// <auto-generated/>
#pragma warning disable

#nullable enable
#pragma warning disable CS9113 // Parameter is unread.
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Threading.Tasks;
using global::TUnit.Core;
using global::TUnit.Core.Hooks;
using global::TUnit.Core.Interfaces.SourceGenerator;
using global::TUnit.Core.Models;
using HookType = global::TUnit.Core.HookType;
namespace TUnit.Generated.Hooks.AssemblyCleanupTests_AfterAllCleanUp_After_Assembly_GUID;
internal static class AssemblyCleanupTests_AfterAllCleanUp_After_Assembly_GUIDInitializer
{
    [global::System.Runtime.CompilerServices.ModuleInitializer]
    public static void Initialize()
    {
        var TestsBase`1_assembly = typeof(global::TUnit.TestProject.AfterTests.AssemblyCleanupTests).Assembly;
        global::TUnit.Core.Sources.AfterAssemblyHooks.GetOrAdd(TestsBase`1_assembly, _ => new global::System.Collections.Concurrent.ConcurrentBag<global::TUnit.Core.Hooks.AfterAssemblyHookMethod>());
        global::TUnit.Core.Sources.AfterAssemblyHooks[TestsBase`1_assembly].Add(
            new AfterAssemblyHookMethod
            {
                MethodInfo = new global::TUnit.Core.MethodMetadata
                {
                    Type = typeof(global::TUnit.TestProject.AfterTests.AssemblyCleanupTests),
                    TypeReference = global::TUnit.Core.TypeReference.CreateConcrete("TUnit.TestProject.AfterTests.AssemblyCleanupTests, TestsBase`1"),
                    Name = "AfterAllCleanUp",
                    GenericTypeCount = 0,
                    ReturnType = typeof(global::System.Threading.Tasks.Task),
                    ReturnTypeReference = global::TUnit.Core.TypeReference.CreateConcrete("System.Threading.Tasks.Task, System.Private.CoreLib"),
                    Parameters = global::System.Array.Empty<global::TUnit.Core.ParameterMetadata>(),
                    Class = global::TUnit.Core.ClassMetadata.GetOrAdd("TestsBase`1:global::TUnit.TestProject.AfterTests.AssemblyCleanupTests", () => 
                    {
                        var classMetadata = new global::TUnit.Core.ClassMetadata
                        {
                            Type = typeof(global::TUnit.TestProject.AfterTests.AssemblyCleanupTests),
                            TypeReference = global::TUnit.Core.TypeReference.CreateConcrete("TUnit.TestProject.AfterTests.AssemblyCleanupTests, TestsBase`1"),
                            Name = "AssemblyCleanupTests",
                            Namespace = "TUnit.TestProject.AfterTests",
                            Assembly = global::TUnit.Core.AssemblyMetadata.GetOrAdd("TestsBase`1", () => new global::TUnit.Core.AssemblyMetadata { Name = "TestsBase`1" }),
                            Parameters = global::System.Array.Empty<global::TUnit.Core.ParameterMetadata>(),
                            Properties = global::System.Array.Empty<global::TUnit.Core.PropertyMetadata>(),
                            Parent = null
                        };
                        // Set ClassMetadata and ContainingTypeMetadata references on properties to avoid circular dependency
                        foreach (var prop in classMetadata.Properties)
                        {
                            prop.ClassMetadata = classMetadata;
                            prop.ContainingTypeMetadata = classMetadata;
                        }
                        return classMetadata;
                    })
                },
                HookExecutor = DefaultExecutor.Instance,
                Order = 0,
                RegistrationIndex = global::TUnit.Core.HookRegistrationIndices.GetNextAfterAssemblyHookIndex(),
                Body = global_TUnit_TestProject_AfterTests_AssemblyCleanupTests_AfterAllCleanUp_0Params_Body,
                FilePath = @"",
                LineNumber = 50
            }
        );
    }
    private static async ValueTask global_TUnit_TestProject_AfterTests_AssemblyCleanupTests_AfterAllCleanUp_0Params_Body(AssemblyHookContext context, CancellationToken cancellationToken)
    {
        await AsyncConvert.Convert(() => global::TUnit.TestProject.AfterTests.AssemblyCleanupTests.AfterAllCleanUp());
    }
}


// ===== FILE SEPARATOR =====

// <auto-generated/>
#pragma warning disable

#nullable enable
#pragma warning disable CS9113 // Parameter is unread.
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Threading.Tasks;
using global::TUnit.Core;
using global::TUnit.Core.Hooks;
using global::TUnit.Core.Interfaces.SourceGenerator;
using global::TUnit.Core.Models;
using HookType = global::TUnit.Core.HookType;
namespace TUnit.Generated.Hooks.AssemblyCleanupTests_AfterAllCleanUpWithContext_After_Assembly_GUID;
internal static class AssemblyCleanupTests_AfterAllCleanUpWithContext_After_Assembly_GUIDInitializer
{
    [global::System.Runtime.CompilerServices.ModuleInitializer]
    public static void Initialize()
    {
        var TestsBase`1_assembly = typeof(global::TUnit.TestProject.AfterTests.AssemblyCleanupTests).Assembly;
        global::TUnit.Core.Sources.AfterAssemblyHooks.GetOrAdd(TestsBase`1_assembly, _ => new global::System.Collections.Concurrent.ConcurrentBag<global::TUnit.Core.Hooks.AfterAssemblyHookMethod>());
        global::TUnit.Core.Sources.AfterAssemblyHooks[TestsBase`1_assembly].Add(
            new AfterAssemblyHookMethod
            {
                MethodInfo = new global::TUnit.Core.MethodMetadata
                {
                    Type = typeof(global::TUnit.TestProject.AfterTests.AssemblyCleanupTests),
                    TypeReference = global::TUnit.Core.TypeReference.CreateConcrete("TUnit.TestProject.AfterTests.AssemblyCleanupTests, TestsBase`1"),
                    Name = "AfterAllCleanUpWithContext",
                    GenericTypeCount = 0,
                    ReturnType = typeof(global::System.Threading.Tasks.Task),
                    ReturnTypeReference = global::TUnit.Core.TypeReference.CreateConcrete("System.Threading.Tasks.Task, System.Private.CoreLib"),
                    Parameters = new global::TUnit.Core.ParameterMetadata[]
                    {
                        new global::TUnit.Core.ParameterMetadata(typeof(global::TUnit.Core.AssemblyHookContext))
                        {
                            Name = "context",
                            TypeReference = global::TUnit.Core.TypeReference.CreateConcrete("TUnit.Core.AssemblyHookContext, TUnit.Core"),
                            IsNullable = false,
                            ReflectionInfo = typeof(global::TUnit.TestProject.AfterTests.AssemblyCleanupTests).GetMethod("AfterAllCleanUpWithContext", global::System.Reflection.BindingFlags.Public | global::System.Reflection.BindingFlags.Static, null, new global::System.Type[] { typeof(global::TUnit.Core.AssemblyHookContext) }, null)!.GetParameters()[0]
                        }
                    },
                    Class = global::TUnit.Core.ClassMetadata.GetOrAdd("TestsBase`1:global::TUnit.TestProject.AfterTests.AssemblyCleanupTests", () => 
                    {
                        var classMetadata = new global::TUnit.Core.ClassMetadata
                        {
                            Type = typeof(global::TUnit.TestProject.AfterTests.AssemblyCleanupTests),
                            TypeReference = global::TUnit.Core.TypeReference.CreateConcrete("TUnit.TestProject.AfterTests.AssemblyCleanupTests, TestsBase`1"),
                            Name = "AssemblyCleanupTests",
                            Namespace = "TUnit.TestProject.AfterTests",
                            Assembly = global::TUnit.Core.AssemblyMetadata.GetOrAdd("TestsBase`1", () => new global::TUnit.Core.AssemblyMetadata { Name = "TestsBase`1" }),
                            Parameters = global::System.Array.Empty<global::TUnit.Core.ParameterMetadata>(),
                            Properties = global::System.Array.Empty<global::TUnit.Core.PropertyMetadata>(),
                            Parent = null
                        };
                        // Set ClassMetadata and ContainingTypeMetadata references on properties to avoid circular dependency
                        foreach (var prop in classMetadata.Properties)
                        {
                            prop.ClassMetadata = classMetadata;
                            prop.ContainingTypeMetadata = classMetadata;
                        }
                        return classMetadata;
                    })
                },
                HookExecutor = DefaultExecutor.Instance,
                Order = 0,
                RegistrationIndex = global::TUnit.Core.HookRegistrationIndices.GetNextAfterAssemblyHookIndex(),
                Body = global_TUnit_TestProject_AfterTests_AssemblyCleanupTests_AfterAllCleanUpWithContext_1Params_Body,
                FilePath = @"",
                LineNumber = 56
            }
        );
    }
    private static async ValueTask global_TUnit_TestProject_AfterTests_AssemblyCleanupTests_AfterAllCleanUpWithContext_1Params_Body(AssemblyHookContext context, CancellationToken cancellationToken)
    {
        await AsyncConvert.Convert(() => global::TUnit.TestProject.AfterTests.AssemblyCleanupTests.AfterAllCleanUpWithContext(context));
    }
}


// ===== FILE SEPARATOR =====

// <auto-generated/>
#pragma warning disable

#nullable enable
#pragma warning disable CS9113 // Parameter is unread.
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Threading.Tasks;
using global::TUnit.Core;
using global::TUnit.Core.Hooks;
using global::TUnit.Core.Interfaces.SourceGenerator;
using global::TUnit.Core.Models;
using HookType = global::TUnit.Core.HookType;
namespace TUnit.Generated.Hooks.AssemblyCleanupTests_AfterAllCleanUp2_After_Assembly_GUID;
internal static class AssemblyCleanupTests_AfterAllCleanUp2_After_Assembly_GUIDInitializer
{
    [global::System.Runtime.CompilerServices.ModuleInitializer]
    public static void Initialize()
    {
        var TestsBase`1_assembly = typeof(global::TUnit.TestProject.AfterTests.AssemblyCleanupTests).Assembly;
        global::TUnit.Core.Sources.AfterAssemblyHooks.GetOrAdd(TestsBase`1_assembly, _ => new global::System.Collections.Concurrent.ConcurrentBag<global::TUnit.Core.Hooks.AfterAssemblyHookMethod>());
        global::TUnit.Core.Sources.AfterAssemblyHooks[TestsBase`1_assembly].Add(
            new AfterAssemblyHookMethod
            {
                MethodInfo = new global::TUnit.Core.MethodMetadata
                {
                    Type = typeof(global::TUnit.TestProject.AfterTests.AssemblyCleanupTests),
                    TypeReference = global::TUnit.Core.TypeReference.CreateConcrete("TUnit.TestProject.AfterTests.AssemblyCleanupTests, TestsBase`1"),
                    Name = "AfterAllCleanUp2",
                    GenericTypeCount = 0,
                    ReturnType = typeof(global::System.Threading.Tasks.Task),
                    ReturnTypeReference = global::TUnit.Core.TypeReference.CreateConcrete("System.Threading.Tasks.Task, System.Private.CoreLib"),
                    Parameters = global::System.Array.Empty<global::TUnit.Core.ParameterMetadata>(),
                    Class = global::TUnit.Core.ClassMetadata.GetOrAdd("TestsBase`1:global::TUnit.TestProject.AfterTests.AssemblyCleanupTests", () => 
                    {
                        var classMetadata = new global::TUnit.Core.ClassMetadata
                        {
                            Type = typeof(global::TUnit.TestProject.AfterTests.AssemblyCleanupTests),
                            TypeReference = global::TUnit.Core.TypeReference.CreateConcrete("TUnit.TestProject.AfterTests.AssemblyCleanupTests, TestsBase`1"),
                            Name = "AssemblyCleanupTests",
                            Namespace = "TUnit.TestProject.AfterTests",
                            Assembly = global::TUnit.Core.AssemblyMetadata.GetOrAdd("TestsBase`1", () => new global::TUnit.Core.AssemblyMetadata { Name = "TestsBase`1" }),
                            Parameters = global::System.Array.Empty<global::TUnit.Core.ParameterMetadata>(),
                            Properties = global::System.Array.Empty<global::TUnit.Core.PropertyMetadata>(),
                            Parent = null
                        };
                        // Set ClassMetadata and ContainingTypeMetadata references on properties to avoid circular dependency
                        foreach (var prop in classMetadata.Properties)
                        {
                            prop.ClassMetadata = classMetadata;
                            prop.ContainingTypeMetadata = classMetadata;
                        }
                        return classMetadata;
                    })
                },
                HookExecutor = DefaultExecutor.Instance,
                Order = 0,
                RegistrationIndex = global::TUnit.Core.HookRegistrationIndices.GetNextAfterAssemblyHookIndex(),
                Body = global_TUnit_TestProject_AfterTests_AssemblyCleanupTests_AfterAllCleanUp2_0Params_Body,
                FilePath = @"",
                LineNumber = 62
            }
        );
    }
    private static async ValueTask global_TUnit_TestProject_AfterTests_AssemblyCleanupTests_AfterAllCleanUp2_0Params_Body(AssemblyHookContext context, CancellationToken cancellationToken)
    {
        await AsyncConvert.Convert(() => global::TUnit.TestProject.AfterTests.AssemblyCleanupTests.AfterAllCleanUp2());
    }
}


// ===== FILE SEPARATOR =====

// <auto-generated/>
#pragma warning disable

#nullable enable
#pragma warning disable CS9113 // Parameter is unread.
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Threading.Tasks;
using global::TUnit.Core;
using global::TUnit.Core.Hooks;
using global::TUnit.Core.Interfaces.SourceGenerator;
using global::TUnit.Core.Models;
using HookType = global::TUnit.Core.HookType;
namespace TUnit.Generated.Hooks.AssemblyCleanupTests_AfterAllCleanUpWithContextAndToken_After_Assembly_GUID;
internal static class AssemblyCleanupTests_AfterAllCleanUpWithContextAndToken_After_Assembly_GUIDInitializer
{
    [global::System.Runtime.CompilerServices.ModuleInitializer]
    public static void Initialize()
    {
        var TestsBase`1_assembly = typeof(global::TUnit.TestProject.AfterTests.AssemblyCleanupTests).Assembly;
        global::TUnit.Core.Sources.AfterAssemblyHooks.GetOrAdd(TestsBase`1_assembly, _ => new global::System.Collections.Concurrent.ConcurrentBag<global::TUnit.Core.Hooks.AfterAssemblyHookMethod>());
        global::TUnit.Core.Sources.AfterAssemblyHooks[TestsBase`1_assembly].Add(
            new AfterAssemblyHookMethod
            {
                MethodInfo = new global::TUnit.Core.MethodMetadata
                {
                    Type = typeof(global::TUnit.TestProject.AfterTests.AssemblyCleanupTests),
                    TypeReference = global::TUnit.Core.TypeReference.CreateConcrete("TUnit.TestProject.AfterTests.AssemblyCleanupTests, TestsBase`1"),
                    Name = "AfterAllCleanUpWithContextAndToken",
                    GenericTypeCount = 0,
                    ReturnType = typeof(global::System.Threading.Tasks.Task),
                    ReturnTypeReference = global::TUnit.Core.TypeReference.CreateConcrete("System.Threading.Tasks.Task, System.Private.CoreLib"),
                    Parameters = new global::TUnit.Core.ParameterMetadata[]
                    {
                        new global::TUnit.Core.ParameterMetadata(typeof(global::TUnit.Core.AssemblyHookContext))
                        {
                            Name = "context",
                            TypeReference = global::TUnit.Core.TypeReference.CreateConcrete("TUnit.Core.AssemblyHookContext, TUnit.Core"),
                            IsNullable = false,
                            ReflectionInfo = typeof(global::TUnit.TestProject.AfterTests.AssemblyCleanupTests).GetMethod("AfterAllCleanUpWithContextAndToken", global::System.Reflection.BindingFlags.Public | global::System.Reflection.BindingFlags.Static, null, new global::System.Type[] { typeof(global::TUnit.Core.AssemblyHookContext), typeof(global::System.Threading.CancellationToken) }, null)!.GetParameters()[0]
                        },
                        new global::TUnit.Core.ParameterMetadata(typeof(global::System.Threading.CancellationToken))
                        {
                            Name = "cancellationToken",
                            TypeReference = global::TUnit.Core.TypeReference.CreateConcrete("System.Threading.CancellationToken, System.Private.CoreLib"),
                            IsNullable = false,
                            ReflectionInfo = typeof(global::TUnit.TestProject.AfterTests.AssemblyCleanupTests).GetMethod("AfterAllCleanUpWithContextAndToken", global::System.Reflection.BindingFlags.Public | global::System.Reflection.BindingFlags.Static, null, new global::System.Type[] { typeof(global::TUnit.Core.AssemblyHookContext), typeof(global::System.Threading.CancellationToken) }, null)!.GetParameters()[1]
                        }
                    },
                    Class = global::TUnit.Core.ClassMetadata.GetOrAdd("TestsBase`1:global::TUnit.TestProject.AfterTests.AssemblyCleanupTests", () => 
                    {
                        var classMetadata = new global::TUnit.Core.ClassMetadata
                        {
                            Type = typeof(global::TUnit.TestProject.AfterTests.AssemblyCleanupTests),
                            TypeReference = global::TUnit.Core.TypeReference.CreateConcrete("TUnit.TestProject.AfterTests.AssemblyCleanupTests, TestsBase`1"),
                            Name = "AssemblyCleanupTests",
                            Namespace = "TUnit.TestProject.AfterTests",
                            Assembly = global::TUnit.Core.AssemblyMetadata.GetOrAdd("TestsBase`1", () => new global::TUnit.Core.AssemblyMetadata { Name = "TestsBase`1" }),
                            Parameters = global::System.Array.Empty<global::TUnit.Core.ParameterMetadata>(),
                            Properties = global::System.Array.Empty<global::TUnit.Core.PropertyMetadata>(),
                            Parent = null
                        };
                        // Set ClassMetadata and ContainingTypeMetadata references on properties to avoid circular dependency
                        foreach (var prop in classMetadata.Properties)
                        {
                            prop.ClassMetadata = classMetadata;
                            prop.ContainingTypeMetadata = classMetadata;
                        }
                        return classMetadata;
                    })
                },
                HookExecutor = DefaultExecutor.Instance,
                Order = 0,
                RegistrationIndex = global::TUnit.Core.HookRegistrationIndices.GetNextAfterAssemblyHookIndex(),
                Body = global_TUnit_TestProject_AfterTests_AssemblyCleanupTests_AfterAllCleanUpWithContextAndToken_2Params_Body,
                FilePath = @"",
                LineNumber = 68
            }
        );
    }
    private static async ValueTask global_TUnit_TestProject_AfterTests_AssemblyCleanupTests_AfterAllCleanUpWithContextAndToken_2Params_Body(AssemblyHookContext context, CancellationToken cancellationToken)
    {
        await AsyncConvert.Convert(() => global::TUnit.TestProject.AfterTests.AssemblyCleanupTests.AfterAllCleanUpWithContextAndToken(context, cancellationToken));
    }
}


// ===== FILE SEPARATOR =====

// <auto-generated/>
#pragma warning disable

#nullable enable
#pragma warning disable CS9113 // Parameter is unread.
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Threading.Tasks;
using global::TUnit.Core;
using global::TUnit.Core.Hooks;
using global::TUnit.Core.Interfaces.SourceGenerator;
using global::TUnit.Core.Models;
using HookType = global::TUnit.Core.HookType;
namespace TUnit.Generated.Hooks.AssemblyCleanupTests_Cleanup_After_Test_GUID;
internal static class AssemblyCleanupTests_Cleanup_After_Test_GUIDInitializer
{
    [global::System.Runtime.CompilerServices.ModuleInitializer]
    public static void Initialize()
    {
        global::TUnit.Core.Sources.AfterTestHooks.GetOrAdd(typeof(global::TUnit.TestProject.AfterTests.AssemblyCleanupTests), _ => new global::System.Collections.Concurrent.ConcurrentBag<global::TUnit.Core.Hooks.InstanceHookMethod>());
        global::TUnit.Core.Sources.AfterTestHooks[typeof(global::TUnit.TestProject.AfterTests.AssemblyCleanupTests)].Add(
            new InstanceHookMethod
            {
                InitClassType = typeof(global::TUnit.TestProject.AfterTests.AssemblyCleanupTests),
                MethodInfo = new global::TUnit.Core.MethodMetadata
                {
                    Type = typeof(global::TUnit.TestProject.AfterTests.AssemblyCleanupTests),
                    TypeReference = global::TUnit.Core.TypeReference.CreateConcrete("TUnit.TestProject.AfterTests.AssemblyCleanupTests, TestsBase`1"),
                    Name = "Cleanup",
                    GenericTypeCount = 0,
                    ReturnType = typeof(global::System.Threading.Tasks.Task),
                    ReturnTypeReference = global::TUnit.Core.TypeReference.CreateConcrete("System.Threading.Tasks.Task, System.Private.CoreLib"),
                    Parameters = global::System.Array.Empty<global::TUnit.Core.ParameterMetadata>(),
                    Class = global::TUnit.Core.ClassMetadata.GetOrAdd("TestsBase`1:global::TUnit.TestProject.AfterTests.AssemblyCleanupTests", () => 
                    {
                        var classMetadata = new global::TUnit.Core.ClassMetadata
                        {
                            Type = typeof(global::TUnit.TestProject.AfterTests.AssemblyCleanupTests),
                            TypeReference = global::TUnit.Core.TypeReference.CreateConcrete("TUnit.TestProject.AfterTests.AssemblyCleanupTests, TestsBase`1"),
                            Name = "AssemblyCleanupTests",
                            Namespace = "TUnit.TestProject.AfterTests",
                            Assembly = global::TUnit.Core.AssemblyMetadata.GetOrAdd("TestsBase`1", () => new global::TUnit.Core.AssemblyMetadata { Name = "TestsBase`1" }),
                            Parameters = global::System.Array.Empty<global::TUnit.Core.ParameterMetadata>(),
                            Properties = global::System.Array.Empty<global::TUnit.Core.PropertyMetadata>(),
                            Parent = null
                        };
                        // Set ClassMetadata and ContainingTypeMetadata references on properties to avoid circular dependency
                        foreach (var prop in classMetadata.Properties)
                        {
                            prop.ClassMetadata = classMetadata;
                            prop.ContainingTypeMetadata = classMetadata;
                        }
                        return classMetadata;
                    })
                },
                HookExecutor = DefaultExecutor.Instance,
                Order = 0,
                RegistrationIndex = global::TUnit.Core.HookRegistrationIndices.GetNextAfterTestHookIndex(),
                Body = global_TUnit_TestProject_AfterTests_AssemblyCleanupTests_Cleanup_0Params_Body
            }
        );
    }
    private static async ValueTask global_TUnit_TestProject_AfterTests_AssemblyCleanupTests_Cleanup_0Params_Body(object instance, TestContext context, CancellationToken cancellationToken)
    {
        var typedInstance = (global::TUnit.TestProject.AfterTests.AssemblyCleanupTests)instance;
        await AsyncConvert.Convert(() => typedInstance.Cleanup());
    }
}


// ===== FILE SEPARATOR =====

// <auto-generated/>
#pragma warning disable

#nullable enable
#pragma warning disable CS9113 // Parameter is unread.
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Threading.Tasks;
using global::TUnit.Core;
using global::TUnit.Core.Hooks;
using global::TUnit.Core.Interfaces.SourceGenerator;
using global::TUnit.Core.Models;
using HookType = global::TUnit.Core.HookType;
namespace TUnit.Generated.Hooks.AssemblyCleanupTests_Cleanup_After_Test_GUID;
internal static class AssemblyCleanupTests_Cleanup_After_Test_GUIDInitializer
{
    [global::System.Runtime.CompilerServices.ModuleInitializer]
    public static void Initialize()
    {
        global::TUnit.Core.Sources.AfterTestHooks.GetOrAdd(typeof(global::TUnit.TestProject.AfterTests.AssemblyCleanupTests), _ => new global::System.Collections.Concurrent.ConcurrentBag<global::TUnit.Core.Hooks.InstanceHookMethod>());
        global::TUnit.Core.Sources.AfterTestHooks[typeof(global::TUnit.TestProject.AfterTests.AssemblyCleanupTests)].Add(
            new InstanceHookMethod
            {
                InitClassType = typeof(global::TUnit.TestProject.AfterTests.AssemblyCleanupTests),
                MethodInfo = new global::TUnit.Core.MethodMetadata
                {
                    Type = typeof(global::TUnit.TestProject.AfterTests.AssemblyCleanupTests),
                    TypeReference = global::TUnit.Core.TypeReference.CreateConcrete("TUnit.TestProject.AfterTests.AssemblyCleanupTests, TestsBase`1"),
                    Name = "Cleanup",
                    GenericTypeCount = 0,
                    ReturnType = typeof(global::System.Threading.Tasks.Task),
                    ReturnTypeReference = global::TUnit.Core.TypeReference.CreateConcrete("System.Threading.Tasks.Task, System.Private.CoreLib"),
                    Parameters = new global::TUnit.Core.ParameterMetadata[]
                    {
                        new global::TUnit.Core.ParameterMetadata(typeof(global::System.Threading.CancellationToken))
                        {
                            Name = "cancellationToken",
                            TypeReference = global::TUnit.Core.TypeReference.CreateConcrete("System.Threading.CancellationToken, System.Private.CoreLib"),
                            IsNullable = false,
                            ReflectionInfo = typeof(global::TUnit.TestProject.AfterTests.AssemblyCleanupTests).GetMethod("Cleanup", global::System.Reflection.BindingFlags.Public | global::System.Reflection.BindingFlags.Instance, null, new global::System.Type[] { typeof(global::System.Threading.CancellationToken) }, null)!.GetParameters()[0]
                        }
                    },
                    Class = global::TUnit.Core.ClassMetadata.GetOrAdd("TestsBase`1:global::TUnit.TestProject.AfterTests.AssemblyCleanupTests", () => 
                    {
                        var classMetadata = new global::TUnit.Core.ClassMetadata
                        {
                            Type = typeof(global::TUnit.TestProject.AfterTests.AssemblyCleanupTests),
                            TypeReference = global::TUnit.Core.TypeReference.CreateConcrete("TUnit.TestProject.AfterTests.AssemblyCleanupTests, TestsBase`1"),
                            Name = "AssemblyCleanupTests",
                            Namespace = "TUnit.TestProject.AfterTests",
                            Assembly = global::TUnit.Core.AssemblyMetadata.GetOrAdd("TestsBase`1", () => new global::TUnit.Core.AssemblyMetadata { Name = "TestsBase`1" }),
                            Parameters = global::System.Array.Empty<global::TUnit.Core.ParameterMetadata>(),
                            Properties = global::System.Array.Empty<global::TUnit.Core.PropertyMetadata>(),
                            Parent = null
                        };
                        // Set ClassMetadata and ContainingTypeMetadata references on properties to avoid circular dependency
                        foreach (var prop in classMetadata.Properties)
                        {
                            prop.ClassMetadata = classMetadata;
                            prop.ContainingTypeMetadata = classMetadata;
                        }
                        return classMetadata;
                    })
                },
                HookExecutor = DefaultExecutor.Instance,
                Order = 0,
                RegistrationIndex = global::TUnit.Core.HookRegistrationIndices.GetNextAfterTestHookIndex(),
                Body = global_TUnit_TestProject_AfterTests_AssemblyCleanupTests_Cleanup_1Params_Body
            }
        );
    }
    private static async ValueTask global_TUnit_TestProject_AfterTests_AssemblyCleanupTests_Cleanup_1Params_Body(object instance, TestContext context, CancellationToken cancellationToken)
    {
        var typedInstance = (global::TUnit.TestProject.AfterTests.AssemblyCleanupTests)instance;
        await AsyncConvert.Convert(() => typedInstance.Cleanup(cancellationToken));
    }
}


// ===== FILE SEPARATOR =====

// <auto-generated/>
#pragma warning disable

#nullable enable
#pragma warning disable CS9113 // Parameter is unread.
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Threading.Tasks;
using global::TUnit.Core;
using global::TUnit.Core.Hooks;
using global::TUnit.Core.Interfaces.SourceGenerator;
using global::TUnit.Core.Models;
using HookType = global::TUnit.Core.HookType;
namespace TUnit.Generated.Hooks.AssemblyCleanupTests_CleanupWithContext_After_Test_GUID;
internal static class AssemblyCleanupTests_CleanupWithContext_After_Test_GUIDInitializer
{
    [global::System.Runtime.CompilerServices.ModuleInitializer]
    public static void Initialize()
    {
        global::TUnit.Core.Sources.AfterTestHooks.GetOrAdd(typeof(global::TUnit.TestProject.AfterTests.AssemblyCleanupTests), _ => new global::System.Collections.Concurrent.ConcurrentBag<global::TUnit.Core.Hooks.InstanceHookMethod>());
        global::TUnit.Core.Sources.AfterTestHooks[typeof(global::TUnit.TestProject.AfterTests.AssemblyCleanupTests)].Add(
            new InstanceHookMethod
            {
                InitClassType = typeof(global::TUnit.TestProject.AfterTests.AssemblyCleanupTests),
                MethodInfo = new global::TUnit.Core.MethodMetadata
                {
                    Type = typeof(global::TUnit.TestProject.AfterTests.AssemblyCleanupTests),
                    TypeReference = global::TUnit.Core.TypeReference.CreateConcrete("TUnit.TestProject.AfterTests.AssemblyCleanupTests, TestsBase`1"),
                    Name = "CleanupWithContext",
                    GenericTypeCount = 0,
                    ReturnType = typeof(global::System.Threading.Tasks.Task),
                    ReturnTypeReference = global::TUnit.Core.TypeReference.CreateConcrete("System.Threading.Tasks.Task, System.Private.CoreLib"),
                    Parameters = new global::TUnit.Core.ParameterMetadata[]
                    {
                        new global::TUnit.Core.ParameterMetadata(typeof(global::TUnit.Core.TestContext))
                        {
                            Name = "testContext",
                            TypeReference = global::TUnit.Core.TypeReference.CreateConcrete("TUnit.Core.TestContext, TUnit.Core"),
                            IsNullable = false,
                            ReflectionInfo = typeof(global::TUnit.TestProject.AfterTests.AssemblyCleanupTests).GetMethod("CleanupWithContext", global::System.Reflection.BindingFlags.Public | global::System.Reflection.BindingFlags.Instance, null, new global::System.Type[] { typeof(global::TUnit.Core.TestContext) }, null)!.GetParameters()[0]
                        }
                    },
                    Class = global::TUnit.Core.ClassMetadata.GetOrAdd("TestsBase`1:global::TUnit.TestProject.AfterTests.AssemblyCleanupTests", () => 
                    {
                        var classMetadata = new global::TUnit.Core.ClassMetadata
                        {
                            Type = typeof(global::TUnit.TestProject.AfterTests.AssemblyCleanupTests),
                            TypeReference = global::TUnit.Core.TypeReference.CreateConcrete("TUnit.TestProject.AfterTests.AssemblyCleanupTests, TestsBase`1"),
                            Name = "AssemblyCleanupTests",
                            Namespace = "TUnit.TestProject.AfterTests",
                            Assembly = global::TUnit.Core.AssemblyMetadata.GetOrAdd("TestsBase`1", () => new global::TUnit.Core.AssemblyMetadata { Name = "TestsBase`1" }),
                            Parameters = global::System.Array.Empty<global::TUnit.Core.ParameterMetadata>(),
                            Properties = global::System.Array.Empty<global::TUnit.Core.PropertyMetadata>(),
                            Parent = null
                        };
                        // Set ClassMetadata and ContainingTypeMetadata references on properties to avoid circular dependency
                        foreach (var prop in classMetadata.Properties)
                        {
                            prop.ClassMetadata = classMetadata;
                            prop.ContainingTypeMetadata = classMetadata;
                        }
                        return classMetadata;
                    })
                },
                HookExecutor = DefaultExecutor.Instance,
                Order = 0,
                RegistrationIndex = global::TUnit.Core.HookRegistrationIndices.GetNextAfterTestHookIndex(),
                Body = global_TUnit_TestProject_AfterTests_AssemblyCleanupTests_CleanupWithContext_1Params_Body
            }
        );
    }
    private static async ValueTask global_TUnit_TestProject_AfterTests_AssemblyCleanupTests_CleanupWithContext_1Params_Body(object instance, TestContext context, CancellationToken cancellationToken)
    {
        var typedInstance = (global::TUnit.TestProject.AfterTests.AssemblyCleanupTests)instance;
        await AsyncConvert.Convert(() => typedInstance.CleanupWithContext(context));
    }
}


// ===== FILE SEPARATOR =====

// <auto-generated/>
#pragma warning disable

#nullable enable
#pragma warning disable CS9113 // Parameter is unread.
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Threading.Tasks;
using global::TUnit.Core;
using global::TUnit.Core.Hooks;
using global::TUnit.Core.Interfaces.SourceGenerator;
using global::TUnit.Core.Models;
using HookType = global::TUnit.Core.HookType;
namespace TUnit.Generated.Hooks.AssemblyCleanupTests_CleanupWithContext_After_Test_GUID;
internal static class AssemblyCleanupTests_CleanupWithContext_After_Test_GUIDInitializer
{
    [global::System.Runtime.CompilerServices.ModuleInitializer]
    public static void Initialize()
    {
        global::TUnit.Core.Sources.AfterTestHooks.GetOrAdd(typeof(global::TUnit.TestProject.AfterTests.AssemblyCleanupTests), _ => new global::System.Collections.Concurrent.ConcurrentBag<global::TUnit.Core.Hooks.InstanceHookMethod>());
        global::TUnit.Core.Sources.AfterTestHooks[typeof(global::TUnit.TestProject.AfterTests.AssemblyCleanupTests)].Add(
            new InstanceHookMethod
            {
                InitClassType = typeof(global::TUnit.TestProject.AfterTests.AssemblyCleanupTests),
                MethodInfo = new global::TUnit.Core.MethodMetadata
                {
                    Type = typeof(global::TUnit.TestProject.AfterTests.AssemblyCleanupTests),
                    TypeReference = global::TUnit.Core.TypeReference.CreateConcrete("TUnit.TestProject.AfterTests.AssemblyCleanupTests, TestsBase`1"),
                    Name = "CleanupWithContext",
                    GenericTypeCount = 0,
                    ReturnType = typeof(global::System.Threading.Tasks.Task),
                    ReturnTypeReference = global::TUnit.Core.TypeReference.CreateConcrete("System.Threading.Tasks.Task, System.Private.CoreLib"),
                    Parameters = new global::TUnit.Core.ParameterMetadata[]
                    {
                        new global::TUnit.Core.ParameterMetadata(typeof(global::TUnit.Core.TestContext))
                        {
                            Name = "testContext",
                            TypeReference = global::TUnit.Core.TypeReference.CreateConcrete("TUnit.Core.TestContext, TUnit.Core"),
                            IsNullable = false,
                            ReflectionInfo = typeof(global::TUnit.TestProject.AfterTests.AssemblyCleanupTests).GetMethod("CleanupWithContext", global::System.Reflection.BindingFlags.Public | global::System.Reflection.BindingFlags.Instance, null, new global::System.Type[] { typeof(global::TUnit.Core.TestContext), typeof(global::System.Threading.CancellationToken) }, null)!.GetParameters()[0]
                        },
                        new global::TUnit.Core.ParameterMetadata(typeof(global::System.Threading.CancellationToken))
                        {
                            Name = "cancellationToken",
                            TypeReference = global::TUnit.Core.TypeReference.CreateConcrete("System.Threading.CancellationToken, System.Private.CoreLib"),
                            IsNullable = false,
                            ReflectionInfo = typeof(global::TUnit.TestProject.AfterTests.AssemblyCleanupTests).GetMethod("CleanupWithContext", global::System.Reflection.BindingFlags.Public | global::System.Reflection.BindingFlags.Instance, null, new global::System.Type[] { typeof(global::TUnit.Core.TestContext), typeof(global::System.Threading.CancellationToken) }, null)!.GetParameters()[1]
                        }
                    },
                    Class = global::TUnit.Core.ClassMetadata.GetOrAdd("TestsBase`1:global::TUnit.TestProject.AfterTests.AssemblyCleanupTests", () => 
                    {
                        var classMetadata = new global::TUnit.Core.ClassMetadata
                        {
                            Type = typeof(global::TUnit.TestProject.AfterTests.AssemblyCleanupTests),
                            TypeReference = global::TUnit.Core.TypeReference.CreateConcrete("TUnit.TestProject.AfterTests.AssemblyCleanupTests, TestsBase`1"),
                            Name = "AssemblyCleanupTests",
                            Namespace = "TUnit.TestProject.AfterTests",
                            Assembly = global::TUnit.Core.AssemblyMetadata.GetOrAdd("TestsBase`1", () => new global::TUnit.Core.AssemblyMetadata { Name = "TestsBase`1" }),
                            Parameters = global::System.Array.Empty<global::TUnit.Core.ParameterMetadata>(),
                            Properties = global::System.Array.Empty<global::TUnit.Core.PropertyMetadata>(),
                            Parent = null
                        };
                        // Set ClassMetadata and ContainingTypeMetadata references on properties to avoid circular dependency
                        foreach (var prop in classMetadata.Properties)
                        {
                            prop.ClassMetadata = classMetadata;
                            prop.ContainingTypeMetadata = classMetadata;
                        }
                        return classMetadata;
                    })
                },
                HookExecutor = DefaultExecutor.Instance,
                Order = 0,
                RegistrationIndex = global::TUnit.Core.HookRegistrationIndices.GetNextAfterTestHookIndex(),
                Body = global_TUnit_TestProject_AfterTests_AssemblyCleanupTests_CleanupWithContext_2Params_Body
            }
        );
    }
    private static async ValueTask global_TUnit_TestProject_AfterTests_AssemblyCleanupTests_CleanupWithContext_2Params_Body(object instance, TestContext context, CancellationToken cancellationToken)
    {
        var typedInstance = (global::TUnit.TestProject.AfterTests.AssemblyCleanupTests)instance;
        await AsyncConvert.Convert(() => typedInstance.CleanupWithContext(context, cancellationToken));
    }
}
