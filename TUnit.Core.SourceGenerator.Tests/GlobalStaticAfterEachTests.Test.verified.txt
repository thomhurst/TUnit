// <auto-generated/>
#pragma warning disable

#nullable enable
#pragma warning disable CS9113 // Parameter is unread.
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Threading.Tasks;
using global::TUnit.Core;
using global::TUnit.Core.Hooks;
using global::TUnit.Core.Interfaces.SourceGenerator;
using global::TUnit.Core.Models;
using HookType = global::TUnit.Core.HookType;
namespace TUnit.Generated.Hooks;
public sealed class GeneratedHookRegistry
{
    static GeneratedHookRegistry()
    {
        try
        {
            PopulateSourcesDictionaries();
        }
        catch (Exception ex)
        {
            throw new InvalidOperationException($"Failed to initialize hook registry: {ex.Message}", ex);
        }
    }
    private static void PopulateSourcesDictionaries()
    {
        global::TUnit.Core.Sources.AfterTestHooks.GetOrAdd(typeof(global::TUnit.TestProject.AfterTests.GlobalBase1), _ => new global::System.Collections.Concurrent.ConcurrentBag<global::TUnit.Core.Hooks.InstanceHookMethod>());
        global::TUnit.Core.Sources.AfterTestHooks[typeof(global::TUnit.TestProject.AfterTests.GlobalBase1)].Add(
            new InstanceHookMethod
            {
                ClassType = typeof(global::TUnit.TestProject.AfterTests.GlobalBase1),
                MethodInfo = new global::TUnit.Core.MethodMetadata
{
Type = typeof(global::TUnit.TestProject.AfterTests.GlobalBase1),
TypeReference = global::TUnit.Core.TypeReference.CreateConcrete("TUnit.TestProject.AfterTests.GlobalBase1, TestsBase`1"),
Name = "AfterEach1",
GenericTypeCount = 0,
ReturnType = typeof(global::System.Threading.Tasks.Task),
ReturnTypeReference = global::TUnit.Core.TypeReference.CreateConcrete("System.Threading.Tasks.Task, System.Private.CoreLib"),
Parameters = global::System.Array.Empty<global::TUnit.Core.ParameterMetadata>(),
Class = global::TUnit.Core.ClassMetadata.GetOrAdd("TestsBase`1:global::TUnit.TestProject.AfterTests.GlobalBase1", () => 
{
var classMetadata = new global::TUnit.Core.ClassMetadata
{
Type = typeof(global::TUnit.TestProject.AfterTests.GlobalBase1),
TypeReference = global::TUnit.Core.TypeReference.CreateConcrete("TUnit.TestProject.AfterTests.GlobalBase1, TestsBase`1"),
Name = "GlobalBase1",
Namespace = "TUnit.TestProject.AfterTests",
Assembly = global::TUnit.Core.AssemblyMetadata.GetOrAdd("TestsBase`1", () => new global::TUnit.Core.AssemblyMetadata { Name = "TestsBase`1" }),
Parameters = global::System.Array.Empty<global::TUnit.Core.ParameterMetadata>(),
Properties = global::System.Array.Empty<global::TUnit.Core.PropertyMetadata>(),
Parent = null
};
// Set ClassMetadata and ContainingTypeMetadata references on properties to avoid circular dependency
foreach (var prop in classMetadata.Properties)
{
prop.ClassMetadata = classMetadata;
prop.ContainingTypeMetadata = classMetadata;
}
return classMetadata;
})
},
                HookExecutor = null!,
                Order = 0,
                Body = global_TUnit_TestProject_AfterTests_GlobalBase1_AfterEach1_0Params_Body
            }
        );
        global::TUnit.Core.Sources.AfterTestHooks.GetOrAdd(typeof(global::TUnit.TestProject.AfterTests.GlobalBase2), _ => new global::System.Collections.Concurrent.ConcurrentBag<global::TUnit.Core.Hooks.InstanceHookMethod>());
        global::TUnit.Core.Sources.AfterTestHooks[typeof(global::TUnit.TestProject.AfterTests.GlobalBase2)].Add(
            new InstanceHookMethod
            {
                ClassType = typeof(global::TUnit.TestProject.AfterTests.GlobalBase2),
                MethodInfo = new global::TUnit.Core.MethodMetadata
{
Type = typeof(global::TUnit.TestProject.AfterTests.GlobalBase2),
TypeReference = global::TUnit.Core.TypeReference.CreateConcrete("TUnit.TestProject.AfterTests.GlobalBase2, TestsBase`1"),
Name = "AfterEach2",
GenericTypeCount = 0,
ReturnType = typeof(global::System.Threading.Tasks.Task),
ReturnTypeReference = global::TUnit.Core.TypeReference.CreateConcrete("System.Threading.Tasks.Task, System.Private.CoreLib"),
Parameters = global::System.Array.Empty<global::TUnit.Core.ParameterMetadata>(),
Class = global::TUnit.Core.ClassMetadata.GetOrAdd("TestsBase`1:global::TUnit.TestProject.AfterTests.GlobalBase2", () => 
{
var classMetadata = new global::TUnit.Core.ClassMetadata
{
Type = typeof(global::TUnit.TestProject.AfterTests.GlobalBase2),
TypeReference = global::TUnit.Core.TypeReference.CreateConcrete("TUnit.TestProject.AfterTests.GlobalBase2, TestsBase`1"),
Name = "GlobalBase2",
Namespace = "TUnit.TestProject.AfterTests",
Assembly = global::TUnit.Core.AssemblyMetadata.GetOrAdd("TestsBase`1", () => new global::TUnit.Core.AssemblyMetadata { Name = "TestsBase`1" }),
Parameters = global::System.Array.Empty<global::TUnit.Core.ParameterMetadata>(),
Properties = global::System.Array.Empty<global::TUnit.Core.PropertyMetadata>(),
Parent = null
};
// Set ClassMetadata and ContainingTypeMetadata references on properties to avoid circular dependency
foreach (var prop in classMetadata.Properties)
{
prop.ClassMetadata = classMetadata;
prop.ContainingTypeMetadata = classMetadata;
}
return classMetadata;
})
},
                HookExecutor = null!,
                Order = 0,
                Body = global_TUnit_TestProject_AfterTests_GlobalBase2_AfterEach2_0Params_Body
            }
        );
        global::TUnit.Core.Sources.AfterTestHooks.GetOrAdd(typeof(global::TUnit.TestProject.AfterTests.GlobalBase3), _ => new global::System.Collections.Concurrent.ConcurrentBag<global::TUnit.Core.Hooks.InstanceHookMethod>());
        global::TUnit.Core.Sources.AfterTestHooks[typeof(global::TUnit.TestProject.AfterTests.GlobalBase3)].Add(
            new InstanceHookMethod
            {
                ClassType = typeof(global::TUnit.TestProject.AfterTests.GlobalBase3),
                MethodInfo = new global::TUnit.Core.MethodMetadata
{
Type = typeof(global::TUnit.TestProject.AfterTests.GlobalBase3),
TypeReference = global::TUnit.Core.TypeReference.CreateConcrete("TUnit.TestProject.AfterTests.GlobalBase3, TestsBase`1"),
Name = "AfterEach3",
GenericTypeCount = 0,
ReturnType = typeof(global::System.Threading.Tasks.Task),
ReturnTypeReference = global::TUnit.Core.TypeReference.CreateConcrete("System.Threading.Tasks.Task, System.Private.CoreLib"),
Parameters = global::System.Array.Empty<global::TUnit.Core.ParameterMetadata>(),
Class = global::TUnit.Core.ClassMetadata.GetOrAdd("TestsBase`1:global::TUnit.TestProject.AfterTests.GlobalBase3", () => 
{
var classMetadata = new global::TUnit.Core.ClassMetadata
{
Type = typeof(global::TUnit.TestProject.AfterTests.GlobalBase3),
TypeReference = global::TUnit.Core.TypeReference.CreateConcrete("TUnit.TestProject.AfterTests.GlobalBase3, TestsBase`1"),
Name = "GlobalBase3",
Namespace = "TUnit.TestProject.AfterTests",
Assembly = global::TUnit.Core.AssemblyMetadata.GetOrAdd("TestsBase`1", () => new global::TUnit.Core.AssemblyMetadata { Name = "TestsBase`1" }),
Parameters = global::System.Array.Empty<global::TUnit.Core.ParameterMetadata>(),
Properties = global::System.Array.Empty<global::TUnit.Core.PropertyMetadata>(),
Parent = null
};
// Set ClassMetadata and ContainingTypeMetadata references on properties to avoid circular dependency
foreach (var prop in classMetadata.Properties)
{
prop.ClassMetadata = classMetadata;
prop.ContainingTypeMetadata = classMetadata;
}
return classMetadata;
})
},
                HookExecutor = null!,
                Order = 0,
                Body = global_TUnit_TestProject_AfterTests_GlobalBase3_AfterEach3_0Params_Body
            }
        );
        global::TUnit.Core.Sources.AfterTestHooks.GetOrAdd(typeof(global::TUnit.TestProject.AfterTests.GlobalCleanUpTests), _ => new global::System.Collections.Concurrent.ConcurrentBag<global::TUnit.Core.Hooks.InstanceHookMethod>());
        global::TUnit.Core.Sources.AfterTestHooks[typeof(global::TUnit.TestProject.AfterTests.GlobalCleanUpTests)].Add(
            new InstanceHookMethod
            {
                ClassType = typeof(global::TUnit.TestProject.AfterTests.GlobalCleanUpTests),
                MethodInfo = new global::TUnit.Core.MethodMetadata
{
Type = typeof(global::TUnit.TestProject.AfterTests.GlobalCleanUpTests),
TypeReference = global::TUnit.Core.TypeReference.CreateConcrete("TUnit.TestProject.AfterTests.GlobalCleanUpTests, TestsBase`1"),
Name = "CleanUp",
GenericTypeCount = 0,
ReturnType = typeof(global::System.Threading.Tasks.Task),
ReturnTypeReference = global::TUnit.Core.TypeReference.CreateConcrete("System.Threading.Tasks.Task, System.Private.CoreLib"),
Parameters = global::System.Array.Empty<global::TUnit.Core.ParameterMetadata>(),
Class = global::TUnit.Core.ClassMetadata.GetOrAdd("TestsBase`1:global::TUnit.TestProject.AfterTests.GlobalCleanUpTests", () => 
{
var classMetadata = new global::TUnit.Core.ClassMetadata
{
Type = typeof(global::TUnit.TestProject.AfterTests.GlobalCleanUpTests),
TypeReference = global::TUnit.Core.TypeReference.CreateConcrete("TUnit.TestProject.AfterTests.GlobalCleanUpTests, TestsBase`1"),
Name = "GlobalCleanUpTests",
Namespace = "TUnit.TestProject.AfterTests",
Assembly = global::TUnit.Core.AssemblyMetadata.GetOrAdd("TestsBase`1", () => new global::TUnit.Core.AssemblyMetadata { Name = "TestsBase`1" }),
Parameters = global::System.Array.Empty<global::TUnit.Core.ParameterMetadata>(),
Properties = global::System.Array.Empty<global::TUnit.Core.PropertyMetadata>(),
Parent = null
};
// Set ClassMetadata and ContainingTypeMetadata references on properties to avoid circular dependency
foreach (var prop in classMetadata.Properties)
{
prop.ClassMetadata = classMetadata;
prop.ContainingTypeMetadata = classMetadata;
}
return classMetadata;
})
},
                HookExecutor = null!,
                Order = 0,
                Body = global_TUnit_TestProject_AfterTests_GlobalCleanUpTests_CleanUp_0Params_Body
            }
        );
        global::TUnit.Core.Sources.AfterTestHooks[typeof(global::TUnit.TestProject.AfterTests.GlobalCleanUpTests)].Add(
            new InstanceHookMethod
            {
                ClassType = typeof(global::TUnit.TestProject.AfterTests.GlobalCleanUpTests),
                MethodInfo = new global::TUnit.Core.MethodMetadata
{
Type = typeof(global::TUnit.TestProject.AfterTests.GlobalCleanUpTests),
TypeReference = global::TUnit.Core.TypeReference.CreateConcrete("TUnit.TestProject.AfterTests.GlobalCleanUpTests, TestsBase`1"),
Name = "CleanUp",
GenericTypeCount = 0,
ReturnType = typeof(global::System.Threading.Tasks.Task),
ReturnTypeReference = global::TUnit.Core.TypeReference.CreateConcrete("System.Threading.Tasks.Task, System.Private.CoreLib"),
Parameters = new global::TUnit.Core.ParameterMetadata[]
{
new global::TUnit.Core.ParameterMetadata(typeof(global::System.Threading.CancellationToken))
{
    Name = "cancellationToken",
    TypeReference = global::TUnit.Core.TypeReference.CreateConcrete("System.Threading.CancellationToken, System.Private.CoreLib"),
    IsNullable = false,
    ReflectionInfo = typeof(global::TUnit.TestProject.AfterTests.GlobalCleanUpTests).GetMethod("CleanUp", System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Instance, null, new global::System.Type[] { typeof(global::System.Threading.CancellationToken) }, null)!.GetParameters()[0]
},
},
Class = global::TUnit.Core.ClassMetadata.GetOrAdd("TestsBase`1:global::TUnit.TestProject.AfterTests.GlobalCleanUpTests", () => 
{
var classMetadata = new global::TUnit.Core.ClassMetadata
{
Type = typeof(global::TUnit.TestProject.AfterTests.GlobalCleanUpTests),
TypeReference = global::TUnit.Core.TypeReference.CreateConcrete("TUnit.TestProject.AfterTests.GlobalCleanUpTests, TestsBase`1"),
Name = "GlobalCleanUpTests",
Namespace = "TUnit.TestProject.AfterTests",
Assembly = global::TUnit.Core.AssemblyMetadata.GetOrAdd("TestsBase`1", () => new global::TUnit.Core.AssemblyMetadata { Name = "TestsBase`1" }),
Parameters = global::System.Array.Empty<global::TUnit.Core.ParameterMetadata>(),
Properties = global::System.Array.Empty<global::TUnit.Core.PropertyMetadata>(),
Parent = null
};
// Set ClassMetadata and ContainingTypeMetadata references on properties to avoid circular dependency
foreach (var prop in classMetadata.Properties)
{
prop.ClassMetadata = classMetadata;
prop.ContainingTypeMetadata = classMetadata;
}
return classMetadata;
})
},
                HookExecutor = null!,
                Order = 0,
                Body = global_TUnit_TestProject_AfterTests_GlobalCleanUpTests_CleanUp_1Params_Body
            }
        );
        global::TUnit.Core.Sources.AfterTestHooks[typeof(global::TUnit.TestProject.AfterTests.GlobalCleanUpTests)].Add(
            new InstanceHookMethod
            {
                ClassType = typeof(global::TUnit.TestProject.AfterTests.GlobalCleanUpTests),
                MethodInfo = new global::TUnit.Core.MethodMetadata
{
Type = typeof(global::TUnit.TestProject.AfterTests.GlobalCleanUpTests),
TypeReference = global::TUnit.Core.TypeReference.CreateConcrete("TUnit.TestProject.AfterTests.GlobalCleanUpTests, TestsBase`1"),
Name = "CleanUpWithContext",
GenericTypeCount = 0,
ReturnType = typeof(global::System.Threading.Tasks.Task),
ReturnTypeReference = global::TUnit.Core.TypeReference.CreateConcrete("System.Threading.Tasks.Task, System.Private.CoreLib"),
Parameters = new global::TUnit.Core.ParameterMetadata[]
{
new global::TUnit.Core.ParameterMetadata(typeof(global::TUnit.Core.TestContext))
{
    Name = "testContext",
    TypeReference = global::TUnit.Core.TypeReference.CreateConcrete("TUnit.Core.TestContext, TUnit.Core"),
    IsNullable = false,
    ReflectionInfo = typeof(global::TUnit.TestProject.AfterTests.GlobalCleanUpTests).GetMethod("CleanUpWithContext", System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Instance, null, new global::System.Type[] { typeof(global::TUnit.Core.TestContext) }, null)!.GetParameters()[0]
},
},
Class = global::TUnit.Core.ClassMetadata.GetOrAdd("TestsBase`1:global::TUnit.TestProject.AfterTests.GlobalCleanUpTests", () => 
{
var classMetadata = new global::TUnit.Core.ClassMetadata
{
Type = typeof(global::TUnit.TestProject.AfterTests.GlobalCleanUpTests),
TypeReference = global::TUnit.Core.TypeReference.CreateConcrete("TUnit.TestProject.AfterTests.GlobalCleanUpTests, TestsBase`1"),
Name = "GlobalCleanUpTests",
Namespace = "TUnit.TestProject.AfterTests",
Assembly = global::TUnit.Core.AssemblyMetadata.GetOrAdd("TestsBase`1", () => new global::TUnit.Core.AssemblyMetadata { Name = "TestsBase`1" }),
Parameters = global::System.Array.Empty<global::TUnit.Core.ParameterMetadata>(),
Properties = global::System.Array.Empty<global::TUnit.Core.PropertyMetadata>(),
Parent = null
};
// Set ClassMetadata and ContainingTypeMetadata references on properties to avoid circular dependency
foreach (var prop in classMetadata.Properties)
{
prop.ClassMetadata = classMetadata;
prop.ContainingTypeMetadata = classMetadata;
}
return classMetadata;
})
},
                HookExecutor = null!,
                Order = 0,
                Body = global_TUnit_TestProject_AfterTests_GlobalCleanUpTests_CleanUpWithContext_1Params_Body
            }
        );
        global::TUnit.Core.Sources.AfterTestHooks[typeof(global::TUnit.TestProject.AfterTests.GlobalCleanUpTests)].Add(
            new InstanceHookMethod
            {
                ClassType = typeof(global::TUnit.TestProject.AfterTests.GlobalCleanUpTests),
                MethodInfo = new global::TUnit.Core.MethodMetadata
{
Type = typeof(global::TUnit.TestProject.AfterTests.GlobalCleanUpTests),
TypeReference = global::TUnit.Core.TypeReference.CreateConcrete("TUnit.TestProject.AfterTests.GlobalCleanUpTests, TestsBase`1"),
Name = "CleanUpWithContext",
GenericTypeCount = 0,
ReturnType = typeof(global::System.Threading.Tasks.Task),
ReturnTypeReference = global::TUnit.Core.TypeReference.CreateConcrete("System.Threading.Tasks.Task, System.Private.CoreLib"),
Parameters = new global::TUnit.Core.ParameterMetadata[]
{
new global::TUnit.Core.ParameterMetadata(typeof(global::TUnit.Core.TestContext))
{
    Name = "testContext",
    TypeReference = global::TUnit.Core.TypeReference.CreateConcrete("TUnit.Core.TestContext, TUnit.Core"),
    IsNullable = false,
    ReflectionInfo = typeof(global::TUnit.TestProject.AfterTests.GlobalCleanUpTests).GetMethod("CleanUpWithContext", System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Instance, null, new global::System.Type[] { typeof(global::TUnit.Core.TestContext), typeof(global::System.Threading.CancellationToken) }, null)!.GetParameters()[0]
},
new global::TUnit.Core.ParameterMetadata(typeof(global::System.Threading.CancellationToken))
{
    Name = "cancellationToken",
    TypeReference = global::TUnit.Core.TypeReference.CreateConcrete("System.Threading.CancellationToken, System.Private.CoreLib"),
    IsNullable = false,
    ReflectionInfo = typeof(global::TUnit.TestProject.AfterTests.GlobalCleanUpTests).GetMethod("CleanUpWithContext", System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Instance, null, new global::System.Type[] { typeof(global::TUnit.Core.TestContext), typeof(global::System.Threading.CancellationToken) }, null)!.GetParameters()[1]
},
},
Class = global::TUnit.Core.ClassMetadata.GetOrAdd("TestsBase`1:global::TUnit.TestProject.AfterTests.GlobalCleanUpTests", () => 
{
var classMetadata = new global::TUnit.Core.ClassMetadata
{
Type = typeof(global::TUnit.TestProject.AfterTests.GlobalCleanUpTests),
TypeReference = global::TUnit.Core.TypeReference.CreateConcrete("TUnit.TestProject.AfterTests.GlobalCleanUpTests, TestsBase`1"),
Name = "GlobalCleanUpTests",
Namespace = "TUnit.TestProject.AfterTests",
Assembly = global::TUnit.Core.AssemblyMetadata.GetOrAdd("TestsBase`1", () => new global::TUnit.Core.AssemblyMetadata { Name = "TestsBase`1" }),
Parameters = global::System.Array.Empty<global::TUnit.Core.ParameterMetadata>(),
Properties = global::System.Array.Empty<global::TUnit.Core.PropertyMetadata>(),
Parent = null
};
// Set ClassMetadata and ContainingTypeMetadata references on properties to avoid circular dependency
foreach (var prop in classMetadata.Properties)
{
prop.ClassMetadata = classMetadata;
prop.ContainingTypeMetadata = classMetadata;
}
return classMetadata;
})
},
                HookExecutor = null!,
                Order = 0,
                Body = global_TUnit_TestProject_AfterTests_GlobalCleanUpTests_CleanUpWithContext_2Params_Body
            }
        );
        global::TUnit.Core.Sources.AfterEveryTestHooks.Add(
            new AfterTestHookMethod
            {
                MethodInfo = new global::TUnit.Core.MethodMetadata
{
Type = typeof(global::TUnit.TestProject.AfterTests.GlobalBase1),
TypeReference = global::TUnit.Core.TypeReference.CreateConcrete("TUnit.TestProject.AfterTests.GlobalBase1, TestsBase`1"),
Name = "AfterAll1",
GenericTypeCount = 0,
ReturnType = typeof(global::System.Threading.Tasks.Task),
ReturnTypeReference = global::TUnit.Core.TypeReference.CreateConcrete("System.Threading.Tasks.Task, System.Private.CoreLib"),
Parameters = new global::TUnit.Core.ParameterMetadata[]
{
new global::TUnit.Core.ParameterMetadata(typeof(global::TUnit.Core.TestContext))
{
    Name = "context",
    TypeReference = global::TUnit.Core.TypeReference.CreateConcrete("TUnit.Core.TestContext, TUnit.Core"),
    IsNullable = false,
    ReflectionInfo = typeof(global::TUnit.TestProject.AfterTests.GlobalBase1).GetMethod("AfterAll1", System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Static, null, new global::System.Type[] { typeof(global::TUnit.Core.TestContext) }, null)!.GetParameters()[0]
},
},
Class = global::TUnit.Core.ClassMetadata.GetOrAdd("TestsBase`1:global::TUnit.TestProject.AfterTests.GlobalBase1", () => 
{
var classMetadata = new global::TUnit.Core.ClassMetadata
{
Type = typeof(global::TUnit.TestProject.AfterTests.GlobalBase1),
TypeReference = global::TUnit.Core.TypeReference.CreateConcrete("TUnit.TestProject.AfterTests.GlobalBase1, TestsBase`1"),
Name = "GlobalBase1",
Namespace = "TUnit.TestProject.AfterTests",
Assembly = global::TUnit.Core.AssemblyMetadata.GetOrAdd("TestsBase`1", () => new global::TUnit.Core.AssemblyMetadata { Name = "TestsBase`1" }),
Parameters = global::System.Array.Empty<global::TUnit.Core.ParameterMetadata>(),
Properties = global::System.Array.Empty<global::TUnit.Core.PropertyMetadata>(),
Parent = null
};
// Set ClassMetadata and ContainingTypeMetadata references on properties to avoid circular dependency
foreach (var prop in classMetadata.Properties)
{
prop.ClassMetadata = classMetadata;
prop.ContainingTypeMetadata = classMetadata;
}
return classMetadata;
})
},
                HookExecutor = null!,
                Order = 0,
                Body = global_TUnit_TestProject_AfterTests_GlobalBase1_AfterAll1_1Params_Body,
                FilePath = @"",
                LineNumber = 5
            }
        );
        global::TUnit.Core.Sources.AfterEveryTestHooks.Add(
            new AfterTestHookMethod
            {
                MethodInfo = new global::TUnit.Core.MethodMetadata
{
Type = typeof(global::TUnit.TestProject.AfterTests.GlobalBase2),
TypeReference = global::TUnit.Core.TypeReference.CreateConcrete("TUnit.TestProject.AfterTests.GlobalBase2, TestsBase`1"),
Name = "AfterAll2",
GenericTypeCount = 0,
ReturnType = typeof(global::System.Threading.Tasks.Task),
ReturnTypeReference = global::TUnit.Core.TypeReference.CreateConcrete("System.Threading.Tasks.Task, System.Private.CoreLib"),
Parameters = new global::TUnit.Core.ParameterMetadata[]
{
new global::TUnit.Core.ParameterMetadata(typeof(global::TUnit.Core.TestContext))
{
    Name = "context",
    TypeReference = global::TUnit.Core.TypeReference.CreateConcrete("TUnit.Core.TestContext, TUnit.Core"),
    IsNullable = false,
    ReflectionInfo = typeof(global::TUnit.TestProject.AfterTests.GlobalBase2).GetMethod("AfterAll2", System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Static, null, new global::System.Type[] { typeof(global::TUnit.Core.TestContext) }, null)!.GetParameters()[0]
},
},
Class = global::TUnit.Core.ClassMetadata.GetOrAdd("TestsBase`1:global::TUnit.TestProject.AfterTests.GlobalBase2", () => 
{
var classMetadata = new global::TUnit.Core.ClassMetadata
{
Type = typeof(global::TUnit.TestProject.AfterTests.GlobalBase2),
TypeReference = global::TUnit.Core.TypeReference.CreateConcrete("TUnit.TestProject.AfterTests.GlobalBase2, TestsBase`1"),
Name = "GlobalBase2",
Namespace = "TUnit.TestProject.AfterTests",
Assembly = global::TUnit.Core.AssemblyMetadata.GetOrAdd("TestsBase`1", () => new global::TUnit.Core.AssemblyMetadata { Name = "TestsBase`1" }),
Parameters = global::System.Array.Empty<global::TUnit.Core.ParameterMetadata>(),
Properties = global::System.Array.Empty<global::TUnit.Core.PropertyMetadata>(),
Parent = null
};
// Set ClassMetadata and ContainingTypeMetadata references on properties to avoid circular dependency
foreach (var prop in classMetadata.Properties)
{
prop.ClassMetadata = classMetadata;
prop.ContainingTypeMetadata = classMetadata;
}
return classMetadata;
})
},
                HookExecutor = null!,
                Order = 0,
                Body = global_TUnit_TestProject_AfterTests_GlobalBase2_AfterAll2_1Params_Body,
                FilePath = @"",
                LineNumber = 20
            }
        );
        global::TUnit.Core.Sources.AfterEveryTestHooks.Add(
            new AfterTestHookMethod
            {
                MethodInfo = new global::TUnit.Core.MethodMetadata
{
Type = typeof(global::TUnit.TestProject.AfterTests.GlobalBase3),
TypeReference = global::TUnit.Core.TypeReference.CreateConcrete("TUnit.TestProject.AfterTests.GlobalBase3, TestsBase`1"),
Name = "AfterAll3",
GenericTypeCount = 0,
ReturnType = typeof(global::System.Threading.Tasks.Task),
ReturnTypeReference = global::TUnit.Core.TypeReference.CreateConcrete("System.Threading.Tasks.Task, System.Private.CoreLib"),
Parameters = new global::TUnit.Core.ParameterMetadata[]
{
new global::TUnit.Core.ParameterMetadata(typeof(global::TUnit.Core.TestContext))
{
    Name = "context",
    TypeReference = global::TUnit.Core.TypeReference.CreateConcrete("TUnit.Core.TestContext, TUnit.Core"),
    IsNullable = false,
    ReflectionInfo = typeof(global::TUnit.TestProject.AfterTests.GlobalBase3).GetMethod("AfterAll3", System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Static, null, new global::System.Type[] { typeof(global::TUnit.Core.TestContext) }, null)!.GetParameters()[0]
},
},
Class = global::TUnit.Core.ClassMetadata.GetOrAdd("TestsBase`1:global::TUnit.TestProject.AfterTests.GlobalBase3", () => 
{
var classMetadata = new global::TUnit.Core.ClassMetadata
{
Type = typeof(global::TUnit.TestProject.AfterTests.GlobalBase3),
TypeReference = global::TUnit.Core.TypeReference.CreateConcrete("TUnit.TestProject.AfterTests.GlobalBase3, TestsBase`1"),
Name = "GlobalBase3",
Namespace = "TUnit.TestProject.AfterTests",
Assembly = global::TUnit.Core.AssemblyMetadata.GetOrAdd("TestsBase`1", () => new global::TUnit.Core.AssemblyMetadata { Name = "TestsBase`1" }),
Parameters = global::System.Array.Empty<global::TUnit.Core.ParameterMetadata>(),
Properties = global::System.Array.Empty<global::TUnit.Core.PropertyMetadata>(),
Parent = null
};
// Set ClassMetadata and ContainingTypeMetadata references on properties to avoid circular dependency
foreach (var prop in classMetadata.Properties)
{
prop.ClassMetadata = classMetadata;
prop.ContainingTypeMetadata = classMetadata;
}
return classMetadata;
})
},
                HookExecutor = null!,
                Order = 0,
                Body = global_TUnit_TestProject_AfterTests_GlobalBase3_AfterAll3_1Params_Body,
                FilePath = @"",
                LineNumber = 35
            }
        );
        global::TUnit.Core.Sources.AfterEveryTestHooks.Add(
            new AfterTestHookMethod
            {
                MethodInfo = new global::TUnit.Core.MethodMetadata
{
Type = typeof(global::TUnit.TestProject.AfterTests.GlobalCleanUpTests),
TypeReference = global::TUnit.Core.TypeReference.CreateConcrete("TUnit.TestProject.AfterTests.GlobalCleanUpTests, TestsBase`1"),
Name = "AfterAllCleanUp",
GenericTypeCount = 0,
ReturnType = typeof(global::System.Threading.Tasks.Task),
ReturnTypeReference = global::TUnit.Core.TypeReference.CreateConcrete("System.Threading.Tasks.Task, System.Private.CoreLib"),
Parameters = new global::TUnit.Core.ParameterMetadata[]
{
new global::TUnit.Core.ParameterMetadata(typeof(global::TUnit.Core.TestContext))
{
    Name = "context",
    TypeReference = global::TUnit.Core.TypeReference.CreateConcrete("TUnit.Core.TestContext, TUnit.Core"),
    IsNullable = false,
    ReflectionInfo = typeof(global::TUnit.TestProject.AfterTests.GlobalCleanUpTests).GetMethod("AfterAllCleanUp", System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Static, null, new global::System.Type[] { typeof(global::TUnit.Core.TestContext) }, null)!.GetParameters()[0]
},
},
Class = global::TUnit.Core.ClassMetadata.GetOrAdd("TestsBase`1:global::TUnit.TestProject.AfterTests.GlobalCleanUpTests", () => 
{
var classMetadata = new global::TUnit.Core.ClassMetadata
{
Type = typeof(global::TUnit.TestProject.AfterTests.GlobalCleanUpTests),
TypeReference = global::TUnit.Core.TypeReference.CreateConcrete("TUnit.TestProject.AfterTests.GlobalCleanUpTests, TestsBase`1"),
Name = "GlobalCleanUpTests",
Namespace = "TUnit.TestProject.AfterTests",
Assembly = global::TUnit.Core.AssemblyMetadata.GetOrAdd("TestsBase`1", () => new global::TUnit.Core.AssemblyMetadata { Name = "TestsBase`1" }),
Parameters = global::System.Array.Empty<global::TUnit.Core.ParameterMetadata>(),
Properties = global::System.Array.Empty<global::TUnit.Core.PropertyMetadata>(),
Parent = null
};
// Set ClassMetadata and ContainingTypeMetadata references on properties to avoid circular dependency
foreach (var prop in classMetadata.Properties)
{
prop.ClassMetadata = classMetadata;
prop.ContainingTypeMetadata = classMetadata;
}
return classMetadata;
})
},
                HookExecutor = null!,
                Order = 0,
                Body = global_TUnit_TestProject_AfterTests_GlobalCleanUpTests_AfterAllCleanUp_1Params_Body,
                FilePath = @"",
                LineNumber = 50
            }
        );
        global::TUnit.Core.Sources.AfterEveryTestHooks.Add(
            new AfterTestHookMethod
            {
                MethodInfo = new global::TUnit.Core.MethodMetadata
{
Type = typeof(global::TUnit.TestProject.AfterTests.GlobalCleanUpTests),
TypeReference = global::TUnit.Core.TypeReference.CreateConcrete("TUnit.TestProject.AfterTests.GlobalCleanUpTests, TestsBase`1"),
Name = "AfterAllCleanUp",
GenericTypeCount = 0,
ReturnType = typeof(global::System.Threading.Tasks.Task),
ReturnTypeReference = global::TUnit.Core.TypeReference.CreateConcrete("System.Threading.Tasks.Task, System.Private.CoreLib"),
Parameters = new global::TUnit.Core.ParameterMetadata[]
{
new global::TUnit.Core.ParameterMetadata(typeof(global::TUnit.Core.TestContext))
{
    Name = "context",
    TypeReference = global::TUnit.Core.TypeReference.CreateConcrete("TUnit.Core.TestContext, TUnit.Core"),
    IsNullable = false,
    ReflectionInfo = typeof(global::TUnit.TestProject.AfterTests.GlobalCleanUpTests).GetMethod("AfterAllCleanUp", System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Static, null, new global::System.Type[] { typeof(global::TUnit.Core.TestContext), typeof(global::System.Threading.CancellationToken) }, null)!.GetParameters()[0]
},
new global::TUnit.Core.ParameterMetadata(typeof(global::System.Threading.CancellationToken))
{
    Name = "cancellationToken",
    TypeReference = global::TUnit.Core.TypeReference.CreateConcrete("System.Threading.CancellationToken, System.Private.CoreLib"),
    IsNullable = false,
    ReflectionInfo = typeof(global::TUnit.TestProject.AfterTests.GlobalCleanUpTests).GetMethod("AfterAllCleanUp", System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Static, null, new global::System.Type[] { typeof(global::TUnit.Core.TestContext), typeof(global::System.Threading.CancellationToken) }, null)!.GetParameters()[1]
},
},
Class = global::TUnit.Core.ClassMetadata.GetOrAdd("TestsBase`1:global::TUnit.TestProject.AfterTests.GlobalCleanUpTests", () => 
{
var classMetadata = new global::TUnit.Core.ClassMetadata
{
Type = typeof(global::TUnit.TestProject.AfterTests.GlobalCleanUpTests),
TypeReference = global::TUnit.Core.TypeReference.CreateConcrete("TUnit.TestProject.AfterTests.GlobalCleanUpTests, TestsBase`1"),
Name = "GlobalCleanUpTests",
Namespace = "TUnit.TestProject.AfterTests",
Assembly = global::TUnit.Core.AssemblyMetadata.GetOrAdd("TestsBase`1", () => new global::TUnit.Core.AssemblyMetadata { Name = "TestsBase`1" }),
Parameters = global::System.Array.Empty<global::TUnit.Core.ParameterMetadata>(),
Properties = global::System.Array.Empty<global::TUnit.Core.PropertyMetadata>(),
Parent = null
};
// Set ClassMetadata and ContainingTypeMetadata references on properties to avoid circular dependency
foreach (var prop in classMetadata.Properties)
{
prop.ClassMetadata = classMetadata;
prop.ContainingTypeMetadata = classMetadata;
}
return classMetadata;
})
},
                HookExecutor = null!,
                Order = 0,
                Body = global_TUnit_TestProject_AfterTests_GlobalCleanUpTests_AfterAllCleanUp_2Params_Body,
                FilePath = @"",
                LineNumber = 56
            }
        );
        global::TUnit.Core.Sources.AfterEveryTestHooks.Add(
            new AfterTestHookMethod
            {
                MethodInfo = new global::TUnit.Core.MethodMetadata
{
Type = typeof(global::TUnit.TestProject.AfterTests.GlobalCleanUpTests),
TypeReference = global::TUnit.Core.TypeReference.CreateConcrete("TUnit.TestProject.AfterTests.GlobalCleanUpTests, TestsBase`1"),
Name = "AfterAllCleanUpWithContext",
GenericTypeCount = 0,
ReturnType = typeof(global::System.Threading.Tasks.Task),
ReturnTypeReference = global::TUnit.Core.TypeReference.CreateConcrete("System.Threading.Tasks.Task, System.Private.CoreLib"),
Parameters = new global::TUnit.Core.ParameterMetadata[]
{
new global::TUnit.Core.ParameterMetadata(typeof(global::TUnit.Core.TestContext))
{
    Name = "context",
    TypeReference = global::TUnit.Core.TypeReference.CreateConcrete("TUnit.Core.TestContext, TUnit.Core"),
    IsNullable = false,
    ReflectionInfo = typeof(global::TUnit.TestProject.AfterTests.GlobalCleanUpTests).GetMethod("AfterAllCleanUpWithContext", System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Static, null, new global::System.Type[] { typeof(global::TUnit.Core.TestContext) }, null)!.GetParameters()[0]
},
},
Class = global::TUnit.Core.ClassMetadata.GetOrAdd("TestsBase`1:global::TUnit.TestProject.AfterTests.GlobalCleanUpTests", () => 
{
var classMetadata = new global::TUnit.Core.ClassMetadata
{
Type = typeof(global::TUnit.TestProject.AfterTests.GlobalCleanUpTests),
TypeReference = global::TUnit.Core.TypeReference.CreateConcrete("TUnit.TestProject.AfterTests.GlobalCleanUpTests, TestsBase`1"),
Name = "GlobalCleanUpTests",
Namespace = "TUnit.TestProject.AfterTests",
Assembly = global::TUnit.Core.AssemblyMetadata.GetOrAdd("TestsBase`1", () => new global::TUnit.Core.AssemblyMetadata { Name = "TestsBase`1" }),
Parameters = global::System.Array.Empty<global::TUnit.Core.ParameterMetadata>(),
Properties = global::System.Array.Empty<global::TUnit.Core.PropertyMetadata>(),
Parent = null
};
// Set ClassMetadata and ContainingTypeMetadata references on properties to avoid circular dependency
foreach (var prop in classMetadata.Properties)
{
prop.ClassMetadata = classMetadata;
prop.ContainingTypeMetadata = classMetadata;
}
return classMetadata;
})
},
                HookExecutor = null!,
                Order = 0,
                Body = global_TUnit_TestProject_AfterTests_GlobalCleanUpTests_AfterAllCleanUpWithContext_1Params_Body,
                FilePath = @"",
                LineNumber = 62
            }
        );
        global::TUnit.Core.Sources.AfterEveryTestHooks.Add(
            new AfterTestHookMethod
            {
                MethodInfo = new global::TUnit.Core.MethodMetadata
{
Type = typeof(global::TUnit.TestProject.AfterTests.GlobalCleanUpTests),
TypeReference = global::TUnit.Core.TypeReference.CreateConcrete("TUnit.TestProject.AfterTests.GlobalCleanUpTests, TestsBase`1"),
Name = "AfterAllCleanUpWithContext",
GenericTypeCount = 0,
ReturnType = typeof(global::System.Threading.Tasks.Task),
ReturnTypeReference = global::TUnit.Core.TypeReference.CreateConcrete("System.Threading.Tasks.Task, System.Private.CoreLib"),
Parameters = new global::TUnit.Core.ParameterMetadata[]
{
new global::TUnit.Core.ParameterMetadata(typeof(global::TUnit.Core.TestContext))
{
    Name = "context",
    TypeReference = global::TUnit.Core.TypeReference.CreateConcrete("TUnit.Core.TestContext, TUnit.Core"),
    IsNullable = false,
    ReflectionInfo = typeof(global::TUnit.TestProject.AfterTests.GlobalCleanUpTests).GetMethod("AfterAllCleanUpWithContext", System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Static, null, new global::System.Type[] { typeof(global::TUnit.Core.TestContext), typeof(global::System.Threading.CancellationToken) }, null)!.GetParameters()[0]
},
new global::TUnit.Core.ParameterMetadata(typeof(global::System.Threading.CancellationToken))
{
    Name = "cancellationToken",
    TypeReference = global::TUnit.Core.TypeReference.CreateConcrete("System.Threading.CancellationToken, System.Private.CoreLib"),
    IsNullable = false,
    ReflectionInfo = typeof(global::TUnit.TestProject.AfterTests.GlobalCleanUpTests).GetMethod("AfterAllCleanUpWithContext", System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Static, null, new global::System.Type[] { typeof(global::TUnit.Core.TestContext), typeof(global::System.Threading.CancellationToken) }, null)!.GetParameters()[1]
},
},
Class = global::TUnit.Core.ClassMetadata.GetOrAdd("TestsBase`1:global::TUnit.TestProject.AfterTests.GlobalCleanUpTests", () => 
{
var classMetadata = new global::TUnit.Core.ClassMetadata
{
Type = typeof(global::TUnit.TestProject.AfterTests.GlobalCleanUpTests),
TypeReference = global::TUnit.Core.TypeReference.CreateConcrete("TUnit.TestProject.AfterTests.GlobalCleanUpTests, TestsBase`1"),
Name = "GlobalCleanUpTests",
Namespace = "TUnit.TestProject.AfterTests",
Assembly = global::TUnit.Core.AssemblyMetadata.GetOrAdd("TestsBase`1", () => new global::TUnit.Core.AssemblyMetadata { Name = "TestsBase`1" }),
Parameters = global::System.Array.Empty<global::TUnit.Core.ParameterMetadata>(),
Properties = global::System.Array.Empty<global::TUnit.Core.PropertyMetadata>(),
Parent = null
};
// Set ClassMetadata and ContainingTypeMetadata references on properties to avoid circular dependency
foreach (var prop in classMetadata.Properties)
{
prop.ClassMetadata = classMetadata;
prop.ContainingTypeMetadata = classMetadata;
}
return classMetadata;
})
},
                HookExecutor = null!,
                Order = 0,
                Body = global_TUnit_TestProject_AfterTests_GlobalCleanUpTests_AfterAllCleanUpWithContext_2Params_Body,
                FilePath = @"",
                LineNumber = 68
            }
        );
    }
    private static async ValueTask global_TUnit_TestProject_AfterTests_GlobalBase1_AfterEach1_0Params_Body(object instance, TestContext context, CancellationToken cancellationToken)
    {
        var typedInstance = (global::TUnit.TestProject.AfterTests.GlobalBase1)instance;
        await AsyncConvert.Convert(() => typedInstance.AfterEach1());
    }
    private static async ValueTask global_TUnit_TestProject_AfterTests_GlobalBase2_AfterEach2_0Params_Body(object instance, TestContext context, CancellationToken cancellationToken)
    {
        var typedInstance = (global::TUnit.TestProject.AfterTests.GlobalBase2)instance;
        await AsyncConvert.Convert(() => typedInstance.AfterEach2());
    }
    private static async ValueTask global_TUnit_TestProject_AfterTests_GlobalBase3_AfterEach3_0Params_Body(object instance, TestContext context, CancellationToken cancellationToken)
    {
        var typedInstance = (global::TUnit.TestProject.AfterTests.GlobalBase3)instance;
        await AsyncConvert.Convert(() => typedInstance.AfterEach3());
    }
    private static async ValueTask global_TUnit_TestProject_AfterTests_GlobalCleanUpTests_CleanUp_0Params_Body(object instance, TestContext context, CancellationToken cancellationToken)
    {
        var typedInstance = (global::TUnit.TestProject.AfterTests.GlobalCleanUpTests)instance;
        await AsyncConvert.Convert(() => typedInstance.CleanUp());
    }
    private static async ValueTask global_TUnit_TestProject_AfterTests_GlobalCleanUpTests_CleanUp_1Params_Body(object instance, TestContext context, CancellationToken cancellationToken)
    {
        var typedInstance = (global::TUnit.TestProject.AfterTests.GlobalCleanUpTests)instance;
        await AsyncConvert.Convert(() => typedInstance.CleanUp(cancellationToken));
    }
    private static async ValueTask global_TUnit_TestProject_AfterTests_GlobalCleanUpTests_CleanUpWithContext_1Params_Body(object instance, TestContext context, CancellationToken cancellationToken)
    {
        var typedInstance = (global::TUnit.TestProject.AfterTests.GlobalCleanUpTests)instance;
        await AsyncConvert.Convert(() => typedInstance.CleanUpWithContext(context));
    }
    private static async ValueTask global_TUnit_TestProject_AfterTests_GlobalCleanUpTests_CleanUpWithContext_2Params_Body(object instance, TestContext context, CancellationToken cancellationToken)
    {
        var typedInstance = (global::TUnit.TestProject.AfterTests.GlobalCleanUpTests)instance;
        await AsyncConvert.Convert(() => typedInstance.CleanUpWithContext(context, cancellationToken));
    }
    private static async ValueTask global_TUnit_TestProject_AfterTests_GlobalBase1_AfterAll1_1Params_Body(TestContext context, CancellationToken cancellationToken)
    {
        await AsyncConvert.Convert(() => global::TUnit.TestProject.AfterTests.GlobalBase1.AfterAll1(context));
    }
    private static async ValueTask global_TUnit_TestProject_AfterTests_GlobalBase2_AfterAll2_1Params_Body(TestContext context, CancellationToken cancellationToken)
    {
        await AsyncConvert.Convert(() => global::TUnit.TestProject.AfterTests.GlobalBase2.AfterAll2(context));
    }
    private static async ValueTask global_TUnit_TestProject_AfterTests_GlobalBase3_AfterAll3_1Params_Body(TestContext context, CancellationToken cancellationToken)
    {
        await AsyncConvert.Convert(() => global::TUnit.TestProject.AfterTests.GlobalBase3.AfterAll3(context));
    }
    private static async ValueTask global_TUnit_TestProject_AfterTests_GlobalCleanUpTests_AfterAllCleanUp_1Params_Body(TestContext context, CancellationToken cancellationToken)
    {
        await AsyncConvert.Convert(() => global::TUnit.TestProject.AfterTests.GlobalCleanUpTests.AfterAllCleanUp(context));
    }
    private static async ValueTask global_TUnit_TestProject_AfterTests_GlobalCleanUpTests_AfterAllCleanUp_2Params_Body(TestContext context, CancellationToken cancellationToken)
    {
        await AsyncConvert.Convert(() => global::TUnit.TestProject.AfterTests.GlobalCleanUpTests.AfterAllCleanUp(context, cancellationToken));
    }
    private static async ValueTask global_TUnit_TestProject_AfterTests_GlobalCleanUpTests_AfterAllCleanUpWithContext_1Params_Body(TestContext context, CancellationToken cancellationToken)
    {
        await AsyncConvert.Convert(() => global::TUnit.TestProject.AfterTests.GlobalCleanUpTests.AfterAllCleanUpWithContext(context));
    }
    private static async ValueTask global_TUnit_TestProject_AfterTests_GlobalCleanUpTests_AfterAllCleanUpWithContext_2Params_Body(TestContext context, CancellationToken cancellationToken)
    {
        await AsyncConvert.Convert(() => global::TUnit.TestProject.AfterTests.GlobalCleanUpTests.AfterAllCleanUpWithContext(context, cancellationToken));
    }
}
internal static class HookModuleInitializer
{
    [ModuleInitializer]
    public static void Initialize()
    {
        _ = new GeneratedHookRegistry();
    }
}
