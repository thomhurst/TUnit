// <auto-generated/>
#pragma warning disable

// <auto-generated/>
#pragma warning disable
#nullable enable
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Threading;
using System.Threading.Tasks;
using global::TUnit.Core;
using global::TUnit.Core.Enums;
using global::TUnit.Core.Interfaces;
using global::TUnit.Core.Interfaces.SourceGenerator;
namespace TUnit.Generated;
internal sealed class ConfigurationTest_TestWithConfiguration_TestSource_c95dc5e0b5b249a7a65878dd95e21afa : ITestSource
{
    public async ValueTask<List<TestMetadata>> GetTestsAsync(string testSessionId)
    {
        var tests = new List<TestMetadata>();
        var metadata = new TestMetadata<global::TUnit.TestProject.ConfigurationTest>
        {
            TestName = "TestWithConfiguration",
            TestClassType = typeof(global::TUnit.TestProject.ConfigurationTest),
            TestMethodName = "TestWithConfiguration",
            Categories = Array.Empty<string>(),
            TimeoutMs = null,
            RetryCount = 0,
            CanRunInParallel = true,
            Dependencies = Array.Empty<TestDependency>(),
            AttributeFactory = () =>
            [
                new global::TUnit.Core.TestAttribute(),
                new global::TUnit.TestProject.Attributes.ClassDisplayNameAttribute()
            ],
            DataSources = Array.Empty<TestDataSource>(),
            ClassDataSources = Array.Empty<TestDataSource>(),
            PropertyDataSources = Array.Empty<PropertyDataSource>(),
            ParameterTypes = new Type[]
            {
            },
            TestMethodParameterTypes = new string[]
            {
            },
            MethodMetadata = new global::TUnit.Core.MethodMetadata{Type = typeof(global::TUnit.TestProject.ConfigurationTest),TypeReference = global::TUnit.Core.TypeReference.CreateConcrete("TUnit.TestProject.ConfigurationTest, UnifiedReflectionFreeTests"),Name = "TestWithConfiguration",GenericTypeCount = 0,ReturnType = typeof(void),ReturnTypeReference = global::TUnit.Core.TypeReference.CreateConcrete("void, System.Private.CoreLib"),Parameters = [],Class = global::TUnit.Core.ClassMetadata.GetOrAdd("global::TUnit.TestProject.ConfigurationTest", () => new global::TUnit.Core.ClassMetadata{Parent = null,Type = typeof(global::TUnit.TestProject.ConfigurationTest),TypeReference = global::TUnit.Core.TypeReference.CreateConcrete("TUnit.TestProject.ConfigurationTest, UnifiedReflectionFreeTests"),Assembly = global::TUnit.Core.AssemblyMetadata.GetOrAdd("UnifiedReflectionFreeTests", () => new global::TUnit.Core.AssemblyMetadata{Name = "UnifiedReflectionFreeTests",}),Name = "ConfigurationTest",Namespace = "TUnit.TestProject",Parameters = [],Properties = [],}),},
            Hooks = new TestHooks
            {
                BeforeClass = Array.Empty<HookMetadata>(),
                AfterClass = Array.Empty<HookMetadata>(),
                BeforeTest = Array.Empty<HookMetadata>(),
                AfterTest = Array.Empty<HookMetadata>()
            },
            InstanceFactory = args => new global::TUnit.TestProject.ConfigurationTest(),
            TestInvoker = async (instance, args) =>
            {
                var typedInstance = (global::TUnit.TestProject.ConfigurationTest)instance;
                typedInstance.TestWithConfiguration();
                await Task.CompletedTask;
            },
            PropertySetters = new Dictionary<string, Action<global::TUnit.TestProject.ConfigurationTest, object?>>(),
            PropertyInjections = Array.Empty<PropertyInjectionData>(),
            CreateTypedInstance = null,
            InvokeTypedTest = async (instance, args, cancellationToken) =>
            {
                instance.TestWithConfiguration();
                await Task.CompletedTask;
            },
            CreateExecutableTest = (context, metadata) =>
            {
                var typedMetadata = (TestMetadata<global::TUnit.TestProject.ConfigurationTest>)metadata;
                return new global::TUnit.Core.ExecutableTest<global::TUnit.TestProject.ConfigurationTest>
                {
                    TestId = context.TestId,
                    DisplayName = context.DisplayName,
                    Arguments = context.Arguments,
                    ClassArguments = context.ClassArguments,
                    PropertyValues = context.PropertyValues,
                    BeforeTestHooks = context.BeforeTestHooks,
                    AfterTestHooks = context.AfterTestHooks,
                    Context = context.Context,
                    Metadata = typedMetadata,
                    CreateTypedInstance = async () =>
                    {
                        if (typedMetadata.InstanceFactory == null)
                        {
                            throw new InvalidOperationException("No instance factory");
                        }
                        var instance = (global::TUnit.TestProject.ConfigurationTest)typedMetadata.InstanceFactory(context.ClassArguments);
                        await global::TUnit.Core.ObjectInitializer.InitializeAsync(instance);
                        return instance;
                    },
                    InvokeTypedTest = typedMetadata.InvokeTypedTest ?? throw new InvalidOperationException("No typed test invoker"),
                    TypedPropertySetters = typedMetadata.PropertySetters
                };
            }
        };
        metadata.SetDataCombinationGenerator(() => GenerateCombinations_1eb78e18(testSessionId));
        tests.Add(metadata);
        return tests;
    }
    private async IAsyncEnumerable<TestDataCombination> GenerateCombinations_1eb78e18(string testSessionId)
    {
        object? InvokeIfFunc(object? value)
        {
            if (value == null) return null;
            var type = value.GetType();
            if (type.IsGenericType && type.GetGenericTypeDefinition() == typeof(Func<>))
            {
                var invokeMethod = type.GetMethod("Invoke");
                return invokeMethod?.Invoke(value, Array.Empty<object>());
            }
            return value;
        }
        Func<Task<object?>>[] HandleTupleValue(object? value, bool shouldUnwrap)
        {
            if (!shouldUnwrap || value == null)
            {
                return new[] { () => Task.FromResult<object?>(value) };
            }
            // Check if it's a tuple and unwrap it
            var unwrapped = global::TUnit.Core.Helpers.TupleHelper.UnwrapTuple(value);
            if (unwrapped.Length > 1)
            {
                // Multiple values from tuple - create a factory for each
                return unwrapped.Select(v => new Func<Task<object?>>(() => Task.FromResult<object?>(v))).ToArray();
            }
            // Single value or not a tuple
            return new[] { () => Task.FromResult<object?>(value) };
        }
        yield return new TestDataCombination { RepeatIndex = 0 };
    }
}
internal static class ConfigurationTest_TestWithConfiguration_ModuleInitializer_c95dc5e0b5b249a7a65878dd95e21afa
{
    [System.Runtime.CompilerServices.ModuleInitializer]
    public static void Initialize()
    {
        global::TUnit.Core.SourceRegistrar.Register(new ConfigurationTest_TestWithConfiguration_TestSource_c95dc5e0b5b249a7a65878dd95e21afa());
    }
}
