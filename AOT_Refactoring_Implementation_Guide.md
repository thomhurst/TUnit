# AOT Refactoring Implementation Guide

## 1. Tuple Factory Implementation

Replace dynamic tuple creation with AOT-safe factory pattern.

### Current Implementation (PropertyInjector.cs)
```csharp
[UnconditionalSuppressMessage("AOT", "IL2067:UnrecognizedReflectionPattern", 
    Justification = "Tuple types have public constructors and are safe for AOT")]
private static object? CreateTupleFromElements(
    [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicConstructors)] Type tupleType, 
    object?[] elements)
{
    return Activator.CreateInstance(tupleType, elements);
}
```

### Proposed AOT-Safe Implementation
```csharp
public static class TupleFactory
{
    private static readonly Dictionary<Type, Func<object?[], object?>> TypedFactories = new();
    
    static TupleFactory()
    {
        // Register common tuple types
        RegisterFactory<ValueTuple<object?, object?>>((args) => 
            new ValueTuple<object?, object?>(args[0], args[1]));
        RegisterFactory<ValueTuple<object?, object?, object?>>((args) => 
            new ValueTuple<object?, object?, object?>(args[0], args[1], args[2]));
        // ... register up to 7 elements
    }
    
    private static void RegisterFactory<T>(Func<object?[], T> factory) where T : struct
    {
        TypedFactories[typeof(T)] = args => factory(args);
    }
    
    public static object? CreateTuple(Type tupleType, object?[] elements)
    {
        // Try typed factory first
        if (TypedFactories.TryGetValue(tupleType, out var factory))
        {
            return factory(elements);
        }
        
        // Try generic factory based on element count
        if (tupleType.IsGenericType && 
            tupleType.GetGenericTypeDefinition().FullName?.StartsWith("System.ValueTuple") == true)
        {
            return elements.Length switch
            {
                2 => (elements[0], elements[1]),
                3 => (elements[0], elements[1], elements[2]),
                4 => (elements[0], elements[1], elements[2], elements[3]),
                5 => (elements[0], elements[1], elements[2], elements[3], elements[4]),
                6 => (elements[0], elements[1], elements[2], elements[3], elements[4], elements[5]),
                7 => (elements[0], elements[1], elements[2], elements[3], elements[4], elements[5], elements[6]),
                _ => CreateTupleWithReflection(tupleType, elements)
            };
        }
        
        return CreateTupleWithReflection(tupleType, elements);
    }
    
    [RequiresUnreferencedCode("Dynamic tuple creation is not AOT-compatible")]
    [RequiresDynamicCode("Dynamic tuple creation requires runtime code generation")]
    private static object? CreateTupleWithReflection(Type tupleType, object?[] elements)
    {
        return Activator.CreateInstance(tupleType, elements);
    }
}
```

## 2. Improved DynamicallyAccessedMembers Flow

### Current Pattern (Multiple Files)
```csharp
// Method A - No annotations
public static Type GetTestType(object test)
{
    return test.GetType();
}

// Method B - Suppression needed
[UnconditionalSuppressMessage("Trimming", "IL2070:...")]
public static ConstructorInfo[] GetConstructors(object test)
{
    var type = GetTestType(test); // <- No annotations flow here
    return type.GetConstructors(); // <- Warning IL2070
}
```

### Improved Pattern
```csharp
// Method A - With proper annotations
public static Type GetTestType(object test)
{
    return test.GetType();
}

// Method B - No suppression needed
public static ConstructorInfo[] GetConstructors(
    [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicConstructors)] Type type)
{
    return type.GetConstructors(); // <- No warning
}

// Usage
var type = GetTestType(test);
if (type.IsDefined(typeof(PreserveConstructorsAttribute)))
{
    var constructors = GetConstructors(type);
}
```

## 3. Source Generator Extension for Property Injection

### New Source Generator Output
```csharp
// Generated by TUnit.SourceGenerator
public static partial class PropertyInjectionMetadataRegistry
{
    private static readonly Dictionary<Type, PropertyInjectionMetadata[]> Registry = new()
    {
        [typeof(MyTestClass)] = new[]
        {
            new PropertyInjectionMetadata
            {
                PropertyName = "TestData",
                PropertyType = typeof(string),
                PropertySetter = (instance, value) => ((MyTestClass)instance).TestData = (string)value,
                DataSourceFactory = () => new MethodDataSource("GetTestData", typeof(MyTestClass))
            }
        }
    };
    
    public static bool TryGetMetadata(Type type, out PropertyInjectionMetadata[] metadata)
    {
        return Registry.TryGetValue(type, out metadata);
    }
}
```

## 4. AOT-Safe Async Conversion

### Current Implementation (AsyncConvert.cs)
```csharp
[UnconditionalSuppressMessage("Trimming", "IL2060:...")]
[UnconditionalSuppressMessage("AOT", "IL3050:...")]
private static ValueTask StartAsFSharpTask(object invoke, Type type)
{
    var startAsTaskOpenGenericMethod = (_fSharpAsyncType ??= type.Assembly.GetType("Microsoft.FSharp.Control.FSharpAsync"))!
        .GetRuntimeMethods()
        .First(m => m.Name == "StartAsTask");

    var fSharpTask = (Task) startAsTaskOpenGenericMethod.MakeGenericMethod(type.GetGenericArguments()[0])
        .Invoke(null, [invoke, null, null])!;
    
    return new ValueTask(fSharpTask);
}
```

### Improved Implementation with Type Preservation
```csharp
public static class AsyncConvert
{
    // Mark F# types as preserved
    [DynamicDependency(DynamicallyAccessedMemberTypes.PublicMethods, "Microsoft.FSharp.Control.FSharpAsync", "FSharp.Core")]
    [DynamicDependency("StartAsTask", "Microsoft.FSharp.Control.FSharpAsync", "FSharp.Core")]
    private static Type? _fSharpAsyncType;
    
    [RequiresUnreferencedCode("F# async support requires dynamic access to FSharp.Core types")]
    [RequiresDynamicCode("F# async support requires runtime code generation")]
    private static ValueTask StartAsFSharpTask(object invoke, Type type)
    {
        _fSharpAsyncType ??= type.Assembly.GetType("Microsoft.FSharp.Control.FSharpAsync");
        
        if (_fSharpAsyncType == null)
        {
            throw new InvalidOperationException("F# async type not found. Ensure FSharp.Core is referenced.");
        }
        
        var startAsTaskMethod = _fSharpAsyncType
            .GetMethod("StartAsTask", BindingFlags.Public | BindingFlags.Static);
            
        if (startAsTaskMethod == null)
        {
            throw new InvalidOperationException("StartAsTask method not found on FSharpAsync type.");
        }
        
        var genericMethod = startAsTaskMethod.MakeGenericMethod(type.GetGenericArguments()[0]);
        var fSharpTask = (Task)genericMethod.Invoke(null, [invoke, null, null])!;
        
        return new ValueTask(fSharpTask);
    }
}
```

## 5. Clear Separation of AOT and Reflection Modes

### Create Mode-Specific Interfaces
```csharp
// Base interface
public interface ITestDiscovery
{
    bool SupportsAot { get; }
    IEnumerable<TestMetadata> DiscoverTests(Assembly assembly);
}

// AOT implementation
public sealed class AotTestDiscovery : ITestDiscovery
{
    public bool SupportsAot => true;
    
    public IEnumerable<TestMetadata> DiscoverTests(Assembly assembly)
    {
        // Use source-generated registry
        return TestMetadataRegistry.GetTestsForAssembly(assembly);
    }
}

// Reflection implementation
[RequiresUnreferencedCode("Reflection-based test discovery is not AOT-compatible")]
[RequiresDynamicCode("Reflection-based test discovery requires runtime code generation")]
public sealed class ReflectionTestDiscovery : ITestDiscovery
{
    public bool SupportsAot => false;
    
    public IEnumerable<TestMetadata> DiscoverTests(Assembly assembly)
    {
        // Use reflection to discover tests
        return DiscoverTestsViaReflection(assembly);
    }
}

// Factory with clear mode selection
public static class TestDiscoveryFactory
{
    public static ITestDiscovery Create(TestExecutionMode mode)
    {
        return mode switch
        {
            TestExecutionMode.SourceGeneration => new AotTestDiscovery(),
            TestExecutionMode.Reflection => CreateReflectionDiscovery(),
            TestExecutionMode.Auto => TryCreateAotDiscovery() ?? CreateReflectionDiscovery(),
            _ => throw new ArgumentOutOfRangeException(nameof(mode))
        };
    }
    
    [RequiresUnreferencedCode("Reflection mode is not AOT-compatible")]
    [RequiresDynamicCode("Reflection mode requires runtime code generation")]
    private static ITestDiscovery CreateReflectionDiscovery()
    {
        return new ReflectionTestDiscovery();
    }
    
    private static ITestDiscovery? TryCreateAotDiscovery()
    {
        if (TestMetadataRegistry.HasRegisteredTests)
        {
            return new AotTestDiscovery();
        }
        return null;
    }
}
```

## 6. AOT Compatibility Attributes

### Create Custom Attributes for Clear Intent
```csharp
/// <summary>
/// Indicates that a type or member is compatible with AOT compilation
/// </summary>
[AttributeUsage(AttributeTargets.Class | AttributeTargets.Method | AttributeTargets.Property)]
public sealed class AotCompatibleAttribute : Attribute
{
    public string? AlternativeForReflection { get; set; }
}

/// <summary>
/// Indicates that a type or member requires reflection and is not AOT-compatible
/// </summary>
[AttributeUsage(AttributeTargets.Class | AttributeTargets.Method | AttributeTargets.Property)]
public sealed class RequiresReflectionAttribute : Attribute
{
    public string Reason { get; }
    public string? AotAlternative { get; set; }
    
    public RequiresReflectionAttribute(string reason)
    {
        Reason = reason;
    }
}

// Usage examples
[AotCompatible]
public class SourceGeneratedTest
{
    // ...
}

[RequiresReflection("Dynamic test discovery requires reflection", 
    AotAlternative = "Use [TestSourceGeneration] attribute")]
public class DynamicTestDiscoverer
{
    // ...
}
```

## Testing Strategy

### 1. Create AOT Verification Tests
```csharp
[TestFixture]
public class AotCompatibilityTests
{
    [Test]
    [Conditional("AOT")]
    public void VerifyNoReflectionInAotMode()
    {
        var collector = TestDataCollectorFactory.Create(TestExecutionMode.SourceGeneration);
        Assert.That(collector, Is.TypeOf<AotTestDataCollector>());
        Assert.That(collector.IsAotCompatible, Is.True);
    }
    
    [Test]
    public void VerifyTupleFactoryHandlesCommonCases()
    {
        var result = TupleFactory.CreateTuple(typeof(ValueTuple<int, string>), [42, "test"]);
        Assert.That(result, Is.EqualTo((42, "test")));
    }
}
```

### 2. Add Build-Time Verification
```xml
<Project>
  <PropertyGroup>
    <EnableTrimAnalyzer>true</EnableTrimAnalyzer>
    <EnableAotAnalyzer>true</EnableAotAnalyzer>
    <TreatWarningsAsErrors>true</TreatWarningsAsErrors>
    <NoWarn>$(NoWarn);IL2104;IL2026;IL3050</NoWarn> <!-- Only for known reflection paths -->
  </PropertyGroup>
</Project>
```

## Migration Checklist

- [ ] Implement TupleFactory and migrate all tuple creation
- [ ] Add DynamicallyAccessedMembers to all type parameters in public APIs
- [ ] Create mode-specific implementations for test discovery
- [ ] Extend source generators for property injection metadata
- [ ] Add RequiresUnreferencedCode to all reflection-only code paths
- [ ] Update documentation with AOT vs Reflection mode guidance
- [ ] Add AOT compatibility tests to CI pipeline
- [ ] Create migration guide for users