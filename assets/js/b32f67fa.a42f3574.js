"use strict";(self.webpackChunktunit_docs_site=self.webpackChunktunit_docs_site||[]).push([[6900],{253:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>a,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"tutorial-assertions/extensibility/returning-items-from-await","title":"Returning Data via await","description":"It may make sense for our assertions to return data that is different from the input, based on what the assertion is doing. This can allow more cleanly written tests than have to manually do casting or parsing afterwards.","source":"@site/docs/tutorial-assertions/extensibility/returning-items-from-await.md","sourceDirName":"tutorial-assertions/extensibility","slug":"/tutorial-assertions/extensibility/returning-items-from-await","permalink":"/docs/tutorial-assertions/extensibility/returning-items-from-await","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"Chaining and Converting","permalink":"/docs/tutorial-assertions/extensibility/chaining-and-converting"},"next":{"title":"Or Conditions","permalink":"/docs/tutorial-assertions/or-conditions"}}');var i=t(4848),r=t(8453);const a={sidebar_position:3},o="Returning Data via await",l={},c=[];function d(e){const n={code:"code",h1:"h1",header:"header",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsxs)(n.h1,{id:"returning-data-via-await",children:["Returning Data via ",(0,i.jsx)(n.code,{children:"await"})]})}),"\n",(0,i.jsx)(n.p,{children:"It may make sense for our assertions to return data that is different from the input, based on what the assertion is doing. This can allow more cleanly written tests than have to manually do casting or parsing afterwards."}),"\n",(0,i.jsxs)(n.p,{children:["For example, ",(0,i.jsx)(n.code,{children:"await Assert.That(collection).Contains(item => item.Price < 0.99)"})]}),"\n",(0,i.jsx)(n.p,{children:"We could make that statement return the first item it finds that meets the criteria."}),"\n",(0,i.jsxs)(n.p,{children:["To do this, in your assert condition, in the ",(0,i.jsx)(n.code,{children:"GetResult"})," method where the logic is evaluated, store the item you'll return if the assertion passes within a property."]}),"\n",(0,i.jsx)(n.p,{children:"For the example above:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:'public class EnumerableContainsExpectedFuncAssertCondition<TActual, TInner>(\n    Func<TInner, bool> matcher, string? matcherString)\n    : BaseAssertCondition<TActual>\n    where TActual : IEnumerable<TInner>\n{\n    private bool _wasFound;\n    \n    protected override string GetExpectation() => $"to contain an entry matching {matcherString ?? "null"}";\n    \n    protected override ValueTask<AssertionResult> GetResult(\n        TActual? actualValue, Exception? exception,\n        AssertionMetadata assertionMetadata\n    )\n    {\n        if (actualValue is null)\n        {\n            return FailWithMessage($"{ActualExpression ?? typeof(TActual).Name} is null");\n        }\n\n        foreach (var inner in actualValue)\n        {\n            if (matcher(inner))\n            {\n                _wasFound = true;\n                FoundItem = inner;\n                break;\n            }\n        }\n        \n        return AssertionResult\n            .FailIf(_wasFound is false, "there was no match found in the collection");\n    }\n\n    public TInner? FoundItem { get; private set; }\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["As you can see, if we find an item that matches the predicate, we store it in the ",(0,i.jsx)(n.code,{children:"FoundItem"})," property."]}),"\n",(0,i.jsxs)(n.p,{children:["After that, the extension method to invoke your assertion should return a ",(0,i.jsx)(n.code,{children:"MappableResultAssertionBuilder<TSource, TAssertCondition, TMappedResult>"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"TSource"})," is the original type of the data you're asserting on. For the above, that's an ",(0,i.jsx)(n.code,{children:"IEnumerable<>"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"TAssertCondition"})," is the Assert Condition that you've created, where you've stored the item in the field."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"TMappedResult"})," is the type of object that you'd return from the ",(0,i.jsx)(n.code,{children:"await Assert.That(...)"})]}),"\n",(0,i.jsx)(n.p,{children:"This takes 3 arguments:"}),"\n",(0,i.jsxs)(n.p,{children:["The assertion builder, via ",(0,i.jsx)(n.code,{children:"valueSource.RegisterAssertion(assertCondition)"})," - As per how assertions are normally registered."]}),"\n",(0,i.jsxs)(n.p,{children:["The assert condition object. It is important that you use the same instance that is passed into the ",(0,i.jsx)(n.code,{children:"RegisterAssertion(...)"})," call."]}),"\n",(0,i.jsx)(n.p,{children:"And a mapper to tell the code how to find the item."}),"\n",(0,i.jsx)(n.p,{children:"So for the above example, that looks like this. (It looks like a lot of generics, I know!)"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:"public static MappableResultAssertionBuilder<IEnumerable<TInner>, EnumerableContainsExpectedFuncAssertCondition<IEnumerable<TInner>, TInner>, TInner> Contains<TInner>(this IValueSource<IEnumerable<TInner>> valueSource, Func<TInner, bool> matcher, [CallerArgumentExpression(nameof(matcher))] string doNotPopulateThisValue = null)\n    {\n        var enumerableContainsExpectedFuncAssertCondition = new EnumerableContainsExpectedFuncAssertCondition<IEnumerable<TInner>, TInner>(matcher, doNotPopulateThisValue);\n\n        return new MappableResultAssertionBuilder<IEnumerable<TInner>,\n            EnumerableContainsExpectedFuncAssertCondition<IEnumerable<TInner>, TInner>, TInner>(\n            valueSource.RegisterAssertion(enumerableContainsExpectedFuncAssertCondition, [doNotPopulateThisValue]),\n            enumerableContainsExpectedFuncAssertCondition,\n            (_, assertCondition) => assertCondition.FoundItem\n        );\n    }\n"})})]})}function u(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>o});var s=t(6540);const i={},r=s.createContext(i);function a(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);