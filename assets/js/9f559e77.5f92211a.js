"use strict";(self.webpackChunktunit_docs_site=self.webpackChunktunit_docs_site||[]).push([[6644],{9393:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>u,frontMatter:()=>r,metadata:()=>s,toc:()=>o});const s=JSON.parse('{"id":"advanced/extension-points","title":"Extension Points","description":"TUnit provides several extension points that allow you to customize and extend the framework\'s behavior. These interfaces enable you to implement custom test execution logic, hook into the test lifecycle, and control parallel execution.","source":"@site/docs/advanced/extension-points.md","sourceDirName":"advanced","slug":"/advanced/extension-points","permalink":"/docs/advanced/extension-points","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{}}');var i=t(4848),a=t(8453);const r={},l="Extension Points",c={},o=[{value:"ITestExecutor",id:"itestexecutor",level:2},{value:"Interface Definition",id:"interface-definition",level:3},{value:"Example Implementation",id:"example-implementation",level:3},{value:"Registering a Test Executor",id:"registering-a-test-executor",level:3},{value:"IHookExecutor",id:"ihookexecutor",level:2},{value:"Interface Definition",id:"interface-definition-1",level:3},{value:"Example Implementation",id:"example-implementation-1",level:3},{value:"Event Receivers",id:"event-receivers",level:2},{value:"ITestDiscoveryEventReceiver",id:"itestdiscoveryeventreceiver",level:3},{value:"ITestRegisteredEventReceiver",id:"itestregisteredeventreceiver",level:3},{value:"ITestStartEventReceiver",id:"iteststarteventreceiver",level:3},{value:"ITestEndEventReceiver",id:"itestendeventreceiver",level:3},{value:"ITestRetryEventReceiver",id:"itestretryeventreceiver",level:3},{value:"Example Event Receiver Implementation",id:"example-event-receiver-implementation",level:3},{value:"Registering Event Receivers",id:"registering-event-receivers",level:3},{value:"Parallel Execution Control",id:"parallel-execution-control",level:2},{value:"IParallelLimit",id:"iparallellimit",level:3},{value:"IParallelConstraint",id:"iparallelconstraint",level:3},{value:"IAsyncInitializer",id:"iasyncinitializer",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"Common Use Cases",id:"common-use-cases",level:2},{value:"Cross-Cutting Concerns",id:"cross-cutting-concerns",level:3},{value:"Integration Testing",id:"integration-testing",level:3},{value:"Compliance and Auditing",id:"compliance-and-auditing",level:3},{value:"Example: Database Transaction Extension",id:"example-database-transaction-extension",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"extension-points",children:"Extension Points"})}),"\n",(0,i.jsx)(n.p,{children:"TUnit provides several extension points that allow you to customize and extend the framework's behavior. These interfaces enable you to implement custom test execution logic, hook into the test lifecycle, and control parallel execution."}),"\n",(0,i.jsx)(n.h2,{id:"itestexecutor",children:"ITestExecutor"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"ITestExecutor"})," interface allows you to customize how tests are executed. This is useful for scenarios like:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Adding custom logging or telemetry"}),"\n",(0,i.jsx)(n.li,{children:"Implementing custom retry logic"}),"\n",(0,i.jsx)(n.li,{children:"Wrapping test execution with special context"}),"\n",(0,i.jsx)(n.li,{children:"Implementing custom timeout behavior"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"interface-definition",children:"Interface Definition"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:"public interface ITestExecutor\n{\n    Task ExecuteAsync(TestContext context, Func<Task> testBody);\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"example-implementation",children:"Example Implementation"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:'public class TimingTestExecutor : ITestExecutor\n{\n    public async Task ExecuteAsync(TestContext context, Func<Task> testBody)\n    {\n        var stopwatch = Stopwatch.StartNew();\n\n        try\n        {\n            await testBody();\n        }\n        finally\n        {\n            stopwatch.Stop();\n            context.WriteLine($"Test execution took: {stopwatch.ElapsedMilliseconds}ms");\n\n            // You could also send this to telemetry\n            TelemetryClient.TrackMetric("TestDuration", stopwatch.ElapsedMilliseconds);\n        }\n    }\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"registering-a-test-executor",children:"Registering a Test Executor"}),"\n",(0,i.jsxs)(n.p,{children:["To use your custom test executor, apply the ",(0,i.jsx)(n.code,{children:"TestExecutorAttribute"})," at the assembly, class, or method level:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:"// Assembly-level (applies to all tests in the assembly)\n[assembly: TestExecutor<TimingTestExecutor>]\n\n// Or use the non-generic version\n[assembly: TestExecutor(typeof(TimingTestExecutor))]\n\n// Class-level (applies to all tests in the class)\n[TestExecutor<TimingTestExecutor>]\npublic class MyTestClass\n{\n    [Test]\n    public async Task MyTest()\n    {\n        // Test logic here\n    }\n}\n\n// Method-level (applies to specific test)\n[Test]\n[TestExecutor<TimingTestExecutor>]\npublic async Task MyTest()\n{\n    // Test logic here\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"ihookexecutor",children:"IHookExecutor"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"IHookExecutor"})," interface allows you to customize how setup and cleanup hooks are executed. This is useful for:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Adding error handling around hooks"}),"\n",(0,i.jsx)(n.li,{children:"Implementing hook-specific logging"}),"\n",(0,i.jsx)(n.li,{children:"Managing shared resources during hooks"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"interface-definition-1",children:"Interface Definition"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:"public interface IHookExecutor\n{\n    Task ExecuteAsync(HookContext context, Func<Task> hookBody);\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"example-implementation-1",children:"Example Implementation"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:"public class ResourceManagingHookExecutor : IHookExecutor\n{\n    private static readonly Dictionary<string, IDisposable> Resources = new();\n\n    public async Task ExecuteAsync(HookContext context, Func<Task> hookBody)\n    {\n        if (context.HookType == HookType.Before)\n        {\n            // Allocate resources before the hook\n            var resource = AllocateResource(context.TestContext.TestName);\n            Resources[context.TestContext.TestName] = resource;\n        }\n\n        try\n        {\n            await hookBody();\n        }\n        finally\n        {\n            if (context.HookType == HookType.After)\n            {\n                // Clean up resources after the hook\n                if (Resources.TryGetValue(context.TestContext.TestName, out var resource))\n                {\n                    resource.Dispose();\n                    Resources.Remove(context.TestContext.TestName);\n                }\n            }\n        }\n    }\n\n    private IDisposable AllocateResource(string testName)\n    {\n        // Allocate some resource\n        return new SomeResource(testName);\n    }\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"event-receivers",children:"Event Receivers"}),"\n",(0,i.jsx)(n.p,{children:"TUnit provides several event receiver interfaces that allow you to hook into different stages of the test lifecycle:"}),"\n",(0,i.jsx)(n.h3,{id:"itestdiscoveryeventreceiver",children:"ITestDiscoveryEventReceiver"}),"\n",(0,i.jsx)(n.p,{children:"Notified when a test is discovered during the discovery phase."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:"public interface ITestDiscoveryEventReceiver\n{\n    ValueTask OnTestDiscovered(DiscoveredTestContext context);\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"itestregisteredeventreceiver",children:"ITestRegisteredEventReceiver"}),"\n",(0,i.jsx)(n.p,{children:"Notified when a test is registered with the test engine."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:"public interface ITestRegisteredEventReceiver\n{\n    ValueTask OnTestRegistered(TestRegisteredContext context);\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"iteststarteventreceiver",children:"ITestStartEventReceiver"}),"\n",(0,i.jsx)(n.p,{children:"Notified when a test starts execution."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:"public interface ITestStartEventReceiver\n{\n    ValueTask OnTestStart(TestContext context);\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"itestendeventreceiver",children:"ITestEndEventReceiver"}),"\n",(0,i.jsx)(n.p,{children:"Notified when a test completes execution."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:"public interface ITestEndEventReceiver\n{\n    ValueTask OnTestEnd(TestContext context);\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"itestretryeventreceiver",children:"ITestRetryEventReceiver"}),"\n",(0,i.jsx)(n.p,{children:"Notified when a test is retried."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:"public interface ITestRetryEventReceiver\n{\n    ValueTask OnTestRetry(TestContext context, int retryAttempt);\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"example-event-receiver-implementation",children:"Example Event Receiver Implementation"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:"[AttributeUsage(AttributeTargets.Assembly | AttributeTargets.Class | AttributeTargets.Method)]\npublic class TestReporterAttribute : Attribute, ITestStartEventReceiver, ITestEndEventReceiver\n{\n    public int Order => 0;\n\n    public async ValueTask OnTestStart(TestContext context)\n    {\n        await ReportingService.ReportTestStarted(\n            context.GetDisplayName(),\n            context.TestDetails.TestClass?.FullName,\n            context.TestDetails.TestMethodArguments\n        );\n    }\n\n    public async ValueTask OnTestEnd(TestContext context)\n    {\n        await ReportingService.ReportTestCompleted(\n            context.GetDisplayName(),\n            context.Result?.State,\n            context.Result?.Duration,\n            context.Result?.Exception?.Message\n        );\n    }\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"registering-event-receivers",children:"Registering Event Receivers"}),"\n",(0,i.jsx)(n.p,{children:"Event receivers are registered by implementing the interfaces in an attribute class, then applying that attribute at the assembly, class, or method level:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:'// Create an attribute that implements the event receiver interfaces\n[AttributeUsage(AttributeTargets.Assembly | AttributeTargets.Class | AttributeTargets.Method)]\npublic class CustomEventReceiverAttribute : Attribute, ITestStartEventReceiver, ITestEndEventReceiver\n{\n    public int Order => 0;\n    \n    public ValueTask OnTestStart(TestContext context)\n    {\n        Console.WriteLine($"Test starting: {context.GetDisplayName()}");\n        return default;\n    }\n    \n    public ValueTask OnTestEnd(TestContext context)\n    {\n        Console.WriteLine($"Test ended: {context.GetDisplayName()} - {context.Result?.State}");\n        return default;\n    }\n}\n\n// Apply at assembly level\n[assembly: CustomEventReceiver]\n\n// Or at class level\n[CustomEventReceiver]\npublic class MyTestClass\n{\n    [Test]\n    public async Task MyTest() { }\n}\n\n// Or at method level\n[Test]\n[CustomEventReceiver]\npublic async Task MyTest() { }\n'})}),"\n",(0,i.jsx)(n.h2,{id:"parallel-execution-control",children:"Parallel Execution Control"}),"\n",(0,i.jsx)(n.h3,{id:"iparallellimit",children:"IParallelLimit"}),"\n",(0,i.jsx)(n.p,{children:"Controls the maximum degree of parallelism for tests."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:"public interface IParallelLimit\n{\n    int Limit { get; }\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"Example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:"public class DatabaseParallelLimit : IParallelLimit\n{\n    public int Limit => 5; // Max 5 database tests in parallel\n}\n\n[ParallelLimiter<DatabaseParallelLimit>]\npublic class DatabaseTests\n{\n    // All tests in this class will be limited to 5 parallel executions\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"iparallelconstraint",children:"IParallelConstraint"}),"\n",(0,i.jsx)(n.p,{children:"Defines constraints for parallel execution."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:"public interface IParallelConstraint\n{\n    string ConstraintKey { get; }\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"Example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:"public class SharedResourceConstraint : IParallelConstraint\n{\n    public string ConstraintKey => \"SharedFile\";\n}\n\n[NotInParallel<SharedResourceConstraint>]\npublic async Task Test1()\n{\n    // This test won't run in parallel with other tests\n    // that have the same constraint\n}\n\n[NotInParallel<SharedResourceConstraint>]\npublic async Task Test2()\n{\n    // This test won't run in parallel with Test1\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"iasyncinitializer",children:"IAsyncInitializer"}),"\n",(0,i.jsx)(n.p,{children:"Provides async initialization support for test classes."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:"public interface IAsyncInitializer\n{\n    Task InitializeAsync();\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"Example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:'public class DatabaseTests : IAsyncInitializer\n{\n    private DatabaseConnection _connection;\n\n    public async Task InitializeAsync()\n    {\n        _connection = await DatabaseConnection.CreateAsync();\n        await _connection.MigrateAsync();\n    }\n\n    [Test]\n    public async Task TestDatabaseOperation()\n    {\n        // _connection is guaranteed to be initialized\n        await _connection.ExecuteAsync("SELECT 1");\n    }\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Keep Extensions Focused"}),": Each extension should have a single, clear responsibility."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Handle Exceptions Gracefully"}),": Always wrap the execution of the original body in try-catch blocks."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Avoid State"}),": Extensions should be stateless when possible. If state is needed, ensure it's thread-safe."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Document Behavior"}),": Clearly document what your extension does and any side effects."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Test Your Extensions"}),": Write tests for your custom extensions to ensure they behave correctly."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Consider Performance"}),": Extensions run for every test, so keep them lightweight."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"common-use-cases",children:"Common Use Cases"}),"\n",(0,i.jsx)(n.h3,{id:"cross-cutting-concerns",children:"Cross-Cutting Concerns"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Logging and telemetry"}),"\n",(0,i.jsx)(n.li,{children:"Performance monitoring"}),"\n",(0,i.jsx)(n.li,{children:"Resource management"}),"\n",(0,i.jsx)(n.li,{children:"Security context setup"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"integration-testing",children:"Integration Testing"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Database transaction management"}),"\n",(0,i.jsx)(n.li,{children:"HTTP client configuration"}),"\n",(0,i.jsx)(n.li,{children:"Mock server setup/teardown"}),"\n",(0,i.jsx)(n.li,{children:"Container orchestration"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"compliance-and-auditing",children:"Compliance and Auditing"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Test execution auditing"}),"\n",(0,i.jsx)(n.li,{children:"Compliance logging"}),"\n",(0,i.jsx)(n.li,{children:"Screenshot capture for UI tests"}),"\n",(0,i.jsx)(n.li,{children:"Result archival"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"example-database-transaction-extension",children:"Example: Database Transaction Extension"}),"\n",(0,i.jsx)(n.p,{children:"Here's a complete example that wraps each test in a database transaction:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:'public class TransactionalTestExecutor : ITestExecutor\n{\n    public async Task ExecuteAsync(TestContext context, Func<Task> testBody)\n    {\n        // Get the database connection from DI\n        var dbContext = context.GetService<ApplicationDbContext>();\n\n        using var transaction = await dbContext.Database.BeginTransactionAsync();\n\n        try\n        {\n            await testBody();\n\n            // Rollback instead of commit to keep tests isolated\n            await transaction.RollbackAsync();\n        }\n        catch\n        {\n            await transaction.RollbackAsync();\n            throw;\n        }\n    }\n}\n\n[TestExecutor<TransactionalTestExecutor>]\npublic class DatabaseTests\n{\n    private readonly ApplicationDbContext _dbContext;\n\n    public DatabaseTests(ApplicationDbContext dbContext)\n    {\n        _dbContext = dbContext;\n    }\n\n    [Test]\n    public async Task CreateUser_ShouldAddToDatabase()\n    {\n        // This test runs in a transaction that\'s rolled back\n        var user = new User { Name = "Test User" };\n        _dbContext.Users.Add(user);\n        await _dbContext.SaveChangesAsync();\n\n        var count = await _dbContext.Users.CountAsync();\n        await Assert.That(count).IsEqualTo(1);\n    }\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"This ensures that each test runs in isolation without affecting the database state."})]})}function u(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>l});var s=t(6540);const i={},a=s.createContext(i);function r(e){const n=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);