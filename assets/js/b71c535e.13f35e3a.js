"use strict";(self.webpackChunktunit_docs_site=self.webpackChunktunit_docs_site||[]).push([[368],{3570:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>u,frontMatter:()=>r,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"assertions/extensibility/extensibility-chaining-and-converting","title":"Chaining and Converting","description":"TUnit allows you to chain assertions that change the type being asserted, enabling fluent and expressive test code.","source":"@site/docs/assertions/extensibility/extensibility-chaining-and-converting.md","sourceDirName":"assertions/extensibility","slug":"/assertions/extensibility/extensibility-chaining-and-converting","permalink":"/docs/assertions/extensibility/extensibility-chaining-and-converting","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"docs","previous":{"title":"Custom Assertions","permalink":"/docs/assertions/extensibility/custom-assertions"},"next":{"title":"Returning Data via await","permalink":"/docs/assertions/extensibility/extensibility-returning-items-from-await"}}');var i=s(4848),o=s(8453);const r={},a="Chaining and Converting",l={},c=[];function d(e){const n={br:"br",code:"code",h1:"h1",header:"header",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"chaining-and-converting",children:"Chaining and Converting"})}),"\n",(0,i.jsxs)(n.p,{children:["TUnit allows you to chain assertions that change the type being asserted, enabling fluent and expressive test code.",(0,i.jsx)(n.br,{}),"\n","This is useful when an assertion transforms the value (e.g., parsing a response), and you want to continue asserting on the new type."]}),"\n",(0,i.jsx)(n.p,{children:"Chaining is especially helpful when you want to perform multiple assertions on a value that is transformed by a previous assertion, without having to create intermediate variables."}),"\n",(0,i.jsx)(n.p,{children:"For example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:'        HttpResponseMessage response = ...;\n        \n        await Assert.That(response)\n            .IsProblemDetails()\n            .And\n            .HasTitle("Invalid Authentication Token")\n            .And\n            .HasDetail("No token provided");\n'})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"response"})," object initially passed in is a ",(0,i.jsx)(n.code,{children:"HttpResponseMessage"}),", but then after we assert it's a ",(0,i.jsx)(n.code,{children:"ProblemDetails"})," object, the chain has changed to that type so that we can further assert with methods specific to ",(0,i.jsx)(n.code,{children:"ProblemDetails"})," instead of ",(0,i.jsx)(n.code,{children:"HttpResponseMessage"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"This involves a few steps and specific types to work."}),"\n",(0,i.jsxs)(n.p,{children:["Firstly, you need to create a custom assert condition that inherits from ",(0,i.jsx)(n.code,{children:"ConvertToAssertCondition<TFromType, TToType>"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"In the example above, that'd look like:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:'public class HttpResponseIsProblemDetailsAssertCondition() : ConvertToAssertCondition<HttpResponseMessage, ProblemDetails>()\n{\n    protected override string GetExpectation()\n    {\n        return $"HTTP response to be in the format of a Problem Details object";\n    }\n\n    public override async ValueTask<(AssertionResult, TToType?)> ConvertValue(HttpResponseMessage value)\n    {\n        var content = await value.Content.ReadFromJsonAsync<ProblemDetails>();\n\n        return \n        (\n            AssertionResult.FailIf(content is null, $"response body is not Problem Details"), \n            content\n        );\n    }\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"As you can see, this returns two objects (via a Tuple) - An assertion result, so we know if it's passed or failed the conversion, and then the actual converted object."}),"\n",(0,i.jsxs)(n.p,{children:["You then need to create an extension method to register this assert condition on your data.\nInstead of calling ",(0,i.jsx)(n.code,{children:"source.RegisterAssertion(...)"})," like we do on standard assertions, we instead call ",(0,i.jsx)(n.code,{children:"source.RegisterConversionAssertion(...)"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"Again, for the above example, that'd look like:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:"public static class HttpResponseAssertionExtensions\n{\n    public static InvokableValueAssertionBuilder<ProblemDetails> IsProblemDetails(this IValueSource<HttpResponseMessage> valueSource)\n    {\n        return valueSource.RegisterConversionAssertion(new HttpResponseIsProblemDetailsAssertCondition());\n    }\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"That's it!"}),"\n",(0,i.jsxs)(n.p,{children:["Now any assertions built for the ",(0,i.jsx)(n.code,{children:"ProblemDetails"})," type will work off of that same chain."]}),"\n",(0,i.jsx)(n.p,{children:"E.g."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:'public static class ProblemDetailsAssertionExtensions\n{\n    public static InvokableValueAssertionBuilder<ProblemDetails> HasTitle(this IValueSource<ProblemDetails> valueSource,\n        string title, [CallerArgumentExpression("title")] string? titleExpression = null)\n    {\n        return valueSource.RegisterAssertion(new ProblemDetailsHasTitleAssertCondition(title), [titleExpression]);\n    }\n    \n    public static InvokableValueAssertionBuilder<ProblemDetails> HasDetail(this IValueSource<ProblemDetails> valueSource,\n        string detail, [CallerArgumentExpression("detail")] string? detailExpression = null)\n    {\n        return valueSource.RegisterAssertion(new ProblemDetailsHasDetailAssertCondition(detail), [detailExpression]);\n    }\n}\n'})})]})}function u(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>r,x:()=>a});var t=s(6540);const i={},o=t.createContext(i);function r(e){const n=t.useContext(o);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),t.createElement(o.Provider,{value:n},e.children)}}}]);