"use strict";(self.webpackChunktunit_docs_site=self.webpackChunktunit_docs_site||[]).push([[4508],{1618:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>c,default:()=>u,frontMatter:()=>i,metadata:()=>r,toc:()=>o});const r=JSON.parse('{"id":"test-authoring/generic-attributes","title":"Generic Attributes","description":"TUnit provides generic versions of several attributes that offer enhanced type safety and better IDE support. These attributes allow you to specify types at compile time, reducing errors and improving code maintainability.","source":"@site/docs/test-authoring/generic-attributes.md","sourceDirName":"test-authoring","slug":"/test-authoring/generic-attributes","permalink":"/docs/test-authoring/generic-attributes","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"docs","previous":{"title":"Mocking","permalink":"/docs/test-authoring/mocking"},"next":{"title":"Test Filters","permalink":"/docs/execution/test-filters"}}');var a=n(4848),s=n(8453);const i={},c="Generic Attributes",l={},o=[{value:"Generic Test Attributes",id:"generic-test-attributes",level:2},{value:"MethodDataSourceAttribute&lt;T&gt;",id:"methoddatasourceattributet",level:3},{value:"ClassDataSourceAttribute&lt;T&gt;",id:"classdatasourceattributet",level:3},{value:"DependsOnAttribute&lt;T&gt;",id:"dependsonattributet",level:3},{value:"Generic Data Source Attributes",id:"generic-data-source-attributes",level:2},{value:"DataSourceGeneratorAttribute&lt;T&gt;",id:"datasourcegeneratorattributet",level:3},{value:"AsyncDataSourceGeneratorAttribute&lt;T&gt;",id:"asyncdatasourcegeneratorattributet",level:3},{value:"TypedDataSourceAttribute&lt;T&gt;",id:"typeddatasourceattributet",level:3},{value:"Complex Generic Scenarios",id:"complex-generic-scenarios",level:2},{value:"Combining Multiple Generic Attributes",id:"combining-multiple-generic-attributes",level:3},{value:"Generic Test Base Classes",id:"generic-test-base-classes",level:3},{value:"Workaround 1: Use InstanceMethodDataSource",id:"workaround-1-use-instancemethoddatasource",level:4},{value:"Workaround 2: Create Concrete Base Classes",id:"workaround-2-create-concrete-base-classes",level:4},{value:"AOT Compatibility",id:"aot-compatibility",level:2},{value:"DynamicallyAccessedMembers",id:"dynamicallyaccessedmembers",level:3},{value:"Generic Constraints for AOT",id:"generic-constraints-for-aot",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"1. Use Generic Attributes for Type Safety",id:"1-use-generic-attributes-for-type-safety",level:3},{value:"2. Leverage Constraints",id:"2-leverage-constraints",level:3},{value:"3. Create Reusable Generic Base Attributes",id:"3-create-reusable-generic-base-attributes",level:3},{value:"4. Document Generic Type Parameters",id:"4-document-generic-type-parameters",level:3},{value:"Common Patterns",id:"common-patterns",level:2},{value:"Factory Pattern with Generics",id:"factory-pattern-with-generics",level:3},{value:"Builder Pattern with Generics",id:"builder-pattern-with-generics",level:3},{value:"Summary",id:"summary",level:2}];function d(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.header,{children:(0,a.jsx)(t.h1,{id:"generic-attributes",children:"Generic Attributes"})}),"\n",(0,a.jsx)(t.p,{children:"TUnit provides generic versions of several attributes that offer enhanced type safety and better IDE support. These attributes allow you to specify types at compile time, reducing errors and improving code maintainability."}),"\n",(0,a.jsx)(t.h2,{id:"generic-test-attributes",children:"Generic Test Attributes"}),"\n",(0,a.jsx)(t.h3,{id:"methoddatasourceattributet",children:"MethodDataSourceAttribute<T>"}),"\n",(0,a.jsxs)(t.p,{children:["The generic version of ",(0,a.jsx)(t.code,{children:"MethodDataSource"})," provides type safety for the class containing the data source method."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-csharp",children:"public class TestDataProviders\n{\n    public static IEnumerable<(int, int, int)> AdditionTestCases()\n    {\n        yield return (1, 2, 3);\n        yield return (5, 5, 10);\n        yield return (-1, 1, 0);\n    }\n}\n\npublic class CalculatorTests\n{\n    [Test]\n    [MethodDataSource<TestDataProviders>(nameof(TestDataProviders.AdditionTestCases))]\n    public void Add_ShouldReturnCorrectSum(int a, int b, int expected)\n    {\n        var result = Calculator.Add(a, b);\n        Assert.That(result).IsEqualTo(expected);\n    }\n}\n"})}),"\n",(0,a.jsx)(t.p,{children:"Benefits over non-generic version:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Compile-time type checking"}),"\n",(0,a.jsx)(t.li,{children:"IDE refactoring support"}),"\n",(0,a.jsx)(t.li,{children:"Prevents typos in class names"}),"\n"]}),"\n",(0,a.jsx)(t.h3,{id:"classdatasourceattributet",children:"ClassDataSourceAttribute<T>"}),"\n",(0,a.jsx)(t.p,{children:"The generic version ensures type safety when referencing data source classes."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-csharp",children:'public class UserTestData : IEnumerable<User>\n{\n    public IEnumerator<User> GetEnumerator()\n    {\n        yield return new User { Id = 1, Name = "Alice" };\n        yield return new User { Id = 2, Name = "Bob" };\n    }\n    \n    IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();\n}\n\npublic class UserTests\n{\n    [Test]\n    [ClassDataSource<UserTestData>]\n    public async Task ValidateUser_ShouldPass(User user)\n    {\n        var isValid = await UserValidator.ValidateAsync(user);\n        await Assert.That(isValid).IsTrue();\n    }\n}\n'})}),"\n",(0,a.jsx)(t.h3,{id:"dependsonattributet",children:"DependsOnAttribute<T>"}),"\n",(0,a.jsxs)(t.p,{children:["The generic ",(0,a.jsx)(t.code,{children:"DependsOn"})," attribute provides type-safe test dependency declarations."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-csharp",children:"public class OrderProcessingTests\n{\n    [Test]\n    public async Task CreateOrder()\n    {\n        // Create order logic\n    }\n    \n    [Test]\n    [DependsOn<OrderProcessingTests>(nameof(CreateOrder))]\n    public async Task ProcessPayment()\n    {\n        // This test depends on CreateOrder from the same class\n    }\n}\n\npublic class ShippingTests\n{\n    [Test]\n    [DependsOn<OrderProcessingTests>(nameof(OrderProcessingTests.ProcessPayment))]\n    public async Task ShipOrder()\n    {\n        // This test depends on ProcessPayment from another class\n    }\n}\n"})}),"\n",(0,a.jsx)(t.h2,{id:"generic-data-source-attributes",children:"Generic Data Source Attributes"}),"\n",(0,a.jsx)(t.h3,{id:"datasourcegeneratorattributet",children:"DataSourceGeneratorAttribute<T>"}),"\n",(0,a.jsx)(t.p,{children:"Create strongly-typed data source generators:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-csharp",children:"public abstract class DataSourceGeneratorAttribute<T> : Attribute\n{\n    public abstract IEnumerable<T> GenerateData();\n}\n\n// Custom implementation\npublic class RandomNumbersAttribute : DataSourceGeneratorAttribute<int>\n{\n    private readonly int _count;\n    private readonly int _min;\n    private readonly int _max;\n    \n    public RandomNumbersAttribute(int count, int min = 0, int max = 100)\n    {\n        _count = count;\n        _min = min;\n        _max = max;\n    }\n    \n    public override IEnumerable<int> GenerateData()\n    {\n        var random = new Random();\n        for (int i = 0; i < _count; i++)\n        {\n            yield return random.Next(_min, _max);\n        }\n    }\n}\n\n// Usage\n[Test]\n[RandomNumbers(5, min: 1, max: 10)]\npublic void TestWithRandomNumbers(int number)\n{\n    Assert.That(number).IsBetween(1, 10);\n}\n"})}),"\n",(0,a.jsx)(t.h3,{id:"asyncdatasourcegeneratorattributet",children:"AsyncDataSourceGeneratorAttribute<T>"}),"\n",(0,a.jsx)(t.p,{children:"For asynchronous data generation:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-csharp",children:'public abstract class AsyncDataSourceGeneratorAttribute<T> : Attribute\n{\n    public abstract Task<IEnumerable<T>> GenerateDataAsync();\n}\n\n// Custom implementation\npublic class DatabaseUsersAttribute : AsyncDataSourceGeneratorAttribute<User>\n{\n    private readonly string _role;\n    \n    public DatabaseUsersAttribute(string role)\n    {\n        _role = role;\n    }\n    \n    public override async Task<IEnumerable<User>> GenerateDataAsync()\n    {\n        using var db = new DatabaseContext();\n        return await db.Users\n            .Where(u => u.Role == _role)\n            .ToListAsync();\n    }\n}\n\n// Usage\n[Test]\n[DatabaseUsers("Admin")]\npublic async Task AdminUser_ShouldHaveFullPermissions(User adminUser)\n{\n    var permissions = await GetUserPermissions(adminUser);\n    await Assert.That(permissions).Contains(Permission.FullAccess);\n}\n'})}),"\n",(0,a.jsx)(t.h3,{id:"typeddatasourceattributet",children:"TypedDataSourceAttribute<T>"}),"\n",(0,a.jsx)(t.p,{children:"Base class for creating custom typed data sources:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-csharp",children:"public abstract class TypedDataSourceAttribute<T> : DataSourceAttribute\n{\n    public abstract IEnumerable<T> GetData();\n}\n\n// Implementation example\npublic class FibonacciDataAttribute : TypedDataSourceAttribute<int>\n{\n    private readonly int _count;\n    \n    public FibonacciDataAttribute(int count)\n    {\n        _count = count;\n    }\n    \n    public override IEnumerable<int> GetData()\n    {\n        int a = 0, b = 1;\n        yield return a;\n        \n        if (_count > 1) yield return b;\n        \n        for (int i = 2; i < _count; i++)\n        {\n            int temp = a + b;\n            yield return temp;\n            a = b;\n            b = temp;\n        }\n    }\n}\n\n// Usage\n[Test]\n[FibonacciData(7)]\npublic void TestFibonacciNumber(int fibNumber)\n{\n    // Test with Fibonacci sequence: 0, 1, 1, 2, 3, 5, 8\n    Assert.That(fibNumber).IsGreaterThanOrEqualTo(0);\n}\n"})}),"\n",(0,a.jsx)(t.h2,{id:"complex-generic-scenarios",children:"Complex Generic Scenarios"}),"\n",(0,a.jsx)(t.h3,{id:"combining-multiple-generic-attributes",children:"Combining Multiple Generic Attributes"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-csharp",children:"public interface ITestScenario<TInput, TExpected>\n{\n    TInput Input { get; }\n    TExpected Expected { get; }\n}\n\npublic class CalculationScenario : ITestScenario<(int, int), int>\n{\n    public (int, int) Input { get; set; }\n    public int Expected { get; set; }\n}\n\npublic class ScenarioDataSource<TScenario> : TypedDataSourceAttribute<TScenario>\n    where TScenario : ITestScenario<(int, int), int>, new()\n{\n    public override IEnumerable<TScenario> GetData()\n    {\n        yield return new TScenario { Input = (1, 2), Expected = 3 };\n        yield return new TScenario { Input = (5, 5), Expected = 10 };\n    }\n}\n\n[Test]\n[ScenarioDataSource<CalculationScenario>]\npublic void TestCalculation(CalculationScenario scenario)\n{\n    var (a, b) = scenario.Input;\n    var result = Calculator.Add(a, b);\n    Assert.That(result).IsEqualTo(scenario.Expected);\n}\n"})}),"\n",(0,a.jsx)(t.h3,{id:"generic-test-base-classes",children:"Generic Test Base Classes"}),"\n",(0,a.jsxs)(t.p,{children:["\u26a0\ufe0f ",(0,a.jsx)(t.strong,{children:"Important Limitation"}),": C# does not allow generic type parameters to be used as attribute arguments. This is a known language limitation (see ",(0,a.jsx)(t.a,{href:"https://github.com/dotnet/csharplang/issues/124",children:"dotnet/csharplang#124"}),")."]}),"\n",(0,a.jsxs)(t.p,{children:["The following code ",(0,a.jsx)(t.strong,{children:"WILL NOT COMPILE"})," due to error CS8968:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-csharp",children:"// \u274c This does NOT work - CS8968 error\npublic abstract class EntityTestBase<TEntity, TId>\n    where TEntity : IEntity<TId>\n{\n    [Test]\n    [MethodDataSource<EntityTestBase<TEntity, TId>>(nameof(GetTestIds))]  // \u274c Error!\n    public async Task Entity_ShouldBeRetrievable(TId id) { }\n}\n"})}),"\n",(0,a.jsx)(t.h4,{id:"workaround-1-use-instancemethoddatasource",children:"Workaround 1: Use InstanceMethodDataSource"}),"\n",(0,a.jsxs)(t.p,{children:["The recommended approach is to use ",(0,a.jsx)(t.code,{children:"InstanceMethodDataSource"})," instead:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-csharp",children:'public abstract class EntityTestBase<TEntity, TId>\n    where TEntity : IEntity<TId>\n    where TId : IEquatable<TId>\n{\n    protected abstract TEntity CreateEntity(TId id);\n    protected abstract Task<TEntity> GetEntityAsync(TId id);\n\n    // \u2705 This works - instance method data source\n    [Test]\n    [InstanceMethodDataSource(nameof(GetTestIds))]\n    public async Task Entity_ShouldBeRetrievable(TId id)\n    {\n        var entity = CreateEntity(id);\n        await SaveEntityAsync(entity);\n\n        var retrieved = await GetEntityAsync(id);\n        await Assert.That(retrieved.Id).IsEqualTo(id);\n    }\n\n    // Instance method (not static)\n    public IEnumerable<TId> GetTestIds()\n    {\n        return GetTestIdsCore();\n    }\n\n    protected abstract IEnumerable<TId> GetTestIdsCore();\n}\n\npublic class UserEntityTests : EntityTestBase<User, Guid>\n{\n    protected override User CreateEntity(Guid id) =>\n        new User { Id = id, Name = "Test User" };\n\n    protected override Task<User> GetEntityAsync(Guid id) =>\n        UserRepository.GetByIdAsync(id);\n\n    protected override IEnumerable<Guid> GetTestIdsCore()\n    {\n        yield return Guid.NewGuid();\n        yield return Guid.NewGuid();\n    }\n}\n'})}),"\n",(0,a.jsx)(t.h4,{id:"workaround-2-create-concrete-base-classes",children:"Workaround 2: Create Concrete Base Classes"}),"\n",(0,a.jsx)(t.p,{children:"For a limited set of types, create non-generic derived classes:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-csharp",children:'// Base generic class (no data source attributes using generics)\npublic abstract class EntityTestBase<TEntity, TId>\n    where TEntity : IEntity<TId>\n    where TId : IEquatable<TId>\n{\n    protected abstract TEntity CreateEntity(TId id);\n    protected abstract Task<TEntity> GetEntityAsync(TId id);\n\n    protected async Task Entity_ShouldBeRetrievable(TId id)\n    {\n        var entity = CreateEntity(id);\n        await SaveEntityAsync(entity);\n\n        var retrieved = await GetEntityAsync(id);\n        await Assert.That(retrieved.Id).IsEqualTo(id);\n    }\n}\n\n// Concrete base class for Guid-based entities\npublic abstract class GuidEntityTestBase<TEntity> : EntityTestBase<TEntity, Guid>\n    where TEntity : IEntity<Guid>\n{\n    [Test]\n    [MethodDataSource<GuidEntityTestBase<TEntity>>(nameof(GetTestIds))]\n    public async Task TestEntity(Guid id)\n    {\n        await Entity_ShouldBeRetrievable(id);\n    }\n\n    public static IEnumerable<Guid> GetTestIds()\n    {\n        yield return Guid.NewGuid();\n        yield return Guid.NewGuid();\n    }\n}\n\n// Your test class\npublic class UserEntityTests : GuidEntityTestBase<User>\n{\n    protected override User CreateEntity(Guid id) =>\n        new User { Id = id, Name = "Test User" };\n\n    protected override Task<User> GetEntityAsync(Guid id) =>\n        UserRepository.GetByIdAsync(id);\n}\n'})}),"\n",(0,a.jsx)(t.h2,{id:"aot-compatibility",children:"AOT Compatibility"}),"\n",(0,a.jsx)(t.p,{children:"Generic attributes work well with AOT compilation, but there are some considerations:"}),"\n",(0,a.jsx)(t.h3,{id:"dynamicallyaccessedmembers",children:"DynamicallyAccessedMembers"}),"\n",(0,a.jsx)(t.p,{children:"When creating generic attributes that use reflection, add appropriate attributes:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-csharp",children:"public class ReflectiveDataSource<[DynamicallyAccessedMembers(\n    DynamicallyAccessedMemberTypes.PublicConstructors | \n    DynamicallyAccessedMemberTypes.PublicProperties)] T> \n    : TypedDataSourceAttribute<T> where T : new()\n{\n    public override IEnumerable<T> GetData()\n    {\n        var type = typeof(T);\n        var properties = type.GetProperties();\n        \n        // Create instances with different property values\n        foreach (var prop in properties)\n        {\n            var instance = new T();\n            // Set property values...\n            yield return instance;\n        }\n    }\n}\n"})}),"\n",(0,a.jsx)(t.h3,{id:"generic-constraints-for-aot",children:"Generic Constraints for AOT"}),"\n",(0,a.jsx)(t.p,{children:"Use constraints to ensure AOT compatibility:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-csharp",children:"public class SerializableDataSource<T> : TypedDataSourceAttribute<T>\n    where T : IJsonSerializable<T> // Ensures T can be serialized\n{\n    private readonly string _jsonFile;\n    \n    public SerializableDataSource(string jsonFile)\n    {\n        _jsonFile = jsonFile;\n    }\n    \n    public override IEnumerable<T> GetData()\n    {\n        var json = File.ReadAllText(_jsonFile);\n        var items = JsonSerializer.Deserialize<List<T>>(json);\n        return items ?? Enumerable.Empty<T>();\n    }\n}\n"})}),"\n",(0,a.jsx)(t.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,a.jsx)(t.h3,{id:"1-use-generic-attributes-for-type-safety",children:"1. Use Generic Attributes for Type Safety"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-csharp",children:'// \u274c Non-generic - prone to errors\n[MethodDataSource(typeof(DataProvider), "GetData")]\n\n// \u2705 Generic - compile-time safety\n[MethodDataSource<DataProvider>(nameof(DataProvider.GetData))]\n'})}),"\n",(0,a.jsx)(t.h3,{id:"2-leverage-constraints",children:"2. Leverage Constraints"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-csharp",children:"public class ValidatableDataSource<T> : TypedDataSourceAttribute<T>\n    where T : IValidatable\n{\n    public override IEnumerable<T> GetData()\n    {\n        // Only return valid instances\n        return GenerateInstances().Where(x => x.IsValid());\n    }\n}\n"})}),"\n",(0,a.jsx)(t.h3,{id:"3-create-reusable-generic-base-attributes",children:"3. Create Reusable Generic Base Attributes"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-csharp",children:'public abstract class JsonFileDataSource<T> : TypedDataSourceAttribute<T>\n{\n    protected abstract string FilePath { get; }\n    \n    public override IEnumerable<T> GetData()\n    {\n        var json = File.ReadAllText(FilePath);\n        return JsonSerializer.Deserialize<List<T>>(json) \n            ?? Enumerable.Empty<T>();\n    }\n}\n\npublic class UserJsonDataSource : JsonFileDataSource<User>\n{\n    protected override string FilePath => "TestData/users.json";\n}\n'})}),"\n",(0,a.jsx)(t.h3,{id:"4-document-generic-type-parameters",children:"4. Document Generic Type Parameters"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-csharp",children:'/// <summary>\n/// Provides test data from a CSV file\n/// </summary>\n/// <typeparam name="T">The type to deserialize CSV rows into. \n/// Must have a parameterless constructor.</typeparam>\npublic class CsvDataSource<T> : TypedDataSourceAttribute<T> \n    where T : new()\n{\n    // Implementation\n}\n'})}),"\n",(0,a.jsx)(t.h2,{id:"common-patterns",children:"Common Patterns"}),"\n",(0,a.jsx)(t.h3,{id:"factory-pattern-with-generics",children:"Factory Pattern with Generics"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-csharp",children:"public class EntityFactory<T> where T : IEntity, new()\n{\n    public static IEnumerable<T> CreateTestEntities(int count)\n    {\n        for (int i = 0; i < count; i++)\n        {\n            yield return new T \n            { \n                Id = i,\n                CreatedAt = DateTime.UtcNow\n            };\n        }\n    }\n}\n\npublic class FactoryDataSource<T> : TypedDataSourceAttribute<T>\n    where T : IEntity, new()\n{\n    private readonly int _count;\n    \n    public FactoryDataSource(int count = 3)\n    {\n        _count = count;\n    }\n    \n    public override IEnumerable<T> GetData()\n    {\n        return EntityFactory<T>.CreateTestEntities(_count);\n    }\n}\n\n// Usage\n[Test]\n[FactoryDataSource<Product>(5)]\npublic async Task TestProductEntity(Product product)\n{\n    await Assert.That(product.Id).IsGreaterThanOrEqualTo(0);\n}\n"})}),"\n",(0,a.jsx)(t.h3,{id:"builder-pattern-with-generics",children:"Builder Pattern with Generics"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-csharp",children:'public abstract class TestDataBuilder<T> : TypedDataSourceAttribute<T>\n{\n    protected abstract T BuildDefault();\n    protected abstract T BuildInvalid();\n    protected abstract T BuildEdgeCase();\n    \n    public override IEnumerable<T> GetData()\n    {\n        yield return BuildDefault();\n        yield return BuildInvalid();\n        yield return BuildEdgeCase();\n    }\n}\n\npublic class UserDataBuilder : TestDataBuilder<User>\n{\n    protected override User BuildDefault() => \n        new User { Id = 1, Name = "John", Age = 30 };\n        \n    protected override User BuildInvalid() => \n        new User { Id = -1, Name = "", Age = -5 };\n        \n    protected override User BuildEdgeCase() => \n        new User { Id = int.MaxValue, Name = new string(\'a\', 1000), Age = 150 };\n}\n'})}),"\n",(0,a.jsx)(t.h2,{id:"summary",children:"Summary"}),"\n",(0,a.jsx)(t.p,{children:"Generic attributes in TUnit provide:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Type Safety"}),": Compile-time checking prevents runtime errors"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Better IDE Support"}),": Refactoring and navigation work correctly"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Cleaner Code"}),": No magic strings or typeof expressions"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"AOT Compatibility"}),": Work well with ahead-of-time compilation"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Reusability"}),": Easy to create generic base attributes for common patterns"]}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"Use generic attributes whenever possible to improve code quality and maintainability in your test suites."})]})}function u(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>c});var r=n(6540);const a={},s=r.createContext(a);function i(e){const t=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),r.createElement(s.Provider,{value:t},e.children)}}}]);