"use strict";(self.webpackChunktunit_docs_site=self.webpackChunktunit_docs_site||[]).push([[368],{3570:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"assertions/extensibility/extensibility-chaining-and-converting","title":"Chaining and Converting","description":"TUnit allows you to chain assertions that change the type being asserted, enabling fluent and expressive test code.","source":"@site/docs/assertions/extensibility/extensibility-chaining-and-converting.md","sourceDirName":"assertions/extensibility","slug":"/assertions/extensibility/extensibility-chaining-and-converting","permalink":"/docs/assertions/extensibility/extensibility-chaining-and-converting","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"docs","previous":{"title":"Source Generator Assertions","permalink":"/docs/assertions/extensibility/source-generator-assertions"},"next":{"title":"Returning Data via await","permalink":"/docs/assertions/extensibility/extensibility-returning-items-from-await"}}');var i=n(4848),r=n(8453);const a={},o="Chaining and Converting",l={},c=[{value:"How to Implement Type Conversion Assertions",id:"how-to-implement-type-conversion-assertions",level:2},{value:"1. Create the Assertion Class",id:"1-create-the-assertion-class",level:3},{value:"2. Create the Extension Method",id:"2-create-the-extension-method",level:3},{value:"3. Create Assertions for the Target Type",id:"3-create-assertions-for-the-target-type",level:3},{value:"Built-in Examples",id:"built-in-examples",level:2}];function d(e){const t={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"chaining-and-converting",children:"Chaining and Converting"})}),"\n",(0,i.jsx)(t.p,{children:"TUnit allows you to chain assertions that change the type being asserted, enabling fluent and expressive test code.\nThis is useful when an assertion transforms the value (e.g., parsing a response), and you want to continue asserting on the new type."}),"\n",(0,i.jsx)(t.p,{children:"Chaining is especially helpful when you want to perform multiple assertions on a value that is transformed by a previous assertion, without having to create intermediate variables."}),"\n",(0,i.jsx)(t.p,{children:"For example:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-csharp",children:'        HttpResponseMessage response = ...;\n\n        await Assert.That(response)\n            .IsProblemDetails()\n            .And\n            .HasTitle("Invalid Authentication Token")\n            .And\n            .HasDetail("No token provided");\n'})}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.code,{children:"response"})," object initially passed in is a ",(0,i.jsx)(t.code,{children:"HttpResponseMessage"}),", but then after we assert it's a ",(0,i.jsx)(t.code,{children:"ProblemDetails"})," object, the chain has changed to that type so that we can further assert with methods specific to ",(0,i.jsx)(t.code,{children:"ProblemDetails"})," instead of ",(0,i.jsx)(t.code,{children:"HttpResponseMessage"}),"."]}),"\n",(0,i.jsx)(t.h2,{id:"how-to-implement-type-conversion-assertions",children:"How to Implement Type Conversion Assertions"}),"\n",(0,i.jsx)(t.p,{children:"Creating a type-converting assertion involves two main steps:"}),"\n",(0,i.jsx)(t.h3,{id:"1-create-the-assertion-class",children:"1. Create the Assertion Class"}),"\n",(0,i.jsxs)(t.p,{children:["Create a custom assertion class that extends ",(0,i.jsx)(t.code,{children:"Assertion<TTo>"})," where ",(0,i.jsx)(t.code,{children:"TTo"})," is the target type. The constructor should take ",(0,i.jsx)(t.code,{children:"AssertionContext<TFrom>"})," (the source type) and use ",(0,i.jsx)(t.code,{children:".Map<TTo>(...)"})," to transform the value."]}),"\n",(0,i.jsx)(t.p,{children:"In the example above, that'd look like:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-csharp",children:'public class IsProblemDetailsAssertion : Assertion<ProblemDetails>\n{\n    public IsProblemDetailsAssertion(AssertionContext<HttpResponseMessage> context)\n        : base(context.Map<ProblemDetails>(async response =>\n        {\n            var content = await response.Content.ReadFromJsonAsync<ProblemDetails>();\n\n            if (content is null)\n            {\n                throw new InvalidOperationException("Response body is not Problem Details");\n            }\n\n            return content;\n        }))\n    {\n    }\n\n    protected override Task<AssertionResult> CheckAsync(EvaluationMetadata<ProblemDetails> metadata)\n    {\n        // The transformation already happened in the Map function\n        // If we got here without exception, the conversion succeeded\n        if (metadata.Exception != null)\n        {\n            return Task.FromResult(AssertionResult.Failed(metadata.Exception.Message));\n        }\n\n        return Task.FromResult(AssertionResult.Passed);\n    }\n\n    protected override string GetExpectation()\n    {\n        return "HTTP response to be in the format of a Problem Details object";\n    }\n}\n'})}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.code,{children:".Map<TTo>(...)"})," method handles the type conversion. If the conversion fails, throw an exception which will be captured and reported as an assertion failure."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Note:"})," The ",(0,i.jsx)(t.code,{children:"Map"})," method supports both synchronous and asynchronous transformations:"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Synchronous"}),": ",(0,i.jsx)(t.code,{children:"context.Map<TTo>(value => transformedValue)"})]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Asynchronous"}),": ",(0,i.jsx)(t.code,{children:"context.Map<TTo>(async value => await transformedValueAsync)"})]}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"In both cases, the Task is automatically unwrapped, allowing you to chain assertions directly on the result type."}),"\n",(0,i.jsx)(t.h3,{id:"2-create-the-extension-method",children:"2. Create the Extension Method"}),"\n",(0,i.jsxs)(t.p,{children:["Create an extension method on ",(0,i.jsx)(t.code,{children:"IAssertionSource<TFrom>"})," that returns your assertion class:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-csharp",children:'public static class HttpResponseAssertionExtensions\n{\n    public static IsProblemDetailsAssertion IsProblemDetails(\n        this IAssertionSource<HttpResponseMessage> source)\n    {\n        source.Context.ExpressionBuilder.Append(".IsProblemDetails()");\n        return new IsProblemDetailsAssertion(source.Context);\n    }\n}\n'})}),"\n",(0,i.jsx)(t.p,{children:"That's it!"}),"\n",(0,i.jsxs)(t.p,{children:["Now any assertions built for the ",(0,i.jsx)(t.code,{children:"ProblemDetails"})," type will work off of that same chain."]}),"\n",(0,i.jsx)(t.h3,{id:"3-create-assertions-for-the-target-type",children:"3. Create Assertions for the Target Type"}),"\n",(0,i.jsxs)(t.p,{children:["You can then create standard assertions for the target type (",(0,i.jsx)(t.code,{children:"ProblemDetails"})," in this case):"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-csharp",children:'public static class ProblemDetailsAssertionExtensions\n{\n    public static HasTitleAssertion HasTitle(\n        this IAssertionSource<ProblemDetails> source,\n        string expectedTitle,\n        [CallerArgumentExpression(nameof(expectedTitle))] string? expression = null)\n    {\n        source.Context.ExpressionBuilder.Append($".HasTitle({expression})");\n        return new HasTitleAssertion(source.Context, expectedTitle);\n    }\n\n    public static HasDetailAssertion HasDetail(\n        this IAssertionSource<ProblemDetails> source,\n        string expectedDetail,\n        [CallerArgumentExpression(nameof(expectedDetail))] string? expression = null)\n    {\n        source.Context.ExpressionBuilder.Append($".HasDetail({expression})");\n        return new HasDetailAssertion(source.Context, expectedDetail);\n    }\n}\n\npublic class HasTitleAssertion : Assertion<ProblemDetails>\n{\n    private readonly string _expectedTitle;\n\n    public HasTitleAssertion(AssertionContext<ProblemDetails> context, string expectedTitle)\n        : base(context)\n    {\n        _expectedTitle = expectedTitle;\n    }\n\n    protected override Task<AssertionResult> CheckAsync(EvaluationMetadata<ProblemDetails> metadata)\n    {\n        if (metadata.Exception != null)\n        {\n            return Task.FromResult(AssertionResult.Failed("ProblemDetails is null"));\n        }\n\n        if (metadata.Value?.Title != _expectedTitle)\n        {\n            return Task.FromResult(AssertionResult.Failed(\n                $"Expected title \'{_expectedTitle}\' but was \'{metadata.Value?.Title}\'"));\n        }\n\n        return Task.FromResult(AssertionResult.Passed);\n    }\n\n    protected override string GetExpectation() => $"to have title \'{_expectedTitle}\'";\n}\n\npublic class HasDetailAssertion : Assertion<ProblemDetails>\n{\n    private readonly string _expectedDetail;\n\n    public HasDetailAssertion(AssertionContext<ProblemDetails> context, string expectedDetail)\n        : base(context)\n    {\n        _expectedDetail = expectedDetail;\n    }\n\n    protected override Task<AssertionResult> CheckAsync(EvaluationMetadata<ProblemDetails> metadata)\n    {\n        if (metadata.Exception != null)\n        {\n            return Task.FromResult(AssertionResult.Failed("ProblemDetails is null"));\n        }\n\n        if (metadata.Value?.Detail != _expectedDetail)\n        {\n            return Task.FromResult(AssertionResult.Failed(\n                $"Expected detail \'{_expectedDetail}\' but was \'{metadata.Value?.Detail}\'"));\n        }\n\n        return Task.FromResult(AssertionResult.Passed);\n    }\n\n    protected override string GetExpectation() => $"to have detail \'{_expectedDetail}\'";\n}\n'})}),"\n",(0,i.jsx)(t.h2,{id:"built-in-examples",children:"Built-in Examples"}),"\n",(0,i.jsx)(t.p,{children:"TUnit includes several built-in examples of type conversion assertions:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"WhenParsedInto<T>()"})," - Converts a string to a parsed type (e.g., ",(0,i.jsx)(t.code,{children:'await Assert.That("123").WhenParsedInto<int>().IsEqualTo(123)'}),")"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"IsTypeOf<T>()"})," - Converts to a specific type (e.g., ",(0,i.jsx)(t.code,{children:"await Assert.That(obj).IsTypeOf<StringBuilder>().HasLength(5)"}),")"]}),"\n"]})]})}function h(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>o});var s=n(6540);const i={},r=s.createContext(i);function a(e){const t=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),s.createElement(r.Provider,{value:t},e.children)}}}]);