"use strict";(self.webpackChunktunit_docs_site=self.webpackChunktunit_docs_site||[]).push([[9611],{3644:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>c,default:()=>p,frontMatter:()=>r,metadata:()=>s,toc:()=>o});const s=JSON.parse('{"id":"test-authoring/nested-data-sources","title":"Nested Data Sources with Initialization","description":"When writing integration tests, you often need complex test fixtures that depend on other initialized resources. TUnit\'s nested data source initialization feature makes this elegant and automatic.","source":"@site/docs/test-authoring/nested-data-sources.md","sourceDirName":"test-authoring","slug":"/test-authoring/nested-data-sources","permalink":"/docs/test-authoring/nested-data-sources","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":7,"frontMatter":{"sidebar_position":7},"sidebar":"docs","previous":{"title":"CombinedDataSources","permalink":"/docs/test-authoring/combined-data-source"},"next":{"title":"Skipping Tests","permalink":"/docs/test-authoring/skip"}}');var t=i(4848),a=i(8453);const r={sidebar_position:7},c="Nested Data Sources with Initialization",l={},o=[{value:"The Problem",id:"the-problem",level:2},{value:"The Solution",id:"the-solution",level:2},{value:"Basic Example",id:"basic-example",level:2},{value:"Multiple Dependencies",id:"multiple-dependencies",level:2},{value:"Sharing Resources",id:"sharing-resources",level:2},{value:"Combining with Method Data Sources",id:"combining-with-method-data-sources",level:2},{value:"How It Works",id:"how-it-works",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"Common Patterns",id:"common-patterns",level:2},{value:"Database Migrations",id:"database-migrations",level:3},{value:"Seeding Test Data",id:"seeding-test-data",level:3},{value:"Health Checks",id:"health-checks",level:3},{value:"Summary",id:"summary",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"nested-data-sources-with-initialization",children:"Nested Data Sources with Initialization"})}),"\n",(0,t.jsx)(n.p,{children:"When writing integration tests, you often need complex test fixtures that depend on other initialized resources. TUnit's nested data source initialization feature makes this elegant and automatic."}),"\n",(0,t.jsx)(n.h2,{id:"the-problem",children:"The Problem"}),"\n",(0,t.jsx)(n.p,{children:"Traditional integration test setup often requires:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Starting test containers (databases, message queues, etc.)"}),"\n",(0,t.jsx)(n.li,{children:"Initializing WebApplicationFactory with custom services"}),"\n",(0,t.jsx)(n.li,{children:"Ensuring proper initialization order"}),"\n",(0,t.jsx)(n.li,{children:"Managing resource lifecycle"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"This typically leads to complex setup code with manual initialization chains."}),"\n",(0,t.jsx)(n.h2,{id:"the-solution",children:"The Solution"}),"\n",(0,t.jsxs)(n.p,{children:["TUnit automatically initializes nested data sources in the correct order using any data source attribute that implements ",(0,t.jsx)(n.code,{children:"IDataSourceAttribute"})," (such as ",(0,t.jsx)(n.code,{children:"[ClassDataSource<T>]"}),")."]}),"\n",(0,t.jsx)(n.h2,{id:"basic-example",children:"Basic Example"}),"\n",(0,t.jsx)(n.p,{children:"Here's a complete example of setting up integration tests with Redis and WebApplicationFactory:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'using Testcontainers.Redis;\nusing TUnit.Core;\nusing Microsoft.AspNetCore.Mvc.Testing;\nusing StackExchange.Redis;\n\n// 1. Define a test container that needs initialization\npublic class RedisTestContainer : IAsyncInitializer, IAsyncDisposable\n{\n    private readonly RedisContainer _container;\n    \n    public string ConnectionString => _container.GetConnectionString();\n    \n    public RedisTestContainer()\n    {\n        _container = new RedisBuilder()\n            .WithImage("redis:7-alpine")\n            .Build();\n    }\n    \n    public async Task InitializeAsync()\n    {\n        await _container.StartAsync();\n    }\n    \n    public async ValueTask DisposeAsync()\n    {\n        await _container.DisposeAsync();\n    }\n}\n\n// 2. Create a test application that depends on Redis\npublic class TestApplication : IAsyncInitializer, IAsyncDisposable\n{\n    private WebApplicationFactory<Program>? _factory;\n    \n    // This property will be initialized BEFORE InitializeAsync is called\n    [ClassDataSource<RedisTestContainer>]\n    public required RedisTestContainer Redis { get; init; }\n    \n    public HttpClient Client { get; private set; } = null!;\n    \n    public async Task InitializeAsync()\n    {\n        // At this point, Redis is already started and ready!\n        _factory = new WebApplicationFactory<Program>()\n            .WithWebHostBuilder(builder =>\n            {\n                builder.ConfigureServices(services =>\n                {\n                    // Replace production Redis with our test container\n                    services.AddSingleton<IConnectionMultiplexer>(_ => \n                        ConnectionMultiplexer.Connect(Redis.ConnectionString));\n                });\n            });\n        \n        Client = _factory.CreateClient();\n    }\n    \n    public async ValueTask DisposeAsync()\n    {\n        Client?.Dispose();\n        if (_factory != null) await _factory.DisposeAsync();\n    }\n}\n\n// 3. Use in tests - TUnit automatically handles nested initialization\npublic class UserApiTests\n{\n    [Test]\n    [ClassDataSource<TestApplication>(Shared = SharedType.PerClass)]\n    public async Task CreateUser_Should_Cache_In_Redis(TestApplication app)\n    {\n        // Arrange\n        var user = new { Name = "John", Email = "john@example.com" };\n        \n        // Act\n        var response = await app.Client.PostAsJsonAsync("/api/users", user);\n        \n        // Assert\n        response.EnsureSuccessStatusCode();\n        \n        // Verify the user was cached in Redis\n        var services = app.Client.Services;\n        var redis = services.GetRequiredService<IConnectionMultiplexer>();\n        var cached = await redis.GetDatabase().StringGetAsync("user:john@example.com");\n        \n        Assert.That(cached.HasValue).IsTrue();\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"multiple-dependencies",children:"Multiple Dependencies"}),"\n",(0,t.jsx)(n.p,{children:"You can have multiple nested dependencies, and TUnit will initialize them in the correct order:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"public class CompleteTestEnvironment : IAsyncInitializer, IAsyncDisposable\n{\n    private WebApplicationFactory<Program>? _factory;\n    \n    // All of these will be initialized before InitializeAsync\n    [ClassDataSource<RedisTestContainer>]\n    public required RedisTestContainer Redis { get; init; }\n    \n    [ClassDataSource<PostgresTestContainer>]\n    public required PostgresTestContainer Database { get; init; }\n    \n    [ClassDataSource<LocalStackContainer>]\n    public required LocalStackContainer LocalStack { get; init; }\n    \n    public HttpClient Client { get; private set; } = null!;\n    \n    public async Task InitializeAsync()\n    {\n        // All containers are running at this point\n        _factory = new WebApplicationFactory<Program>()\n            .WithWebHostBuilder(builder =>\n            {\n                builder.ConfigureServices(services =>\n                {\n                    // Wire up all test services\n                    ConfigureRedis(services);\n                    ConfigureDatabase(services);\n                    ConfigureAwsServices(services);\n                });\n            });\n        \n        Client = _factory.CreateClient();\n        \n        // Run any post-initialization setup\n        await SeedTestData();\n    }\n    \n    // ... configuration methods\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"sharing-resources",children:"Sharing Resources"}),"\n",(0,t.jsxs)(n.p,{children:["Expensive resources like test containers should be shared across tests using the ",(0,t.jsx)(n.code,{children:"Shared"})," parameter:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'public class OrderApiTests\n{\n    [Test]\n    [ClassDataSource<TestApplication>(Shared = SharedType.PerClass)]\n    public async Task Test1(TestApplication app)\n    {\n        // First test - creates new instance\n    }\n\n    [Test]\n    [ClassDataSource<TestApplication>(Shared = SharedType.PerClass)]\n    public async Task Test2(TestApplication app)\n    {\n        // Reuses the same instance as Test1\n    }\n}\n\n// Or share with a specific key for fine-grained control across multiple test classes\npublic class UserApiTests\n{\n    [Test]\n    [ClassDataSource<TestApplication>(Shared = SharedType.Keyed, Key = "integration-tests")]\n    public async Task CreateUser(TestApplication app) { /* ... */ }\n}\n\npublic class ProductApiTests\n{\n    [Test]\n    [ClassDataSource<TestApplication>(Shared = SharedType.Keyed, Key = "integration-tests")]\n    public async Task CreateProduct(TestApplication app)\n    {\n        // Shares the same TestApplication instance with UserApiTests.CreateUser\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"combining-with-method-data-sources",children:"Combining with Method Data Sources"}),"\n",(0,t.jsx)(n.p,{children:"You can combine nested data sources with parameterized tests using method data sources:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'public class UserPermissionTests\n{\n    [Test]\n    [ClassDataSource<TestApplication>(Shared = SharedType.PerClass)]\n    [MethodDataSource(nameof(UserScenarios))]\n    public async Task User_Should_Have_Correct_Permissions(\n        TestApplication app,\n        string userEmail,\n        string role,\n        string[] expectedPermissions)\n    {\n        // Create user through API\n        var createResponse = await app.Client.PostAsJsonAsync("/api/users",\n            new { Email = userEmail, Role = role });\n        createResponse.EnsureSuccessStatusCode();\n\n        // Verify permissions\n        var permissionsResponse = await app.Client.GetAsync($"/api/users/{userEmail}/permissions");\n        var permissions = await permissionsResponse.Content.ReadFromJsonAsync<string[]>();\n\n        await Assert.That(permissions).IsEquivalentTo(expectedPermissions);\n    }\n\n    private static IEnumerable<(string Email, string Role, string[] Permissions)> UserScenarios()\n    {\n        yield return ("admin@test.com", "Admin", new[] { "read", "write", "delete" });\n        yield return ("user@test.com", "User", new[] { "read" });\n        yield return ("guest@test.com", "Guest", Array.Empty<string>());\n    }\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"For more complex scenarios where you need to query the initialized application during data generation, you can access it through the test context metadata."}),"\n",(0,t.jsx)(n.h2,{id:"how-it-works",children:"How It Works"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["TUnit detects properties marked with data source attributes (like ",(0,t.jsx)(n.code,{children:"[ClassDataSource<T>]"}),")"]}),"\n",(0,t.jsx)(n.li,{children:"It builds a dependency graph and initializes in the correct order"}),"\n",(0,t.jsxs)(n.li,{children:["Each object's ",(0,t.jsx)(n.code,{children:"InitializeAsync"})," is called after its dependencies are ready"]}),"\n",(0,t.jsx)(n.li,{children:"Disposal happens in reverse order automatically"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Implement IAsyncInitializer"}),": For any class that needs async initialization"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Use Data Source Attributes"}),": Use attributes like ",(0,t.jsx)(n.code,{children:"[ClassDataSource<T>]"})," to declare dependencies that must be initialized first"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Share Expensive Resources"}),": Use ",(0,t.jsx)(n.code,{children:"SharedType"})," attributes to avoid creating multiple containers"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Dispose Properly"}),": Implement ",(0,t.jsx)(n.code,{children:"IAsyncDisposable"})," for cleanup"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Keep Initialization Fast"}),": Do only essential setup in ",(0,t.jsx)(n.code,{children:"InitializeAsync"})]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"common-patterns",children:"Common Patterns"}),"\n",(0,t.jsx)(n.h3,{id:"database-migrations",children:"Database Migrations"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'public async Task InitializeAsync()\n{\n    await _container.StartAsync();\n    \n    // Run migrations after container starts\n    using var connection = new NpgsqlConnection(ConnectionString);\n    await connection.ExecuteAsync(@"\n        CREATE TABLE IF NOT EXISTS users (\n            id SERIAL PRIMARY KEY,\n            email VARCHAR(255) UNIQUE NOT NULL\n        )");\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"seeding-test-data",children:"Seeding Test Data"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"public async Task InitializeAsync()\n{\n    // ... create WebApplicationFactory\n    \n    // Seed data after app starts\n    using var scope = _factory.Services.CreateScope();\n    var seeder = scope.ServiceProvider.GetRequiredService<ITestDataSeeder>();\n    await seeder.SeedAsync();\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"health-checks",children:"Health Checks"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'public async Task InitializeAsync()\n{\n    // ... create client\n    \n    // Wait for app to be healthy\n    var healthCheck = await Client.GetAsync("/health");\n    healthCheck.EnsureSuccessStatusCode();\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,t.jsx)(n.p,{children:"Nested data source initialization in TUnit:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"\u2705 Eliminates manual initialization chains"}),"\n",(0,t.jsx)(n.li,{children:"\u2705 Ensures correct initialization order"}),"\n",(0,t.jsx)(n.li,{children:"\u2705 Supports complex dependency graphs"}),"\n",(0,t.jsx)(n.li,{children:"\u2705 Works seamlessly with async operations"}),"\n",(0,t.jsx)(n.li,{children:"\u2705 Provides automatic cleanup"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"This makes integration testing with complex dependencies simple and maintainable."})]})}function p(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>r,x:()=>c});var s=i(6540);const t={},a=s.createContext(t);function r(e){const n=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);