"use strict";(self.webpackChunktunit_docs_site=self.webpackChunktunit_docs_site||[]).push([[4508],{1618:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>c,default:()=>d,frontMatter:()=>s,metadata:()=>r,toc:()=>o});const r=JSON.parse('{"id":"test-authoring/generic-attributes","title":"Generic Attributes","description":"TUnit provides generic versions of several attributes that offer enhanced type safety and better IDE support. These attributes allow you to specify types at compile time, reducing errors and improving code maintainability.","source":"@site/docs/test-authoring/generic-attributes.md","sourceDirName":"test-authoring","slug":"/test-authoring/generic-attributes","permalink":"/docs/test-authoring/generic-attributes","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{}}');var a=t(4848),i=t(8453);const s={},c="Generic Attributes",l={},o=[{value:"Generic Test Attributes",id:"generic-test-attributes",level:2},{value:"MethodDataSourceAttribute&lt;T&gt;",id:"methoddatasourceattributet",level:3},{value:"ClassDataSourceAttribute&lt;T&gt;",id:"classdatasourceattributet",level:3},{value:"DependsOnAttribute&lt;T&gt;",id:"dependsonattributet",level:3},{value:"Generic Data Source Attributes",id:"generic-data-source-attributes",level:2},{value:"DataSourceGeneratorAttribute&lt;T&gt;",id:"datasourcegeneratorattributet",level:3},{value:"AsyncDataSourceGeneratorAttribute&lt;T&gt;",id:"asyncdatasourcegeneratorattributet",level:3},{value:"TypedDataSourceAttribute&lt;T&gt;",id:"typeddatasourceattributet",level:3},{value:"Complex Generic Scenarios",id:"complex-generic-scenarios",level:2},{value:"Combining Multiple Generic Attributes",id:"combining-multiple-generic-attributes",level:3},{value:"Generic Test Base Classes",id:"generic-test-base-classes",level:3},{value:"AOT Compatibility",id:"aot-compatibility",level:2},{value:"DynamicallyAccessedMembers",id:"dynamicallyaccessedmembers",level:3},{value:"Generic Constraints for AOT",id:"generic-constraints-for-aot",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"1. Use Generic Attributes for Type Safety",id:"1-use-generic-attributes-for-type-safety",level:3},{value:"2. Leverage Constraints",id:"2-leverage-constraints",level:3},{value:"3. Create Reusable Generic Base Attributes",id:"3-create-reusable-generic-base-attributes",level:3},{value:"4. Document Generic Type Parameters",id:"4-document-generic-type-parameters",level:3},{value:"Common Patterns",id:"common-patterns",level:2},{value:"Factory Pattern with Generics",id:"factory-pattern-with-generics",level:3},{value:"Builder Pattern with Generics",id:"builder-pattern-with-generics",level:3},{value:"Summary",id:"summary",level:2}];function u(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"generic-attributes",children:"Generic Attributes"})}),"\n",(0,a.jsx)(n.p,{children:"TUnit provides generic versions of several attributes that offer enhanced type safety and better IDE support. These attributes allow you to specify types at compile time, reducing errors and improving code maintainability."}),"\n",(0,a.jsx)(n.h2,{id:"generic-test-attributes",children:"Generic Test Attributes"}),"\n",(0,a.jsx)(n.h3,{id:"methoddatasourceattributet",children:"MethodDataSourceAttribute<T>"}),"\n",(0,a.jsxs)(n.p,{children:["The generic version of ",(0,a.jsx)(n.code,{children:"MethodDataSource"})," provides type safety for the class containing the data source method."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:"public class TestDataProviders\n{\n    public static IEnumerable<(int, int, int)> AdditionTestCases()\n    {\n        yield return (1, 2, 3);\n        yield return (5, 5, 10);\n        yield return (-1, 1, 0);\n    }\n}\n\npublic class CalculatorTests\n{\n    [Test]\n    [MethodDataSource<TestDataProviders>(nameof(TestDataProviders.AdditionTestCases))]\n    public void Add_ShouldReturnCorrectSum(int a, int b, int expected)\n    {\n        var result = Calculator.Add(a, b);\n        Assert.That(result).IsEqualTo(expected);\n    }\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"Benefits over non-generic version:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Compile-time type checking"}),"\n",(0,a.jsx)(n.li,{children:"IDE refactoring support"}),"\n",(0,a.jsx)(n.li,{children:"Prevents typos in class names"}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"classdatasourceattributet",children:"ClassDataSourceAttribute<T>"}),"\n",(0,a.jsx)(n.p,{children:"The generic version ensures type safety when referencing data source classes."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:'public class UserTestData : IEnumerable<User>\n{\n    public IEnumerator<User> GetEnumerator()\n    {\n        yield return new User { Id = 1, Name = "Alice" };\n        yield return new User { Id = 2, Name = "Bob" };\n    }\n    \n    IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();\n}\n\npublic class UserTests\n{\n    [Test]\n    [ClassDataSource<UserTestData>]\n    public async Task ValidateUser_ShouldPass(User user)\n    {\n        var isValid = await UserValidator.ValidateAsync(user);\n        await Assert.That(isValid).IsTrue();\n    }\n}\n'})}),"\n",(0,a.jsx)(n.h3,{id:"dependsonattributet",children:"DependsOnAttribute<T>"}),"\n",(0,a.jsxs)(n.p,{children:["The generic ",(0,a.jsx)(n.code,{children:"DependsOn"})," attribute provides type-safe test dependency declarations."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:"public class OrderProcessingTests\n{\n    [Test]\n    public async Task CreateOrder()\n    {\n        // Create order logic\n    }\n    \n    [Test]\n    [DependsOn<OrderProcessingTests>(nameof(CreateOrder))]\n    public async Task ProcessPayment()\n    {\n        // This test depends on CreateOrder from the same class\n    }\n}\n\npublic class ShippingTests\n{\n    [Test]\n    [DependsOn<OrderProcessingTests>(nameof(OrderProcessingTests.ProcessPayment))]\n    public async Task ShipOrder()\n    {\n        // This test depends on ProcessPayment from another class\n    }\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"generic-data-source-attributes",children:"Generic Data Source Attributes"}),"\n",(0,a.jsx)(n.h3,{id:"datasourcegeneratorattributet",children:"DataSourceGeneratorAttribute<T>"}),"\n",(0,a.jsx)(n.p,{children:"Create strongly-typed data source generators:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:"public abstract class DataSourceGeneratorAttribute<T> : Attribute\n{\n    public abstract IEnumerable<T> GenerateData();\n}\n\n// Custom implementation\npublic class RandomNumbersAttribute : DataSourceGeneratorAttribute<int>\n{\n    private readonly int _count;\n    private readonly int _min;\n    private readonly int _max;\n    \n    public RandomNumbersAttribute(int count, int min = 0, int max = 100)\n    {\n        _count = count;\n        _min = min;\n        _max = max;\n    }\n    \n    public override IEnumerable<int> GenerateData()\n    {\n        var random = new Random();\n        for (int i = 0; i < _count; i++)\n        {\n            yield return random.Next(_min, _max);\n        }\n    }\n}\n\n// Usage\n[Test]\n[RandomNumbers(5, min: 1, max: 10)]\npublic void TestWithRandomNumbers(int number)\n{\n    Assert.That(number).IsBetween(1, 10);\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"asyncdatasourcegeneratorattributet",children:"AsyncDataSourceGeneratorAttribute<T>"}),"\n",(0,a.jsx)(n.p,{children:"For asynchronous data generation:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:'public abstract class AsyncDataSourceGeneratorAttribute<T> : Attribute\n{\n    public abstract Task<IEnumerable<T>> GenerateDataAsync();\n}\n\n// Custom implementation\npublic class DatabaseUsersAttribute : AsyncDataSourceGeneratorAttribute<User>\n{\n    private readonly string _role;\n    \n    public DatabaseUsersAttribute(string role)\n    {\n        _role = role;\n    }\n    \n    public override async Task<IEnumerable<User>> GenerateDataAsync()\n    {\n        using var db = new DatabaseContext();\n        return await db.Users\n            .Where(u => u.Role == _role)\n            .ToListAsync();\n    }\n}\n\n// Usage\n[Test]\n[DatabaseUsers("Admin")]\npublic async Task AdminUser_ShouldHaveFullPermissions(User adminUser)\n{\n    var permissions = await GetUserPermissions(adminUser);\n    await Assert.That(permissions).Contains(Permission.FullAccess);\n}\n'})}),"\n",(0,a.jsx)(n.h3,{id:"typeddatasourceattributet",children:"TypedDataSourceAttribute<T>"}),"\n",(0,a.jsx)(n.p,{children:"Base class for creating custom typed data sources:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:"public abstract class TypedDataSourceAttribute<T> : DataSourceAttribute\n{\n    public abstract IEnumerable<T> GetData();\n}\n\n// Implementation example\npublic class FibonacciDataAttribute : TypedDataSourceAttribute<int>\n{\n    private readonly int _count;\n    \n    public FibonacciDataAttribute(int count)\n    {\n        _count = count;\n    }\n    \n    public override IEnumerable<int> GetData()\n    {\n        int a = 0, b = 1;\n        yield return a;\n        \n        if (_count > 1) yield return b;\n        \n        for (int i = 2; i < _count; i++)\n        {\n            int temp = a + b;\n            yield return temp;\n            a = b;\n            b = temp;\n        }\n    }\n}\n\n// Usage\n[Test]\n[FibonacciData(7)]\npublic void TestFibonacciNumber(int fibNumber)\n{\n    // Test with Fibonacci sequence: 0, 1, 1, 2, 3, 5, 8\n    Assert.That(fibNumber).IsGreaterThanOrEqualTo(0);\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"complex-generic-scenarios",children:"Complex Generic Scenarios"}),"\n",(0,a.jsx)(n.h3,{id:"combining-multiple-generic-attributes",children:"Combining Multiple Generic Attributes"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:"public interface ITestScenario<TInput, TExpected>\n{\n    TInput Input { get; }\n    TExpected Expected { get; }\n}\n\npublic class CalculationScenario : ITestScenario<(int, int), int>\n{\n    public (int, int) Input { get; set; }\n    public int Expected { get; set; }\n}\n\npublic class ScenarioDataSource<TScenario> : TypedDataSourceAttribute<TScenario>\n    where TScenario : ITestScenario<(int, int), int>, new()\n{\n    public override IEnumerable<TScenario> GetData()\n    {\n        yield return new TScenario { Input = (1, 2), Expected = 3 };\n        yield return new TScenario { Input = (5, 5), Expected = 10 };\n    }\n}\n\n[Test]\n[ScenarioDataSource<CalculationScenario>]\npublic void TestCalculation(CalculationScenario scenario)\n{\n    var (a, b) = scenario.Input;\n    var result = Calculator.Add(a, b);\n    Assert.That(result).IsEqualTo(scenario.Expected);\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"generic-test-base-classes",children:"Generic Test Base Classes"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:'public abstract class EntityTestBase<TEntity, TId> \n    where TEntity : IEntity<TId>\n    where TId : IEquatable<TId>\n{\n    protected abstract TEntity CreateEntity(TId id);\n    protected abstract Task<TEntity> GetEntityAsync(TId id);\n    \n    [Test]\n    [MethodDataSource<EntityTestBase<TEntity, TId>>(nameof(GetTestIds))]\n    public async Task Entity_ShouldBeRetrievable(TId id)\n    {\n        var entity = CreateEntity(id);\n        await SaveEntityAsync(entity);\n        \n        var retrieved = await GetEntityAsync(id);\n        await Assert.That(retrieved.Id).IsEqualTo(id);\n    }\n    \n    public static IEnumerable<TId> GetTestIds()\n    {\n        // Override in derived classes\n        yield break;\n    }\n}\n\npublic class UserEntityTests : EntityTestBase<User, Guid>\n{\n    protected override User CreateEntity(Guid id) => \n        new User { Id = id, Name = "Test User" };\n        \n    protected override Task<User> GetEntityAsync(Guid id) =>\n        UserRepository.GetByIdAsync(id);\n        \n    public new static IEnumerable<Guid> GetTestIds()\n    {\n        yield return Guid.NewGuid();\n        yield return Guid.NewGuid();\n    }\n}\n'})}),"\n",(0,a.jsx)(n.h2,{id:"aot-compatibility",children:"AOT Compatibility"}),"\n",(0,a.jsx)(n.p,{children:"Generic attributes work well with AOT compilation, but there are some considerations:"}),"\n",(0,a.jsx)(n.h3,{id:"dynamicallyaccessedmembers",children:"DynamicallyAccessedMembers"}),"\n",(0,a.jsx)(n.p,{children:"When creating generic attributes that use reflection, add appropriate attributes:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:"public class ReflectiveDataSource<[DynamicallyAccessedMembers(\n    DynamicallyAccessedMemberTypes.PublicConstructors | \n    DynamicallyAccessedMemberTypes.PublicProperties)] T> \n    : TypedDataSourceAttribute<T> where T : new()\n{\n    public override IEnumerable<T> GetData()\n    {\n        var type = typeof(T);\n        var properties = type.GetProperties();\n        \n        // Create instances with different property values\n        foreach (var prop in properties)\n        {\n            var instance = new T();\n            // Set property values...\n            yield return instance;\n        }\n    }\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"generic-constraints-for-aot",children:"Generic Constraints for AOT"}),"\n",(0,a.jsx)(n.p,{children:"Use constraints to ensure AOT compatibility:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:"public class SerializableDataSource<T> : TypedDataSourceAttribute<T>\n    where T : IJsonSerializable<T> // Ensures T can be serialized\n{\n    private readonly string _jsonFile;\n    \n    public SerializableDataSource(string jsonFile)\n    {\n        _jsonFile = jsonFile;\n    }\n    \n    public override IEnumerable<T> GetData()\n    {\n        var json = File.ReadAllText(_jsonFile);\n        var items = JsonSerializer.Deserialize<List<T>>(json);\n        return items ?? Enumerable.Empty<T>();\n    }\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,a.jsx)(n.h3,{id:"1-use-generic-attributes-for-type-safety",children:"1. Use Generic Attributes for Type Safety"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:'// \u274c Non-generic - prone to errors\n[MethodDataSource(typeof(DataProvider), "GetData")]\n\n// \u2705 Generic - compile-time safety\n[MethodDataSource<DataProvider>(nameof(DataProvider.GetData))]\n'})}),"\n",(0,a.jsx)(n.h3,{id:"2-leverage-constraints",children:"2. Leverage Constraints"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:"public class ValidatableDataSource<T> : TypedDataSourceAttribute<T>\n    where T : IValidatable\n{\n    public override IEnumerable<T> GetData()\n    {\n        // Only return valid instances\n        return GenerateInstances().Where(x => x.IsValid());\n    }\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"3-create-reusable-generic-base-attributes",children:"3. Create Reusable Generic Base Attributes"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:'public abstract class JsonFileDataSource<T> : TypedDataSourceAttribute<T>\n{\n    protected abstract string FilePath { get; }\n    \n    public override IEnumerable<T> GetData()\n    {\n        var json = File.ReadAllText(FilePath);\n        return JsonSerializer.Deserialize<List<T>>(json) \n            ?? Enumerable.Empty<T>();\n    }\n}\n\npublic class UserJsonDataSource : JsonFileDataSource<User>\n{\n    protected override string FilePath => "TestData/users.json";\n}\n'})}),"\n",(0,a.jsx)(n.h3,{id:"4-document-generic-type-parameters",children:"4. Document Generic Type Parameters"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:'/// <summary>\n/// Provides test data from a CSV file\n/// </summary>\n/// <typeparam name="T">The type to deserialize CSV rows into. \n/// Must have a parameterless constructor.</typeparam>\npublic class CsvDataSource<T> : TypedDataSourceAttribute<T> \n    where T : new()\n{\n    // Implementation\n}\n'})}),"\n",(0,a.jsx)(n.h2,{id:"common-patterns",children:"Common Patterns"}),"\n",(0,a.jsx)(n.h3,{id:"factory-pattern-with-generics",children:"Factory Pattern with Generics"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:"public class EntityFactory<T> where T : IEntity, new()\n{\n    public static IEnumerable<T> CreateTestEntities(int count)\n    {\n        for (int i = 0; i < count; i++)\n        {\n            yield return new T \n            { \n                Id = i,\n                CreatedAt = DateTime.UtcNow\n            };\n        }\n    }\n}\n\npublic class FactoryDataSource<T> : TypedDataSourceAttribute<T>\n    where T : IEntity, new()\n{\n    private readonly int _count;\n    \n    public FactoryDataSource(int count = 3)\n    {\n        _count = count;\n    }\n    \n    public override IEnumerable<T> GetData()\n    {\n        return EntityFactory<T>.CreateTestEntities(_count);\n    }\n}\n\n// Usage\n[Test]\n[FactoryDataSource<Product>(5)]\npublic async Task TestProductEntity(Product product)\n{\n    await Assert.That(product.Id).IsGreaterThanOrEqualTo(0);\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"builder-pattern-with-generics",children:"Builder Pattern with Generics"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:'public abstract class TestDataBuilder<T> : TypedDataSourceAttribute<T>\n{\n    protected abstract T BuildDefault();\n    protected abstract T BuildInvalid();\n    protected abstract T BuildEdgeCase();\n    \n    public override IEnumerable<T> GetData()\n    {\n        yield return BuildDefault();\n        yield return BuildInvalid();\n        yield return BuildEdgeCase();\n    }\n}\n\npublic class UserDataBuilder : TestDataBuilder<User>\n{\n    protected override User BuildDefault() => \n        new User { Id = 1, Name = "John", Age = 30 };\n        \n    protected override User BuildInvalid() => \n        new User { Id = -1, Name = "", Age = -5 };\n        \n    protected override User BuildEdgeCase() => \n        new User { Id = int.MaxValue, Name = new string(\'a\', 1000), Age = 150 };\n}\n'})}),"\n",(0,a.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,a.jsx)(n.p,{children:"Generic attributes in TUnit provide:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Type Safety"}),": Compile-time checking prevents runtime errors"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Better IDE Support"}),": Refactoring and navigation work correctly"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Cleaner Code"}),": No magic strings or typeof expressions"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"AOT Compatibility"}),": Work well with ahead-of-time compilation"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Reusability"}),": Easy to create generic base attributes for common patterns"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Use generic attributes whenever possible to improve code quality and maintainability in your test suites."})]})}function d(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(u,{...e})}):u(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>c});var r=t(6540);const a={},i=r.createContext(a);function s(e){const n=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);