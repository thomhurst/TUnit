"use strict";(self.webpackChunktunit_docs_site=self.webpackChunktunit_docs_site||[]).push([[7424],{6692:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>r,contentTitle:()=>c,default:()=>u,frontMatter:()=>a,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"execution/timeouts","title":"Timeouts","description":"If you want to stop a test after a specified amount of time, add a [Timeout] attribute onto your test method or class. This takes an int of how many milliseconds a test can execute for.","source":"@site/docs/execution/timeouts.md","sourceDirName":"execution","slug":"/execution/timeouts","permalink":"/docs/execution/timeouts","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"sidebar_position":5},"sidebar":"docs","previous":{"title":"Test Filters","permalink":"/docs/execution/test-filters"},"next":{"title":"Retrying","permalink":"/docs/execution/retrying"}}');var o=n(4848),i=n(8453);const a={sidebar_position:5},c="Timeouts",r={},l=[{value:"Global Timeout",id:"global-timeout",level:2}];function d(e){const t={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.header,{children:(0,o.jsx)(t.h1,{id:"timeouts",children:"Timeouts"})}),"\n",(0,o.jsxs)(t.p,{children:["If you want to stop a test after a specified amount of time, add a ",(0,o.jsx)(t.code,{children:"[Timeout]"})," attribute onto your test method or class. This takes an ",(0,o.jsx)(t.code,{children:"int"})," of how many milliseconds a test can execute for."]}),"\n",(0,o.jsx)(t.p,{children:"A cancellation token will be passed to tests too, which should be used where appropriate. This ensures that after the timeout is reached, operations are cancelled properly, and not wasting system resources."}),"\n",(0,o.jsx)(t.p,{children:"This can be used on base classes and inherited to affect all tests in sub-classes."}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-csharp",children:"using TUnit.Core;\n\nnamespace MyTestProject;\n\npublic class MyTestClass\n{\n    [Test]\n    [Timeout(30_000)]\n    public async Task MyTest(CancellationToken cancellationToken)\n    {\n        \n    }\n}\n"})}),"\n",(0,o.jsx)(t.h2,{id:"global-timeout",children:"Global Timeout"}),"\n",(0,o.jsx)(t.p,{children:"In case you want to apply the timeout to all tests in a project, you can add the attribute on the assembly level."}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-csharp",children:"[assembly: Timeout(3000)]\n"})}),"\n",(0,o.jsx)(t.p,{children:"Or you can apply the Timeout on all the tests in a class like this:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-csharp",children:"[Timeout(3000)]\npublic class MyTestClass\n{\n}\n"})}),"\n",(0,o.jsxs)(t.p,{children:["The more specific attribute will always override the more general one.\nFor example, the ",(0,o.jsx)(t.code,{children:"[Timeout(3000)]"})," on a method will override the ",(0,o.jsx)(t.code,{children:"[Timeout(5000)]"})," on the class,\nwhich in turn will override the ",(0,o.jsx)(t.code,{children:"[Timeout(7000)]"})," on the assembly."]}),"\n",(0,o.jsx)(t.p,{children:"So the order of precedence is:"}),"\n",(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsx)(t.li,{children:"Method"}),"\n",(0,o.jsx)(t.li,{children:"Class"}),"\n",(0,o.jsx)(t.li,{children:"Assembly"}),"\n"]})]})}function u(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>c});var s=n(6540);const o={},i=s.createContext(o);function a(e){const t=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),s.createElement(i.Provider,{value:t},e.children)}}}]);