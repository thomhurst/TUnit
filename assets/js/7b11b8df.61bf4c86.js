"use strict";(self.webpackChunktunit_docs_site=self.webpackChunktunit_docs_site||[]).push([[6690],{6711:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>o,contentTitle:()=>l,default:()=>d,frontMatter:()=>a,metadata:()=>n,toc:()=>c});const n=JSON.parse('{"id":"getting-started/writing-your-first-test","title":"Writing your first test","description":"Quick Start: Complete Example","source":"@site/docs/getting-started/writing-your-first-test.md","sourceDirName":"getting-started","slug":"/getting-started/writing-your-first-test","permalink":"/docs/getting-started/writing-your-first-test","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"docs","previous":{"title":"Installing TUnit","permalink":"/docs/getting-started/installation"},"next":{"title":"Running your tests","permalink":"/docs/getting-started/running-your-tests"}}');var i=s(4848),r=s(8453);const a={},l="Writing your first test",o={},c=[{value:"Quick Start: Complete Example",id:"quick-start-complete-example",level:2},{value:"Step-by-Step Guide",id:"step-by-step-guide",level:2},{value:"Common Test Patterns",id:"common-test-patterns",level:2},{value:"Testing Boolean Returns",id:"testing-boolean-returns",level:3},{value:"Testing with Multiple Assertions",id:"testing-with-multiple-assertions",level:3},{value:"Using Statements",id:"using-statements",level:3}];function u(e){const t={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",strong:"strong",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"writing-your-first-test",children:"Writing your first test"})}),"\n",(0,i.jsx)(t.h2,{id:"quick-start-complete-example",children:"Quick Start: Complete Example"}),"\n",(0,i.jsx)(t.p,{children:"Here's a complete TUnit test class with all necessary using statements:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-csharp",children:"using TUnit.Assertions;\nusing TUnit.Assertions.Extensions;\nusing TUnit.Core;\n\nnamespace MyTestProject;\n\npublic class CalculatorTests\n{\n    [Test]\n    public async Task Add_WithTwoNumbers_ReturnsSum()\n    {\n        // Arrange\n        var calculator = new Calculator();\n\n        // Act\n        var result = calculator.Add(2, 3);\n\n        // Assert\n        await Assert.That(result).IsEqualTo(5);\n    }\n}\n"})}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Important"}),": TUnit does ",(0,i.jsx)(t.strong,{children:"not"})," require a ",(0,i.jsx)(t.code,{children:"[TestClass]"})," attribute. Unlike MSTest or NUnit, you only need the ",(0,i.jsx)(t.code,{children:"[Test]"})," attribute on your test methods."]}),"\n",(0,i.jsx)(t.h2,{id:"step-by-step-guide",children:"Step-by-Step Guide"}),"\n",(0,i.jsx)(t.p,{children:"Start by creating a new class:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-csharp",children:"namespace MyTestProject;\n\npublic class MyTestClass\n{\n\n}\n"})}),"\n",(0,i.jsxs)(t.p,{children:["Now add a method with a ",(0,i.jsx)(t.code,{children:"[Test]"})," attribute on it:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-csharp",children:"using TUnit.Core;\n\nnamespace MyTestProject;\n\npublic class MyTestClass\n{\n    [Test]\n    public async Task MyTest()\n    {\n\n    }\n}\n"})}),"\n",(0,i.jsx)(t.p,{children:"That's it. That is your runnable test."}),"\n",(0,i.jsx)(t.p,{children:"We haven't actually made it do anything yet, but we should be able to build our project and run that test."}),"\n",(0,i.jsx)(t.p,{children:"Tests will pass if they execute successfully without any exceptions."}),"\n",(0,i.jsx)(t.p,{children:"Let's add some code to show you how a test might look once finished:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-csharp",children:"using TUnit.Assertions;\nusing TUnit.Assertions.Extensions;\nusing TUnit.Core;\n\nnamespace MyTestProject;\n\npublic class MyTestClass\n{\n    [Test]\n    public async Task MyTest()\n    {\n        var result = Add(1, 2);\n\n        await Assert.That(result).IsEqualTo(3);\n    }\n\n    private int Add(int x, int y)\n    {\n        return x + y;\n    }\n}\n"})}),"\n",(0,i.jsx)(t.p,{children:"Here you can see we've executed some code and added an assertion. We'll go more into that later."}),"\n",(0,i.jsx)(t.h2,{id:"common-test-patterns",children:"Common Test Patterns"}),"\n",(0,i.jsx)(t.h3,{id:"testing-boolean-returns",children:"Testing Boolean Returns"}),"\n",(0,i.jsxs)(t.p,{children:["When testing methods that return boolean values, use ",(0,i.jsx)(t.code,{children:"IsTrue()"})," or ",(0,i.jsx)(t.code,{children:"IsFalse()"}),":"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-csharp",children:"using TUnit.Assertions;\nusing TUnit.Assertions.Extensions;\nusing TUnit.Core;\n\nnamespace MyTestProject;\n\npublic class ValidatorTests\n{\n    [Test]\n    public async Task IsPositive_WithNegativeNumber_ReturnsFalse()\n    {\n        // Arrange & Act\n        var result = Validator.IsPositive(-1);\n\n        // Assert\n        await Assert.That(result).IsFalse();\n    }\n\n    [Test]\n    public async Task IsPositive_WithPositiveNumber_ReturnsTrue()\n    {\n        // Arrange & Act\n        var result = Validator.IsPositive(5);\n\n        // Assert\n        await Assert.That(result).IsTrue();\n    }\n}\n\npublic static class Validator\n{\n    public static bool IsPositive(int number)\n    {\n        return number > 0;\n    }\n}\n"})}),"\n",(0,i.jsx)(t.h3,{id:"testing-with-multiple-assertions",children:"Testing with Multiple Assertions"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-csharp",children:'using TUnit.Assertions;\nusing TUnit.Assertions.Extensions;\nusing TUnit.Core;\n\nnamespace MyTestProject;\n\npublic class StringTests\n{\n    [Test]\n    public async Task ProcessString_WithValidInput_ReturnsExpectedResult()\n    {\n        // Arrange\n        var input = "hello";\n\n        // Act\n        var result = input.ToUpper();\n\n        // Assert\n        await Assert.That(result).IsEqualTo("HELLO");\n        await Assert.That(result).HasLength(5);\n        await Assert.That(result.StartsWith("HE")).IsTrue();\n    }\n}\n'})}),"\n",(0,i.jsx)(t.h3,{id:"using-statements",children:"Using Statements"}),"\n",(0,i.jsx)(t.p,{children:"The examples above show explicit using statements for clarity:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-csharp",children:"using TUnit.Core;                    // For [Test] attribute\nusing TUnit.Assertions;              // For Assert.That()\nusing TUnit.Assertions.Extensions;   // For assertion methods like IsEqualTo(), IsTrue(), etc.\n"})}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"However"}),", the TUnit package automatically configures these namespaces as global usings, so in practice you don't need to include them in each test file. Your test classes can be as simple as:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-csharp",children:"namespace MyTestProject;\n\npublic class ValidatorTests\n{\n    [Test]\n    public async Task IsPositive_WithNegativeNumber_ReturnsFalse()\n    {\n        var result = Validator.IsPositive(-1);\n        await Assert.That(result).IsFalse();\n    }\n}\n"})})]})}function d(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(u,{...e})}):u(e)}},8453:(e,t,s)=>{s.d(t,{R:()=>a,x:()=>l});var n=s(6540);const i={},r=n.createContext(i);function a(e){const t=n.useContext(r);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),n.createElement(r.Provider,{value:t},e.children)}}}]);