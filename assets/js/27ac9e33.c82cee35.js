"use strict";(self.webpackChunktunit_docs_site=self.webpackChunktunit_docs_site||[]).push([[1278],{8619:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>c,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"migration/testcontext-interface-organization","title":"TestContext Interface Organization Migration Guide","description":"Overview","source":"@site/docs/migration/testcontext-interface-organization.md","sourceDirName":"migration","slug":"/migration/testcontext-interface-organization","permalink":"/docs/migration/testcontext-interface-organization","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"docs","previous":{"title":"Performance Best Practices","permalink":"/docs/advanced/performance-best-practices"},"next":{"title":"Migrating from xUnit.net","permalink":"/docs/migration/xunit"}}');var i=n(4848),r=n(8453);const a={},c="TestContext Interface Organization Migration Guide",o={},l=[{value:"Overview",id:"overview",level:2},{value:"What Changed",id:"what-changed",level:2},{value:"New Interface Organization",id:"new-interface-organization",level:3},{value:"Property Reorganization",id:"property-reorganization",level:3},{value:"<code>ITestExecution</code> - Execution State and Lifecycle",id:"itestexecution---execution-state-and-lifecycle",level:4},{value:"<code>ITestMetadata</code> - Test Identity and Metadata",id:"itestmetadata---test-identity-and-metadata",level:4},{value:"<code>ITestEvents</code> - Test Event Integration",id:"itestevents---test-event-integration",level:4},{value:"Migration Steps",id:"migration-steps",level:2},{value:"Direct Property Access",id:"direct-property-access",level:3},{value:"Execution-Related Properties",id:"execution-related-properties",level:4},{value:"Metadata-Related Properties",id:"metadata-related-properties",level:4},{value:"Event Access",id:"event-access",level:4},{value:"Custom Hook Executors",id:"custom-hook-executors",level:3},{value:"Test Registration/Building",id:"test-registrationbuilding",level:3},{value:"Cancellation Token Linking",id:"cancellation-token-linking",level:3},{value:"Benefits of the New Organization",id:"benefits-of-the-new-organization",level:2},{value:"1. Better Discoverability",id:"1-better-discoverability",level:3},{value:"2. Clearer Intent",id:"2-clearer-intent",level:3},{value:"3. Interface Segregation Principle",id:"3-interface-segregation-principle",level:3},{value:"4. Zero-Allocation Design",id:"4-zero-allocation-design",level:3},{value:"Complete Interface Reference",id:"complete-interface-reference",level:2},{value:"ITestExecution",id:"itestexecution",level:3},{value:"ITestMetadata",id:"itestmetadata",level:3},{value:"ITestEvents",id:"itestevents",level:3},{value:"Other Interfaces",id:"other-interfaces",level:3},{value:"ITestOutput",id:"itestoutput",level:4},{value:"ITestParallelization",id:"itestparallelization",level:4},{value:"ITestDependencies",id:"itestdependencies",level:4},{value:"ITestStateBag",id:"iteststatebag",level:4},{value:"Summary",id:"summary",level:2}];function d(e){const t={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"testcontext-interface-organization-migration-guide",children:"TestContext Interface Organization Migration Guide"})}),"\n",(0,i.jsx)(t.h2,{id:"overview",children:"Overview"}),"\n",(0,i.jsxs)(t.p,{children:["TUnit has reorganized the ",(0,i.jsx)(t.code,{children:"TestContext"})," API to provide a cleaner, more discoverable interface structure. Properties and methods are now organized into logical, focused interfaces that group related functionality together."]}),"\n",(0,i.jsxs)(t.p,{children:["This migration guide helps you update code that directly accesses ",(0,i.jsx)(t.code,{children:"TestContext"})," properties to use the new interface-based API."]}),"\n",(0,i.jsx)(t.h2,{id:"what-changed",children:"What Changed"}),"\n",(0,i.jsx)(t.h3,{id:"new-interface-organization",children:"New Interface Organization"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.code,{children:"TestContext"})," now exposes its API through focused interface properties:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-csharp",children:"public partial class TestContext :\n    ITestExecution,\n    ITestParallelization,\n    ITestOutput,\n    ITestMetadata,\n    ITestDependencies,\n    ITestStateBag,\n    ITestEvents\n{\n    // Organized API access through interface properties\n    public ITestExecution Execution => this;\n    public ITestParallelization Parallelism => this;\n    public ITestOutput Output => this;\n    public ITestMetadata Metadata => this;\n    public ITestDependencies Dependencies => this;\n    public ITestStateBag StateBag => this;\n    public ITestEvents Events => this;\n    public IServiceProvider Services => ServiceProvider;\n}\n"})}),"\n",(0,i.jsx)(t.h3,{id:"property-reorganization",children:"Property Reorganization"}),"\n",(0,i.jsxs)(t.p,{children:["Several properties have been moved from the main ",(0,i.jsx)(t.code,{children:"TestContext"})," class into their appropriate interfaces:"]}),"\n",(0,i.jsxs)(t.h4,{id:"itestexecution---execution-state-and-lifecycle",children:[(0,i.jsx)(t.code,{children:"ITestExecution"})," - Execution State and Lifecycle"]}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"New members:"})}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"CustomHookExecutor"})," - Custom hook executor for test-level hooks"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"ReportResult"})," - Whether test results should be reported"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"AddLinkedCancellationToken()"})," - Link external cancellation tokens"]}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"Existing members:"})}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"Phase"})," - Current test phase (Discovery, Execution, Cleanup, etc.)"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"Result"})," - Test result after execution completes"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"CancellationToken"})," - Cancellation token for this test"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"TestStart"})," - Test execution start timestamp"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"TestEnd"})," - Test execution end timestamp"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"CurrentRetryAttempt"})," - Current retry attempt number"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"SkipReason"})," - Reason why test was skipped"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"RetryFunc"})," - Retry function for failed tests"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"OverrideResult()"})," - Override test result methods"]}),"\n"]}),"\n",(0,i.jsxs)(t.h4,{id:"itestmetadata---test-identity-and-metadata",children:[(0,i.jsx)(t.code,{children:"ITestMetadata"})," - Test Identity and Metadata"]}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"New member:"})}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"DisplayNameFormatter"})," - Custom display name formatter type"]}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"Existing members:"})}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"Id"})," - Unique identifier for this test instance"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"TestDetails"})," - Detailed metadata about the test"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"TestName"})," - Base name of the test method"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"DisplayName"})," - Display name for the test (get/set)"]}),"\n"]}),"\n",(0,i.jsxs)(t.h4,{id:"itestevents---test-event-integration",children:[(0,i.jsx)(t.code,{children:"ITestEvents"})," - Test Event Integration"]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"New interface"})," exposing:"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"Events"})," - Event manager for test lifecycle integration"]}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"migration-steps",children:"Migration Steps"}),"\n",(0,i.jsx)(t.h3,{id:"direct-property-access",children:"Direct Property Access"}),"\n",(0,i.jsxs)(t.p,{children:["If you were directly accessing properties on ",(0,i.jsx)(t.code,{children:"TestContext"}),", they now need to be accessed through the appropriate interface property."]}),"\n",(0,i.jsx)(t.h4,{id:"execution-related-properties",children:"Execution-Related Properties"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"Before:"})}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-csharp",children:"// \u274c Old - Direct access\nvar customExecutor = TestContext.Current.CustomHookExecutor;\nTestContext.Current.ReportResult = false;\nTestContext.Current.AddLinkedCancellationToken(externalToken);\n"})}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"After:"})}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-csharp",children:"// \u2705 New - Through Execution interface\nvar customExecutor = TestContext.Current.Execution.CustomHookExecutor;\nTestContext.Current.Execution.ReportResult = false;\nTestContext.Current.Execution.AddLinkedCancellationToken(externalToken);\n"})}),"\n",(0,i.jsx)(t.h4,{id:"metadata-related-properties",children:"Metadata-Related Properties"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"Before:"})}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-csharp",children:"// \u274c Old - Direct access\nvar formatter = TestContext.Current.DisplayNameFormatter;\nTestContext.Current.DisplayNameFormatter = typeof(MyFormatter);\n"})}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"After:"})}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-csharp",children:"// \u2705 New - Through Metadata interface\nvar formatter = TestContext.Current.Metadata.DisplayNameFormatter;\nTestContext.Current.Metadata.DisplayNameFormatter = typeof(MyFormatter);\n"})}),"\n",(0,i.jsx)(t.h4,{id:"event-access",children:"Event Access"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"Before:"})}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-csharp",children:"// \u274c Old - Direct access\nTestContext.Current.Events.OnTestStart += handler;\n"})}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"After:"})}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-csharp",children:"// \u2705 New - Through Events interface (note: access is still the same, but now properly exposed through interface)\nTestContext.Current.Events.OnTestStart += handler;\n"})}),"\n",(0,i.jsx)(t.h3,{id:"custom-hook-executors",children:"Custom Hook Executors"}),"\n",(0,i.jsx)(t.p,{children:"If you're implementing custom hook executors that access these properties:"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"Before:"})}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-csharp",children:"public class MyHookExecutor : IHookExecutor\n{\n    public async Task ExecuteAsync(TestContext context, Func<Task> hookBody)\n    {\n        // \u274c Old - Direct property access\n        if (context.ReportResult)\n        {\n            await hookBody();\n        }\n    }\n}\n"})}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"After:"})}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-csharp",children:"public class MyHookExecutor : IHookExecutor\n{\n    public async Task ExecuteAsync(TestContext context, Func<Task> hookBody)\n    {\n        // \u2705 New - Through Execution interface\n        if (context.Execution.ReportResult)\n        {\n            await hookBody();\n        }\n    }\n}\n"})}),"\n",(0,i.jsx)(t.h3,{id:"test-registrationbuilding",children:"Test Registration/Building"}),"\n",(0,i.jsx)(t.p,{children:"If you're setting custom hook executors during test registration:"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"Before:"})}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-csharp",children:"public class CustomTestBuilder\n{\n    public void ConfigureTest(TestContext context)\n    {\n        // \u274c Old - Direct property access\n        context.CustomHookExecutor = new MyCustomExecutor();\n        context.DisplayNameFormatter = typeof(MyFormatter);\n    }\n}\n"})}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"After:"})}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-csharp",children:"public class CustomTestBuilder\n{\n    public void ConfigureTest(TestContext context)\n    {\n        // \u2705 New - Through appropriate interfaces\n        context.Execution.CustomHookExecutor = new MyCustomExecutor();\n        context.Metadata.DisplayNameFormatter = typeof(MyFormatter);\n    }\n}\n"})}),"\n",(0,i.jsx)(t.h3,{id:"cancellation-token-linking",children:"Cancellation Token Linking"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"Before:"})}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-csharp",children:"[Before(HookType.Test)]\npublic void Setup()\n{\n    var externalCts = new CancellationTokenSource();\n\n    // \u274c Old - Direct method call\n    TestContext.Current.AddLinkedCancellationToken(externalCts.Token);\n}\n"})}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"After:"})}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-csharp",children:"[Before(HookType.Test)]\npublic void Setup()\n{\n    var externalCts = new CancellationTokenSource();\n\n    // \u2705 New - Through Execution interface\n    TestContext.Current.Execution.AddLinkedCancellationToken(externalCts.Token);\n}\n"})}),"\n",(0,i.jsx)(t.h2,{id:"benefits-of-the-new-organization",children:"Benefits of the New Organization"}),"\n",(0,i.jsx)(t.h3,{id:"1-better-discoverability",children:"1. Better Discoverability"}),"\n",(0,i.jsx)(t.p,{children:"IntelliSense now groups related functionality together, making it easier to find what you need:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-csharp",children:"TestContext.Current.Execution.  // Shows only execution-related members\nTestContext.Current.Metadata.   // Shows only metadata-related members\nTestContext.Current.Output.     // Shows only output-related members\n"})}),"\n",(0,i.jsx)(t.h3,{id:"2-clearer-intent",children:"2. Clearer Intent"}),"\n",(0,i.jsx)(t.p,{children:"Code that accesses interface-specific properties communicates its intent more clearly:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-csharp",children:'// Clear that we\'re dealing with execution lifecycle\ncontext.Execution.OverrideResult(TestState.Passed, "Mocked result");\n\n// Clear that we\'re configuring metadata\ncontext.Metadata.DisplayName = "Custom Test Name";\n\n// Clear that we\'re working with test output\ncontext.Output.WriteLine("Debug information");\n'})}),"\n",(0,i.jsx)(t.h3,{id:"3-interface-segregation-principle",children:"3. Interface Segregation Principle"}),"\n",(0,i.jsxs)(t.p,{children:["Consumers can depend on specific interfaces instead of the full ",(0,i.jsx)(t.code,{children:"TestContext"}),":"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-csharp",children:"// Before: Depends on entire TestContext\npublic class MyService\n{\n    public void ProcessTest(TestContext context) { }\n}\n\n// After: Depends only on what's needed\npublic class MyService\n{\n    public void ProcessTest(ITestMetadata metadata) { }\n    public void HandleExecution(ITestExecution execution) { }\n}\n"})}),"\n",(0,i.jsx)(t.h3,{id:"4-zero-allocation-design",children:"4. Zero-Allocation Design"}),"\n",(0,i.jsxs)(t.p,{children:["The interface properties return ",(0,i.jsx)(t.code,{children:"this"})," cast to the appropriate interface type, ensuring zero allocation overhead:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-csharp",children:"// No new objects created - just interface casting\nITestExecution execution = testContext.Execution;  // Zero allocations\n"})}),"\n",(0,i.jsx)(t.h2,{id:"complete-interface-reference",children:"Complete Interface Reference"}),"\n",(0,i.jsx)(t.h3,{id:"itestexecution",children:"ITestExecution"}),"\n",(0,i.jsx)(t.p,{children:"Test execution state and lifecycle management:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-csharp",children:"public interface ITestExecution\n{\n    TestPhase Phase { get; }\n    TestResult? Result { get; }\n    CancellationToken CancellationToken { get; }\n    DateTimeOffset? TestStart { get; }\n    DateTimeOffset? TestEnd { get; }\n    int CurrentRetryAttempt { get; }\n    string? SkipReason { get; }\n    Func<TestContext, Exception, int, Task<bool>>? RetryFunc { get; }\n    IHookExecutor? CustomHookExecutor { get; set; }\n    bool ReportResult { get; set; }\n\n    void OverrideResult(string reason);\n    void OverrideResult(TestState state, string reason);\n    void AddLinkedCancellationToken(CancellationToken cancellationToken);\n}\n"})}),"\n",(0,i.jsx)(t.h3,{id:"itestmetadata",children:"ITestMetadata"}),"\n",(0,i.jsx)(t.p,{children:"Test metadata and identity:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-csharp",children:"public interface ITestMetadata\n{\n    Guid Id { get; }\n    TestDetails TestDetails { get; }\n    string TestName { get; }\n    string DisplayName { get; set; }\n    Type? DisplayNameFormatter { get; set; }\n}\n"})}),"\n",(0,i.jsx)(t.h3,{id:"itestevents",children:"ITestEvents"}),"\n",(0,i.jsx)(t.p,{children:"Test event integration:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-csharp",children:"public interface ITestEvents\n{\n    TestContextEvents Events { get; }\n}\n"})}),"\n",(0,i.jsx)(t.h3,{id:"other-interfaces",children:"Other Interfaces"}),"\n",(0,i.jsx)(t.p,{children:"For completeness, here are the other interface properties available:"}),"\n",(0,i.jsx)(t.h4,{id:"itestoutput",children:"ITestOutput"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-csharp",children:"public interface ITestOutput\n{\n    void WriteLine(string message);\n    void WriteError(string message);\n    string GetOutput();\n    string GetErrorOutput();\n}\n"})}),"\n",(0,i.jsx)(t.h4,{id:"itestparallelization",children:"ITestParallelization"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-csharp",children:"public interface ITestParallelization\n{\n    // Parallelization configuration\n}\n"})}),"\n",(0,i.jsx)(t.h4,{id:"itestdependencies",children:"ITestDependencies"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-csharp",children:"public interface ITestDependencies\n{\n    IEnumerable<TestContext> GetTests(Func<TestContext, bool> predicate);\n    List<TestContext> GetTests(string testName);\n    List<TestContext> GetTests(string testName, Type classType);\n}\n"})}),"\n",(0,i.jsx)(t.h4,{id:"iteststatebag",children:"ITestStateBag"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-csharp",children:"public interface ITestStateBag\n{\n    ConcurrentDictionary<string, object?> ObjectBag { get; }\n}\n"})}),"\n",(0,i.jsx)(t.h2,{id:"summary",children:"Summary"}),"\n",(0,i.jsx)(t.p,{children:"The TestContext interface organization provides:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["\u2705 ",(0,i.jsx)(t.strong,{children:"Better discoverability"})," through grouped functionality"]}),"\n",(0,i.jsxs)(t.li,{children:["\u2705 ",(0,i.jsx)(t.strong,{children:"Clearer code intent"})," with semantic interface names"]}),"\n",(0,i.jsxs)(t.li,{children:["\u2705 ",(0,i.jsx)(t.strong,{children:"Zero performance overhead"})," with allocation-free design"]}),"\n",(0,i.jsxs)(t.li,{children:["\u2705 ",(0,i.jsx)(t.strong,{children:"Backwards compatibility"})," with direct property access"]}),"\n",(0,i.jsxs)(t.li,{children:["\u2705 ",(0,i.jsx)(t.strong,{children:"Future flexibility"})," for interface-based dependencies"]}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"Update your code incrementally, starting with new code and high-value refactorings, while legacy code continues to work unchanged."})]})}function h(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>c});var s=n(6540);const i={},r=s.createContext(i);function a(e){const t=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),s.createElement(r.Provider,{value:t},e.children)}}}]);