"use strict";(globalThis.webpackChunktunit_docs_site=globalThis.webpackChunktunit_docs_site||[]).push([[5536],{36299(e,s,i){i.r(s),i.d(s,{assets:()=>a,contentTitle:()=>o,default:()=>h,frontMatter:()=>c,metadata:()=>n,toc:()=>l});const n=JSON.parse('{"id":"examples/aspire","title":"Aspire Integration Testing","description":"TUnit provides first-class support for .NET Aspire integration testing through the TUnit.Aspire package. This package eliminates the boilerplate of managing an Aspire distributed application in tests, handling the full lifecycle (build, start, wait for resources, stop, dispose) automatically.","source":"@site/docs/examples/aspire.md","sourceDirName":"examples","slug":"/examples/aspire","permalink":"/docs/examples/aspire","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"docs","previous":{"title":"ASP.NET Core Integration Testing","permalink":"/docs/examples/aspnet"},"next":{"title":"Playwright","permalink":"/docs/examples/playwright"}}');var t=i(74848),r=i(28453);const c={},o="Aspire Integration Testing",a={},l=[{value:"Installation",id:"installation",level:2},{value:"Quick Start",id:"quick-start",level:2},{value:"1. Use the Fixture Directly",id:"1-use-the-fixture-directly",level:3},{value:"2. Subclass for Customization",id:"2-subclass-for-customization",level:3},{value:"Core Concepts",id:"core-concepts",level:2},{value:"Lifecycle",id:"lifecycle",level:3},{value:"Shared Session",id:"shared-session",level:3},{value:"Resource Waiting",id:"resource-waiting",level:3},{value:"Timeouts",id:"timeouts",level:3},{value:"Public API",id:"public-api",level:2},{value:"Properties",id:"properties",level:3},{value:"Methods",id:"methods",level:3},{value:"Virtual Methods (Override to Customize)",id:"virtual-methods-override-to-customize",level:3},{value:"Overriding the Lifecycle",id:"overriding-the-lifecycle",level:3},{value:"Passing Arguments to the AppHost",id:"passing-arguments-to-the-apphost",level:3},{value:"Watching Resource Logs",id:"watching-resource-logs",level:2},{value:"Building Fixture Chains",id:"building-fixture-chains",level:2},{value:"HTTP Client Fixture",id:"http-client-fixture",level:3},{value:"Database Fixture",id:"database-fixture",level:3},{value:"Redis Fixture",id:"redis-fixture",level:3},{value:"Using Fixtures in Tests",id:"using-fixtures-in-tests",level:3},{value:"Diagnostics",id:"diagnostics",level:2},{value:"Progress Logging",id:"progress-logging",level:3},{value:"Timeout Diagnostics",id:"timeout-diagnostics",level:3},{value:"Fail-Fast Detection",id:"fail-fast-detection",level:3},{value:"CI/CD",id:"cicd",level:2},{value:"GitHub Actions",id:"github-actions",level:3},{value:"Tips for CI",id:"tips-for-ci",level:3},{value:"Templates",id:"templates",level:2},{value:"FAQ &amp; Troubleshooting",id:"faq--troubleshooting",level:2},{value:"StartAsync hangs or times out",id:"startasync-hangs-or-times-out",level:3},{value:"How do I access infrastructure directly?",id:"how-do-i-access-infrastructure-directly",level:3},{value:"Can I run different AppHosts in different test classes?",id:"can-i-run-different-apphosts-in-different-test-classes",level:3},{value:"How do I skip waiting for tool containers?",id:"how-do-i-skip-waiting-for-tool-containers",level:3},{value:"My resource never becomes healthy",id:"my-resource-never-becomes-healthy",level:3},{value:"What&#39;s the difference between TUnit.Aspire and TUnit.AspNetCore?",id:"whats-the-difference-between-tunitaspire-and-tunitaspnetcore",level:3}];function d(e){const s={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",mdxAdmonitionTitle:"mdxAdmonitionTitle",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(s.header,{children:(0,t.jsx)(s.h1,{id:"aspire-integration-testing",children:"Aspire Integration Testing"})}),"\n",(0,t.jsxs)(s.p,{children:["TUnit provides first-class support for ",(0,t.jsx)(s.a,{href:"https://learn.microsoft.com/en-us/dotnet/aspire/overview",children:".NET Aspire"})," integration testing through the ",(0,t.jsx)(s.code,{children:"TUnit.Aspire"})," package. This package eliminates the boilerplate of managing an Aspire distributed application in tests, handling the full lifecycle (build, start, wait for resources, stop, dispose) automatically."]}),"\n",(0,t.jsx)(s.h2,{id:"installation",children:"Installation"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-bash",children:"dotnet add package TUnit.Aspire\n"})}),"\n",(0,t.jsx)(s.admonition,{title:"Prerequisites",type:"info",children:(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:"An Aspire AppHost project in your solution"}),"\n",(0,t.jsx)(s.li,{children:"Docker running (Aspire uses containers for infrastructure resources)"}),"\n",(0,t.jsx)(s.li,{children:".NET 8.0 or later"}),"\n"]})}),"\n",(0,t.jsx)(s.h2,{id:"quick-start",children:"Quick Start"}),"\n",(0,t.jsx)(s.h3,{id:"1-use-the-fixture-directly",children:"1. Use the Fixture Directly"}),"\n",(0,t.jsx)(s.p,{children:"The simplest approach requires no subclassing at all:"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-csharp",children:'[ClassDataSource<AspireFixture<Projects.MyAppHost>>(Shared = SharedType.PerTestSession)]\npublic class ApiTests(AspireFixture<Projects.MyAppHost> fixture)\n{\n    [Test]\n    public async Task GetWeatherForecast_ReturnsOk()\n    {\n        var client = fixture.CreateHttpClient("apiservice");\n\n        var response = await client.GetAsync("/weatherforecast");\n\n        await Assert.That(response.StatusCode).IsEqualTo(HttpStatusCode.OK);\n    }\n}\n'})}),"\n",(0,t.jsx)(s.p,{children:"That's it. The fixture will:"}),"\n",(0,t.jsxs)(s.ol,{children:["\n",(0,t.jsx)(s.li,{children:"Build your Aspire AppHost"}),"\n",(0,t.jsx)(s.li,{children:"Start all containers and projects"}),"\n",(0,t.jsx)(s.li,{children:"Wait for all resources to become healthy"}),"\n",(0,t.jsx)(s.li,{children:"Provide HTTP clients and connection strings"}),"\n",(0,t.jsx)(s.li,{children:"Stop and dispose everything when tests complete"}),"\n"]}),"\n",(0,t.jsx)(s.h3,{id:"2-subclass-for-customization",children:"2. Subclass for Customization"}),"\n",(0,t.jsx)(s.p,{children:"For more control, create a subclass:"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-csharp",children:"using TUnit.Aspire;\n\npublic class AppFixture : AspireFixture<Projects.MyAppHost>\n{\n    protected override TimeSpan ResourceTimeout => TimeSpan.FromMinutes(3);\n\n    protected override void ConfigureBuilder(IDistributedApplicationTestingBuilder builder)\n    {\n        // Configure the builder before the app is built\n        builder.Services.ConfigureHttpClientDefaults(clientBuilder =>\n        {\n            clientBuilder.AddStandardResilienceHandler();\n        });\n    }\n}\n"})}),"\n",(0,t.jsx)(s.p,{children:"Then use it in tests:"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-csharp",children:'[ClassDataSource<AppFixture>(Shared = SharedType.PerTestSession)]\npublic class ApiTests(AppFixture fixture)\n{\n    [Test]\n    public async Task GetWeatherForecast_ReturnsOk()\n    {\n        var client = fixture.CreateHttpClient("apiservice");\n        var response = await client.GetAsync("/weatherforecast");\n        await Assert.That(response.StatusCode).IsEqualTo(HttpStatusCode.OK);\n    }\n}\n'})}),"\n",(0,t.jsx)(s.h2,{id:"core-concepts",children:"Core Concepts"}),"\n",(0,t.jsx)(s.h3,{id:"lifecycle",children:"Lifecycle"}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.code,{children:"AspireFixture<TAppHost>"})," implements ",(0,t.jsx)(s.code,{children:"IAsyncInitializer"})," and ",(0,t.jsx)(s.code,{children:"IAsyncDisposable"}),", integrating with TUnit's lifecycle automatically:"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{children:"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                  FIXTURE LIFECYCLE                                \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  1. CreateAsync<TAppHost>()    Build the Aspire test builder     \u2502\n\u2502  2. ConfigureBuilder()         Your customization hook           \u2502\n\u2502  3. BuildAsync()               Build the distributed app         \u2502\n\u2502  4. StartAsync()               Start containers & projects       \u2502\n\u2502     \u21b3 Resource monitoring      Real-time state change logging    \u2502\n\u2502  5. WaitForResources()         Wait for healthy/running state    \u2502\n\u2502     \u21b3 Fail-fast detection      Immediate error on FailedToStart  \u2502\n\u2502  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502\n\u2502  6. Tests run                  Use CreateHttpClient, App, etc.   \u2502\n\u2502  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502\n\u2502  7. StopAsync()                Stop the application              \u2502\n\u2502  8. DisposeAsync()             Clean up all resources             \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,t.jsx)(s.h3,{id:"shared-session",children:"Shared Session"}),"\n",(0,t.jsxs)(s.p,{children:["Use ",(0,t.jsx)(s.code,{children:"Shared = SharedType.PerTestSession"})," to start the Aspire app once and share it across all tests:"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-csharp",children:"[ClassDataSource<AppFixture>(Shared = SharedType.PerTestSession)]\npublic class OrderTests(AppFixture fixture) { /* ... */ }\n\n[ClassDataSource<AppFixture>(Shared = SharedType.PerTestSession)]\npublic class ProductTests(AppFixture fixture) { /* ... */ }\n// Both test classes share the same AppFixture instance\n"})}),"\n",(0,t.jsx)(s.p,{children:"This is the recommended approach since starting an Aspire distributed application is expensive (containers, databases, etc.)."}),"\n",(0,t.jsx)(s.h3,{id:"resource-waiting",children:"Resource Waiting"}),"\n",(0,t.jsxs)(s.p,{children:["By default, the fixture waits for ",(0,t.jsx)(s.strong,{children:"all resources to become healthy"})," before tests run. You can customize this:"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-csharp",children:'public class AppFixture : AspireFixture<Projects.MyAppHost>\n{\n    // Option 1: Change the wait behavior via property\n    protected override ResourceWaitBehavior WaitBehavior => ResourceWaitBehavior.AllRunning;\n\n    // Option 2: Wait for specific resources only\n    protected override ResourceWaitBehavior WaitBehavior => ResourceWaitBehavior.Named;\n    protected override IEnumerable<string> ResourcesToWaitFor() => ["apiservice", "worker"];\n\n    // Option 3: Full control over the waiting logic\n    protected override async Task WaitForResourcesAsync(\n        DistributedApplication app, CancellationToken cancellationToken)\n    {\n        var notifications = app.Services.GetRequiredService<ResourceNotificationService>();\n        await notifications.WaitForResourceAsync("apiservice",\n            KnownResourceStates.Running, cancellationToken);\n        await notifications.WaitForResourceAsync("worker",\n            KnownResourceStates.Running, cancellationToken);\n    }\n}\n'})}),"\n",(0,t.jsxs)(s.p,{children:["Available ",(0,t.jsx)(s.code,{children:"ResourceWaitBehavior"})," values:"]}),"\n",(0,t.jsxs)(s.table,{children:[(0,t.jsx)(s.thead,{children:(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.th,{children:"Value"}),(0,t.jsx)(s.th,{children:"Description"})]})}),(0,t.jsxs)(s.tbody,{children:[(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"AllHealthy"})}),(0,t.jsx)(s.td,{children:"Wait for all resources to pass health checks (default)"})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"AllRunning"})}),(0,t.jsx)(s.td,{children:"Wait for all resources to reach the Running state"})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"Named"})}),(0,t.jsxs)(s.td,{children:["Wait only for resources returned by ",(0,t.jsx)(s.code,{children:"ResourcesToWaitFor()"})]})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"None"})}),(0,t.jsx)(s.td,{children:"Don't wait \u2014 handle readiness manually in tests"})]})]})]}),"\n",(0,t.jsx)(s.h3,{id:"timeouts",children:"Timeouts"}),"\n",(0,t.jsxs)(s.p,{children:["The ",(0,t.jsx)(s.code,{children:"ResourceTimeout"})," controls how long the fixture waits for both ",(0,t.jsx)(s.code,{children:"StartAsync()"})," and resource readiness:"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-csharp",children:"public class AppFixture : AspireFixture<Projects.MyAppHost>\n{\n    // Default is 60 seconds. Increase for slow containers or CI environments.\n    protected override TimeSpan ResourceTimeout => TimeSpan.FromMinutes(3);\n}\n"})}),"\n",(0,t.jsx)(s.p,{children:"When a timeout occurs, the error includes:"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:"Which resources are ready vs. still pending"}),"\n",(0,t.jsx)(s.li,{children:"Recent container logs from pending resources"}),"\n",(0,t.jsx)(s.li,{children:"Diagnostic information about the failure"}),"\n"]}),"\n",(0,t.jsx)(s.h2,{id:"public-api",children:"Public API"}),"\n",(0,t.jsx)(s.h3,{id:"properties",children:"Properties"}),"\n",(0,t.jsxs)(s.table,{children:[(0,t.jsx)(s.thead,{children:(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.th,{children:"Property"}),(0,t.jsx)(s.th,{children:"Type"}),(0,t.jsx)(s.th,{children:"Description"})]})}),(0,t.jsx)(s.tbody,{children:(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"App"})}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"DistributedApplication"})}),(0,t.jsx)(s.td,{children:"The running Aspire app. Access for advanced scenarios."})]})})]}),"\n",(0,t.jsx)(s.h3,{id:"methods",children:"Methods"}),"\n",(0,t.jsxs)(s.table,{children:[(0,t.jsx)(s.thead,{children:(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.th,{children:"Method"}),(0,t.jsx)(s.th,{children:"Returns"}),(0,t.jsx)(s.th,{children:"Description"})]})}),(0,t.jsxs)(s.tbody,{children:[(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"CreateHttpClient(resourceName, endpointName?)"})}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"HttpClient"})}),(0,t.jsx)(s.td,{children:"Creates an HTTP client connected to the named resource"})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"GetConnectionStringAsync(resourceName, ct?)"})}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"Task<string?>"})}),(0,t.jsx)(s.td,{children:"Gets the connection string for the named resource"})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"WatchResourceLogs(resourceName)"})}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"IAsyncDisposable"})}),(0,t.jsx)(s.td,{children:"Streams resource logs to the current test's output"})]})]})]}),"\n",(0,t.jsx)(s.h3,{id:"virtual-methods-override-to-customize",children:"Virtual Methods (Override to Customize)"}),"\n",(0,t.jsxs)(s.table,{children:[(0,t.jsx)(s.thead,{children:(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.th,{children:"Method"}),(0,t.jsx)(s.th,{children:"Default"}),(0,t.jsx)(s.th,{children:"Description"})]})}),(0,t.jsxs)(s.tbody,{children:[(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"InitializeAsync()"})}),(0,t.jsx)(s.td,{children:"Full lifecycle"}),(0,t.jsx)(s.td,{children:"Override to add post-start logic (migrations, seeding)"})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"DisposeAsync()"})}),(0,t.jsx)(s.td,{children:"Stop and dispose app"}),(0,t.jsx)(s.td,{children:"Override to add custom cleanup"})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"Args"})}),(0,t.jsx)(s.td,{children:"Empty"}),(0,t.jsx)(s.td,{children:"Command-line arguments passed to the AppHost entry point"})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"ConfigureBuilder(builder)"})}),(0,t.jsx)(s.td,{children:"No-op"}),(0,t.jsx)(s.td,{children:"Customize the builder before building"})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"ResourceTimeout"})}),(0,t.jsx)(s.td,{children:"60 seconds"}),(0,t.jsx)(s.td,{children:"How long to wait for startup and resources"})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"WaitBehavior"})}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"AllHealthy"})}),(0,t.jsx)(s.td,{children:"Which resources to wait for"})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"ResourcesToWaitFor()"})}),(0,t.jsx)(s.td,{children:"Empty"}),(0,t.jsxs)(s.td,{children:["Resource names when ",(0,t.jsx)(s.code,{children:"WaitBehavior"})," is ",(0,t.jsx)(s.code,{children:"Named"})]})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"WaitForResourcesAsync(app, ct)"})}),(0,t.jsxs)(s.td,{children:["Waits per ",(0,t.jsx)(s.code,{children:"WaitBehavior"})]}),(0,t.jsx)(s.td,{children:"Full control over resource waiting"})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"LogProgress(message)"})}),(0,t.jsx)(s.td,{children:"Writes to stderr"}),(0,t.jsx)(s.td,{children:"Override to route progress logs elsewhere"})]})]})]}),"\n",(0,t.jsx)(s.h3,{id:"overriding-the-lifecycle",children:"Overriding the Lifecycle"}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.code,{children:"InitializeAsync"})," and ",(0,t.jsx)(s.code,{children:"DisposeAsync"})," are virtual, so you can add post-start or pre-dispose logic:"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-csharp",children:'public class AppFixture : AspireFixture<Projects.MyAppHost>\n{\n    public override async Task InitializeAsync()\n    {\n        await base.InitializeAsync(); // Build, start, wait for resources\n\n        // Post-start: run migrations, seed data, warm caches, etc.\n        var connectionString = await GetConnectionStringAsync("postgresdb");\n        await RunMigrationsAsync(connectionString!);\n        await SeedTestDataAsync(connectionString!);\n    }\n\n    public override async ValueTask DisposeAsync()\n    {\n        // Pre-dispose: dump diagnostics on failure, clean up external state, etc.\n        LogProgress("Cleaning up test data...");\n        await base.DisposeAsync();\n    }\n}\n'})}),"\n",(0,t.jsx)(s.h3,{id:"passing-arguments-to-the-apphost",children:"Passing Arguments to the AppHost"}),"\n",(0,t.jsxs)(s.p,{children:["Use the ",(0,t.jsx)(s.code,{children:"Args"})," property to pass command-line arguments to the AppHost entry point. These are forwarded to ",(0,t.jsx)(s.code,{children:"DistributedApplicationTestingBuilder.CreateAsync"})," and are available in the AppHost's ",(0,t.jsx)(s.code,{children:"builder.Configuration"})," during builder creation \u2014 before ",(0,t.jsx)(s.code,{children:"ConfigureBuilder"})," is called:"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-csharp",children:'public class AppFixture : AspireFixture<Projects.MyAppHost>\n{\n    protected override string[] Args =>\n    [\n        "--UseVolumes=false",\n        "--UsePostgresWithPersistentLifetime=false",\n        "--UsePostgresWithSessionLifetime=true"\n    ];\n}\n'})}),"\n",(0,t.jsxs)(s.admonition,{type:"tip",children:[(0,t.jsxs)(s.mdxAdmonitionTitle,{children:["When to use ",(0,t.jsx)(s.code,{children:"Args"})," vs ",(0,t.jsx)(s.code,{children:"ConfigureBuilder"})]}),(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:["Use ",(0,t.jsx)(s.strong,{children:(0,t.jsx)(s.code,{children:"Args"})})," for configuration values that the AppHost reads during ",(0,t.jsx)(s.code,{children:"CreateBuilder(args)"})," \u2014 these must be set ",(0,t.jsx)(s.em,{children:"before"})," the builder is created."]}),"\n",(0,t.jsxs)(s.li,{children:["Use ",(0,t.jsx)(s.strong,{children:(0,t.jsx)(s.code,{children:"ConfigureBuilder"})})," for service registrations, HTTP client defaults, and other configuration that can be applied ",(0,t.jsx)(s.em,{children:"after"})," the builder is created."]}),"\n"]})]}),"\n",(0,t.jsx)(s.h2,{id:"watching-resource-logs",children:"Watching Resource Logs"}),"\n",(0,t.jsxs)(s.p,{children:["Use ",(0,t.jsx)(s.code,{children:"WatchResourceLogs()"})," inside a test to stream a resource's container logs to the test output. This is invaluable for debugging failures:"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-csharp",children:'[Test]\npublic async Task Debug_Api_Behavior()\n{\n    await using var _ = fixture.WatchResourceLogs("apiservice");\n\n    var client = fixture.CreateHttpClient("apiservice");\n    var response = await client.PostAsJsonAsync("/api/orders", new { /* ... */ });\n\n    // If this fails, the apiservice container logs will be in the test output\n    await Assert.That(response.StatusCode).IsEqualTo(HttpStatusCode.Created);\n}\n'})}),"\n",(0,t.jsxs)(s.p,{children:["Dispose the returned value (or use ",(0,t.jsx)(s.code,{children:"await using"}),") to stop watching."]}),"\n",(0,t.jsx)(s.h2,{id:"building-fixture-chains",children:"Building Fixture Chains"}),"\n",(0,t.jsxs)(s.p,{children:["For real-world apps, you'll want layered fixtures. Use TUnit's ",(0,t.jsx)(s.code,{children:"[ClassDataSource]"})," property injection to create dependency chains:"]}),"\n",(0,t.jsx)(s.h3,{id:"http-client-fixture",children:"HTTP Client Fixture"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-csharp",children:'public class ApiClientFixture : IAsyncInitializer\n{\n    [ClassDataSource<AppFixture>(Shared = SharedType.PerTestSession)]\n    public required AppFixture App { get; init; }\n\n    public HttpClient Client { get; private set; } = null!;\n\n    public Task InitializeAsync()\n    {\n        Client = App.CreateHttpClient("apiservice");\n        Client.DefaultRequestHeaders.Accept.Add(\n            new MediaTypeWithQualityHeaderValue("application/json"));\n        return Task.CompletedTask;\n    }\n}\n'})}),"\n",(0,t.jsx)(s.h3,{id:"database-fixture",children:"Database Fixture"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-csharp",children:'public class DatabaseFixture : IAsyncInitializer, IAsyncDisposable\n{\n    [ClassDataSource<AppFixture>(Shared = SharedType.PerTestSession)]\n    public required AppFixture App { get; init; }\n\n    public NpgsqlConnection Connection { get; private set; } = null!;\n\n    public async Task InitializeAsync()\n    {\n        var connectionString = await App.GetConnectionStringAsync("postgresdb");\n        Connection = new NpgsqlConnection(connectionString);\n        await Connection.OpenAsync();\n    }\n\n    public async ValueTask DisposeAsync() => await Connection.DisposeAsync();\n}\n'})}),"\n",(0,t.jsx)(s.h3,{id:"redis-fixture",children:"Redis Fixture"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-csharp",children:'public class RedisFixture : IAsyncInitializer, IAsyncDisposable\n{\n    [ClassDataSource<AppFixture>(Shared = SharedType.PerTestSession)]\n    public required AppFixture App { get; init; }\n\n    public IConnectionMultiplexer Connection { get; private set; } = null!;\n    public IDatabase Database => Connection.GetDatabase();\n\n    public async Task InitializeAsync()\n    {\n        var connectionString = await App.GetConnectionStringAsync("redis");\n        Connection = await ConnectionMultiplexer.ConnectAsync(connectionString);\n    }\n\n    public async ValueTask DisposeAsync() => await Connection.DisposeAsync();\n}\n'})}),"\n",(0,t.jsx)(s.h3,{id:"using-fixtures-in-tests",children:"Using Fixtures in Tests"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-csharp",children:'[Category("Integration"), Category("Cache")]\npublic class ProductCacheTests\n{\n    [ClassDataSource<ApiClientFixture>(Shared = SharedType.PerTestSession)]\n    public required ApiClientFixture Api { get; init; }\n\n    [ClassDataSource<RedisFixture>(Shared = SharedType.PerTestSession)]\n    public required RedisFixture Redis { get; init; }\n\n    [Test]\n    public async Task Product_Is_Cached_After_Fetch()\n    {\n        // Create a product via API\n        var response = await Api.Client.PostAsJsonAsync("/api/products",\n            new { Name = "Test", Category = "electronics", Price = 9.99m });\n        var product = await response.Content.ReadFromJsonAsync<ProductResponse>();\n\n        // Fetch it (triggers caching)\n        await Api.Client.GetAsync($"/api/products/{product!.Id}");\n\n        // Verify Redis has the cached entry\n        var cached = await Redis.Database.StringGetAsync($"product:{product.Id}");\n        await Assert.That(cached.HasValue).IsTrue();\n    }\n}\n'})}),"\n",(0,t.jsxs)(s.p,{children:["TUnit resolves the dependency chain automatically: ",(0,t.jsx)(s.code,{children:"AppFixture"})," starts first, then ",(0,t.jsx)(s.code,{children:"ApiClientFixture"})," and ",(0,t.jsx)(s.code,{children:"RedisFixture"})," initialize using the running app."]}),"\n",(0,t.jsx)(s.h2,{id:"diagnostics",children:"Diagnostics"}),"\n",(0,t.jsx)(s.h3,{id:"progress-logging",children:"Progress Logging"}),"\n",(0,t.jsx)(s.p,{children:"During initialization, the fixture logs progress to stderr for CI visibility:"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{children:"[Aspire] Creating distributed application builder for MyAppHost...\n[Aspire] Builder created in 0.3s\n[Aspire] Building application...\n[Aspire] Application built in 1.2s\n[Aspire] Starting application with resources: [postgres, redis, apiservice, worker]\n[Aspire]   [postgres] unknown -> Starting\n[Aspire]   [redis] unknown -> Starting\n[Aspire]   [postgres] Starting -> Running\n[Aspire]   [redis] Starting -> Running\n[Aspire] Application started in 8.5s. Waiting for resources...\n[Aspire]   Resource 'apiservice' is healthy (1/4)\n[Aspire]   Resource 'worker' is healthy (2/4)\n[Aspire] All resources ready.\n"})}),"\n",(0,t.jsxs)(s.p,{children:["Override ",(0,t.jsx)(s.code,{children:"LogProgress"})," to route these messages elsewhere:"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-csharp",children:"public class AppFixture : AspireFixture<Projects.MyAppHost>\n{\n    protected override void LogProgress(string message)\n    {\n        // Route to your preferred logger\n        Console.WriteLine(message);\n    }\n}\n"})}),"\n",(0,t.jsx)(s.h3,{id:"timeout-diagnostics",children:"Timeout Diagnostics"}),"\n",(0,t.jsx)(s.p,{children:"When a timeout occurs, the error message includes container logs from the failing resources, so you can see exactly what went wrong without having to reproduce the failure:"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{children:"TimeoutException: Timed out after 60s waiting for the Aspire application to start.\n\n--- redis logs ---\n  Error accepting a client connection: error:0A000126:SSL routines::unexpected eof\n  Error accepting a client connection: error:0A000126:SSL routines::unexpected eof\n"})}),"\n",(0,t.jsx)(s.h3,{id:"fail-fast-detection",children:"Fail-Fast Detection"}),"\n",(0,t.jsxs)(s.p,{children:["The default resource waiting logic watches for resources entering a ",(0,t.jsx)(s.code,{children:"FailedToStart"})," state. If any resource fails, the fixture throws immediately with that resource's logs instead of waiting for the full timeout."]}),"\n",(0,t.jsx)(s.h2,{id:"cicd",children:"CI/CD"}),"\n",(0,t.jsx)(s.h3,{id:"github-actions",children:"GitHub Actions"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-yaml",children:'jobs:\n  integration-tests:\n    runs-on: ubuntu-latest\n    timeout-minutes: 15\n    steps:\n      - uses: actions/checkout@v4\n      - uses: actions/setup-dotnet@v4\n        with:\n          dotnet-version: 9.0.x\n\n      - run: dotnet build MyApp.Tests -c Release\n      - run: dotnet run --project MyApp.Tests -c Release --no-build\n        env:\n          ASPIRE_ALLOW_UNSECURED_TRANSPORT: "true"\n'})}),"\n",(0,t.jsx)(s.admonition,{title:"ASPIRE_ALLOW_UNSECURED_TRANSPORT",type:"warning",children:(0,t.jsxs)(s.p,{children:["Set ",(0,t.jsx)(s.code,{children:"ASPIRE_ALLOW_UNSECURED_TRANSPORT=true"})," in CI environments where the ASP.NET Core developer certificate isn't trusted. Without this, container health checks may fail with TLS errors."]})}),"\n",(0,t.jsx)(s.h3,{id:"tips-for-ci",children:"Tips for CI"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsxs)(s.strong,{children:["Increase ",(0,t.jsx)(s.code,{children:"ResourceTimeout"})]})," \u2014 CI runners are slower than local machines. 2-5 minutes is typical."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsxs)(s.strong,{children:["Use ",(0,t.jsx)(s.code,{children:"Shared = SharedType.PerTestSession"})]})," \u2014 Start the app once, not per test class."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Check Docker availability"})," \u2014 Aspire requires Docker. Ensure your CI runner has it installed."]}),"\n"]}),"\n",(0,t.jsx)(s.h2,{id:"templates",children:"Templates"}),"\n",(0,t.jsx)(s.p,{children:"TUnit includes project templates for Aspire testing:"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-bash",children:"# Install TUnit templates\ndotnet new install TUnit.Templates\n\n# Scaffold a complete Aspire solution with tests\ndotnet new tunit-aspire-starter -n MyApp\n\n# Add a test project to an existing Aspire solution\ndotnet new tunit-aspire-test -n MyApp.Tests\n"})}),"\n",(0,t.jsx)(s.h2,{id:"faq--troubleshooting",children:"FAQ & Troubleshooting"}),"\n",(0,t.jsx)(s.h3,{id:"startasync-hangs-or-times-out",children:"StartAsync hangs or times out"}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Symptom:"})," Tests time out during startup with no obvious error."]}),"\n",(0,t.jsx)(s.p,{children:(0,t.jsx)(s.strong,{children:"Common causes:"})}),"\n",(0,t.jsxs)(s.ol,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"TLS/SSL errors"})," \u2014 Set ",(0,t.jsx)(s.code,{children:"ASPIRE_ALLOW_UNSECURED_TRANSPORT=true"})," or call ",(0,t.jsx)(s.code,{children:".WithoutHttpsCertificate()"})," on container resources in your AppHost."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Docker images not pulled"})," \u2014 First run pulls container images, which can take minutes. Increase ",(0,t.jsx)(s.code,{children:"ResourceTimeout"}),"."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Docker not running"})," \u2014 Aspire requires Docker. Verify with ",(0,t.jsx)(s.code,{children:"docker info"}),"."]}),"\n"]}),"\n",(0,t.jsxs)(s.p,{children:["The fixture logs resource state changes in real time to stderr, so check your CI output for lines like ",(0,t.jsx)(s.code,{children:"[redis] Running -> unhealthy"}),"."]}),"\n",(0,t.jsx)(s.h3,{id:"how-do-i-access-infrastructure-directly",children:"How do I access infrastructure directly?"}),"\n",(0,t.jsxs)(s.p,{children:["Use ",(0,t.jsx)(s.code,{children:"App"})," to access the full ",(0,t.jsx)(s.code,{children:"DistributedApplication"}),", then get services or connection strings:"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-csharp",children:'// Direct service access\nvar notifications = fixture.App.Services.GetRequiredService<ResourceNotificationService>();\n\n// Connection strings\nvar connStr = await fixture.GetConnectionStringAsync("postgresdb");\n'})}),"\n",(0,t.jsx)(s.h3,{id:"can-i-run-different-apphosts-in-different-test-classes",children:"Can I run different AppHosts in different test classes?"}),"\n",(0,t.jsx)(s.p,{children:"Yes. Create separate fixtures for each AppHost:"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-csharp",children:"public class AppAFixture : AspireFixture<Projects.AppHostA> { }\npublic class AppBFixture : AspireFixture<Projects.AppHostB> { }\n\n[ClassDataSource<AppAFixture>(Shared = SharedType.PerTestSession)]\npublic class AppATests(AppAFixture fixture) { /* ... */ }\n\n[ClassDataSource<AppBFixture>(Shared = SharedType.PerTestSession)]\npublic class AppBTests(AppBFixture fixture) { /* ... */ }\n"})}),"\n",(0,t.jsx)(s.h3,{id:"how-do-i-skip-waiting-for-tool-containers",children:"How do I skip waiting for tool containers?"}),"\n",(0,t.jsxs)(s.p,{children:["Tool containers like pgAdmin or RedisInsight don't need to be ready before tests run. Use ",(0,t.jsx)(s.code,{children:"Named"})," wait behavior:"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-csharp",children:'public class AppFixture : AspireFixture<Projects.MyAppHost>\n{\n    protected override ResourceWaitBehavior WaitBehavior => ResourceWaitBehavior.Named;\n\n    protected override IEnumerable<string> ResourcesToWaitFor()\n        => ["apiservice", "worker", "postgres", "redis"];\n    // pgadmin, redisinsight are excluded \u2014 tests don\'t need them\n}\n'})}),"\n",(0,t.jsx)(s.h3,{id:"my-resource-never-becomes-healthy",children:"My resource never becomes healthy"}),"\n",(0,t.jsxs)(s.p,{children:["If a resource stays in ",(0,t.jsx)(s.code,{children:"Running"})," but never reaches ",(0,t.jsx)(s.code,{children:"Healthy"}),", check:"]}),"\n",(0,t.jsxs)(s.ol,{children:["\n",(0,t.jsxs)(s.li,{children:["The resource has a health check configured (",(0,t.jsx)(s.code,{children:'.WithHttpHealthCheck("/health")'})," or similar)"]}),"\n",(0,t.jsx)(s.li,{children:"The health check endpoint is reachable from inside the container network"}),"\n",(0,t.jsxs)(s.li,{children:["Use ",(0,t.jsx)(s.code,{children:'WatchResourceLogs("resourceName")'})," in a test to see the resource's output"]}),"\n"]}),"\n",(0,t.jsxs)(s.p,{children:["If the resource doesn't have health checks, use ",(0,t.jsx)(s.code,{children:"AllRunning"})," instead of ",(0,t.jsx)(s.code,{children:"AllHealthy"}),":"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-csharp",children:"protected override ResourceWaitBehavior WaitBehavior => ResourceWaitBehavior.AllRunning;\n"})}),"\n",(0,t.jsx)(s.h3,{id:"whats-the-difference-between-tunitaspire-and-tunitaspnetcore",children:"What's the difference between TUnit.Aspire and TUnit.AspNetCore?"}),"\n",(0,t.jsxs)(s.table,{children:[(0,t.jsx)(s.thead,{children:(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.th,{}),(0,t.jsx)(s.th,{children:"TUnit.Aspire"}),(0,t.jsx)(s.th,{children:"TUnit.AspNetCore"})]})}),(0,t.jsxs)(s.tbody,{children:[(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.strong,{children:"Purpose"})}),(0,t.jsx)(s.td,{children:"Test distributed apps (multiple services + infrastructure)"}),(0,t.jsx)(s.td,{children:"Test a single ASP.NET Core app"})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.strong,{children:"Infrastructure"})}),(0,t.jsx)(s.td,{children:"Real containers via Aspire/Docker"}),(0,t.jsxs)(s.td,{children:["In-process ",(0,t.jsx)(s.code,{children:"TestServer"})," or Testcontainers"]})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.strong,{children:"Isolation"})}),(0,t.jsx)(s.td,{children:"Shared app, per-test HTTP clients"}),(0,t.jsxs)(s.td,{children:["Per-test ",(0,t.jsx)(s.code,{children:"WebApplicationFactory"})]})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.strong,{children:"Use when"})}),(0,t.jsx)(s.td,{children:"Your app uses Aspire orchestration"}),(0,t.jsx)(s.td,{children:"Your app is a single ASP.NET Core project"})]})]})]}),"\n",(0,t.jsxs)(s.p,{children:["They can be used together \u2014 for example, using Aspire to manage infrastructure while using ",(0,t.jsx)(s.code,{children:"TestWebApplicationFactory"})," for per-test app isolation."]})]})}function h(e={}){const{wrapper:s}={...(0,r.R)(),...e.components};return s?(0,t.jsx)(s,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},28453(e,s,i){i.d(s,{R:()=>c,x:()=>o});var n=i(96540);const t={},r=n.createContext(t);function c(e){const s=n.useContext(r);return n.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function o(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:c(e.components),n.createElement(r.Provider,{value:s},e.children)}}}]);