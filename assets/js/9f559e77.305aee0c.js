"use strict";(self.webpackChunktunit_docs_site=self.webpackChunktunit_docs_site||[]).push([[6644],{9393:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>c,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>r});const s=JSON.parse('{"id":"advanced/extension-points","title":"Extension Points","description":"TUnit provides several extension points that allow you to customize and extend the framework\'s behavior. These interfaces enable you to implement custom test execution logic, hook into the test lifecycle, and control parallel execution.","source":"@site/docs/advanced/extension-points.md","sourceDirName":"advanced","slug":"/advanced/extension-points","permalink":"/docs/advanced/extension-points","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"docs","previous":{"title":"Exception Handling","permalink":"/docs/advanced/exception-handling"},"next":{"title":"Test Variants","permalink":"/docs/advanced/test-variants"}}');var a=n(4848),i=n(8453);const o={},c="Extension Points",l={},r=[{value:"ITestExecutor",id:"itestexecutor",level:2},{value:"Interface Definition",id:"interface-definition",level:3},{value:"Example Implementation",id:"example-implementation",level:3},{value:"Registering a Test Executor",id:"registering-a-test-executor",level:3},{value:"IHookExecutor",id:"ihookexecutor",level:2},{value:"Interface Definition",id:"interface-definition-1",level:3},{value:"Example Implementation",id:"example-implementation-1",level:3},{value:"Event Receivers",id:"event-receivers",level:2},{value:"ITestDiscoveryEventReceiver",id:"itestdiscoveryeventreceiver",level:3},{value:"ITestRegisteredEventReceiver",id:"itestregisteredeventreceiver",level:3},{value:"ITestStartEventReceiver",id:"iteststarteventreceiver",level:3},{value:"ITestEndEventReceiver",id:"itestendeventreceiver",level:3},{value:"ITestRetryEventReceiver",id:"itestretryeventreceiver",level:3},{value:"Example Event Receiver Implementation",id:"example-event-receiver-implementation",level:3},{value:"Registering Event Receivers",id:"registering-event-receivers",level:3},{value:"Parallel Execution Control",id:"parallel-execution-control",level:2},{value:"IParallelLimit",id:"iparallellimit",level:3},{value:"IParallelConstraint",id:"iparallelconstraint",level:3},{value:"IAsyncInitializer",id:"iasyncinitializer",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"Common Use Cases",id:"common-use-cases",level:2},{value:"Cross-Cutting Concerns",id:"cross-cutting-concerns",level:3},{value:"Integration Testing",id:"integration-testing",level:3},{value:"Compliance and Auditing",id:"compliance-and-auditing",level:3},{value:"Example: Database Transaction Extension",id:"example-database-transaction-extension",level:2}];function d(e){const t={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.header,{children:(0,a.jsx)(t.h1,{id:"extension-points",children:"Extension Points"})}),"\n",(0,a.jsx)(t.p,{children:"TUnit provides several extension points that allow you to customize and extend the framework's behavior. These interfaces enable you to implement custom test execution logic, hook into the test lifecycle, and control parallel execution."}),"\n",(0,a.jsx)(t.h2,{id:"itestexecutor",children:"ITestExecutor"}),"\n",(0,a.jsxs)(t.p,{children:["The ",(0,a.jsx)(t.code,{children:"ITestExecutor"})," interface allows you to customize how tests are executed. This is useful for scenarios like:"]}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Adding custom logging or telemetry"}),"\n",(0,a.jsx)(t.li,{children:"Implementing custom retry logic"}),"\n",(0,a.jsx)(t.li,{children:"Wrapping test execution with special context"}),"\n",(0,a.jsx)(t.li,{children:"Implementing custom timeout behavior"}),"\n"]}),"\n",(0,a.jsx)(t.h3,{id:"interface-definition",children:"Interface Definition"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-csharp",children:"public interface ITestExecutor\n{\n    ValueTask ExecuteTest(TestContext context, Func<ValueTask> action);\n}\n"})}),"\n",(0,a.jsx)(t.h3,{id:"example-implementation",children:"Example Implementation"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-csharp",children:'public class TimingTestExecutor : ITestExecutor\n{\n    public async ValueTask ExecuteTest(TestContext context, Func<ValueTask> action)\n    {\n        var stopwatch = Stopwatch.StartNew();\n\n        try\n        {\n            await action();\n        }\n        finally\n        {\n            stopwatch.Stop();\n            context.WriteLine($"Test execution took: {stopwatch.ElapsedMilliseconds}ms");\n\n            // You could also send this to telemetry\n            TelemetryClient.TrackMetric("TestDuration", stopwatch.ElapsedMilliseconds);\n        }\n    }\n}\n'})}),"\n",(0,a.jsx)(t.h3,{id:"registering-a-test-executor",children:"Registering a Test Executor"}),"\n",(0,a.jsxs)(t.p,{children:["To use your custom test executor, apply the ",(0,a.jsx)(t.code,{children:"TestExecutorAttribute"})," at the assembly, class, or method level:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-csharp",children:"// Assembly-level (applies to all tests in the assembly)\n[assembly: TestExecutor<TimingTestExecutor>]\n\n// Or use the non-generic version\n[assembly: TestExecutor(typeof(TimingTestExecutor))]\n\n// Class-level (applies to all tests in the class)\n[TestExecutor<TimingTestExecutor>]\npublic class MyTestClass\n{\n    [Test]\n    public async Task MyTest()\n    {\n        // Test logic here\n    }\n}\n\n// Method-level (applies to specific test)\n[Test]\n[TestExecutor<TimingTestExecutor>]\npublic async Task MyTest()\n{\n    // Test logic here\n}\n"})}),"\n",(0,a.jsx)(t.h2,{id:"ihookexecutor",children:"IHookExecutor"}),"\n",(0,a.jsxs)(t.p,{children:["The ",(0,a.jsx)(t.code,{children:"IHookExecutor"})," interface allows you to customize how setup and cleanup hooks are executed. This is useful for:"]}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Adding error handling around hooks"}),"\n",(0,a.jsx)(t.li,{children:"Implementing hook-specific logging"}),"\n",(0,a.jsx)(t.li,{children:"Managing shared resources during hooks"}),"\n"]}),"\n",(0,a.jsx)(t.h3,{id:"interface-definition-1",children:"Interface Definition"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-csharp",children:"public interface IHookExecutor\n{\n    ValueTask ExecuteBeforeTestDiscoveryHook(MethodMetadata hookMethodInfo, BeforeTestDiscoveryContext context, Func<ValueTask> action);\n    ValueTask ExecuteBeforeTestSessionHook(MethodMetadata hookMethodInfo, TestSessionContext context, Func<ValueTask> action);\n    ValueTask ExecuteBeforeAssemblyHook(MethodMetadata hookMethodInfo, AssemblyHookContext context, Func<ValueTask> action);\n    ValueTask ExecuteBeforeClassHook(MethodMetadata hookMethodInfo, ClassHookContext context, Func<ValueTask> action);\n    ValueTask ExecuteBeforeTestHook(MethodMetadata hookMethodInfo, TestContext context, Func<ValueTask> action);\n\n    ValueTask ExecuteAfterTestDiscoveryHook(MethodMetadata hookMethodInfo, TestDiscoveryContext context, Func<ValueTask> action);\n    ValueTask ExecuteAfterTestSessionHook(MethodMetadata hookMethodInfo, TestSessionContext context, Func<ValueTask> action);\n    ValueTask ExecuteAfterAssemblyHook(MethodMetadata hookMethodInfo, AssemblyHookContext context, Func<ValueTask> action);\n    ValueTask ExecuteAfterClassHook(MethodMetadata hookMethodInfo, ClassHookContext context, Func<ValueTask> action);\n    ValueTask ExecuteAfterTestHook(MethodMetadata hookMethodInfo, TestContext context, Func<ValueTask> action);\n}\n"})}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"Note"}),": This interface has specific methods for each hook type (Before/After \xd7 TestDiscovery/TestSession/Assembly/Class/Test). Each method receives:"]}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"MethodMetadata hookMethodInfo"}),": Information about the hook method being executed"]}),"\n",(0,a.jsx)(t.li,{children:"A context object specific to the hook type"}),"\n",(0,a.jsxs)(t.li,{children:["The ",(0,a.jsx)(t.code,{children:"action"})," to execute (the actual hook logic)"]}),"\n"]}),"\n",(0,a.jsx)(t.h3,{id:"example-implementation-1",children:"Example Implementation"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-csharp",children:'public class LoggingHookExecutor : IHookExecutor\n{\n    public async ValueTask ExecuteBeforeTestDiscoveryHook(MethodMetadata hookMethodInfo, BeforeTestDiscoveryContext context, Func<ValueTask> action)\n    {\n        Console.WriteLine($"Before test discovery hook: {hookMethodInfo.MethodName}");\n        await action();\n    }\n\n    public async ValueTask ExecuteBeforeTestSessionHook(MethodMetadata hookMethodInfo, TestSessionContext context, Func<ValueTask> action)\n    {\n        Console.WriteLine($"Before test session hook: {hookMethodInfo.MethodName}");\n        await action();\n    }\n\n    public async ValueTask ExecuteBeforeAssemblyHook(MethodMetadata hookMethodInfo, AssemblyHookContext context, Func<ValueTask> action)\n    {\n        Console.WriteLine($"Before assembly hook: {hookMethodInfo.MethodName}");\n        await action();\n    }\n\n    public async ValueTask ExecuteBeforeClassHook(MethodMetadata hookMethodInfo, ClassHookContext context, Func<ValueTask> action)\n    {\n        Console.WriteLine($"Before class hook: {hookMethodInfo.MethodName} for class {context.TestClassType.Name}");\n\n        try\n        {\n            await action();\n        }\n        catch (Exception ex)\n        {\n            Console.WriteLine($"Hook failed: {ex.Message}");\n            throw;\n        }\n    }\n\n    public async ValueTask ExecuteBeforeTestHook(MethodMetadata hookMethodInfo, TestContext context, Func<ValueTask> action)\n    {\n        Console.WriteLine($"Before test hook: {hookMethodInfo.MethodName} for test {context.TestDetails.TestName}");\n        await action();\n    }\n\n    public async ValueTask ExecuteAfterTestDiscoveryHook(MethodMetadata hookMethodInfo, TestDiscoveryContext context, Func<ValueTask> action)\n    {\n        await action();\n        Console.WriteLine($"After test discovery hook: {hookMethodInfo.MethodName}");\n    }\n\n    public async ValueTask ExecuteAfterTestSessionHook(MethodMetadata hookMethodInfo, TestSessionContext context, Func<ValueTask> action)\n    {\n        await action();\n        Console.WriteLine($"After test session hook: {hookMethodInfo.MethodName}");\n    }\n\n    public async ValueTask ExecuteAfterAssemblyHook(MethodMetadata hookMethodInfo, AssemblyHookContext context, Func<ValueTask> action)\n    {\n        await action();\n        Console.WriteLine($"After assembly hook: {hookMethodInfo.MethodName}");\n    }\n\n    public async ValueTask ExecuteAfterClassHook(MethodMetadata hookMethodInfo, ClassHookContext context, Func<ValueTask> action)\n    {\n        await action();\n        Console.WriteLine($"After class hook: {hookMethodInfo.MethodName} for class {context.TestClassType.Name}");\n    }\n\n    public async ValueTask ExecuteAfterTestHook(MethodMetadata hookMethodInfo, TestContext context, Func<ValueTask> action)\n    {\n        await action();\n        Console.WriteLine($"After test hook: {hookMethodInfo.MethodName} for test {context.TestDetails.TestName}");\n    }\n}\n'})}),"\n",(0,a.jsx)(t.h2,{id:"event-receivers",children:"Event Receivers"}),"\n",(0,a.jsx)(t.p,{children:"TUnit provides several event receiver interfaces that allow you to hook into different stages of the test lifecycle:"}),"\n",(0,a.jsx)(t.h3,{id:"itestdiscoveryeventreceiver",children:"ITestDiscoveryEventReceiver"}),"\n",(0,a.jsx)(t.p,{children:"Notified when a test is discovered during the discovery phase."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-csharp",children:"public interface ITestDiscoveryEventReceiver\n{\n    ValueTask OnTestDiscovered(DiscoveredTestContext context);\n}\n"})}),"\n",(0,a.jsx)(t.h3,{id:"itestregisteredeventreceiver",children:"ITestRegisteredEventReceiver"}),"\n",(0,a.jsx)(t.p,{children:"Notified when a test is registered with the test engine."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-csharp",children:"public interface ITestRegisteredEventReceiver\n{\n    ValueTask OnTestRegistered(TestRegisteredContext context);\n}\n"})}),"\n",(0,a.jsx)(t.h3,{id:"iteststarteventreceiver",children:"ITestStartEventReceiver"}),"\n",(0,a.jsx)(t.p,{children:"Notified when a test starts execution."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-csharp",children:"public interface ITestStartEventReceiver\n{\n    ValueTask OnTestStart(TestContext context);\n}\n"})}),"\n",(0,a.jsx)(t.h3,{id:"itestendeventreceiver",children:"ITestEndEventReceiver"}),"\n",(0,a.jsx)(t.p,{children:"Notified when a test completes execution."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-csharp",children:"public interface ITestEndEventReceiver\n{\n    ValueTask OnTestEnd(TestContext context);\n}\n"})}),"\n",(0,a.jsx)(t.h3,{id:"itestretryeventreceiver",children:"ITestRetryEventReceiver"}),"\n",(0,a.jsx)(t.p,{children:"Notified when a test is retried."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-csharp",children:"public interface ITestRetryEventReceiver\n{\n    ValueTask OnTestRetry(TestContext context, int retryAttempt);\n}\n"})}),"\n",(0,a.jsx)(t.h3,{id:"example-event-receiver-implementation",children:"Example Event Receiver Implementation"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-csharp",children:"[AttributeUsage(AttributeTargets.Assembly | AttributeTargets.Class | AttributeTargets.Method)]\npublic class TestReporterAttribute : Attribute, ITestStartEventReceiver, ITestEndEventReceiver\n{\n    public int Order => 0;\n\n    public async ValueTask OnTestStart(TestContext context)\n    {\n        await ReportingService.ReportTestStarted(\n            context.GetDisplayName(),\n            context.TestDetails.TestClass?.FullName,\n            context.TestDetails.TestMethodArguments\n        );\n    }\n\n    public async ValueTask OnTestEnd(TestContext context)\n    {\n        await ReportingService.ReportTestCompleted(\n            context.GetDisplayName(),\n            context.Result?.State,\n            context.Result?.Duration,\n            context.Result?.Exception?.Message\n        );\n    }\n}\n"})}),"\n",(0,a.jsx)(t.h3,{id:"registering-event-receivers",children:"Registering Event Receivers"}),"\n",(0,a.jsx)(t.p,{children:"Event receivers are registered by implementing the interfaces in an attribute class, then applying that attribute at the assembly, class, or method level:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-csharp",children:'// Create an attribute that implements the event receiver interfaces\n[AttributeUsage(AttributeTargets.Assembly | AttributeTargets.Class | AttributeTargets.Method)]\npublic class CustomEventReceiverAttribute : Attribute, ITestStartEventReceiver, ITestEndEventReceiver\n{\n    public int Order => 0;\n    \n    public ValueTask OnTestStart(TestContext context)\n    {\n        Console.WriteLine($"Test starting: {context.GetDisplayName()}");\n        return default;\n    }\n    \n    public ValueTask OnTestEnd(TestContext context)\n    {\n        Console.WriteLine($"Test ended: {context.GetDisplayName()} - {context.Result?.State}");\n        return default;\n    }\n}\n\n// Apply at assembly level\n[assembly: CustomEventReceiver]\n\n// Or at class level\n[CustomEventReceiver]\npublic class MyTestClass\n{\n    [Test]\n    public async Task MyTest() { }\n}\n\n// Or at method level\n[Test]\n[CustomEventReceiver]\npublic async Task MyTest() { }\n'})}),"\n",(0,a.jsx)(t.h2,{id:"parallel-execution-control",children:"Parallel Execution Control"}),"\n",(0,a.jsx)(t.h3,{id:"iparallellimit",children:"IParallelLimit"}),"\n",(0,a.jsx)(t.p,{children:"Controls the maximum degree of parallelism for tests."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-csharp",children:"public interface IParallelLimit\n{\n    int Limit { get; }\n}\n"})}),"\n",(0,a.jsx)(t.p,{children:"Example:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-csharp",children:"public class DatabaseParallelLimit : IParallelLimit\n{\n    public int Limit => 5; // Max 5 database tests in parallel\n}\n\n[ParallelLimiter<DatabaseParallelLimit>]\npublic class DatabaseTests\n{\n    // All tests in this class will be limited to 5 parallel executions\n}\n"})}),"\n",(0,a.jsx)(t.h3,{id:"iparallelconstraint",children:"IParallelConstraint"}),"\n",(0,a.jsx)(t.p,{children:"Defines constraints for parallel execution. This is a marker interface with no members - it's used to identify types that represent parallel execution constraints."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-csharp",children:"public interface IParallelConstraint\n{\n}\n"})}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"Note"}),": ",(0,a.jsx)(t.code,{children:"IParallelConstraint"})," is a marker interface. The actual constraint logic is handled by TUnit's built-in constraint implementations like ",(0,a.jsx)(t.code,{children:"NotInParallelConstraint"})," and ",(0,a.jsx)(t.code,{children:"ParallelGroupConstraint"}),"."]}),"\n",(0,a.jsx)(t.p,{children:"Example:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-csharp",children:'public class FileAccessTests\n{\n    [Test]\n    [NotInParallel("SharedFile")]\n    public async Task Test1()\n    {\n        // This test won\'t run in parallel with other tests\n        // that have the same constraint key "SharedFile"\n        await File.WriteAllTextAsync("shared.txt", "test1");\n    }\n\n    [Test]\n    [NotInParallel("SharedFile")]\n    public async Task Test2()\n    {\n        // This test won\'t run in parallel with Test1\n        // because they share the same constraint key\n        await File.WriteAllTextAsync("shared.txt", "test2");\n    }\n\n    [Test]\n    [NotInParallel("Database")]\n    public async Task Test3()\n    {\n        // This test can run in parallel with Test1 and Test2\n        // because it has a different constraint key\n        await Database.ExecuteAsync("UPDATE users SET status = \'active\'");\n    }\n}\n'})}),"\n",(0,a.jsxs)(t.p,{children:["You can also use the ",(0,a.jsx)(t.code,{children:"NotInParallel"})," attribute without arguments to ensure tests don't run in parallel with any other tests:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-csharp",children:"[Test]\n[NotInParallel]\npublic async Task GloballySerializedTest()\n{\n    // This test won't run in parallel with any other tests\n    // marked with [NotInParallel] (no constraint key)\n}\n"})}),"\n",(0,a.jsx)(t.h2,{id:"iasyncinitializer",children:"IAsyncInitializer"}),"\n",(0,a.jsx)(t.p,{children:"Provides async initialization support for test classes."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-csharp",children:"public interface IAsyncInitializer\n{\n    Task InitializeAsync();\n}\n"})}),"\n",(0,a.jsx)(t.p,{children:"Example:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-csharp",children:'public class DatabaseTests : IAsyncInitializer\n{\n    private DatabaseConnection _connection;\n\n    public async Task InitializeAsync()\n    {\n        _connection = await DatabaseConnection.CreateAsync();\n        await _connection.MigrateAsync();\n    }\n\n    [Test]\n    public async Task TestDatabaseOperation()\n    {\n        // _connection is guaranteed to be initialized\n        await _connection.ExecuteAsync("SELECT 1");\n    }\n}\n'})}),"\n",(0,a.jsx)(t.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,a.jsxs)(t.ol,{children:["\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"Keep Extensions Focused"}),": Each extension should have a single, clear responsibility."]}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"Handle Exceptions Gracefully"}),": Always wrap the execution of the original body in try-catch blocks."]}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"Avoid State"}),": Extensions should be stateless when possible. If state is needed, ensure it's thread-safe."]}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"Document Behavior"}),": Clearly document what your extension does and any side effects."]}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"Test Your Extensions"}),": Write tests for your custom extensions to ensure they behave correctly."]}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"Consider Performance"}),": Extensions run for every test, so keep them lightweight."]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(t.h2,{id:"common-use-cases",children:"Common Use Cases"}),"\n",(0,a.jsx)(t.h3,{id:"cross-cutting-concerns",children:"Cross-Cutting Concerns"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Logging and telemetry"}),"\n",(0,a.jsx)(t.li,{children:"Performance monitoring"}),"\n",(0,a.jsx)(t.li,{children:"Resource management"}),"\n",(0,a.jsx)(t.li,{children:"Security context setup"}),"\n"]}),"\n",(0,a.jsx)(t.h3,{id:"integration-testing",children:"Integration Testing"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Database transaction management"}),"\n",(0,a.jsx)(t.li,{children:"HTTP client configuration"}),"\n",(0,a.jsx)(t.li,{children:"Mock server setup/teardown"}),"\n",(0,a.jsx)(t.li,{children:"Container orchestration"}),"\n"]}),"\n",(0,a.jsx)(t.h3,{id:"compliance-and-auditing",children:"Compliance and Auditing"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Test execution auditing"}),"\n",(0,a.jsx)(t.li,{children:"Compliance logging"}),"\n",(0,a.jsx)(t.li,{children:"Screenshot capture for UI tests"}),"\n",(0,a.jsx)(t.li,{children:"Result archival"}),"\n"]}),"\n",(0,a.jsx)(t.h2,{id:"example-database-transaction-extension",children:"Example: Database Transaction Extension"}),"\n",(0,a.jsx)(t.p,{children:"Here's a complete example that wraps each test in a database transaction:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-csharp",children:'public class TransactionalTestExecutor : ITestExecutor\n{\n    public async ValueTask ExecuteTest(TestContext context, Func<ValueTask> action)\n    {\n        // Get the database connection from DI\n        var dbContext = context.GetService<ApplicationDbContext>();\n\n        using var transaction = await dbContext.Database.BeginTransactionAsync();\n\n        try\n        {\n            await action();\n\n            // Rollback instead of commit to keep tests isolated\n            await transaction.RollbackAsync();\n        }\n        catch\n        {\n            await transaction.RollbackAsync();\n            throw;\n        }\n    }\n}\n\n[TestExecutor<TransactionalTestExecutor>]\npublic class DatabaseTests\n{\n    private readonly ApplicationDbContext _dbContext;\n\n    public DatabaseTests(ApplicationDbContext dbContext)\n    {\n        _dbContext = dbContext;\n    }\n\n    [Test]\n    public async Task CreateUser_ShouldAddToDatabase()\n    {\n        // This test runs in a transaction that\'s rolled back\n        var user = new User { Name = "Test User" };\n        _dbContext.Users.Add(user);\n        await _dbContext.SaveChangesAsync();\n\n        var count = await _dbContext.Users.CountAsync();\n        await Assert.That(count).IsEqualTo(1);\n    }\n}\n'})}),"\n",(0,a.jsx)(t.p,{children:"This ensures that each test runs in isolation without affecting the database state."})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>c});var s=n(6540);const a={},i=s.createContext(a);function o(e){const t=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),s.createElement(i.Provider,{value:t},e.children)}}}]);