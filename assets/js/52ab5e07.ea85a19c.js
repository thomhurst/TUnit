"use strict";(self.webpackChunktunit_docs_site=self.webpackChunktunit_docs_site||[]).push([[3274],{7284:(e,s,t)=>{t.r(s),t.d(s,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>n,toc:()=>c});const n=JSON.parse('{"id":"assertions/extensibility/create-assertion-attribute","title":"CreateAssertion Attribute","description":"The [CreateAssertion] attribute provides a powerful way to automatically generate assertion extension methods from existing methods that return boolean values. This approach eliminates boilerplate code and ensures consistency across your assertion library.","source":"@site/docs/assertions/extensibility/create-assertion-attribute.md","sourceDirName":"assertions/extensibility","slug":"/assertions/extensibility/create-assertion-attribute","permalink":"/docs/assertions/extensibility/create-assertion-attribute","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4}}');var i=t(4848),r=t(8453);const a={sidebar_position:4},o="CreateAssertion Attribute",l={},c=[{value:"Overview",id:"overview",level:2},{value:"Basic Usage",id:"basic-usage",level:2},{value:"Instance Methods",id:"instance-methods",level:3},{value:"Static Methods",id:"static-methods",level:3},{value:"Advanced Features",id:"advanced-features",level:2},{value:"Custom Names",id:"custom-names",level:3},{value:"Negative Assertions",id:"negative-assertions",level:3},{value:"Multiple Assertions on One Class",id:"multiple-assertions-on-one-class",level:3},{value:"Attribute Properties",id:"attribute-properties",level:2},{value:"Constructor Parameters",id:"constructor-parameters",level:3},{value:"Optional Properties",id:"optional-properties",level:3},{value:"Complete Examples",id:"complete-examples",level:2},{value:"Example 1: DateTime Assertions",id:"example-1-datetime-assertions",level:3},{value:"Example 2: File System Assertions",id:"example-2-file-system-assertions",level:3},{value:"Example 3: Custom Type Assertions",id:"example-3-custom-type-assertions",level:3},{value:"Benefits",id:"benefits",level:2},{value:"Requirements",id:"requirements",level:2},{value:"Migration from Manual Assertions",id:"migration-from-manual-assertions",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"Limitations",id:"limitations",level:2}];function d(e){const s={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s.header,{children:(0,i.jsx)(s.h1,{id:"createassertion-attribute",children:"CreateAssertion Attribute"})}),"\n",(0,i.jsxs)(s.p,{children:["The ",(0,i.jsx)(s.code,{children:"[CreateAssertion<T>]"})," attribute provides a powerful way to automatically generate assertion extension methods from existing methods that return boolean values. This approach eliminates boilerplate code and ensures consistency across your assertion library."]}),"\n",(0,i.jsx)(s.h2,{id:"overview",children:"Overview"}),"\n",(0,i.jsxs)(s.p,{children:["The ",(0,i.jsx)(s.code,{children:"[CreateAssertion<T>]"})," attribute is a source generator feature that:"]}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"Automatically creates assertion extension methods from existing boolean-returning methods"}),"\n",(0,i.jsx)(s.li,{children:"Supports both instance and static methods"}),"\n",(0,i.jsx)(s.li,{children:"Can generate both positive and negative assertions"}),"\n",(0,i.jsx)(s.li,{children:"Maintains full IntelliSense support and compile-time safety"}),"\n"]}),"\n",(0,i.jsx)(s.h2,{id:"basic-usage",children:"Basic Usage"}),"\n",(0,i.jsx)(s.h3,{id:"instance-methods",children:"Instance Methods"}),"\n",(0,i.jsx)(s.p,{children:"For methods that exist on the type being asserted:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-csharp",children:"using TUnit.Assertions.Attributes;\n\n[CreateAssertion<string>(nameof(string.StartsWith))]\n[CreateAssertion<string>(nameof(string.EndsWith))]\n[CreateAssertion<string>(nameof(string.Contains))]\npublic static partial class StringAssertionExtensions;\n"})}),"\n",(0,i.jsx)(s.p,{children:"This generates assertion methods that can be used as:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-csharp",children:'await Assert.That("Hello World").StartsWith("Hello");\nawait Assert.That("Hello World").EndsWith("World");\nawait Assert.That("Hello World").Contains("lo Wo");\n'})}),"\n",(0,i.jsx)(s.h3,{id:"static-methods",children:"Static Methods"}),"\n",(0,i.jsx)(s.p,{children:"For static methods that take the asserted type as a parameter:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-csharp",children:'using System.IO;\nusing TUnit.Assertions.Attributes;\n\n[CreateAssertion<string>(typeof(Path), nameof(Path.IsPathRooted), CustomName = "IsRootedPath")]\npublic static partial class PathAssertionExtensions;\n'})}),"\n",(0,i.jsx)(s.p,{children:"Usage:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-csharp",children:'await Assert.That(@"C:\\Users\\Documents").IsRootedPath();\n'})}),"\n",(0,i.jsx)(s.h2,{id:"advanced-features",children:"Advanced Features"}),"\n",(0,i.jsx)(s.h3,{id:"custom-names",children:"Custom Names"}),"\n",(0,i.jsxs)(s.p,{children:["You can specify custom names for generated methods using the ",(0,i.jsx)(s.code,{children:"CustomName"})," property:"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-csharp",children:'[CreateAssertion<char>(nameof(char.IsDigit))]\n[CreateAssertion<char>(nameof(char.IsDigit), CustomName = "IsNumeric")]  // Alias\npublic static partial class CharAssertionExtensions;\n'})}),"\n",(0,i.jsx)(s.h3,{id:"negative-assertions",children:"Negative Assertions"}),"\n",(0,i.jsxs)(s.p,{children:["Generate negative assertions by setting ",(0,i.jsx)(s.code,{children:"NegateLogic = true"}),":"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-csharp",children:'[CreateAssertion<string>(nameof(string.Contains))]\n[CreateAssertion<string>(nameof(string.Contains), CustomName = "DoesNotContain", NegateLogic = true)]\npublic static partial class StringAssertionExtensions;\n'})}),"\n",(0,i.jsx)(s.p,{children:"Usage:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-csharp",children:'await Assert.That("Hello").Contains("ell");        // Passes\nawait Assert.That("Hello").DoesNotContain("xyz");  // Passes\n'})}),"\n",(0,i.jsx)(s.h3,{id:"multiple-assertions-on-one-class",children:"Multiple Assertions on One Class"}),"\n",(0,i.jsx)(s.p,{children:"You can apply multiple attributes to generate a comprehensive set of assertions:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-csharp",children:'[CreateAssertion<char>(nameof(char.IsDigit))]\n[CreateAssertion<char>(nameof(char.IsDigit), CustomName = "IsNotDigit", NegateLogic = true)]\n[CreateAssertion<char>(nameof(char.IsLetter))]\n[CreateAssertion<char>(nameof(char.IsLetter), CustomName = "IsNotLetter", NegateLogic = true)]\n[CreateAssertion<char>(nameof(char.IsLetterOrDigit))]\n[CreateAssertion<char>(nameof(char.IsLetterOrDigit), CustomName = "IsNotLetterOrDigit", NegateLogic = true)]\n[CreateAssertion<char>(nameof(char.IsWhiteSpace))]\n[CreateAssertion<char>(nameof(char.IsWhiteSpace), CustomName = "IsNotWhiteSpace", NegateLogic = true)]\npublic static partial class CharAssertionExtensions;\n'})}),"\n",(0,i.jsx)(s.h2,{id:"attribute-properties",children:"Attribute Properties"}),"\n",(0,i.jsx)(s.h3,{id:"constructor-parameters",children:"Constructor Parameters"}),"\n",(0,i.jsxs)(s.ol,{children:["\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"Single Parameter Constructor"})," - For instance methods on the target type:"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-csharp",children:"[CreateAssertion<TTarget>(string methodName)]\n"})}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"Two Parameter Constructor"})," - For static methods on a different type:"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-csharp",children:"[CreateAssertion<TTarget>(Type containingType, string methodName)]\n"})}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(s.h3,{id:"optional-properties",children:"Optional Properties"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:(0,i.jsx)(s.code,{children:"CustomName"})}),": Override the generated method name"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:(0,i.jsx)(s.code,{children:"NegateLogic"})}),": Invert the boolean result for negative assertions"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:(0,i.jsx)(s.code,{children:"RequiresGenericTypeParameter"})}),": For methods that need generic type handling"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:(0,i.jsx)(s.code,{children:"TreatAsInstance"})}),": Force treating a static method as instance (useful for extension methods)"]}),"\n"]}),"\n",(0,i.jsx)(s.h2,{id:"complete-examples",children:"Complete Examples"}),"\n",(0,i.jsx)(s.h3,{id:"example-1-datetime-assertions",children:"Example 1: DateTime Assertions"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-csharp",children:'using System;\nusing TUnit.Assertions.Attributes;\n\n[CreateAssertion<DateTime>(nameof(DateTime.IsLeapYear), CustomName = "IsInLeapYear")]\n[CreateAssertion<DateTime>(nameof(DateTime.IsLeapYear), CustomName = "IsNotInLeapYear", NegateLogic = true)]\n[CreateAssertion<DateTime>(nameof(DateTime.IsDaylightSavingTime))]\n[CreateAssertion<DateTime>(nameof(DateTime.IsDaylightSavingTime), CustomName = "IsNotDaylightSavingTime", NegateLogic = true)]\npublic static partial class DateTimeAssertionExtensions;\n'})}),"\n",(0,i.jsx)(s.h3,{id:"example-2-file-system-assertions",children:"Example 2: File System Assertions"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-csharp",children:'using System.IO;\nusing TUnit.Assertions.Attributes;\n\n[CreateAssertion<FileInfo>(nameof(FileInfo.Exists))]\n[CreateAssertion<FileInfo>(nameof(FileInfo.Exists), CustomName = "DoesNotExist", NegateLogic = true)]\n[CreateAssertion<FileInfo>(nameof(FileInfo.IsReadOnly))]\n[CreateAssertion<FileInfo>(nameof(FileInfo.IsReadOnly), CustomName = "IsNotReadOnly", NegateLogic = true)]\npublic static partial class FileInfoAssertionExtensions;\n'})}),"\n",(0,i.jsx)(s.p,{children:"Usage:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-csharp",children:'var file = new FileInfo(@"C:\\temp\\test.txt");\nawait Assert.That(file).Exists();\nawait Assert.That(file).IsNotReadOnly();\n'})}),"\n",(0,i.jsx)(s.h3,{id:"example-3-custom-type-assertions",children:"Example 3: Custom Type Assertions"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-csharp",children:'// Your custom type\npublic class User\n{\n    public bool IsActive { get; set; }\n    public bool IsVerified { get; set; }\n    public bool HasPremiumAccess() => /* logic */;\n}\n\n// Assertion extensions\n[CreateAssertion<User>(nameof(User.IsActive))]\n[CreateAssertion<User>(nameof(User.IsActive), CustomName = "IsInactive", NegateLogic = true)]\n[CreateAssertion<User>(nameof(User.IsVerified))]\n[CreateAssertion<User>(nameof(User.HasPremiumAccess))]\npublic static partial class UserAssertionExtensions;\n\n// Usage\nvar user = new User { IsActive = true, IsVerified = false };\nawait Assert.That(user).IsActive();\nawait Assert.That(user).IsNotVerified();\n'})}),"\n",(0,i.jsx)(s.h2,{id:"benefits",children:"Benefits"}),"\n",(0,i.jsxs)(s.ol,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Reduced Boilerplate"}),": No need to write repetitive assertion methods"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Consistency"}),": All generated assertions follow the same pattern"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Type Safety"}),": Full compile-time checking and IntelliSense support"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Maintainability"}),": Changes to the source method signature are automatically reflected"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Performance"}),": Source-generated code has no runtime overhead"]}),"\n"]}),"\n",(0,i.jsx)(s.h2,{id:"requirements",children:"Requirements"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["The target method must return a ",(0,i.jsx)(s.code,{children:"bool"})]}),"\n",(0,i.jsxs)(s.li,{children:["The containing class must be ",(0,i.jsx)(s.code,{children:"partial"})]}),"\n",(0,i.jsxs)(s.li,{children:["The containing class must be ",(0,i.jsx)(s.code,{children:"static"})," for extension methods"]}),"\n",(0,i.jsx)(s.li,{children:"The method parameters must be compatible with the assertion pattern"}),"\n"]}),"\n",(0,i.jsx)(s.h2,{id:"migration-from-manual-assertions",children:"Migration from Manual Assertions"}),"\n",(0,i.jsxs)(s.p,{children:["If you have existing manual assertion methods, you can gradually migrate to using ",(0,i.jsx)(s.code,{children:"[CreateAssertion<T>]"}),":"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-csharp",children:"// Before - Manual implementation\npublic static InvokableValueAssertionBuilder<string> StartsWith(\n    this IValueSource<string> valueSource, \n    string expected)\n{\n    return valueSource.RegisterAssertion(\n        new StringStartsWithCondition(expected),\n        [expected]);\n}\n\n// After - Using CreateAssertion\n[CreateAssertion<string>(nameof(string.StartsWith))]\npublic static partial class StringAssertionExtensions;\n"})}),"\n",(0,i.jsx)(s.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,i.jsxs)(s.ol,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Group Related Assertions"}),": Keep assertions for similar types in the same partial class"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Consistent Naming"}),": Use ",(0,i.jsx)(s.code,{children:"CustomName"})," to maintain consistent naming patterns"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Provide Both Positive and Negative"}),": Where it makes sense, provide both forms"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Document Complex Cases"}),": Add XML documentation comments to the partial class for complex scenarios"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Test Generated Code"}),": Ensure generated assertions behave as expected"]}),"\n"]}),"\n",(0,i.jsx)(s.h2,{id:"limitations",children:"Limitations"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["Only works with methods that return ",(0,i.jsx)(s.code,{children:"bool"})]}),"\n",(0,i.jsx)(s.li,{children:"Cannot handle methods with complex parameter patterns"}),"\n",(0,i.jsx)(s.li,{children:"Generic constraints on the method itself may require manual implementation"}),"\n",(0,i.jsx)(s.li,{children:"Methods with optional parameters may need special handling"}),"\n"]}),"\n",(0,i.jsxs)(s.p,{children:["For cases that can't be handled by ",(0,i.jsx)(s.code,{children:"[CreateAssertion<T>]"}),", you can still write manual assertion methods alongside the generated ones in the same partial class."]})]})}function h(e={}){const{wrapper:s}={...(0,r.R)(),...e.components};return s?(0,i.jsx)(s,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,s,t)=>{t.d(s,{R:()=>a,x:()=>o});var n=t(6540);const i={},r=n.createContext(i);function a(e){const s=n.useContext(r);return n.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function o(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),n.createElement(r.Provider,{value:s},e.children)}}}]);