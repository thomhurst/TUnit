"use strict";(self.webpackChunktunit_docs_site=self.webpackChunktunit_docs_site||[]).push([[3458],{5577:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>h,frontMatter:()=>i,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"test-authoring/depends-on","title":"Depends On","description":"Important","source":"@site/docs/test-authoring/depends-on.md","sourceDirName":"test-authoring","slug":"/test-authoring/depends-on","permalink":"/docs/test-authoring/depends-on","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"docs","previous":{"title":"Explicit","permalink":"/docs/test-authoring/explicit"},"next":{"title":"Ordering Tests","permalink":"/docs/test-authoring/order"}}');var r=t(4848),o=t(8453);const i={},a="Depends On",d={},l=[{value:"Getting other tests",id:"getting-other-tests",level:2},{value:"Failures",id:"failures",level:2}];function c(e){const n={admonition:"admonition",br:"br",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"depends-on",children:"Depends On"})}),"\n",(0,r.jsxs)(n.admonition,{title:"Test Isolation Best Practice",type:"warning",children:[(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Important"}),": Tests should ideally be self-contained, isolated, and side-effect free. This ensures they are:"]}),(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Reliable and repeatable"}),"\n",(0,r.jsx)(n.li,{children:"Can run in any order"}),"\n",(0,r.jsx)(n.li,{children:"Easy to understand and maintain"}),"\n",(0,r.jsx)(n.li,{children:"Fast to execute"}),"\n"]}),(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"[DependsOn]"})," feature should only be used for systems where creating stateless tests is:"]}),(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Impossible (e.g., testing deployment pipelines)"}),"\n",(0,r.jsx)(n.li,{children:"Extremely difficult (e.g., complex multi-step workflows)"}),"\n",(0,r.jsx)(n.li,{children:"Too slow (e.g., expensive setup that must be shared)"}),"\n"]}),(0,r.jsxs)(n.p,{children:["Before using ",(0,r.jsx)(n.code,{children:"[DependsOn]"}),", consider if you can refactor your tests to be independent by using proper setup/teardown methods or test fixtures."]})]}),"\n",(0,r.jsx)(n.p,{children:"A test can depend on another test. This means that your test will not start unless the other test has finished."}),"\n",(0,r.jsxs)(n.p,{children:["To do this, add a  ",(0,r.jsx)(n.code,{children:"[DependsOn]"})," to your test."]}),"\n",(0,r.jsxs)(n.p,{children:["This takes a test name, which you can easily reference by using the ",(0,r.jsx)(n.code,{children:"nameof(TestMethod)"})," keyword."]}),"\n",(0,r.jsx)(n.admonition,{type:"info",children:(0,r.jsxs)(n.p,{children:["If you have multiple tests with the same name, but different parameter types, then you you must include the types of parameters in the ",(0,r.jsx)(n.code,{children:"[DependsOn]"})," attribute too so TUnit can locate the correct test."]})}),"\n",(0,r.jsx)(n.p,{children:"e.g.:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"public void Test1(string value1, int value2) { ... }\n\n[DependsOn(nameof(Test1), new[] { typeof(string), typeof(int) })]\npublic void Test2() { ... }\n"})}),"\n",(0,r.jsx)(n.p,{children:"This means you can create more complex test suites, without having to compromise on parallelism or speed."}),"\n",(0,r.jsx)(n.p,{children:"For example, performing some operations on a database and asserting a count at the end:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"[Test]\npublic async Task AddUser1() \n{\n    ...\n}\n\n[Test]\npublic async Task AddUser2() \n{\n    ...\n}\n\n[Test]\npublic async Task AddUser3() \n{\n    ...\n}\n\n[Test]\npublic async Task AddUser4() \n{\n    ...\n}\n\n[Test]\npublic async Task AddUser5() \n{\n    ...\n}\n\n[Test, DependsOn(nameof(AddUser1))]\npublic async Task AddItemToBagForUser1() \n{\n    ...\n}\n\n[Test, DependsOn(nameof(AddUser2))]\npublic async Task AddItemToBagForUser2() \n{\n    ...\n}\n\n[Test, DependsOn(nameof(AddUser3))]\npublic async Task AddItemToBagForUser3() \n{\n    ...\n}\n\n[Test]\n[DependsOn(nameof(AddUser4))]\n[DependsOn(nameof(AddUser5))]\n[DependsOn(nameof(AddItemToBagForUser1))]\n[DependsOn(nameof(AddItemToBagForUser2))]\n[DependsOn(nameof(AddItemToBagForUser3))]\npublic async Task AssertItemsInDatabase() \n{\n    ...\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"getting-other-tests",children:"Getting other tests"}),"\n",(0,r.jsx)(n.p,{children:"If your tests depends on another test, it's possible to retrieve that test's context. This allows you to do things like check its result, or retrieve objects from its object bag."}),"\n",(0,r.jsxs)(n.p,{children:["This is done by calling the ",(0,r.jsx)(n.code,{children:"GetTests"})," method on a ",(0,r.jsx)(n.code,{children:"TestContext"})," object. It takes the test's method name (so you can use ",(0,r.jsx)(n.code,{children:"nameof(...)"}),") and optionally the parameter types for if there's multiple overloads."]}),"\n",(0,r.jsx)(n.p,{children:"You'll notice this returns an array - This is because tests may be data driven and be invoked multiple times - If this is the case you'll have to find the one you want yourself."}),"\n",(0,r.jsx)(n.admonition,{type:"info",children:(0,r.jsxs)(n.p,{children:["For data-driven tests (e.g., with ",(0,r.jsx)(n.code,{children:"[Arguments]"})," or ",(0,r.jsx)(n.code,{children:"[MethodDataSource]"}),"), ",(0,r.jsx)(n.code,{children:"GetTests"})," returns all invocations.",(0,r.jsx)(n.br,{}),"\n","Use argument values or other properties to select the specific test context you need."]})}),"\n",(0,r.jsx)(n.p,{children:"Example:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:'[Test]\npublic async Task AddItemToBag() \n{\n    var itemId = await AddToBag();\n    TestContext.Current!.ObjectBag.Add("ItemId", itemId);\n}\n\n[Test]\n[DependsOn(nameof(AddItemToBag))]\npublic async Task DeleteItemFromBag() \n{\n    var addToBagTestContext = TestContext.Current!.GetTests(nameof(AddItemToBag)).First();\n    var itemId = addToBagTestContext.ObjectBag["ItemId"];\n    await DeleteFromBag(itemId);\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"failures",children:"Failures"}),"\n",(0,r.jsxs)(n.p,{children:["If your test depends on another test, by default, if that dependency fails, then your test that depends on it will not start. This can be bypassed by adding the property ",(0,r.jsx)(n.code,{children:"ProceedOnFailure = true"})," to the ",(0,r.jsx)(n.code,{children:"DependsOnAttribute"}),". Your test suite will still fail due to that test, but it allows you to proceed with other tests if you require it. For example, CRUD testing, and wanting to perform a delete after all your other tests, regardless of if they passed."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"[Test]\npublic async Task Test1() \n{\n    ...\n}\n\n[Test]\n[DependsOn(nameof(Test1), ProceedOnFailure = true)]\npublic async Task Test2() \n{\n    ...\n}\n"})})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>a});var s=t(6540);const r={},o=s.createContext(r);function i(e){const n=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),s.createElement(o.Provider,{value:n},e.children)}}}]);