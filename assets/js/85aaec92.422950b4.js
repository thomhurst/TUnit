"use strict";(self.webpackChunktunit_docs_site=self.webpackChunktunit_docs_site||[]).push([[9081],{6273:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>a,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"tutorial-extras/cleanup","title":"Test Clean Ups","description":"TUnit supports having your test class implement IDisposable or IAsyncDisposable. These will be called after your test has finished executing. However, using the attributes below offers better support for running multiple methods, and without having to implement your own try/catch logic. Every [After] method will be run, and any exceptions will be lazily thrown afterwards.","source":"@site/docs/tutorial-extras/cleanup.md","sourceDirName":"tutorial-extras","slug":"/tutorial-extras/cleanup","permalink":"/TUnit/docs/tutorial-extras/cleanup","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"Test Set Ups","permalink":"/TUnit/docs/tutorial-extras/setup"},"next":{"title":"Retrying","permalink":"/TUnit/docs/tutorial-extras/retrying"}}');var n=s(4848),i=s(8453);const a={sidebar_position:2},l="Test Clean Ups",o={},c=[{value:"[After(HookType)]",id:"afterhooktype",level:2},{value:"[After(Test)]",id:"aftertest",level:3},{value:"[After(Class)]",id:"afterclass",level:3},{value:"[After(Assembly)]",id:"afterassembly",level:3},{value:"[After(TestSession)]",id:"aftertestsession",level:3},{value:"[After(TestDiscovery)]",id:"aftertestdiscovery",level:3},{value:"[AfterEvery(HookType)]",id:"aftereveryhooktype",level:2},{value:"[AfterEvery(Test)]",id:"aftereverytest",level:3},{value:"[AfterEvery(Class)]",id:"aftereveryclass",level:3},{value:"[AfterEvery(Assembly)]",id:"aftereveryassembly",level:3},{value:"[AfterEvery(TestSession)]",id:"aftereverytestsession",level:3},{value:"[AfterEvery(TestDiscovery)]",id:"aftereverytestdiscovery",level:3}];function d(e){const t={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.header,{children:(0,n.jsx)(t.h1,{id:"test-clean-ups",children:"Test Clean Ups"})}),"\n",(0,n.jsxs)(t.p,{children:["TUnit supports having your test class implement ",(0,n.jsx)(t.code,{children:"IDisposable"})," or ",(0,n.jsx)(t.code,{children:"IAsyncDisposable"}),". These will be called after your test has finished executing. However, using the attributes below offers better support for running multiple methods, and without having to implement your own try/catch logic. Every ",(0,n.jsx)(t.code,{children:"[After]"})," method will be run, and any exceptions will be lazily thrown afterwards."]}),"\n",(0,n.jsxs)(t.p,{children:["You can also declare a method with an ",(0,n.jsx)(t.code,{children:"[After(...)]"})," or an ",(0,n.jsx)(t.code,{children:"[AfterEvery(...)]"})," attribute."]}),"\n",(0,n.jsx)(t.h2,{id:"afterhooktype",children:"[After(HookType)]"}),"\n",(0,n.jsx)(t.h3,{id:"aftertest",children:"[After(Test)]"}),"\n",(0,n.jsx)(t.p,{children:"Must be an instance method. Will be executed after each test in the class it's defined in.\nMethods will be executed top-down, so the current class clean ups will execute first, then the base classes' last."}),"\n",(0,n.jsx)(t.h3,{id:"afterclass",children:"[After(Class)]"}),"\n",(0,n.jsx)(t.p,{children:"Must be a static method. Will run once after the last test in the class it's defined it finishes."}),"\n",(0,n.jsx)(t.h3,{id:"afterassembly",children:"[After(Assembly)]"}),"\n",(0,n.jsx)(t.p,{children:"Must be a static method. Will run once after the last test in the assembly it's defined it finishes."}),"\n",(0,n.jsx)(t.h3,{id:"aftertestsession",children:"[After(TestSession)]"}),"\n",(0,n.jsx)(t.p,{children:"Must be a static method. Will run once after the last test in the test session finishes."}),"\n",(0,n.jsx)(t.h3,{id:"aftertestdiscovery",children:"[After(TestDiscovery)]"}),"\n",(0,n.jsx)(t.p,{children:"Must be a static method. Will run once after tests are discovered."}),"\n",(0,n.jsx)(t.h2,{id:"aftereveryhooktype",children:"[AfterEvery(HookType)]"}),"\n",(0,n.jsxs)(t.p,{children:["All [AfterEvery(...)] methods must be static - And should ideally be placed in their own file that's easy to find, as they can globally affect the test suite, so it should be easy for developers to locate this behaviour.\ne.g. ",(0,n.jsx)(t.code,{children:"GlobalHooks.cs"})," at the root of the test project."]}),"\n",(0,n.jsx)(t.h3,{id:"aftereverytest",children:"[AfterEvery(Test)]"}),"\n",(0,n.jsx)(t.p,{children:"Will be executed after every test that will run in the test session."}),"\n",(0,n.jsx)(t.h3,{id:"aftereveryclass",children:"[AfterEvery(Class)]"}),"\n",(0,n.jsx)(t.p,{children:"Will be executed after the last test of every class that will run in the test session."}),"\n",(0,n.jsx)(t.h3,{id:"aftereveryassembly",children:"[AfterEvery(Assembly)]"}),"\n",(0,n.jsx)(t.p,{children:"Will be executed after the last test of every assembly that will run in the test session."}),"\n",(0,n.jsx)(t.h3,{id:"aftereverytestsession",children:"[AfterEvery(TestSession)]"}),"\n",(0,n.jsx)(t.p,{children:"The same as [After(TestSession)]"}),"\n",(0,n.jsx)(t.h3,{id:"aftereverytestdiscovery",children:"[AfterEvery(TestDiscovery)]"}),"\n",(0,n.jsx)(t.p,{children:"The same as [After(TestDiscovery)]"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-csharp",children:'using TUnit.Core;\n\nnamespace MyTestProject;\n\npublic class MyTestClass\n{\n    private int _value;\n    private static HttpResponseMessage? _pingResponse;\n\n    [After(Class)]\n    public static async Task KillChromedrivers()\n    {\n        await Task.CompletedTask;\n\n        foreach (var process in Process.GetProcessesByName("chromedriver.exe"))\n        {\n            process.Kill();\n        }\n    }\n    \n    [After(Test)]\n    public async Task AfterEachTest()\n    {\n        await new HttpClient().GetAsync($"https://localhost/test-finished-notifier?testName={TestContext.Current.TestInformation.TestName}");\n    }\n\n    [Test]\n    public async Task MyTest()\n    {\n        // Do something\n    }\n}\n'})})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(d,{...e})}):d(e)}},8453:(e,t,s)=>{s.d(t,{R:()=>a,x:()=>l});var r=s(6540);const n={},i=r.createContext(n);function a(e){const t=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:a(e.components),r.createElement(i.Provider,{value:t},e.children)}}}]);