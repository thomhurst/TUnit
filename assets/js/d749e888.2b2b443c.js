"use strict";(self.webpackChunktunit_docs_site=self.webpackChunktunit_docs_site||[]).push([[3322],{5864:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>d,frontMatter:()=>r,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"test-authoring/matrix-tests","title":"Matrix Tests","description":"The Matrix data source is a way to specify different arguments per parameter, and then generate every possible combination of all of those arguments.","source":"@site/docs/test-authoring/matrix-tests.md","sourceDirName":"test-authoring","slug":"/test-authoring/matrix-tests","permalink":"/docs/test-authoring/matrix-tests","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"docs","previous":{"title":"Injectable Class Data Source","permalink":"/docs/test-authoring/class-data-source"},"next":{"title":"Skipping Tests","permalink":"/docs/test-authoring/skip"}}');var i=t(4848),a=t(8453);const r={},l="Matrix Tests",o={},c=[{value:"Matrix Range",id:"matrix-range",level:2},{value:"Matrix Method",id:"matrix-method",level:2},{value:"Matrix Exclusions",id:"matrix-exclusions",level:2}];function u(e){const n={admonition:"admonition",br:"br",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"matrix-tests",children:"Matrix Tests"})}),"\n",(0,i.jsx)(n.p,{children:"The Matrix data source is a way to specify different arguments per parameter, and then generate every possible combination of all of those arguments."}),"\n",(0,i.jsx)(n.admonition,{type:"warning",children:(0,i.jsxs)(n.p,{children:["As your number of arguments and/or parameters increase, the number of test cases will grow exponentially.",(0,i.jsx)(n.br,{}),"\n","For example, 3 parameters with 10 values each will generate 1,000 test cases (10 \xd7 10 \xd7 10).",(0,i.jsx)(n.br,{}),"\n","Use with caution to avoid very large test suites."]})}),"\n",(0,i.jsxs)(n.p,{children:["For our arguments, we'll add a ",(0,i.jsx)(n.code,{children:"[Matrix]"})," attribute. Instead of this being added to the test method, it's added to the parameters themselves."]}),"\n",(0,i.jsxs)(n.p,{children:["And for the test method, we'll add a ",(0,i.jsx)(n.code,{children:"[MatrixDataSource]"})," attribute which contains the logic to extract out all the data from those parameter Matrix attributes."]}),"\n",(0,i.jsx)(n.p,{children:"Here's an example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:"using TUnit.Assertions;\nusing TUnit.Assertions.Extensions;\nusing TUnit.Assertions.Extensions.Is;\nusing TUnit.Core;\n\nnamespace MyTestProject;\n\npublic class MyTestClass\n{\n    [Test]\n    [MatrixDataSource]\n    public async Task MyTest(\n        [Matrix(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)] int value1,\n        [Matrix(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)] int value2\n        )\n    {\n        var result = Add(value1, value2);\n\n        await Assert.That(result).IsPositive();\n    }\n\n    private int Add(int x, int y)\n    {\n        return x + y;\n    }\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"That will generate 100 test cases. 10 different values for value1, and 10 different values for value2. 10*10 is 100."}),"\n",(0,i.jsx)(n.h2,{id:"matrix-range",children:"Matrix Range"}),"\n",(0,i.jsxs)(n.p,{children:["You can also use the ",(0,i.jsx)(n.code,{children:"[MatrixRange<T>]"})," for numerical types. It will generated a range between the minimum and maximum, with an optional step parameter to define how far to step between each value. By default, this is 1."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:"using TUnit.Assertions;\nusing TUnit.Assertions.Extensions;\nusing TUnit.Assertions.Extensions.Is;\nusing TUnit.Core;\n\nnamespace MyTestProject;\n\npublic class MyTestClass\n{\n    [Test]\n    [MatrixDataSource]\n    public async Task MyTest(\n        [MatrixRange<int>(1, 10)] int value1,\n        [MatrixRange<int>(1, 10)] int value2\n        )\n    {\n        var result = Add(value1, value2);\n\n        await Assert.That(result).IsPositive();\n    }\n\n    private int Add(int x, int y)\n    {\n        return x + y;\n    }\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"matrix-method",children:"Matrix Method"}),"\n",(0,i.jsxs)(n.p,{children:["You can also specify a method that will return an ",(0,i.jsx)(n.code,{children:"IEnumerable<T>"})," of values."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:"using TUnit.Assertions;\nusing TUnit.Assertions.Extensions;\nusing TUnit.Assertions.Extensions.Is;\nusing TUnit.Core;\n\nnamespace MyTestProject;\n\npublic class MyTestClass\n{\n    [Test]\n    [MatrixDataSource]\n    public async Task MyTest(\n        [MatrixRange<int>(1, 10)] int value1,\n        [MatrixMethod(nameof(Numbers))] int value2\n        )\n    {\n        var result = Add(value1, value2);\n\n        await Assert.That(result).IsPositive();\n    }\n\n    private int Add(int x, int y)\n    {\n        return x + y;\n    }\n\n    private IEnumerable<int> Numbers()\n    {\n        yield return 1;\n        yield return 2;\n        yield return 3;\n        yield return 4;\n        yield return 5;\n        yield return 6;\n        yield return 7;\n        yield return 8;\n        yield return 9;\n        yield return 10;\n    }\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"matrix-exclusions",children:"Matrix Exclusions"}),"\n",(0,i.jsxs)(n.p,{children:["You can also add a ",(0,i.jsx)(n.code,{children:"[MatrixExclusion(...)]"})," attribute to your tests.\nThis works similar to the ",(0,i.jsx)(n.code,{children:"[Arguments(...)]"})," attribute, and if objects match a generated matrix test case, it'll be ignored."]}),"\n",(0,i.jsxs)(n.p,{children:["This helps you exclude specific one-off scenarios without having to complicate your tests with ",(0,i.jsx)(n.code,{children:"if"})," conditions."]}),"\n",(0,i.jsx)(n.admonition,{type:"info",children:(0,i.jsx)(n.p,{children:"Use exclusions to keep your test matrix manageable and avoid unnecessary or invalid test cases."})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:"using TUnit.Assertions;\nusing TUnit.Assertions.Extensions;\nusing TUnit.Assertions.Extensions.Is;\nusing TUnit.Core;\n\nnamespace MyTestProject;\n\npublic class MyTestClass\n{\n    [Test]\n    [MatrixDataSource]\n    [MatrixExclusion(1, 1)]\n    [MatrixExclusion(2, 2)]\n    [MatrixExclusion(3, 3)]\n    public async Task MyTest(\n        [MatrixRange<int>(1, 3)] int value1,\n        [MatrixRange<int>(1, 3)] int value2\n        )\n    {\n        ...\n    }\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"Whereas the above Matrix would usually generate:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"1, 1"}),"\n",(0,i.jsx)(n.li,{children:"1, 2"}),"\n",(0,i.jsx)(n.li,{children:"1, 3"}),"\n",(0,i.jsx)(n.li,{children:"2, 1"}),"\n",(0,i.jsx)(n.li,{children:"2, 2"}),"\n",(0,i.jsx)(n.li,{children:"2, 3"}),"\n",(0,i.jsx)(n.li,{children:"3, 1"}),"\n",(0,i.jsx)(n.li,{children:"3, 2"}),"\n",(0,i.jsx)(n.li,{children:"3, 3"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Because of the exclusion attributes, it'll only generate:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"1, 2"}),"\n",(0,i.jsx)(n.li,{children:"1, 3"}),"\n",(0,i.jsx)(n.li,{children:"2, 1"}),"\n",(0,i.jsx)(n.li,{children:"2, 3"}),"\n",(0,i.jsx)(n.li,{children:"3, 1"}),"\n",(0,i.jsx)(n.li,{children:"3, 2"}),"\n"]})]})}function d(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(u,{...e})}):u(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>l});var s=t(6540);const i={},a=s.createContext(i);function r(e){const n=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);