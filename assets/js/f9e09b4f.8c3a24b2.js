"use strict";(self.webpackChunktunit_docs_site=self.webpackChunktunit_docs_site||[]).push([[9996],{3251:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"experimental/dynamic-tests","title":"Dynamically Created Tests","description":"TUnit offers the ability to create your tests via dynamic code, as opposed to the standard [Test] attribute and data attributes.","source":"@site/docs/experimental/dynamic-tests.md","sourceDirName":"experimental","slug":"/experimental/dynamic-tests","permalink":"/docs/experimental/dynamic-tests","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"Experimental","permalink":"/docs/category/experimental"},"next":{"title":"FAQ","permalink":"/docs/faq"}}');var a=n(4848),i=n(8453);const r={sidebar_position:1},o="Dynamically Created Tests",c={},d=[];function l(e){const t={code:"code",h1:"h1",header:"header",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.header,{children:(0,a.jsx)(t.h1,{id:"dynamically-created-tests",children:"Dynamically Created Tests"})}),"\n",(0,a.jsxs)(t.p,{children:["TUnit offers the ability to create your tests via dynamic code, as opposed to the standard ",(0,a.jsx)(t.code,{children:"[Test]"})," attribute and data attributes."]}),"\n",(0,a.jsx)(t.p,{children:"To do this, create a new class with a public parameterless constructor."}),"\n",(0,a.jsxs)(t.p,{children:["Then, create a public method, called whatever you like, with a single parameter of ",(0,a.jsx)(t.code,{children:"DynamicTestBuilderContext"}),", and place the ",(0,a.jsx)(t.code,{children:"[DynamicTestBuilder]"})," attribute on that method."]}),"\n",(0,a.jsxs)(t.p,{children:["On the ",(0,a.jsx)(t.code,{children:"context"})," parameter, you can call ",(0,a.jsx)(t.code,{children:".AddTest(...)"}),", and pass it a ",(0,a.jsx)(t.code,{children:"new DynamicTest<T>"}),"."]}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.code,{children:"T"})," is the class containing the method you want to invoke.\nIf your class contains parameters or properties, or your method contains parameters, you can pass these into the test parameter"]}),"\n",(0,a.jsx)(t.p,{children:"For simple tests, there is not much point using this feature. But it may be helpful when wanting to generate lots of test cases with different data."}),"\n",(0,a.jsx)(t.p,{children:"Here's an example:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-csharp",children:'namespace TUnit.TestProject.DynamicTests;\n\npublic class Basic\n{\n    public void SomeMethod(string name)\n    {\n        Console.WriteLine(@$"Hello, {name}!");\n    }\n    \n    [DynamicTestBuilder]\n    public void BuildTests(DynamicTestBuilderContext context)\n    {\n        context.AddTest(new DynamicTest<Basic>\n        {\n            TestMethod = @class => @class.SomeMethod(DynamicTest.Argument<string>()),\n            TestMethodArguments = [ "Tom" ],\n            Attributes = [new RepeatAttribute(5)]\n        });\n    }\n}\n'})}),"\n",(0,a.jsxs)(t.p,{children:["The test method body is used as an ",(0,a.jsx)(t.code,{children:"Expression"})," - Not as a ",(0,a.jsx)(t.code,{children:"delegate"}),". This means that arguments passed to it within the lambda will be ignored. And if the method is async, it does not need to be awaited.\nArguments must be provided via the ",(0,a.jsx)(t.code,{children:"TestMethodArguments"})," property."]}),"\n",(0,a.jsxs)(t.p,{children:["To make this clearer, it's recommended to use the ",(0,a.jsx)(t.code,{children:"DynamicTest.Argument<T>()"})," helper."]}),"\n",(0,a.jsx)(t.p,{children:"It is also possible to build a test from within another test:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-csharp",children:'[RunOnDiscovery]\n[Arguments(1, 2, 3)]\n[Arguments(101, 202, 303)]\npublic class Runtime(int a, int b, int c)\n{\n    public void SomeMethod(int arg1, int arg2, int arg3)\n    {\n        Console.WriteLine(@"SomeMethod called with:");\n        Console.WriteLine($@"Class args: {a}, {b}, {c}");\n        Console.WriteLine($@"Method args: {arg1}, {arg2}, {arg3}");\n    }\n    \n    [Test]\n    [Arguments(4, 5, 6)]\n    [Arguments(404, 505, 606)]\n    public async Task BuildTests(int d, int e, int f)\n    {\n        var context = TestContext.Current!;\n        \n        await context.AddDynamicTest(new DynamicTest<Runtime>\n        {\n            TestMethod = @class => @class.SomeMethod(0, 0, 0),\n            TestClassArguments = [a + 10, b + 10, c + 10],\n            TestMethodArguments = [d + 10, e + 10, f + 10],\n            Attributes = [new RepeatAttribute(5)]\n        });\n    }\n}\n'})})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>o});var s=n(6540);const a={},i=s.createContext(a);function r(e){const t=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),s.createElement(i.Provider,{value:t},e.children)}}}]);