"use strict";(self.webpackChunktunit_docs_site=self.webpackChunktunit_docs_site||[]).push([[9611],{3644:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>c,default:()=>p,frontMatter:()=>r,metadata:()=>t,toc:()=>o});const t=JSON.parse('{"id":"test-authoring/nested-data-sources","title":"Nested Data Sources with Initialization","description":"When writing integration tests, you often need complex test fixtures that depend on other initialized resources. TUnit\'s nested data source initialization feature makes this elegant and automatic.","source":"@site/docs/test-authoring/nested-data-sources.md","sourceDirName":"test-authoring","slug":"/test-authoring/nested-data-sources","permalink":"/docs/test-authoring/nested-data-sources","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":7,"frontMatter":{"sidebar_position":7},"sidebar":"docs","previous":{"title":"Matrix Tests","permalink":"/docs/test-authoring/matrix-tests"},"next":{"title":"Skipping Tests","permalink":"/docs/test-authoring/skip"}}');var s=i(4848),a=i(8453);const r={sidebar_position:7},c="Nested Data Sources with Initialization",l={},o=[{value:"The Problem",id:"the-problem",level:2},{value:"The Solution",id:"the-solution",level:2},{value:"Basic Example",id:"basic-example",level:2},{value:"Multiple Dependencies",id:"multiple-dependencies",level:2},{value:"Sharing Resources",id:"sharing-resources",level:2},{value:"Async Data Generation with Dependencies",id:"async-data-generation-with-dependencies",level:2},{value:"How It Works",id:"how-it-works",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"Common Patterns",id:"common-patterns",level:2},{value:"Database Migrations",id:"database-migrations",level:3},{value:"Seeding Test Data",id:"seeding-test-data",level:3},{value:"Health Checks",id:"health-checks",level:3},{value:"Summary",id:"summary",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"nested-data-sources-with-initialization",children:"Nested Data Sources with Initialization"})}),"\n",(0,s.jsx)(n.p,{children:"When writing integration tests, you often need complex test fixtures that depend on other initialized resources. TUnit's nested data source initialization feature makes this elegant and automatic."}),"\n",(0,s.jsx)(n.h2,{id:"the-problem",children:"The Problem"}),"\n",(0,s.jsx)(n.p,{children:"Traditional integration test setup often requires:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Starting test containers (databases, message queues, etc.)"}),"\n",(0,s.jsx)(n.li,{children:"Initializing WebApplicationFactory with custom services"}),"\n",(0,s.jsx)(n.li,{children:"Ensuring proper initialization order"}),"\n",(0,s.jsx)(n.li,{children:"Managing resource lifecycle"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"This typically leads to complex setup code with manual initialization chains."}),"\n",(0,s.jsx)(n.h2,{id:"the-solution",children:"The Solution"}),"\n",(0,s.jsxs)(n.p,{children:["TUnit automatically initializes nested data sources in the correct order using any data source attribute that implements ",(0,s.jsx)(n.code,{children:"IDataSourceAttribute"})," (such as ",(0,s.jsx)(n.code,{children:"[ClassDataSource<T>]"}),")."]}),"\n",(0,s.jsx)(n.h2,{id:"basic-example",children:"Basic Example"}),"\n",(0,s.jsx)(n.p,{children:"Here's a complete example of setting up integration tests with Redis and WebApplicationFactory:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:'using Testcontainers.Redis;\nusing TUnit.Core;\nusing Microsoft.AspNetCore.Mvc.Testing;\nusing StackExchange.Redis;\n\n// 1. Define a test container that needs initialization\npublic class RedisTestContainer : IAsyncInitializer, IAsyncDisposable\n{\n    private readonly RedisContainer _container;\n    \n    public string ConnectionString => _container.GetConnectionString();\n    \n    public RedisTestContainer()\n    {\n        _container = new RedisBuilder()\n            .WithImage("redis:7-alpine")\n            .Build();\n    }\n    \n    public async Task InitializeAsync()\n    {\n        await _container.StartAsync();\n    }\n    \n    public async ValueTask DisposeAsync()\n    {\n        await _container.DisposeAsync();\n    }\n}\n\n// 2. Create a test application that depends on Redis\npublic class TestApplication : IAsyncInitializer, IAsyncDisposable\n{\n    private WebApplicationFactory<Program>? _factory;\n    \n    // This property will be initialized BEFORE InitializeAsync is called\n    [ClassDataSource<RedisTestContainer>]\n    public required RedisTestContainer Redis { get; init; }\n    \n    public HttpClient Client { get; private set; } = null!;\n    \n    public async Task InitializeAsync()\n    {\n        // At this point, Redis is already started and ready!\n        _factory = new WebApplicationFactory<Program>()\n            .WithWebHostBuilder(builder =>\n            {\n                builder.ConfigureServices(services =>\n                {\n                    // Replace production Redis with our test container\n                    services.AddSingleton<IConnectionMultiplexer>(_ => \n                        ConnectionMultiplexer.Connect(Redis.ConnectionString));\n                });\n            });\n        \n        Client = _factory.CreateClient();\n    }\n    \n    public async ValueTask DisposeAsync()\n    {\n        Client?.Dispose();\n        if (_factory != null) await _factory.DisposeAsync();\n    }\n}\n\n// 3. Create a data source attribute\npublic class TestApplicationAttribute : DataSourceGeneratorAttribute<TestApplication>\n{\n    public override IEnumerable<TestApplication> GenerateDataSources(DataGeneratorMetadata metadata)\n    {\n        yield return new TestApplication();\n    }\n}\n\n// 4. Use in tests\npublic class UserApiTests\n{\n    [Test]\n    [TestApplication]\n    public async Task CreateUser_Should_Cache_In_Redis(TestApplication app)\n    {\n        // Arrange\n        var user = new { Name = "John", Email = "john@example.com" };\n        \n        // Act\n        var response = await app.Client.PostAsJsonAsync("/api/users", user);\n        \n        // Assert\n        response.EnsureSuccessStatusCode();\n        \n        // Verify the user was cached in Redis\n        var services = app.Client.Services;\n        var redis = services.GetRequiredService<IConnectionMultiplexer>();\n        var cached = await redis.GetDatabase().StringGetAsync("user:john@example.com");\n        \n        Assert.That(cached.HasValue).IsTrue();\n    }\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"multiple-dependencies",children:"Multiple Dependencies"}),"\n",(0,s.jsx)(n.p,{children:"You can have multiple nested dependencies, and TUnit will initialize them in the correct order:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"public class CompleteTestEnvironment : IAsyncInitializer, IAsyncDisposable\n{\n    private WebApplicationFactory<Program>? _factory;\n    \n    // All of these will be initialized before InitializeAsync\n    [ClassDataSource<RedisTestContainer>]\n    public required RedisTestContainer Redis { get; init; }\n    \n    [ClassDataSource<PostgresTestContainer>]\n    public required PostgresTestContainer Database { get; init; }\n    \n    [ClassDataSource<LocalStackContainer>]\n    public required LocalStackContainer LocalStack { get; init; }\n    \n    public HttpClient Client { get; private set; } = null!;\n    \n    public async Task InitializeAsync()\n    {\n        // All containers are running at this point\n        _factory = new WebApplicationFactory<Program>()\n            .WithWebHostBuilder(builder =>\n            {\n                builder.ConfigureServices(services =>\n                {\n                    // Wire up all test services\n                    ConfigureRedis(services);\n                    ConfigureDatabase(services);\n                    ConfigureAwsServices(services);\n                });\n            });\n        \n        Client = _factory.CreateClient();\n        \n        // Run any post-initialization setup\n        await SeedTestData();\n    }\n    \n    // ... configuration methods\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"sharing-resources",children:"Sharing Resources"}),"\n",(0,s.jsx)(n.p,{children:"Expensive resources like test containers should be shared across tests:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:'// Share the same instance across all tests in a class\n[SharedType(SharedType.PerClass)]\npublic class SharedTestApplicationAttribute : TestApplicationAttribute\n{\n}\n\n// Or share with a specific key for fine-grained control\n[SharedType(SharedType.Keyed, "integration-tests")]\npublic class KeyedTestApplicationAttribute : TestApplicationAttribute\n{\n}\n\n// Usage\n[TestClass]\npublic class OrderApiTests\n{\n    [Test]\n    [SharedTestApplication] // Reuses the same instance for all tests in this class\n    public async Task Test1(TestApplication app) { /* ... */ }\n    \n    [Test]\n    [SharedTestApplication] // Same instance as Test1\n    public async Task Test2(TestApplication app) { /* ... */ }\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"async-data-generation-with-dependencies",children:"Async Data Generation with Dependencies"}),"\n",(0,s.jsx)(n.p,{children:"You can also use async data source generators that depend on initialized resources:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:'public class UserTestDataAttribute : AsyncDataSourceGeneratorAttribute<UserTestData>\n{\n    // This will be initialized first\n    [ClassDataSource<TestApplication>]\n    public required TestApplication App { get; init; }\n    \n    public override async IAsyncEnumerable<UserTestData> GenerateDataSourcesAsync(\n        DataGeneratorMetadata metadata)\n    {\n        // App is fully initialized here, including database\n        var dbContext = App.Services.GetRequiredService<AppDbContext>();\n        \n        // Create test users\n        var adminUser = new User { Email = "admin@test.com", Role = "Admin" };\n        var regularUser = new User { Email = "user@test.com", Role = "User" };\n        \n        dbContext.Users.AddRange(adminUser, regularUser);\n        await dbContext.SaveChangesAsync();\n        \n        yield return new UserTestData \n        { \n            User = adminUser, \n            App = App,\n            ExpectedPermissions = new[] { "read", "write", "delete" }\n        };\n        \n        yield return new UserTestData \n        { \n            User = regularUser, \n            App = App,\n            ExpectedPermissions = new[] { "read" }\n        };\n    }\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"how-it-works",children:"How It Works"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["TUnit detects properties marked with data source attributes (like ",(0,s.jsx)(n.code,{children:"[ClassDataSource<T>]"}),")"]}),"\n",(0,s.jsx)(n.li,{children:"It builds a dependency graph and initializes in the correct order"}),"\n",(0,s.jsxs)(n.li,{children:["Each object's ",(0,s.jsx)(n.code,{children:"InitializeAsync"})," is called after its dependencies are ready"]}),"\n",(0,s.jsx)(n.li,{children:"Disposal happens in reverse order automatically"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Implement IAsyncInitializer"}),": For any class that needs async initialization"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Use Data Source Attributes"}),": Use attributes like ",(0,s.jsx)(n.code,{children:"[ClassDataSource<T>]"})," to declare dependencies that must be initialized first"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Share Expensive Resources"}),": Use ",(0,s.jsx)(n.code,{children:"SharedType"})," attributes to avoid creating multiple containers"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Dispose Properly"}),": Implement ",(0,s.jsx)(n.code,{children:"IAsyncDisposable"})," for cleanup"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Keep Initialization Fast"}),": Do only essential setup in ",(0,s.jsx)(n.code,{children:"InitializeAsync"})]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"common-patterns",children:"Common Patterns"}),"\n",(0,s.jsx)(n.h3,{id:"database-migrations",children:"Database Migrations"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:'public async Task InitializeAsync()\n{\n    await _container.StartAsync();\n    \n    // Run migrations after container starts\n    using var connection = new NpgsqlConnection(ConnectionString);\n    await connection.ExecuteAsync(@"\n        CREATE TABLE IF NOT EXISTS users (\n            id SERIAL PRIMARY KEY,\n            email VARCHAR(255) UNIQUE NOT NULL\n        )");\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"seeding-test-data",children:"Seeding Test Data"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"public async Task InitializeAsync()\n{\n    // ... create WebApplicationFactory\n    \n    // Seed data after app starts\n    using var scope = _factory.Services.CreateScope();\n    var seeder = scope.ServiceProvider.GetRequiredService<ITestDataSeeder>();\n    await seeder.SeedAsync();\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"health-checks",children:"Health Checks"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:'public async Task InitializeAsync()\n{\n    // ... create client\n    \n    // Wait for app to be healthy\n    var healthCheck = await Client.GetAsync("/health");\n    healthCheck.EnsureSuccessStatusCode();\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,s.jsx)(n.p,{children:"Nested data source initialization in TUnit:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"\u2705 Eliminates manual initialization chains"}),"\n",(0,s.jsx)(n.li,{children:"\u2705 Ensures correct initialization order"}),"\n",(0,s.jsx)(n.li,{children:"\u2705 Supports complex dependency graphs"}),"\n",(0,s.jsx)(n.li,{children:"\u2705 Works seamlessly with async operations"}),"\n",(0,s.jsx)(n.li,{children:"\u2705 Provides automatic cleanup"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"This makes integration testing with complex dependencies simple and maintainable."})]})}function p(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>r,x:()=>c});var t=i(6540);const s={},a=t.createContext(s);function r(e){const n=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);