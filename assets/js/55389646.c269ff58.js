"use strict";(self.webpackChunktunit_docs_site=self.webpackChunktunit_docs_site||[]).push([[9323],{3839:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>u,contentTitle:()=>c,default:()=>p,frontMatter:()=>o,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"test-authoring/things-to-know","title":"Things to know","description":"TUnit has made some decisions by design. You may need to know about them:","source":"@site/docs/test-authoring/things-to-know.md","sourceDirName":"test-authoring","slug":"/test-authoring/things-to-know","permalink":"/docs/test-authoring/things-to-know","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"docs","previous":{"title":"TestContext Interface Organization Migration Guide","permalink":"/docs/migration/testcontext-interface-organization"},"next":{"title":"Test Set Ups","permalink":"/docs/test-lifecycle/setup"}}');var a=n(4848),r=n(8453),l=n(1470),i=n(9365);const o={},c="Things to know",u={},d=[{value:"Parallelisation",id:"parallelisation",level:2},{value:"Test Classes and Instance Data",id:"test-classes-and-instance-data",level:2}];function h(e){const t={code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",strong:"strong",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.header,{children:(0,a.jsx)(t.h1,{id:"things-to-know",children:"Things to know"})}),"\n",(0,a.jsx)(t.p,{children:"TUnit has made some decisions by design. You may need to know about them:"}),"\n",(0,a.jsx)(t.h2,{id:"parallelisation",children:"Parallelisation"}),"\n",(0,a.jsxs)(t.p,{children:["Tests are run in parallel by design. If you have operations you can't do in parallel, you'll need to add a ",(0,a.jsx)(t.code,{children:"[NotInParallel]"})," attribute to your test. That attribute can also take an ",(0,a.jsx)(t.code,{children:"Order"})," property, so you can control the ordering of your not in parallel tests."]}),"\n",(0,a.jsx)(t.h2,{id:"test-classes-and-instance-data",children:"Test Classes and Instance Data"}),"\n",(0,a.jsxs)(t.p,{children:["Classes are ",(0,a.jsx)(t.code,{children:"new"}),"ed up for each test within their class."]}),"\n",(0,a.jsx)(t.p,{children:"This is by design because tests should be stateless and side effect free."}),"\n",(0,a.jsx)(t.p,{children:"By doing this it enables parallelisation (for speed and throughput), and reduces bugs and side effects when there is stale data left over from previous tests. This is something I've experienced with NUnit before. I've seen test suites that were all green, and they were actually broken, because they were asserting against instance data that had been left over from previous tests."}),"\n",(0,a.jsx)(t.p,{children:"So if you have:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-csharp",children:"public class MyTests\n{\n    [Test]\n    public void MyTest1() { ... }\n\n    [Test]\n    public void MyTest2() { ... }\n}\n"})}),"\n",(0,a.jsxs)(t.p,{children:["Then ",(0,a.jsx)(t.code,{children:"MyTest1"})," and ",(0,a.jsx)(t.code,{children:"MyTest2"})," will have a different instance of ",(0,a.jsx)(t.code,{children:"MyTests"}),"."]}),"\n",(0,a.jsx)(t.p,{children:"This isn't that important unless you're storing state."}),"\n","\n",(0,a.jsxs)(l.A,{children:[(0,a.jsxs)(i.A,{value:"bad",label:"\u274c Bad - Will Fail",default:!0,children:[(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-csharp",children:"public class MyTests\n{\n    private int _value;\n\n    [Test, NotInParallel]\n    public void MyTest1() { _value = 99; }\n\n    [Test, NotInParallel]\n    public async Task MyTest2()\n    {\n        // This will FAIL because _value is 0\n        // Different test instance = different _value\n        await Assert.That(_value).IsEqualTo(99);\n    }\n}\n"})}),(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"Why this fails:"})," Each test gets a new instance of ",(0,a.jsx)(t.code,{children:"MyTests"}),", so ",(0,a.jsx)(t.code,{children:"_value"})," in ",(0,a.jsx)(t.code,{children:"MyTest2"})," is a different field than in ",(0,a.jsx)(t.code,{children:"MyTest1"}),"."]})]}),(0,a.jsxs)(i.A,{value:"good",label:"\u2705 Good - Use Static",children:[(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-csharp",children:"public class MyTests\n{\n    private static int _value;\n\n    [Test, NotInParallel]\n    public void MyTest1() { _value = 99; }\n\n    [Test, NotInParallel]\n    public async Task MyTest2()\n    {\n        // This works because _value is static\n        await Assert.That(_value).IsEqualTo(99);\n    }\n}\n"})}),(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"Why this works:"})," The ",(0,a.jsx)(t.code,{children:"static"})," keyword makes the field persist across instances, making it clear that data is shared."]})]})]})]})}function p(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(h,{...e})}):h(e)}},9365:(e,t,n)=>{n.d(t,{A:()=>l});n(6540);var s=n(4164);const a={tabItem:"tabItem_Ymn6"};var r=n(4848);function l({children:e,hidden:t,className:n}){return(0,r.jsx)("div",{role:"tabpanel",className:(0,s.A)(a.tabItem,n),hidden:t,children:e})}},1470:(e,t,n)=>{n.d(t,{A:()=>w});var s=n(6540),a=n(4164),r=n(7559),l=n(3104),i=n(6347),o=n(205),c=n(7485),u=n(1682),d=n(679);function h(e){return s.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,s.isValidElement)(e)&&function(e){const{props:t}=e;return!!t&&"object"==typeof t&&"value"in t}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function p(e){const{values:t,children:n}=e;return(0,s.useMemo)((()=>{const e=t??function(e){return h(e).map((({props:{value:e,label:t,attributes:n,default:s}})=>({value:e,label:t,attributes:n,default:s})))}(n);return function(e){const t=(0,u.XI)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error(`Docusaurus error: Duplicate values "${t.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[t,n])}function f({value:e,tabValues:t}){return t.some((t=>t.value===e))}function b({queryString:e=!1,groupId:t}){const n=(0,i.W6)(),a=function({queryString:e=!1,groupId:t}){if("string"==typeof e)return e;if(!1===e)return null;if(!0===e&&!t)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return t??null}({queryString:e,groupId:t});return[(0,c.aZ)(a),(0,s.useCallback)((e=>{if(!a)return;const t=new URLSearchParams(n.location.search);t.set(a,e),n.replace({...n.location,search:t.toString()})}),[a,n])]}function m(e){const{defaultValue:t,queryString:n=!1,groupId:a}=e,r=p(e),[l,i]=(0,s.useState)((()=>function({defaultValue:e,tabValues:t}){if(0===t.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(e){if(!f({value:e,tabValues:t}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${e}" but none of its children has the corresponding value. Available values are: ${t.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return e}const n=t.find((e=>e.default))??t[0];if(!n)throw new Error("Unexpected error: 0 tabValues");return n.value}({defaultValue:t,tabValues:r}))),[c,u]=b({queryString:n,groupId:a}),[h,m]=function({groupId:e}){const t=function(e){return e?`docusaurus.tab.${e}`:null}(e),[n,a]=(0,d.Dv)(t);return[n,(0,s.useCallback)((e=>{t&&a.set(e)}),[t,a])]}({groupId:a}),v=(()=>{const e=c??h;return f({value:e,tabValues:r})?e:null})();(0,o.A)((()=>{v&&i(v)}),[v]);return{selectedValue:l,selectValue:(0,s.useCallback)((e=>{if(!f({value:e,tabValues:r}))throw new Error(`Can't select invalid tab value=${e}`);i(e),u(e),m(e)}),[u,m,r]),tabValues:r}}var v=n(2303);const g={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var y=n(4848);function x({className:e,block:t,selectedValue:n,selectValue:s,tabValues:r}){const i=[],{blockElementScrollPositionUntilNextRender:o}=(0,l.a_)(),c=e=>{const t=e.currentTarget,a=i.indexOf(t),l=r[a].value;l!==n&&(o(t),s(l))},u=e=>{let t=null;switch(e.key){case"Enter":c(e);break;case"ArrowRight":{const n=i.indexOf(e.currentTarget)+1;t=i[n]??i[0];break}case"ArrowLeft":{const n=i.indexOf(e.currentTarget)-1;t=i[n]??i[i.length-1];break}}t?.focus()};return(0,y.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,a.A)("tabs",{"tabs--block":t},e),children:r.map((({value:e,label:t,attributes:s})=>(0,y.jsx)("li",{role:"tab",tabIndex:n===e?0:-1,"aria-selected":n===e,ref:e=>{i.push(e)},onKeyDown:u,onClick:c,...s,className:(0,a.A)("tabs__item",g.tabItem,s?.className,{"tabs__item--active":n===e}),children:t??e},e)))})}function T({lazy:e,children:t,selectedValue:n}){const r=(Array.isArray(t)?t:[t]).filter(Boolean);if(e){const e=r.find((e=>e.props.value===n));return e?(0,s.cloneElement)(e,{className:(0,a.A)("margin-top--md",e.props.className)}):null}return(0,y.jsx)("div",{className:"margin-top--md",children:r.map(((e,t)=>(0,s.cloneElement)(e,{key:t,hidden:e.props.value!==n})))})}function j(e){const t=m(e);return(0,y.jsxs)("div",{className:(0,a.A)(r.G.tabs.container,"tabs-container",g.tabList),children:[(0,y.jsx)(x,{...t,...e}),(0,y.jsx)(T,{...t,...e})]})}function w(e){const t=(0,v.A)();return(0,y.jsx)(j,{...e,children:h(e.children)},String(t))}},8453:(e,t,n)=>{n.d(t,{R:()=>l,x:()=>i});var s=n(6540);const a={},r=s.createContext(a);function l(e){const t=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:l(e.components),s.createElement(r.Provider,{value:t},e.children)}}}]);