"use strict";(globalThis.webpackChunktunit_docs_site=globalThis.webpackChunktunit_docs_site||[]).push([[7357],{88987(e,t,n){n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>c,default:()=>u,frontMatter:()=>r,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"test-authoring/method-data-source","title":"Method Data Sources","description":"A limitation of passing data in with [Arguments(...)] is that the data must be constant values. For example, we can\'t new up an object and pass it into this attribute as an argument. This is a constraint of the language and we can\'t change that.","source":"@site/docs/test-authoring/method-data-source.md","sourceDirName":"test-authoring","slug":"/test-authoring/method-data-source","permalink":"/docs/test-authoring/method-data-source","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"docs","previous":{"title":"Data Driven Tests","permalink":"/docs/test-authoring/arguments"},"next":{"title":"Injectable Class Data Source","permalink":"/docs/test-authoring/class-data-source"}}');var a=n(74848),i=n(28453);const r={},c="Method Data Sources",o={},d=[{value:"AOT-Compatible Method Data Sources",id:"aot-compatible-method-data-sources",level:2},{value:"Async Data Sources (AOT-Compatible)",id:"async-data-sources-aot-compatible",level:2},{value:"Instance Method Data Sources",id:"instance-method-data-sources",level:2},{value:"Discovery Phase Considerations",id:"discovery-phase-considerations",level:3}];function l(e){const t={a:"a",admonition:"admonition",br:"br",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.header,{children:(0,a.jsx)(t.h1,{id:"method-data-sources",children:"Method Data Sources"})}),"\n",(0,a.jsxs)(t.p,{children:["A limitation of passing data in with ",(0,a.jsx)(t.code,{children:"[Arguments(...)]"})," is that the data must be ",(0,a.jsx)(t.code,{children:"constant"})," values. For example, we can't new up an object and pass it into this attribute as an argument. This is a constraint of the language and we can't change that."]}),"\n",(0,a.jsx)(t.p,{children:"If we want test data represented in the form of objects, or just to use something that isn't a constant, we can declare a test data source."}),"\n",(0,a.jsx)(t.h2,{id:"aot-compatible-method-data-sources",children:"AOT-Compatible Method Data Sources"}),"\n",(0,a.jsxs)(t.p,{children:["TUnit's AOT-only mode requires ",(0,a.jsx)(t.strong,{children:"static"})," method data sources for compile-time safety and performance. Methods must be static and use compile-time resolvable patterns."]}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.code,{children:"MethodDataSource"})," has two options:"]}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"If you pass in one argument, this is the method name containing your data. TUnit will assume this is in the current test class."}),"\n",(0,a.jsxs)(t.li,{children:["If you pass in two arguments, the first should be the ",(0,a.jsx)(t.code,{children:"Type"})," of the class containing your test source data method, and the second should be the name of the method."]}),"\n"]}),"\n",(0,a.jsx)(t.admonition,{title:"AOT Requirement",type:"warning",children:(0,a.jsxs)(t.p,{children:["Method data sources ",(0,a.jsx)(t.strong,{children:"must be static"})," for AOT compatibility. Instance methods will generate compile-time errors in AOT mode."]})}),"\n",(0,a.jsxs)(t.p,{children:["For reference types, methods should return a ",(0,a.jsx)(t.code,{children:"Func<T>"})," rather than just a ",(0,a.jsx)(t.code,{children:"T"}),", and make sure that ",(0,a.jsx)(t.code,{children:"Func<>"})," returns a ",(0,a.jsx)(t.code,{children:"new T()"})," - This ensures each test has its own instance of that object and tests aren't sharing objects which could lead to unintended side effects."]}),"\n",(0,a.jsx)(t.admonition,{type:"info",children:(0,a.jsxs)(t.p,{children:["Returning a ",(0,a.jsx)(t.code,{children:"Func<T>"})," ensures that each test gets a fresh object.",(0,a.jsx)(t.br,{}),"\n","If you return a reference to the same object, tests may interfere with each other."]})}),"\n",(0,a.jsx)(t.p,{children:"Here's an example returning a simple object:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-csharp",children:"using TUnit.Assertions;\nusing TUnit.Assertions.Extensions;\nusing TUnit.Core;\n\nnamespace MyTestProject;\n\npublic record AdditionTestData(int Value1, int Value2, int ExpectedResult);\n\npublic static class MyTestDataSources\n{\n    public static Func<AdditionTestData> AdditionTestData()\n    {\n        return () => new AdditionTestData(1, 2, 3);\n    }\n}\n\npublic class MyTestClass\n{\n    [Test]\n    [MethodDataSource(typeof(MyTestDataSources), nameof(MyTestDataSources.AdditionTestData))]\n    public async Task MyTest(AdditionTestData additionTestData)\n    {\n        var result = Add(additionTestData.Value1, additionTestData.Value2);\n\n        await Assert.That(result).IsEqualTo(additionTestData.ExpectedResult);\n    }\n\n    private int Add(int x, int y)\n    {\n        return x + y;\n    }\n}\n"})}),"\n",(0,a.jsx)(t.p,{children:"This can also accept tuples if you don't want to create lots of new types within your test assembly:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-csharp",children:"using TUnit.Assertions;\nusing TUnit.Assertions.Extensions;\nusing TUnit.Core;\n\nnamespace MyTestProject;\n\npublic static class MyTestDataSources\n{\n    public static Func<(int, int, int)> AdditionTestData()\n    {\n        return () => (1, 2, 3);\n    }\n}\n\npublic class MyTestClass\n{\n    [Test]\n    [MethodDataSource(typeof(MyTestDataSources), nameof(MyTestDataSources.AdditionTestData))]\n    public async Task MyTest(int value1, int value2, int expectedResult)\n    {\n        var result = Add(value1, value2);\n\n        await Assert.That(result).IsEqualTo(expectedResult);\n    }\n\n    private int Add(int x, int y)\n    {\n        return x + y;\n    }\n}\n"})}),"\n",(0,a.jsxs)(t.p,{children:["This attribute can also accept ",(0,a.jsx)(t.code,{children:"IEnumerable<>"}),". For each item returned, a new test will be created with that item passed in to the parameters. Again, if using a reference type, return an ",(0,a.jsx)(t.code,{children:"IEnumerable<Func<T>>"})," and make sure each ",(0,a.jsx)(t.code,{children:"Func<>"})," returns a ",(0,a.jsx)(t.code,{children:"new T()"})]}),"\n",(0,a.jsx)(t.p,{children:"Here's an example where the test would be invoked 3 times:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-csharp",children:"using TUnit.Assertions;\nusing TUnit.Assertions.Extensions;\nusing TUnit.Core;\n\nnamespace MyTestProject;\n\npublic record AdditionTestData(int Value1, int Value2, int ExpectedResult);\n\npublic static class MyTestDataSources\n{\n    public static IEnumerable<Func<AdditionTestData>> AdditionTestData()\n    {\n        yield return () => new AdditionTestData(1, 2, 3);\n        yield return () => new AdditionTestData(2, 2, 4);\n        yield return () => new AdditionTestData(5, 5, 10);\n    }\n}\n\npublic class MyTestClass\n{\n    [Test]\n    [MethodDataSource(typeof(MyTestDataSources), nameof(MyTestDataSources.AdditionTestData))]\n    public async Task MyTest(AdditionTestData additionTestData)\n    {\n        var result = Add(additionTestData.Value1, additionTestData.Value2);\n\n        await Assert.That(result).IsEqualTo(additionTestData.ExpectedResult);\n    }\n\n    private int Add(int x, int y)\n    {\n        return x + y;\n    }\n}\n"})}),"\n",(0,a.jsx)(t.p,{children:"This can also accept tuples if you don't want to create lots of new types within your test assembly:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-csharp",children:"using TUnit.Assertions;\nusing TUnit.Assertions.Extensions;\nusing TUnit.Core;\n\nnamespace MyTestProject;\n\npublic static class MyTestDataSources\n{\n    public static IEnumerable<Func<(int, int, int)>> AdditionTestData()\n    {\n        yield return () => (1, 2, 3);\n        yield return () => (2, 2, 4);\n        yield return () => (5, 5, 10);\n    }\n}\n\npublic class MyTestClass\n{\n    [Test]\n    [MethodDataSource(typeof(MyTestDataSources), nameof(MyTestDataSources.AdditionTestData))]\n    public async Task MyTest(int value1, int value2, int expectedResult)\n    {\n        var result = Add(value1, value2);\n\n        await Assert.That(result).IsEqualTo(expectedResult);\n    }\n\n    private int Add(int x, int y)\n    {\n        return x + y;\n    }\n}\n"})}),"\n",(0,a.jsx)(t.h2,{id:"async-data-sources-aot-compatible",children:"Async Data Sources (AOT-Compatible)"}),"\n",(0,a.jsxs)(t.p,{children:["TUnit's AOT mode supports async data sources with ",(0,a.jsx)(t.code,{children:"IAsyncEnumerable<T>"})," for scenarios requiring asynchronous data loading:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-csharp",children:'using TUnit.Assertions;\nusing TUnit.Assertions.Extensions;\nusing TUnit.Core;\nusing System.Runtime.CompilerServices;\n\nnamespace MyTestProject;\n\npublic record AsyncTestData(int Id, string Name, DateTime CreatedAt);\n\npublic static class AsyncTestDataSources\n{\n    // AOT-compatible async data source with cancellation support\n    public static async IAsyncEnumerable<Func<AsyncTestData>> GetAsyncTestData(\n        [EnumeratorCancellation] CancellationToken ct = default)\n    {\n        for (int i = 1; i <= 3; i++)\n        {\n            ct.ThrowIfCancellationRequested();\n            \n            // Simulate async data loading (database, API, etc.)\n            await Task.Delay(10, ct);\n            \n            yield return () => new AsyncTestData(\n                Id: i, \n                Name: $"Item_{i}", \n                CreatedAt: DateTime.UtcNow.AddDays(-i)\n            );\n        }\n    }\n\n    // Simple async enumerable returning tuples\n    public static async IAsyncEnumerable<(int, string)> GetSimpleAsyncData(\n        [EnumeratorCancellation] CancellationToken ct = default)\n    {\n        await Task.Delay(1, ct); // Simulate async work\n        yield return (1, "first");\n        yield return (2, "second");\n        yield return (3, "third");\n    }\n}\n\npublic class AsyncDataSourceTests\n{\n    [Test]\n    [MethodDataSource(typeof(AsyncTestDataSources), nameof(AsyncTestDataSources.GetAsyncTestData))]\n    public async Task TestWithAsyncComplexData(AsyncTestData testData)\n    {\n        await Assert.That(testData.Id).IsGreaterThan(0);\n        await Assert.That(testData.Name).StartsWith("Item_");\n        await Assert.That(testData.CreatedAt).IsLessThan(DateTime.UtcNow);\n    }\n\n    [Test]\n    [MethodDataSource(typeof(AsyncTestDataSources), nameof(AsyncTestDataSources.GetSimpleAsyncData))]\n    public async Task TestWithAsyncSimpleData(int id, string name)\n    {\n        await Assert.That(id).IsBetween(1, 3);\n        await Assert.That(name).IsNotEmpty();\n    }\n}\n'})}),"\n",(0,a.jsx)(t.admonition,{title:"Performance Note",type:"tip",children:(0,a.jsx)(t.p,{children:"Async data sources are generated with strongly-typed delegates in AOT mode, providing excellent performance while maintaining full async/await support and cancellation token handling."})}),"\n",(0,a.jsx)(t.h2,{id:"instance-method-data-sources",children:"Instance Method Data Sources"}),"\n",(0,a.jsxs)(t.p,{children:["In addition to static ",(0,a.jsx)(t.code,{children:"MethodDataSource"}),", TUnit supports ",(0,a.jsx)(t.code,{children:"InstanceMethodDataSource"})," for accessing instance members:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-csharp",children:"public class MyTests\n{\n    private IEnumerable<int> TestData => new[] { 1, 2, 3 };\n\n    [Test]\n    [InstanceMethodDataSource(nameof(TestData))]\n    public async Task MyTest(int value)\n    {\n        await Assert.That(value).IsGreaterThan(0);\n    }\n}\n"})}),"\n",(0,a.jsx)(t.h3,{id:"discovery-phase-considerations",children:"Discovery Phase Considerations"}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.code,{children:"InstanceMethodDataSource"})," is evaluated during ",(0,a.jsx)(t.strong,{children:"test discovery"})," (before test execution). If the instance property depends on async initialization via ",(0,a.jsx)(t.code,{children:"IAsyncInitializer"}),", that initialization has ",(0,a.jsx)(t.strong,{children:"not yet run"})," during discovery, potentially resulting in empty data and no tests being generated."]}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.strong,{children:"Solutions:"})}),"\n",(0,a.jsxs)(t.ol,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Preferred:"})," Return predefined values that don't require initialization"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Alternative:"})," Use ",(0,a.jsx)(t.code,{children:"IAsyncDiscoveryInitializer"})," if you need discovery-time initialization"]}),"\n"]}),"\n",(0,a.jsxs)(t.p,{children:["See ",(0,a.jsx)(t.a,{href:"/docs/test-lifecycle/property-injection#discovery-phase-initialization",children:"Property Injection - Discovery Phase Initialization"})," for detailed guidance and examples.\nEOF < /dev/null"]})]})}function u(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}},28453(e,t,n){n.d(t,{R:()=>r,x:()=>c});var s=n(96540);const a={},i=s.createContext(a);function r(e){const t=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),s.createElement(i.Provider,{value:t},e.children)}}}]);