"use strict";(self.webpackChunktunit_docs_site=self.webpackChunktunit_docs_site||[]).push([[6415],{8689:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>c,contentTitle:()=>l,default:()=>d,frontMatter:()=>r,metadata:()=>t,toc:()=>o});const t=JSON.parse('{"id":"assertions/types","title":"Type Assertions","description":"TUnit provides comprehensive assertions for testing types and type properties. These assertions work with both runtime values and Type objects themselves.","source":"@site/docs/assertions/types.md","sourceDirName":"assertions","slug":"/assertions/types","permalink":"/docs/assertions/types","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":9,"frontMatter":{"sidebar_position":9},"sidebar":"docs","previous":{"title":"Exception Assertions","permalink":"/docs/assertions/exceptions"},"next":{"title":"Task and Async Assertions","permalink":"/docs/assertions/tasks-and-async"}}');var i=n(4848),a=n(8453);const r={sidebar_position:9},l="Type Assertions",c={},o=[{value:"Value Type Assertions",id:"value-type-assertions",level:2},{value:"IsTypeOf&lt;T&gt;",id:"istypeoft",level:3},{value:"IsAssignableTo&lt;T&gt;",id:"isassignabletot",level:3},{value:"IsNotAssignableTo&lt;T&gt;",id:"isnotassignabletot",level:3},{value:"Type Object Assertions",id:"type-object-assertions",level:2},{value:"Class and Interface",id:"class-and-interface",level:3},{value:"IsClass / IsNotClass",id:"isclass--isnotclass",level:4},{value:"IsInterface / IsNotInterface",id:"isinterface--isnotinterface",level:4},{value:"Modifiers",id:"modifiers",level:3},{value:"IsAbstract / IsNotAbstract",id:"isabstract--isnotabstract",level:4},{value:"IsSealed / IsNotSealed",id:"issealed--isnotsealed",level:4},{value:"Value Types and Enums",id:"value-types-and-enums",level:3},{value:"IsValueType / IsNotValueType",id:"isvaluetype--isnotvaluetype",level:4},{value:"IsEnum / IsNotEnum",id:"isenum--isnotenum",level:4},{value:"IsPrimitive / IsNotPrimitive",id:"isprimitive--isnotprimitive",level:4},{value:"Visibility",id:"visibility",level:3},{value:"IsPublic / IsNotPublic",id:"ispublic--isnotpublic",level:4},{value:"Generics",id:"generics",level:3},{value:"IsGenericType / IsNotGenericType",id:"isgenerictype--isnotgenerictype",level:4},{value:"IsGenericTypeDefinition / IsNotGenericTypeDefinition",id:"isgenerictypedefinition--isnotgenerictypedefinition",level:4},{value:"IsConstructedGenericType / IsNotConstructedGenericType",id:"isconstructedgenerictype--isnotconstructedgenerictype",level:4},{value:"ContainsGenericParameters / DoesNotContainGenericParameters",id:"containsgenericparameters--doesnotcontaingenericparameters",level:4},{value:"Arrays and Pointers",id:"arrays-and-pointers",level:3},{value:"IsArray / IsNotArray",id:"isarray--isnotarray",level:4},{value:"IsByRef / IsNotByRef",id:"isbyref--isnotbyref",level:4},{value:"IsByRefLike / IsNotByRefLike (.NET 5+)",id:"isbyreflike--isnotbyreflike-net-5",level:4},{value:"IsPointer / IsNotPointer",id:"ispointer--isnotpointer",level:4},{value:"Nested Types",id:"nested-types",level:3},{value:"IsNested / IsNotNested",id:"isnested--isnotnested",level:4},{value:"IsNestedPublic / IsNotNestedPublic",id:"isnestedpublic--isnotnestedpublic",level:4},{value:"IsNestedPrivate / IsNotNestedPrivate",id:"isnestedprivate--isnotnestedprivate",level:4},{value:"IsNestedAssembly / IsNotNestedAssembly",id:"isnestedassembly--isnotnestedassembly",level:4},{value:"IsNestedFamily / IsNotNestedFamily",id:"isnestedfamily--isnotnestedfamily",level:4},{value:"Visibility Checks",id:"visibility-checks",level:3},{value:"IsVisible / IsNotVisible",id:"isvisible--isnotvisible",level:4},{value:"COM Interop",id:"com-interop",level:3},{value:"IsCOMObject / IsNotCOMObject",id:"iscomobject--isnotcomobject",level:4},{value:"Practical Examples",id:"practical-examples",level:2},{value:"Dependency Injection Validation",id:"dependency-injection-validation",level:3},{value:"Plugin System",id:"plugin-system",level:3},{value:"Reflection Testing",id:"reflection-testing",level:3},{value:"Generic Constraints",id:"generic-constraints",level:3},{value:"Enum Validation",id:"enum-validation",level:3},{value:"Abstract Class Validation",id:"abstract-class-validation",level:3},{value:"Chaining Type Assertions",id:"chaining-type-assertions",level:2},{value:"Type Comparison",id:"type-comparison",level:2},{value:"Working with Base Types",id:"working-with-base-types",level:2},{value:"Interface Implementation",id:"interface-implementation",level:2},{value:"Common Patterns",id:"common-patterns",level:2},{value:"Factory Pattern Validation",id:"factory-pattern-validation",level:3},{value:"ORM Entity Validation",id:"orm-entity-validation",level:3},{value:"Serialization Requirements",id:"serialization-requirements",level:3},{value:"Test Double Validation",id:"test-double-validation",level:3},{value:"Struct Validation",id:"struct-validation",level:2},{value:"Record Validation",id:"record-validation",level:2},{value:"See Also",id:"see-also",level:2}];function p(e){const s={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s.header,{children:(0,i.jsx)(s.h1,{id:"type-assertions",children:"Type Assertions"})}),"\n",(0,i.jsxs)(s.p,{children:["TUnit provides comprehensive assertions for testing types and type properties. These assertions work with both runtime values and ",(0,i.jsx)(s.code,{children:"Type"})," objects themselves."]}),"\n",(0,i.jsx)(s.h2,{id:"value-type-assertions",children:"Value Type Assertions"}),"\n",(0,i.jsx)(s.h3,{id:"istypeoft",children:"IsTypeOf<T>"}),"\n",(0,i.jsx)(s.p,{children:"Tests that a value is exactly of a specific type:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-csharp",children:'[Test]\npublic async Task Value_Is_Type()\n{\n    object value = "Hello";\n\n    await Assert.That(value).IsTypeOf<string>();\n}\n'})}),"\n",(0,i.jsx)(s.p,{children:"Works with all types:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-csharp",children:"[Test]\npublic async Task Various_Types()\n{\n    await Assert.That(42).IsTypeOf<int>();\n    await Assert.That(3.14).IsTypeOf<double>();\n    await Assert.That(true).IsTypeOf<bool>();\n    await Assert.That(new List<int>()).IsTypeOf<List<int>>();\n}\n"})}),"\n",(0,i.jsx)(s.h3,{id:"isassignabletot",children:"IsAssignableTo<T>"}),"\n",(0,i.jsx)(s.p,{children:"Tests that a type can be assigned to a target type (inheritance/interface):"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-csharp",children:"[Test]\npublic async Task Type_Is_Assignable()\n{\n    var list = new List<int>();\n\n    await Assert.That(list).IsAssignableTo<IList<int>>();\n    await Assert.That(list).IsAssignableTo<IEnumerable<int>>();\n    await Assert.That(list).IsAssignableTo<object>();\n}\n"})}),"\n",(0,i.jsx)(s.p,{children:"With inheritance:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-csharp",children:"public class Animal { }\npublic class Dog : Animal { }\n\n[Test]\npublic async Task Inheritance_Assignability()\n{\n    var dog = new Dog();\n\n    await Assert.That(dog).IsAssignableTo<Animal>();\n    await Assert.That(dog).IsAssignableTo<Dog>();\n    await Assert.That(dog).IsAssignableTo<object>();\n}\n"})}),"\n",(0,i.jsx)(s.h3,{id:"isnotassignabletot",children:"IsNotAssignableTo<T>"}),"\n",(0,i.jsx)(s.p,{children:"Tests that a type cannot be assigned to a target type:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-csharp",children:"[Test]\npublic async Task Type_Not_Assignable()\n{\n    var value = 42;\n\n    await Assert.That(value).IsNotAssignableTo<string>();\n    await Assert.That(value).IsNotAssignableTo<double>();\n}\n"})}),"\n",(0,i.jsx)(s.h2,{id:"type-object-assertions",children:"Type Object Assertions"}),"\n",(0,i.jsxs)(s.p,{children:["All the following assertions work on ",(0,i.jsx)(s.code,{children:"Type"})," objects directly:"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-csharp",children:"[Test]\npublic async Task Type_Object_Assertions()\n{\n    var type = typeof(string);\n\n    await Assert.That(type).IsClass();\n    await Assert.That(type).IsNotInterface();\n}\n"})}),"\n",(0,i.jsx)(s.h3,{id:"class-and-interface",children:"Class and Interface"}),"\n",(0,i.jsx)(s.h4,{id:"isclass--isnotclass",children:"IsClass / IsNotClass"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-csharp",children:"[Test]\npublic async Task Is_Class()\n{\n    await Assert.That(typeof(string)).IsClass();\n    await Assert.That(typeof(List<int>)).IsClass();\n    await Assert.That(typeof(object)).IsClass();\n\n    await Assert.That(typeof(IEnumerable)).IsNotClass();\n    await Assert.That(typeof(int)).IsNotClass(); // Value type\n}\n"})}),"\n",(0,i.jsx)(s.h4,{id:"isinterface--isnotinterface",children:"IsInterface / IsNotInterface"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-csharp",children:"[Test]\npublic async Task Is_Interface()\n{\n    await Assert.That(typeof(IEnumerable)).IsInterface();\n    await Assert.That(typeof(IDisposable)).IsInterface();\n\n    await Assert.That(typeof(string)).IsNotInterface();\n}\n"})}),"\n",(0,i.jsx)(s.h3,{id:"modifiers",children:"Modifiers"}),"\n",(0,i.jsx)(s.h4,{id:"isabstract--isnotabstract",children:"IsAbstract / IsNotAbstract"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-csharp",children:"public abstract class AbstractBase { }\npublic class Concrete : AbstractBase { }\n\n[Test]\npublic async Task Is_Abstract()\n{\n    await Assert.That(typeof(AbstractBase)).IsAbstract();\n    await Assert.That(typeof(Concrete)).IsNotAbstract();\n}\n"})}),"\n",(0,i.jsx)(s.h4,{id:"issealed--isnotsealed",children:"IsSealed / IsNotSealed"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-csharp",children:"public sealed class SealedClass { }\npublic class OpenClass { }\n\n[Test]\npublic async Task Is_Sealed()\n{\n    await Assert.That(typeof(SealedClass)).IsSealed();\n    await Assert.That(typeof(string)).IsSealed(); // string is sealed\n    await Assert.That(typeof(OpenClass)).IsNotSealed();\n}\n"})}),"\n",(0,i.jsx)(s.h3,{id:"value-types-and-enums",children:"Value Types and Enums"}),"\n",(0,i.jsx)(s.h4,{id:"isvaluetype--isnotvaluetype",children:"IsValueType / IsNotValueType"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-csharp",children:"[Test]\npublic async Task Is_Value_Type()\n{\n    await Assert.That(typeof(int)).IsValueType();\n    await Assert.That(typeof(DateTime)).IsValueType();\n    await Assert.That(typeof(Guid)).IsValueType();\n\n    await Assert.That(typeof(string)).IsNotValueType();\n    await Assert.That(typeof(object)).IsNotValueType();\n}\n"})}),"\n",(0,i.jsx)(s.h4,{id:"isenum--isnotenum",children:"IsEnum / IsNotEnum"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-csharp",children:"public enum Color { Red, Green, Blue }\n\n[Test]\npublic async Task Is_Enum()\n{\n    await Assert.That(typeof(Color)).IsEnum();\n    await Assert.That(typeof(DayOfWeek)).IsEnum();\n\n    await Assert.That(typeof(int)).IsNotEnum();\n}\n"})}),"\n",(0,i.jsx)(s.h4,{id:"isprimitive--isnotprimitive",children:"IsPrimitive / IsNotPrimitive"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-csharp",children:"[Test]\npublic async Task Is_Primitive()\n{\n    // Primitives: bool, byte, sbyte, short, ushort, int, uint,\n    //             long, ulong, char, double, float, IntPtr, UIntPtr\n    await Assert.That(typeof(int)).IsPrimitive();\n    await Assert.That(typeof(bool)).IsPrimitive();\n    await Assert.That(typeof(char)).IsPrimitive();\n\n    await Assert.That(typeof(string)).IsNotPrimitive();\n    await Assert.That(typeof(decimal)).IsNotPrimitive();\n}\n"})}),"\n",(0,i.jsx)(s.h3,{id:"visibility",children:"Visibility"}),"\n",(0,i.jsx)(s.h4,{id:"ispublic--isnotpublic",children:"IsPublic / IsNotPublic"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-csharp",children:"public class PublicClass { }\ninternal class InternalClass { }\n\n[Test]\npublic async Task Is_Public()\n{\n    await Assert.That(typeof(PublicClass)).IsPublic();\n    await Assert.That(typeof(string)).IsPublic();\n\n    await Assert.That(typeof(InternalClass)).IsNotPublic();\n}\n"})}),"\n",(0,i.jsx)(s.h3,{id:"generics",children:"Generics"}),"\n",(0,i.jsx)(s.h4,{id:"isgenerictype--isnotgenerictype",children:"IsGenericType / IsNotGenericType"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-csharp",children:"[Test]\npublic async Task Is_Generic_Type()\n{\n    await Assert.That(typeof(List<int>)).IsGenericType();\n    await Assert.That(typeof(Dictionary<string, int>)).IsGenericType();\n\n    await Assert.That(typeof(string)).IsNotGenericType();\n}\n"})}),"\n",(0,i.jsx)(s.h4,{id:"isgenerictypedefinition--isnotgenerictypedefinition",children:"IsGenericTypeDefinition / IsNotGenericTypeDefinition"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-csharp",children:"[Test]\npublic async Task Is_Generic_Type_Definition()\n{\n    // Generic type definition (unbound)\n    await Assert.That(typeof(List<>)).IsGenericTypeDefinition();\n    await Assert.That(typeof(Dictionary<,>)).IsGenericTypeDefinition();\n\n    // Constructed generic type (bound)\n    await Assert.That(typeof(List<int>)).IsNotGenericTypeDefinition();\n}\n"})}),"\n",(0,i.jsx)(s.h4,{id:"isconstructedgenerictype--isnotconstructedgenerictype",children:"IsConstructedGenericType / IsNotConstructedGenericType"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-csharp",children:"[Test]\npublic async Task Is_Constructed_Generic_Type()\n{\n    await Assert.That(typeof(List<int>)).IsConstructedGenericType();\n    await Assert.That(typeof(Dictionary<string, int>)).IsConstructedGenericType();\n\n    await Assert.That(typeof(List<>)).IsNotConstructedGenericType();\n    await Assert.That(typeof(string)).IsNotConstructedGenericType();\n}\n"})}),"\n",(0,i.jsx)(s.h4,{id:"containsgenericparameters--doesnotcontaingenericparameters",children:"ContainsGenericParameters / DoesNotContainGenericParameters"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-csharp",children:"[Test]\npublic async Task Contains_Generic_Parameters()\n{\n    await Assert.That(typeof(List<>)).ContainsGenericParameters();\n\n    await Assert.That(typeof(List<int>)).DoesNotContainGenericParameters();\n    await Assert.That(typeof(string)).DoesNotContainGenericParameters();\n}\n"})}),"\n",(0,i.jsx)(s.h3,{id:"arrays-and-pointers",children:"Arrays and Pointers"}),"\n",(0,i.jsx)(s.h4,{id:"isarray--isnotarray",children:"IsArray / IsNotArray"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-csharp",children:"[Test]\npublic async Task Is_Array()\n{\n    await Assert.That(typeof(int[])).IsArray();\n    await Assert.That(typeof(string[])).IsArray();\n    await Assert.That(typeof(int[,])).IsArray(); // Multi-dimensional\n\n    await Assert.That(typeof(List<int>)).IsNotArray();\n}\n"})}),"\n",(0,i.jsx)(s.h4,{id:"isbyref--isnotbyref",children:"IsByRef / IsNotByRef"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-csharp",children:"[Test]\npublic async Task Is_By_Ref()\n{\n    var method = typeof(string).GetMethod(nameof(int.TryParse));\n    var parameters = method!.GetParameters();\n    var outParam = parameters.First(p => p.IsOut);\n\n    await Assert.That(outParam.ParameterType).IsByRef();\n}\n"})}),"\n",(0,i.jsx)(s.h4,{id:"isbyreflike--isnotbyreflike-net-5",children:"IsByRefLike / IsNotByRefLike (.NET 5+)"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-csharp",children:"[Test]\npublic async Task Is_By_Ref_Like()\n{\n    await Assert.That(typeof(Span<int>)).IsByRefLike();\n    await Assert.That(typeof(ReadOnlySpan<int>)).IsByRefLike();\n\n    await Assert.That(typeof(string)).IsNotByRefLike();\n}\n"})}),"\n",(0,i.jsx)(s.h4,{id:"ispointer--isnotpointer",children:"IsPointer / IsNotPointer"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-csharp",children:"[Test]\npublic async Task Is_Pointer()\n{\n    unsafe\n    {\n        var intPtr = typeof(int*);\n        await Assert.That(intPtr).IsPointer();\n    }\n\n    await Assert.That(typeof(int)).IsNotPointer();\n}\n"})}),"\n",(0,i.jsx)(s.h3,{id:"nested-types",children:"Nested Types"}),"\n",(0,i.jsx)(s.h4,{id:"isnested--isnotnested",children:"IsNested / IsNotNested"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-csharp",children:"public class Outer\n{\n    public class Inner { }\n}\n\n[Test]\npublic async Task Is_Nested()\n{\n    await Assert.That(typeof(Outer.Inner)).IsNested();\n    await Assert.That(typeof(Outer)).IsNotNested();\n}\n"})}),"\n",(0,i.jsx)(s.h4,{id:"isnestedpublic--isnotnestedpublic",children:"IsNestedPublic / IsNotNestedPublic"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-csharp",children:"public class Container\n{\n    public class PublicNested { }\n    private class PrivateNested { }\n}\n\n[Test]\npublic async Task Is_Nested_Public()\n{\n    await Assert.That(typeof(Container.PublicNested)).IsNestedPublic();\n}\n"})}),"\n",(0,i.jsx)(s.h4,{id:"isnestedprivate--isnotnestedprivate",children:"IsNestedPrivate / IsNotNestedPrivate"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-csharp",children:'[Test]\npublic async Task Is_Nested_Private()\n{\n    var privateType = typeof(Container)\n        .GetNestedType("PrivateNested", BindingFlags.NonPublic);\n\n    await Assert.That(privateType).IsNestedPrivate();\n}\n'})}),"\n",(0,i.jsx)(s.h4,{id:"isnestedassembly--isnotnestedassembly",children:"IsNestedAssembly / IsNotNestedAssembly"}),"\n",(0,i.jsx)(s.p,{children:"For internal nested types."}),"\n",(0,i.jsx)(s.h4,{id:"isnestedfamily--isnotnestedfamily",children:"IsNestedFamily / IsNotNestedFamily"}),"\n",(0,i.jsx)(s.p,{children:"For protected nested types."}),"\n",(0,i.jsx)(s.h3,{id:"visibility-checks",children:"Visibility Checks"}),"\n",(0,i.jsx)(s.h4,{id:"isvisible--isnotvisible",children:"IsVisible / IsNotVisible"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-csharp",children:"[Test]\npublic async Task Is_Visible()\n{\n    await Assert.That(typeof(string)).IsVisible();\n    await Assert.That(typeof(List<int>)).IsVisible();\n\n    // Internal types are not visible\n    var internalType = Assembly.GetExecutingAssembly()\n        .GetTypes()\n        .FirstOrDefault(t => !t.IsPublic && !t.IsNested);\n\n    if (internalType != null)\n    {\n        await Assert.That(internalType).IsNotVisible();\n    }\n}\n"})}),"\n",(0,i.jsx)(s.h3,{id:"com-interop",children:"COM Interop"}),"\n",(0,i.jsx)(s.h4,{id:"iscomobject--isnotcomobject",children:"IsCOMObject / IsNotCOMObject"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-csharp",children:"[Test]\npublic async Task Is_COM_Object()\n{\n    await Assert.That(typeof(string)).IsNotCOMObject();\n    // COM types would return true\n}\n"})}),"\n",(0,i.jsx)(s.h2,{id:"practical-examples",children:"Practical Examples"}),"\n",(0,i.jsx)(s.h3,{id:"dependency-injection-validation",children:"Dependency Injection Validation"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-csharp",children:"[Test]\npublic async Task Service_Implements_Interface()\n{\n    var service = GetService<IUserService>();\n\n    await Assert.That(service).IsAssignableTo<IUserService>();\n    await Assert.That(service).IsNotNull();\n}\n"})}),"\n",(0,i.jsx)(s.h3,{id:"plugin-system",children:"Plugin System"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-csharp",children:"public interface IPlugin { }\n\n[Test]\npublic async Task Plugin_Implements_Interface()\n{\n    var pluginType = LoadPluginType();\n\n    await Assert.That(pluginType).IsAssignableTo<IPlugin>();\n    await Assert.That(pluginType).IsClass();\n    await Assert.That(pluginType).IsNotAbstract();\n}\n"})}),"\n",(0,i.jsx)(s.h3,{id:"reflection-testing",children:"Reflection Testing"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-csharp",children:"[Test]\npublic async Task Type_Has_Expected_Properties()\n{\n    var type = typeof(User);\n\n    await Assert.That(type).IsClass();\n    await Assert.That(type).IsPublic();\n    await Assert.That(type).IsNotAbstract();\n    await Assert.That(type).IsNotSealed();\n}\n"})}),"\n",(0,i.jsx)(s.h3,{id:"generic-constraints",children:"Generic Constraints"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-csharp",children:"[Test]\npublic async Task Validate_Generic_Constraints()\n{\n    var listType = typeof(List<int>);\n\n    await Assert.That(listType).IsGenericType();\n    await Assert.That(listType).IsAssignableTo<IEnumerable<int>>();\n}\n"})}),"\n",(0,i.jsx)(s.h3,{id:"enum-validation",children:"Enum Validation"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-csharp",children:"[Test]\npublic async Task Type_Is_Enum()\n{\n    var statusType = typeof(OrderStatus);\n\n    await Assert.That(statusType).IsEnum();\n    await Assert.That(statusType).IsValueType();\n}\n"})}),"\n",(0,i.jsx)(s.h3,{id:"abstract-class-validation",children:"Abstract Class Validation"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-csharp",children:"[Test]\npublic async Task Base_Class_Is_Abstract()\n{\n    var baseType = typeof(BaseRepository);\n\n    await Assert.That(baseType).IsClass();\n    await Assert.That(baseType).IsAbstract();\n}\n"})}),"\n",(0,i.jsx)(s.h2,{id:"chaining-type-assertions",children:"Chaining Type Assertions"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-csharp",children:"[Test]\npublic async Task Chained_Type_Assertions()\n{\n    var type = typeof(MyService);\n\n    await Assert.That(type)\n        .IsClass()\n        .And.IsPublic()\n        .And.IsNotAbstract()\n        .And.IsNotSealed();\n}\n"})}),"\n",(0,i.jsx)(s.h2,{id:"type-comparison",children:"Type Comparison"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-csharp",children:"[Test]\npublic async Task Compare_Types()\n{\n    var type1 = typeof(List<int>);\n    var type2 = typeof(List<int>);\n    var type3 = typeof(List<string>);\n\n    await Assert.That(type1).IsEqualTo(type2);\n    await Assert.That(type1).IsNotEqualTo(type3);\n}\n"})}),"\n",(0,i.jsx)(s.h2,{id:"working-with-base-types",children:"Working with Base Types"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-csharp",children:"[Test]\npublic async Task Check_Base_Type()\n{\n    var type = typeof(ArgumentNullException);\n    var baseType = type.BaseType;\n\n    await Assert.That(baseType).IsEqualTo(typeof(ArgumentException));\n}\n"})}),"\n",(0,i.jsx)(s.h2,{id:"interface-implementation",children:"Interface Implementation"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-csharp",children:"[Test]\npublic async Task Implements_Multiple_Interfaces()\n{\n    var type = typeof(List<int>);\n\n    await Assert.That(type).IsAssignableTo<IList<int>>();\n    await Assert.That(type).IsAssignableTo<ICollection<int>>();\n    await Assert.That(type).IsAssignableTo<IEnumerable<int>>();\n}\n"})}),"\n",(0,i.jsx)(s.h2,{id:"common-patterns",children:"Common Patterns"}),"\n",(0,i.jsx)(s.h3,{id:"factory-pattern-validation",children:"Factory Pattern Validation"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-csharp",children:'[Test]\npublic async Task Factory_Returns_Correct_Type()\n{\n    var instance = Factory.Create("user-service");\n\n    await Assert.That(instance).IsTypeOf<UserService>();\n    await Assert.That(instance).IsAssignableTo<IService>();\n}\n'})}),"\n",(0,i.jsx)(s.h3,{id:"orm-entity-validation",children:"ORM Entity Validation"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-csharp",children:"[Test]\npublic async Task Entity_Is_Properly_Configured()\n{\n    var entityType = typeof(Order);\n\n    await Assert.That(entityType).IsClass();\n    await Assert.That(entityType).IsPublic();\n    await Assert.That(entityType).IsNotAbstract();\n\n    // Check for required interfaces\n    await Assert.That(entityType).IsAssignableTo<IEntity>();\n}\n"})}),"\n",(0,i.jsx)(s.h3,{id:"serialization-requirements",children:"Serialization Requirements"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-csharp",children:"[Test]\npublic async Task Type_Is_Serializable()\n{\n    var type = typeof(DataTransferObject);\n\n    await Assert.That(type).IsClass();\n    await Assert.That(type).IsPublic();\n\n    // All properties should be public\n    var properties = type.GetProperties();\n    await Assert.That(properties).All(p => p.GetMethod?.IsPublic ?? false);\n}\n"})}),"\n",(0,i.jsx)(s.h3,{id:"test-double-validation",children:"Test Double Validation"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-csharp",children:"[Test]\npublic async Task Mock_Implements_Interface()\n{\n    var mock = new Mock<IUserRepository>();\n    var instance = mock.Object;\n\n    await Assert.That(instance).IsAssignableTo<IUserRepository>();\n}\n"})}),"\n",(0,i.jsx)(s.h2,{id:"struct-validation",children:"Struct Validation"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-csharp",children:"public struct Point\n{\n    public int X { get; set; }\n    public int Y { get; set; }\n}\n\n[Test]\npublic async Task Struct_Properties()\n{\n    var type = typeof(Point);\n\n    await Assert.That(type).IsValueType();\n    await Assert.That(type).IsNotClass();\n    await Assert.That(type).IsNotEnum();\n}\n"})}),"\n",(0,i.jsx)(s.h2,{id:"record-validation",children:"Record Validation"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-csharp",children:"public record Person(string Name, int Age);\n\n[Test]\npublic async Task Record_Properties()\n{\n    var type = typeof(Person);\n\n    await Assert.That(type).IsClass();\n    // Records are classes with special properties\n}\n"})}),"\n",(0,i.jsx)(s.h2,{id:"see-also",children:"See Also"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.a,{href:"/docs/assertions/exceptions",children:"Exceptions"})," - Type checking for exceptions"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.a,{href:"/docs/assertions/equality-and-comparison",children:"Equality & Comparison"})," - Comparing type objects"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.a,{href:"/docs/assertions/collections",children:"Collections"})," - Type checking collection elements"]}),"\n"]})]})}function d(e={}){const{wrapper:s}={...(0,a.R)(),...e.components};return s?(0,i.jsx)(s,{...e,children:(0,i.jsx)(p,{...e})}):p(e)}},8453:(e,s,n)=>{n.d(s,{R:()=>r,x:()=>l});var t=n(6540);const i={},a=t.createContext(i);function r(e){const s=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function l(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),t.createElement(a.Provider,{value:s},e.children)}}}]);