"use strict";(self.webpackChunktunit_docs_site=self.webpackChunktunit_docs_site||[]).push([[2712],{7204:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>u,frontMatter:()=>r,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"advanced/performance-best-practices","title":"Performance Best Practices","description":"This guide provides recommendations for optimizing test performance and ensuring your TUnit test suite runs efficiently.","source":"@site/docs/advanced/performance-best-practices.md","sourceDirName":"advanced","slug":"/advanced/performance-best-practices","permalink":"/docs/advanced/performance-best-practices","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{}}');var a=s(4848),i=s(8453);const r={},l="Performance Best Practices",o={},c=[{value:"Test Discovery Performance",id:"test-discovery-performance",level:2},{value:"Use AOT Mode",id:"use-aot-mode",level:3},{value:"Optimize Data Sources",id:"optimize-data-sources",level:3},{value:"Keep Data Generation Lightweight",id:"keep-data-generation-lightweight",level:4},{value:"Use Lazy Data Loading",id:"use-lazy-data-loading",level:4},{value:"Limit Matrix Test Combinations",id:"limit-matrix-test-combinations",level:3},{value:"Test Execution Performance",id:"test-execution-performance",level:2},{value:"Optimize Parallel Execution",id:"optimize-parallel-execution",level:3},{value:"Configure Appropriate Parallelism",id:"configure-appropriate-parallelism",level:4},{value:"Group Related Tests",id:"group-related-tests",level:4},{value:"Use Parallel Limiters Wisely",id:"use-parallel-limiters-wisely",level:4},{value:"Minimize Test Setup Overhead",id:"minimize-test-setup-overhead",level:3},{value:"Share Expensive Setup",id:"share-expensive-setup",level:4},{value:"Use Lazy Initialization",id:"use-lazy-initialization",level:4},{value:"Optimize Assertions",id:"optimize-assertions",level:3},{value:"Avoid Expensive Operations in Assertions",id:"avoid-expensive-operations-in-assertions",level:4},{value:"Use Early Exit Patterns",id:"use-early-exit-patterns",level:4},{value:"Memory Management",id:"memory-management",level:2},{value:"Dispose Resources Properly",id:"dispose-resources-properly",level:3},{value:"Avoid Memory Leaks in Static Fields",id:"avoid-memory-leaks-in-static-fields",level:3},{value:"Use ValueTask for High-Frequency Operations",id:"use-valuetask-for-high-frequency-operations",level:3},{value:"I/O Performance",id:"io-performance",level:2},{value:"Batch Operations",id:"batch-operations",level:3},{value:"Use Async I/O",id:"use-async-io",level:3},{value:"Cache File Contents",id:"cache-file-contents",level:3},{value:"Database Testing Performance",id:"database-testing-performance",level:2},{value:"Use Transaction Rollback",id:"use-transaction-rollback",level:3},{value:"Use In-Memory Databases for Unit Tests",id:"use-in-memory-databases-for-unit-tests",level:3},{value:"CI/CD Optimization",id:"cicd-optimization",level:2},{value:"Split Test Suites",id:"split-test-suites",level:3},{value:"Use Test Result Caching",id:"use-test-result-caching",level:3},{value:"Fail Fast in CI",id:"fail-fast-in-ci",level:3},{value:"Monitoring and Profiling",id:"monitoring-and-profiling",level:2},{value:"Add Performance Logging",id:"add-performance-logging",level:3},{value:"Track Test Metrics",id:"track-test-metrics",level:3},{value:"Summary",id:"summary",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"performance-best-practices",children:"Performance Best Practices"})}),"\n",(0,a.jsx)(n.p,{children:"This guide provides recommendations for optimizing test performance and ensuring your TUnit test suite runs efficiently."}),"\n",(0,a.jsx)(n.h2,{id:"test-discovery-performance",children:"Test Discovery Performance"}),"\n",(0,a.jsx)(n.h3,{id:"use-aot-mode",children:"Use AOT Mode"}),"\n",(0,a.jsx)(n.p,{children:"TUnit's AOT (Ahead-of-Time) compilation mode provides the best performance for test discovery:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-xml",children:"<PropertyGroup>\n    <IsAotCompatible>true</IsAotCompatible>\n    <EnableTrimAnalyzer>true</EnableTrimAnalyzer>\n</PropertyGroup>\n"})}),"\n",(0,a.jsx)(n.p,{children:"Benefits:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Faster test discovery"}),"\n",(0,a.jsx)(n.li,{children:"Lower memory usage"}),"\n",(0,a.jsx)(n.li,{children:"Better performance in CI/CD pipelines"}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"optimize-data-sources",children:"Optimize Data Sources"}),"\n",(0,a.jsx)(n.h4,{id:"keep-data-generation-lightweight",children:"Keep Data Generation Lightweight"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:'// \u274c Bad: Heavy computation during discovery\npublic static IEnumerable<User> GetTestUsers()\n{\n    // This runs during test discovery!\n    var users = DatabaseQuery.GetAllUsers();\n    return users.Where(u => u.IsActive);\n}\n\n// \u2705 Good: Lightweight data generation\npublic static IEnumerable<User> GetTestUsers()\n{\n    yield return new User { Id = 1, Name = "Test User 1" };\n    yield return new User { Id = 2, Name = "Test User 2" };\n}\n'})}),"\n",(0,a.jsx)(n.h4,{id:"use-lazy-data-loading",children:"Use Lazy Data Loading"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:"// \u2705 Good: Defer expensive operations until test execution\n[Test]\n[MethodDataSource<LazyDataProvider>(nameof(LazyDataProvider.GetIds))]\npublic async Task TestWithLazyData(int id)\n{\n    // Load full data only during test execution\n    var user = await LoadUserAsync(id);\n    await Assert.That(user).IsNotNull();\n}\n\npublic class LazyDataProvider\n{\n    public static IEnumerable<int> GetIds()\n    {\n        // Return only IDs during discovery\n        yield return 1;\n        yield return 2;\n        yield return 3;\n    }\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"limit-matrix-test-combinations",children:"Limit Matrix Test Combinations"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:'// \u274c Bad: Exponential test explosion\n[Test]\n[Arguments(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)]\n[Arguments("a", "b", "c", "d", "e")]\n[Arguments(true, false)]\n// Creates 10 \xd7 5 \xd7 2 = 100 tests!\n\n// \u2705 Good: Targeted test combinations\n[Test]\n[Arguments(1, "a", true)]\n[Arguments(5, "c", false)]\n[Arguments(10, "e", true)]\n// Only 3 specific test cases\n'})}),"\n",(0,a.jsx)(n.h2,{id:"test-execution-performance",children:"Test Execution Performance"}),"\n",(0,a.jsx)(n.h3,{id:"optimize-parallel-execution",children:"Optimize Parallel Execution"}),"\n",(0,a.jsx)(n.h4,{id:"configure-appropriate-parallelism",children:"Configure Appropriate Parallelism"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:"// Set maximum parallel test execution\n[assembly: MaxParallelTests(Environment.ProcessorCount)]\n\n// Or use command line\n// dotnet test --maximum-parallel-tests 8\n"})}),"\n",(0,a.jsx)(n.h4,{id:"group-related-tests",children:"Group Related Tests"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:'// Tests in the same group run sequentially but different groups run in parallel\n[ParallelGroup("DatabaseTests")]\npublic class UserRepositoryTests\n{\n    // These tests share database resources\n}\n\n[ParallelGroup("DatabaseTests")]\npublic class OrderRepositoryTests\n{\n    // These also share database resources\n}\n\n[ParallelGroup("ApiTests")]\npublic class ApiIntegrationTests\n{\n    // These can run in parallel with database tests\n}\n'})}),"\n",(0,a.jsx)(n.h4,{id:"use-parallel-limiters-wisely",children:"Use Parallel Limiters Wisely"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:"public class DatabaseConnectionLimit : IParallelLimit\n{\n    public int Limit => 5; // Max 5 concurrent database connections\n}\n\n[ParallelLimiter<DatabaseConnectionLimit>]\npublic class DatabaseIntegrationTests\n{\n    // All tests here respect the connection limit\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"minimize-test-setup-overhead",children:"Minimize Test Setup Overhead"}),"\n",(0,a.jsx)(n.h4,{id:"share-expensive-setup",children:"Share Expensive Setup"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:"// \u274c Bad: Expensive setup per test\npublic class ExpensiveTests\n{\n    [Before(HookType.Test)]\n    public async Task SetupEachTest()\n    {\n        await StartDatabaseContainer();\n        await MigrateDatabase();\n    }\n}\n\n// \u2705 Good: Share setup across tests\npublic class EfficientTests\n{\n    private static DatabaseContainer? _container;\n    \n    [Before(HookType.Class)]\n    public static async Task SetupOnce()\n    {\n        _container = await StartDatabaseContainer();\n        await MigrateDatabase();\n    }\n    \n    [After(HookType.Class)]\n    public static async Task CleanupOnce()\n    {\n        if (_container != null)\n        {\n            await _container.DisposeAsync();\n        }\n    }\n}\n"})}),"\n",(0,a.jsx)(n.h4,{id:"use-lazy-initialization",children:"Use Lazy Initialization"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:"public class PerformantTests\n{\n    private static readonly Lazy<ExpensiveResource> _resource = \n        new(() => new ExpensiveResource(), LazyThreadSafetyMode.ExecutionAndPublication);\n    \n    [Test]\n    public async Task TestUsingResource()\n    {\n        var resource = _resource.Value; // Only created on first access\n        await resource.DoSomethingAsync();\n    }\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"optimize-assertions",children:"Optimize Assertions"}),"\n",(0,a.jsx)(n.h4,{id:"avoid-expensive-operations-in-assertions",children:"Avoid Expensive Operations in Assertions"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:"// \u274c Bad: Expensive operation in assertion\nawait Assert.That(await GetAllUsersFromDatabase())\n    .HasCount()\n    .EqualTo(1000);\n\n// \u2705 Good: Use efficient queries\nvar userCount = await GetUserCountFromDatabase();\nawait Assert.That(userCount).IsEqualTo(1000);\n"})}),"\n",(0,a.jsx)(n.h4,{id:"use-early-exit-patterns",children:"Use Early Exit Patterns"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:"[Test]\npublic async Task EfficientValidation()\n{\n    var result = await GetResultAsync();\n    \n    // Quick checks first\n    if (result == null)\n    {\n        await Assert.That(result).IsNotNull();\n        return; // Exit early\n    }\n    \n    // More expensive validations only if needed\n    await Assert.That(result.Items).HasCount().GreaterThan(0);\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"memory-management",children:"Memory Management"}),"\n",(0,a.jsx)(n.h3,{id:"dispose-resources-properly",children:"Dispose Resources Properly"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:"public class MemoryEfficientTests : IAsyncDisposable\n{\n    private readonly List<IDisposable> _disposables = new();\n    \n    [Test]\n    public async Task TestWithResources()\n    {\n        var resource = new LargeResource();\n        _disposables.Add(resource);\n        \n        // Use resource\n        await resource.ProcessAsync();\n    }\n    \n    public async ValueTask DisposeAsync()\n    {\n        foreach (var disposable in _disposables)\n        {\n            disposable.Dispose();\n        }\n        _disposables.Clear();\n        \n        // Force garbage collection if needed\n        GC.Collect();\n        GC.WaitForPendingFinalizers();\n    }\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"avoid-memory-leaks-in-static-fields",children:"Avoid Memory Leaks in Static Fields"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:"// \u274c Bad: Static collections that grow indefinitely\npublic class LeakyTests\n{\n    private static readonly List<TestResult> _allResults = new();\n    \n    [After(HookType.Test)]\n    public void StoreResult()\n    {\n        _allResults.Add(GetCurrentResult()); // Memory leak!\n    }\n}\n\n// \u2705 Good: Proper cleanup or bounded collections\npublic class EfficientTests\n{\n    private static readonly Queue<TestResult> _recentResults = new();\n    private const int MaxResults = 100;\n    \n    [After(HookType.Test)]\n    public void StoreResult()\n    {\n        _recentResults.Enqueue(GetCurrentResult());\n        \n        while (_recentResults.Count > MaxResults)\n        {\n            _recentResults.Dequeue();\n        }\n    }\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"use-valuetask-for-high-frequency-operations",children:"Use ValueTask for High-Frequency Operations"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:"// For operations called many times, use ValueTask to reduce allocations\npublic async ValueTask<bool> FastCheckAsync(int id)\n{\n    if (_cache.TryGetValue(id, out var cached))\n    {\n        return cached; // No allocation for cached path\n    }\n    \n    var result = await LoadFromDatabaseAsync(id);\n    _cache[id] = result;\n    return result;\n}\n\n[Test]\n[Arguments(1, 2, 3, 4, 5)] // Many invocations\npublic async Task HighFrequencyTest(int id)\n{\n    var result = await FastCheckAsync(id);\n    await Assert.That(result).IsTrue();\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"io-performance",children:"I/O Performance"}),"\n",(0,a.jsx)(n.h3,{id:"batch-operations",children:"Batch Operations"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:"// \u274c Bad: Individual operations\n[Test]\npublic async Task SlowIOTest()\n{\n    foreach (var id in Enumerable.Range(1, 100))\n    {\n        await SaveUserAsync(new User { Id = id });\n    }\n}\n\n// \u2705 Good: Batch operations\n[Test]\npublic async Task FastIOTest()\n{\n    var users = Enumerable.Range(1, 100)\n        .Select(id => new User { Id = id })\n        .ToList();\n    \n    await SaveUsersBatchAsync(users);\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"use-async-io",children:"Use Async I/O"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:'// \u274c Bad: Synchronous I/O\n[Test]\npublic void SyncIOTest()\n{\n    var content = File.ReadAllText("large-file.txt");\n    ProcessContent(content);\n}\n\n// \u2705 Good: Asynchronous I/O\n[Test]\npublic async Task AsyncIOTest()\n{\n    var content = await File.ReadAllTextAsync("large-file.txt");\n    await ProcessContentAsync(content);\n}\n'})}),"\n",(0,a.jsx)(n.h3,{id:"cache-file-contents",children:"Cache File Contents"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:'public class FileTestsWithCache\n{\n    private static readonly ConcurrentDictionary<string, string> _fileCache = new();\n    \n    private async Task<string> GetFileContentAsync(string path)\n    {\n        return await _fileCache.GetOrAddAsync(path, \n            async p => await File.ReadAllTextAsync(p));\n    }\n    \n    [Test]\n    [Arguments("config1.json")]\n    [Arguments("config2.json")]\n    public async Task TestWithCachedFiles(string filename)\n    {\n        var content = await GetFileContentAsync(filename);\n        await Assert.That(content).IsNotEmpty();\n    }\n}\n'})}),"\n",(0,a.jsx)(n.h2,{id:"database-testing-performance",children:"Database Testing Performance"}),"\n",(0,a.jsx)(n.h3,{id:"use-transaction-rollback",children:"Use Transaction Rollback"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:'public class FastDatabaseTests\n{\n    [Test]\n    public async Task TransactionalTest()\n    {\n        using var transaction = await BeginTransactionAsync();\n        \n        try\n        {\n            // Perform database operations\n            await CreateUserAsync("test@example.com");\n            \n            // Verify\n            var user = await GetUserAsync("test@example.com");\n            await Assert.That(user).IsNotNull();\n            \n            // Rollback instead of cleanup\n            await transaction.RollbackAsync();\n        }\n        catch\n        {\n            await transaction.RollbackAsync();\n            throw;\n        }\n    }\n}\n'})}),"\n",(0,a.jsx)(n.h3,{id:"use-in-memory-databases-for-unit-tests",children:"Use In-Memory Databases for Unit Tests"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:'public class InMemoryDatabaseTests\n{\n    private DbContext CreateInMemoryContext()\n    {\n        var options = new DbContextOptionsBuilder<AppDbContext>()\n            .UseInMemoryDatabase(Guid.NewGuid().ToString())\n            .Options;\n            \n        return new AppDbContext(options);\n    }\n    \n    [Test]\n    public async Task FastDatabaseTest()\n    {\n        using var context = CreateInMemoryContext();\n        \n        // Test runs entirely in memory\n        context.Users.Add(new User { Name = "Test" });\n        await context.SaveChangesAsync();\n        \n        var count = await context.Users.CountAsync();\n        await Assert.That(count).IsEqualTo(1);\n    }\n}\n'})}),"\n",(0,a.jsx)(n.h2,{id:"cicd-optimization",children:"CI/CD Optimization"}),"\n",(0,a.jsx)(n.h3,{id:"split-test-suites",children:"Split Test Suites"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:'# Run fast unit tests first\ndotnet test --filter "Category=Unit" --no-build\n\n# Run slower integration tests separately\ndotnet test --filter "Category=Integration" --no-build\n\n# Run expensive E2E tests last\ndotnet test --filter "Category=E2E" --no-build\n'})}),"\n",(0,a.jsx)(n.h3,{id:"use-test-result-caching",children:"Use Test Result Caching"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-xml",children:"\x3c!-- Cache test results in CI --\x3e\n<PropertyGroup>\n    <TUnitCacheTestResults>true</TUnitCacheTestResults>\n    <TUnitTestResultsCachePath>$(Build.StagingDirectory)/testcache</TUnitTestResultsCachePath>\n</PropertyGroup>\n"})}),"\n",(0,a.jsx)(n.h3,{id:"fail-fast-in-ci",children:"Fail Fast in CI"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"# Stop on first failure to save CI time\ndotnet test --fail-fast\n"})}),"\n",(0,a.jsx)(n.h2,{id:"monitoring-and-profiling",children:"Monitoring and Profiling"}),"\n",(0,a.jsx)(n.h3,{id:"add-performance-logging",children:"Add Performance Logging"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:'public class PerformanceAwareExecutor : ITestExecutor\n{\n    private readonly ILogger<PerformanceAwareExecutor> _logger;\n    \n    public async Task ExecuteAsync(TestContext context, Func<Task> testBody)\n    {\n        var stopwatch = Stopwatch.StartNew();\n        \n        try\n        {\n            await testBody();\n        }\n        finally\n        {\n            stopwatch.Stop();\n            \n            if (stopwatch.ElapsedMilliseconds > 1000)\n            {\n                _logger.LogWarning(\n                    "Slow test detected: {TestName} took {ElapsedMs}ms",\n                    context.TestDetails.TestName,\n                    stopwatch.ElapsedMilliseconds);\n            }\n        }\n    }\n}\n'})}),"\n",(0,a.jsx)(n.h3,{id:"track-test-metrics",children:"Track Test Metrics"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:'[After(HookType.Test)]\npublic static void RecordTestMetrics()\n{\n    var context = TestContext.Current;\n    if (context?.Result != null)\n    {\n        TelemetryClient.TrackMetric(\n            "TestDuration",\n            context.Result.Duration.TotalMilliseconds,\n            new Dictionary<string, string>\n            {\n                ["TestName"] = context.TestDetails.TestName,\n                ["TestClass"] = context.TestDetails.TestClass,\n                ["Result"] = context.Result.State.ToString()\n            });\n    }\n}\n'})}),"\n",(0,a.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,a.jsx)(n.p,{children:"Key performance principles:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Optimize Discovery"}),": Keep data sources lightweight and limit test combinations"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Parallelize Wisely"}),": Use appropriate parallel limits and grouping"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Manage Resources"}),": Dispose properly and avoid memory leaks"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Cache Aggressively"}),": Cache expensive operations and file I/O"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Batch Operations"}),": Group database and I/O operations"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Monitor Performance"}),": Track and alert on slow tests"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Use AOT Mode"}),": Enable AOT for best performance"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Fail Fast"}),": Stop early on failures in CI"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"By following these practices, you can maintain a fast, efficient test suite that scales with your codebase."})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>r,x:()=>l});var t=s(6540);const a={},i=t.createContext(a);function r(e){const n=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);