"use strict";(self.webpackChunktunit_docs_site=self.webpackChunktunit_docs_site||[]).push([[2483],{1175:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>d,contentTitle:()=>c,default:()=>p,frontMatter:()=>i,metadata:()=>t,toc:()=>u});const t=JSON.parse('{"id":"test-lifecycle/setup","title":"Test Set Ups","description":"Most setup for a test can be performed in the constructor (think setting up mocks, assigning fields.)","source":"@site/docs/test-lifecycle/setup.md","sourceDirName":"test-lifecycle","slug":"/test-lifecycle/setup","permalink":"/docs/test-lifecycle/setup","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"docs","previous":{"title":"Things to know","permalink":"/docs/test-authoring/things-to-know"},"next":{"title":"Test Clean Ups","permalink":"/docs/test-lifecycle/cleanup"}}');var o=s(4848),a=s(8453),r=s(1470),l=s(9365);const i={},c="Test Set Ups",d={},u=[{value:"Hook Method Signatures",id:"hook-method-signatures",level:2},{value:"Hook Parameters",id:"hook-parameters",level:3},{value:"[Before(HookType)]",id:"beforehooktype",level:2},{value:"[Before(Test)]",id:"beforetest",level:3},{value:"[Before(Class)]",id:"beforeclass",level:3},{value:"[Before(Assembly)]",id:"beforeassembly",level:3},{value:"[Before(TestSession)]",id:"beforetestsession",level:3},{value:"[Before(TestDiscovery)]",id:"beforetestdiscovery",level:3},{value:"[BeforeEvery(HookType)]",id:"beforeeveryhooktype",level:2},{value:"[BeforeEvery(Test)]",id:"beforeeverytest",level:3},{value:"[BeforeEvery(Class)]",id:"beforeeveryclass",level:3},{value:"[BeforeEvery(Assembly)]",id:"beforeeveryassembly",level:3},{value:"[BeforeEvery(TestSession)]",id:"beforeeverytestsession",level:3},{value:"[BeforeEvery(TestDiscovery)]",id:"beforeeverytestdiscovery",level:3},{value:"Common Mistakes &amp; Best Practices",id:"common-mistakes--best-practices",level:2},{value:"Confusing Instance vs Static Hooks",id:"confusing-instance-vs-static-hooks",level:3},{value:"Mixing Sync and Async Incorrectly",id:"mixing-sync-and-async-incorrectly",level:3},{value:"Expensive Setup at Wrong Level",id:"expensive-setup-at-wrong-level",level:3},{value:"AsyncLocal",id:"asynclocal",level:2}];function h(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,a.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"test-set-ups",children:"Test Set Ups"})}),"\n",(0,o.jsx)(n.p,{children:"Most setup for a test can be performed in the constructor (think setting up mocks, assigning fields.)"}),"\n",(0,o.jsx)(n.p,{children:"However some scenarios require further setup that could be an asynchronous operation.\nE.g. pinging a service to wake it up in preparation for the tests."}),"\n",(0,o.jsxs)(n.p,{children:["For this, we can declare a method with a ",(0,o.jsx)(n.code,{children:"[Before(...)]"})," or a ",(0,o.jsx)(n.code,{children:"[BeforeEvery(...)]"})," attribute."]}),"\n",(0,o.jsx)(n.h2,{id:"hook-method-signatures",children:"Hook Method Signatures"}),"\n",(0,o.jsx)(n.p,{children:"Hook methods can be either synchronous or asynchronous:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:'[Before(Test)]\npublic void SynchronousSetup()  // \u2705 Valid - synchronous hook\n{\n    _value = 99;\n}\n\n[Before(Test)]\npublic async Task AsyncSetup()  // \u2705 Valid - asynchronous hook\n{\n    _response = await new HttpClient().GetAsync("https://localhost/ping");\n}\n'})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Important Notes:"})}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["Hooks can be ",(0,o.jsx)(n.code,{children:"void"})," (synchronous) or ",(0,o.jsx)(n.code,{children:"async Task"})," (asynchronous)"]}),"\n",(0,o.jsx)(n.li,{children:"Use async hooks when you need to perform async operations (HTTP calls, database queries, etc.)"}),"\n",(0,o.jsx)(n.li,{children:"Use synchronous hooks for simple setup (setting fields, initializing values, etc.)"}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"async void"})," hooks are ",(0,o.jsx)(n.strong,{children:"not allowed"})," and will cause a compiler error"]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"hook-parameters",children:"Hook Parameters"}),"\n",(0,o.jsx)(n.p,{children:"Hooks can optionally accept parameters for accessing context information and cancellation tokens:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:'[Before(Test)]\npublic async Task Setup(TestContext context, CancellationToken cancellationToken)\n{\n    // Access test information via context\n    Console.WriteLine($"Setting up test: {context.TestDetails.TestName}");\n\n    // Use cancellation token for timeout-aware operations\n    await SomeLongRunningOperation(cancellationToken);\n}\n\n[Before(Class)]\npublic static async Task ClassSetup(ClassHookContext context, CancellationToken cancellationToken)\n{\n    // Both context and cancellation token available for class-level hooks\n    await InitializeResources(cancellationToken);\n}\n\n[Before(Test)]\npublic async Task SetupWithToken(CancellationToken cancellationToken)\n{\n    // Can use CancellationToken without context\n    await Task.Delay(100, cancellationToken);\n}\n\n[Before(Test)]\npublic async Task SetupWithContext(TestContext context)\n{\n    // Can use context without CancellationToken\n    Console.WriteLine(context.TestDetails.TestName);\n}\n'})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Valid Parameter Combinations:"})}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["No parameters: ",(0,o.jsx)(n.code,{children:"public void Hook() { }"})]}),"\n",(0,o.jsxs)(n.li,{children:["Context only: ",(0,o.jsx)(n.code,{children:"public void Hook(TestContext context) { }"})]}),"\n",(0,o.jsxs)(n.li,{children:["CancellationToken only: ",(0,o.jsx)(n.code,{children:"public async Task Hook(CancellationToken ct) { }"})]}),"\n",(0,o.jsxs)(n.li,{children:["Both: ",(0,o.jsx)(n.code,{children:"public async Task Hook(TestContext context, CancellationToken ct) { }"})]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Context Types by Hook Level:"})}),"\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"Hook Level"}),(0,o.jsx)(n.th,{children:"Context Type"}),(0,o.jsx)(n.th,{children:"Example"})]})}),(0,o.jsxs)(n.tbody,{children:[(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"[Before(Test)]"})}),(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"TestContext"})}),(0,o.jsx)(n.td,{children:"Access test details, output writer"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"[Before(Class)]"})}),(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"ClassHookContext"})}),(0,o.jsx)(n.td,{children:"Access class information"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"[Before(Assembly)]"})}),(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"AssemblyHookContext"})}),(0,o.jsx)(n.td,{children:"Access assembly information"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"[Before(TestSession)]"})}),(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"TestSessionContext"})}),(0,o.jsx)(n.td,{children:"Access test session information"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"[Before(TestDiscovery)]"})}),(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"BeforeTestDiscoveryContext"})}),(0,o.jsx)(n.td,{children:"Access discovery context"})]})]})]}),"\n",(0,o.jsx)(n.h2,{id:"beforehooktype",children:"[Before(HookType)]"}),"\n",(0,o.jsx)(n.h3,{id:"beforetest",children:"[Before(Test)]"}),"\n",(0,o.jsx)(n.p,{children:"Must be an instance method. Will be executed before each test in the class it's defined in.\nMethods will be executed bottom-up, so the base class set ups will execute first and then the inheriting classes."}),"\n",(0,o.jsx)(n.h3,{id:"beforeclass",children:"[Before(Class)]"}),"\n",(0,o.jsx)(n.p,{children:"Must be a static method. Will run once before the first test in the class it's defined in starts."}),"\n",(0,o.jsx)(n.h3,{id:"beforeassembly",children:"[Before(Assembly)]"}),"\n",(0,o.jsx)(n.p,{children:"Must be a static method. Will run once before the first test in the assembly it's defined in starts."}),"\n",(0,o.jsx)(n.h3,{id:"beforetestsession",children:"[Before(TestSession)]"}),"\n",(0,o.jsx)(n.p,{children:"Must be a static method. Will run once before the first test in the test session starts."}),"\n",(0,o.jsx)(n.h3,{id:"beforetestdiscovery",children:"[Before(TestDiscovery)]"}),"\n",(0,o.jsx)(n.p,{children:"Must be a static method. Will run once before any tests are discovered."}),"\n",(0,o.jsx)(n.h2,{id:"beforeeveryhooktype",children:"[BeforeEvery(HookType)]"}),"\n",(0,o.jsxs)(n.p,{children:["All [BeforeEvery(...)] methods must be static - And should ideally be placed in their own file that's easy to find, as they can globally affect the test suite, so it should be easy for developers to locate this behaviour.\ne.g. ",(0,o.jsx)(n.code,{children:"GlobalHooks.cs"})," at the root of the test project."]}),"\n",(0,o.jsx)(n.h3,{id:"beforeeverytest",children:"[BeforeEvery(Test)]"}),"\n",(0,o.jsx)(n.p,{children:"Will be executed before every test that will run in the test session."}),"\n",(0,o.jsx)(n.h3,{id:"beforeeveryclass",children:"[BeforeEvery(Class)]"}),"\n",(0,o.jsx)(n.p,{children:"Will be executed before the first test of every class that will run in the test session."}),"\n",(0,o.jsx)(n.h3,{id:"beforeeveryassembly",children:"[BeforeEvery(Assembly)]"}),"\n",(0,o.jsx)(n.p,{children:"Will be executed before the first test of every assembly that will run in the test session."}),"\n",(0,o.jsx)(n.h3,{id:"beforeeverytestsession",children:"[BeforeEvery(TestSession)]"}),"\n",(0,o.jsx)(n.p,{children:"The same as [Before(TestSession)]"}),"\n",(0,o.jsx)(n.h3,{id:"beforeeverytestdiscovery",children:"[BeforeEvery(TestDiscovery)]"}),"\n",(0,o.jsx)(n.p,{children:"The same as [Before(TestDiscovery)]"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:'using TUnit.Core;\n\nnamespace MyTestProject;\n\npublic class MyTestClass\n{\n    private int _value;\n    private static HttpResponseMessage? _pingResponse;\n\n    [Before(Class)]\n    public static async Task Ping()\n    {\n        _pingResponse = await new HttpClient().GetAsync("https://localhost/ping");\n    }\n    \n    [Before(Test)]\n    public async Task Setup()\n    {\n        await Task.CompletedTask;\n        \n        _value = 99;\n    }\n\n    [Test]\n    public async Task MyTest()\n    {\n        await Assert.That(_value).IsEqualTo(99);\n        await Assert.That(_pingResponse?.StatusCode)\n            .IsNotNull()\n            .And.IsEqualTo(HttpStatusCode.OK);\n    }\n}\n'})}),"\n",(0,o.jsx)(n.h2,{id:"common-mistakes--best-practices",children:"Common Mistakes & Best Practices"}),"\n","\n",(0,o.jsx)(n.h3,{id:"confusing-instance-vs-static-hooks",children:"Confusing Instance vs Static Hooks"}),"\n",(0,o.jsxs)(r.A,{children:[(0,o.jsxs)(l.A,{value:"bad",label:"\u274c Bad - Wrong Hook Scope",default:!0,children:[(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:"public class DatabaseTests\n{\n    // \u274c Won't compile - Class-level hooks must be static\n    [Before(Class)]\n    public async Task SetupDatabase()\n    {\n        await InitializeDatabaseAsync();\n    }\n\n    // \u274c Won't compile - Test hooks cannot be static\n    [Before(Test)]\n    public static void SetupTest()\n    {\n        // Cannot access instance fields\n    }\n}\n"})}),(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Problem:"})," Hook scope (instance/static) must match the hook level."]})]}),(0,o.jsxs)(l.A,{value:"good",label:"\u2705 Good - Correct Hook Scopes",children:[(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:"public class DatabaseTests\n{\n    // \u2705 Class hooks must be static\n    [Before(Class)]\n    public static async Task SetupDatabase()\n    {\n        await InitializeDatabaseAsync();\n    }\n\n    // \u2705 Test hooks must be instance methods\n    [Before(Test)]\n    public void SetupTest()\n    {\n        _testData = CreateTestData();\n    }\n}\n"})}),(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Why:"})," Class-level hooks run once and cannot access instance state. Test-level hooks run per test and can access instance fields."]})]})]}),"\n",(0,o.jsx)(n.h3,{id:"mixing-sync-and-async-incorrectly",children:"Mixing Sync and Async Incorrectly"}),"\n",(0,o.jsxs)(r.A,{children:[(0,o.jsxs)(l.A,{value:"bad",label:"\u274c Bad - Async Void",children:[(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:"// \u274c Won't compile - async void is not allowed\n[Before(Test)]\npublic async void SetupAsync()\n{\n    await Task.Delay(100);\n}\n\n// \u274c Blocking on async code\n[Before(Test)]\npublic void Setup()\n{\n    SomeAsyncMethod().Wait(); // Can cause deadlocks\n}\n"})}),(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Problem:"})," Async void can't be awaited and blocking async code can cause deadlocks."]})]}),(0,o.jsxs)(l.A,{value:"good",label:"\u2705 Good - Proper Async",children:[(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:"// \u2705 Use async Task for asynchronous operations\n[Before(Test)]\npublic async Task SetupAsync()\n{\n    await Task.Delay(100);\n}\n\n// \u2705 Use synchronous method for synchronous work\n[Before(Test)]\npublic void Setup()\n{\n    _value = 42;\n}\n"})}),(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Why:"})," ",(0,o.jsx)(n.code,{children:"async Task"})," allows proper awaiting and error handling. Synchronous hooks are fine for non-async work."]})]})]}),"\n",(0,o.jsx)(n.h3,{id:"expensive-setup-at-wrong-level",children:"Expensive Setup at Wrong Level"}),"\n",(0,o.jsxs)(r.A,{children:[(0,o.jsxs)(l.A,{value:"bad",label:"\u274c Bad - Repeated Expensive Setup",children:[(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:'public class ApiTests\n{\n    private HttpClient _client;\n\n    // \u274c Creates new client for EVERY test\n    [Before(Test)]\n    public void Setup()\n    {\n        _client = new HttpClient\n        {\n            BaseAddress = new Uri("https://api.example.com")\n        };\n    }\n\n    [Test]\n    public async Task Test1() { /* ... */ }\n\n    [Test]\n    public async Task Test2() { /* ... */ }\n    // Client created 2 times unnecessarily\n}\n'})}),(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Problem:"})," Creating expensive resources per test wastes time and resources."]})]}),(0,o.jsxs)(l.A,{value:"good",label:"\u2705 Good - Shared Setup",children:[(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:'public class ApiTests\n{\n    private static HttpClient _client;\n\n    // \u2705 Creates client once for all tests\n    [Before(Class)]\n    public static void SetupOnce()\n    {\n        _client = new HttpClient\n        {\n            BaseAddress = new Uri("https://api.example.com")\n        };\n    }\n\n    [After(Class)]\n    public static void CleanupOnce()\n    {\n        _client?.Dispose();\n    }\n\n    [Test]\n    public async Task Test1() { /* ... */ }\n\n    [Test]\n    public async Task Test2() { /* ... */ }\n    // Client created only once\n}\n'})}),(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Why:"})," Class-level setup runs once, sharing expensive resources across tests. Much faster!"]})]})]}),"\n",(0,o.jsx)(n.h2,{id:"asynclocal",children:"AsyncLocal"}),"\n",(0,o.jsxs)(n.p,{children:["If you are wanting to set AsyncLocal values within your ",(0,o.jsx)(n.code,{children:"[Before(...)]"})," hooks, this is supported."]}),"\n",(0,o.jsxs)(n.p,{children:["But to propagate the values into the test framework, you must call ",(0,o.jsx)(n.code,{children:"context.AddAsyncLocalValues()"})," - Where ",(0,o.jsx)(n.code,{children:"context"})," is the relevant context object injected into your hook method."]}),"\n",(0,o.jsx)(n.p,{children:"E.g."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:'    [BeforeEvery(Class)]\n    public static void BeforeClass(ClassHookContext context)\n    {\n        _myAsyncLocal.Value = "Some Value";\n        context.AddAsyncLocalValues();\n    }\n'})})]})}function p(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(h,{...e})}):h(e)}},9365:(e,n,s)=>{s.d(n,{A:()=>r});s(6540);var t=s(4164);const o={tabItem:"tabItem_Ymn6"};var a=s(4848);function r({children:e,hidden:n,className:s}){return(0,a.jsx)("div",{role:"tabpanel",className:(0,t.A)(o.tabItem,s),hidden:n,children:e})}},1470:(e,n,s)=>{s.d(n,{A:()=>g});var t=s(6540),o=s(4164),a=s(7559),r=s(3104),l=s(6347),i=s(205),c=s(7485),d=s(1682),u=s(679);function h(e){return t.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,t.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function p(e){const{values:n,children:s}=e;return(0,t.useMemo)((()=>{const e=n??function(e){return h(e).map((({props:{value:e,label:n,attributes:s,default:t}})=>({value:e,label:n,attributes:s,default:t})))}(s);return function(e){const n=(0,d.XI)(e,((e,n)=>e.value===n.value));if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[n,s])}function x({value:e,tabValues:n}){return n.some((n=>n.value===e))}function f({queryString:e=!1,groupId:n}){const s=(0,l.W6)(),o=function({queryString:e=!1,groupId:n}){if("string"==typeof e)return e;if(!1===e)return null;if(!0===e&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:e,groupId:n});return[(0,c.aZ)(o),(0,t.useCallback)((e=>{if(!o)return;const n=new URLSearchParams(s.location.search);n.set(o,e),s.replace({...s.location,search:n.toString()})}),[o,s])]}function b(e){const{defaultValue:n,queryString:s=!1,groupId:o}=e,a=p(e),[r,l]=(0,t.useState)((()=>function({defaultValue:e,tabValues:n}){if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(e){if(!x({value:e,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${e}" but none of its children has the corresponding value. Available values are: ${n.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return e}const s=n.find((e=>e.default))??n[0];if(!s)throw new Error("Unexpected error: 0 tabValues");return s.value}({defaultValue:n,tabValues:a}))),[c,d]=f({queryString:s,groupId:o}),[h,b]=function({groupId:e}){const n=function(e){return e?`docusaurus.tab.${e}`:null}(e),[s,o]=(0,u.Dv)(n);return[s,(0,t.useCallback)((e=>{n&&o.set(e)}),[n,o])]}({groupId:o}),y=(()=>{const e=c??h;return x({value:e,tabValues:a})?e:null})();(0,i.A)((()=>{y&&l(y)}),[y]);return{selectedValue:r,selectValue:(0,t.useCallback)((e=>{if(!x({value:e,tabValues:a}))throw new Error(`Can't select invalid tab value=${e}`);l(e),d(e),b(e)}),[d,b,a]),tabValues:a}}var y=s(2303);const v={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var j=s(4848);function m({className:e,block:n,selectedValue:s,selectValue:t,tabValues:a}){const l=[],{blockElementScrollPositionUntilNextRender:i}=(0,r.a_)(),c=e=>{const n=e.currentTarget,o=l.indexOf(n),r=a[o].value;r!==s&&(i(n),t(r))},d=e=>{let n=null;switch(e.key){case"Enter":c(e);break;case"ArrowRight":{const s=l.indexOf(e.currentTarget)+1;n=l[s]??l[0];break}case"ArrowLeft":{const s=l.indexOf(e.currentTarget)-1;n=l[s]??l[l.length-1];break}}n?.focus()};return(0,j.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,o.A)("tabs",{"tabs--block":n},e),children:a.map((({value:e,label:n,attributes:t})=>(0,j.jsx)("li",{role:"tab",tabIndex:s===e?0:-1,"aria-selected":s===e,ref:e=>{l.push(e)},onKeyDown:d,onClick:c,...t,className:(0,o.A)("tabs__item",v.tabItem,t?.className,{"tabs__item--active":s===e}),children:n??e},e)))})}function T({lazy:e,children:n,selectedValue:s}){const a=(Array.isArray(n)?n:[n]).filter(Boolean);if(e){const e=a.find((e=>e.props.value===s));return e?(0,t.cloneElement)(e,{className:(0,o.A)("margin-top--md",e.props.className)}):null}return(0,j.jsx)("div",{className:"margin-top--md",children:a.map(((e,n)=>(0,t.cloneElement)(e,{key:n,hidden:e.props.value!==s})))})}function k(e){const n=b(e);return(0,j.jsxs)("div",{className:(0,o.A)(a.G.tabs.container,"tabs-container",v.tabList),children:[(0,j.jsx)(m,{...n,...e}),(0,j.jsx)(T,{...n,...e})]})}function g(e){const n=(0,y.A)();return(0,j.jsx)(k,{...e,children:h(e.children)},String(n))}},8453:(e,n,s)=>{s.d(n,{R:()=>r,x:()=>l});var t=s(6540);const o={},a=t.createContext(o);function r(e){const n=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);