"use strict";(self.webpackChunktunit_docs_site=self.webpackChunktunit_docs_site||[]).push([[9627],{5854:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>c,contentTitle:()=>l,default:()=>u,frontMatter:()=>i,metadata:()=>t,toc:()=>o});const t=JSON.parse('{"id":"guides/best-practices","title":"Best Practices","description":"This guide covers best practices for writing clean, maintainable, and robust tests with TUnit. Following these patterns will help you create a test suite that\'s easy to understand and maintain over time.","source":"@site/docs/guides/best-practices.md","sourceDirName":"guides","slug":"/guides/best-practices","permalink":"/docs/guides/best-practices","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"docs","previous":{"title":"Complex Test Infrastructure Orchestration","permalink":"/docs/examples/complex-test-infrastructure"},"next":{"title":"Performance Best Practices","permalink":"/docs/advanced/performance-best-practices"}}');var a=n(4848),r=n(8453);const i={},l="Best Practices",c={},o=[{value:"Test Naming",id:"test-naming",level:2},{value:"Use Descriptive Names",id:"use-descriptive-names",level:3},{value:"Alternative Naming Patterns",id:"alternative-naming-patterns",level:3},{value:"Test Organization",id:"test-organization",level:2},{value:"One Test Class Per Production Class",id:"one-test-class-per-production-class",level:3},{value:"Group Related Tests",id:"group-related-tests",level:3},{value:"Keep Test Files Focused",id:"keep-test-files-focused",level:3},{value:"Assertion Best Practices",id:"assertion-best-practices",level:2},{value:"Prefer Specific Assertions",id:"prefer-specific-assertions",level:3},{value:"One Logical Assertion Per Test",id:"one-logical-assertion-per-test",level:3},{value:"Always Await Assertions",id:"always-await-assertions",level:3},{value:"Test Lifecycle Management",id:"test-lifecycle-management",level:2},{value:"Use Hooks for Setup and Cleanup",id:"use-hooks-for-setup-and-cleanup",level:3},{value:"Choose the Right Hook Level",id:"choose-the-right-hook-level",level:3},{value:"Sharing Expensive Resources",id:"sharing-expensive-resources",level:3},{value:"Avoid Complex Setup Logic",id:"avoid-complex-setup-logic",level:3},{value:"Parallelism Guidance",id:"parallelism-guidance",level:2},{value:"Tests Run in Parallel By Default",id:"tests-run-in-parallel-by-default",level:3},{value:"Use NotInParallel When Needed",id:"use-notinparallel-when-needed",level:3},{value:"Control Execution Order",id:"control-execution-order",level:3},{value:"Use Parallel Groups",id:"use-parallel-groups",level:3},{value:"Common Anti-Patterns to Avoid",id:"common-anti-patterns-to-avoid",level:2},{value:"Avoid Test Interdependence",id:"avoid-test-interdependence",level:3},{value:"Avoid Shared Instance State",id:"avoid-shared-instance-state",level:3},{value:"Avoid Complex Test Logic",id:"avoid-complex-test-logic",level:3},{value:"Avoid Over-Mocking",id:"avoid-over-mocking",level:3},{value:"Avoid Testing Implementation Details",id:"avoid-testing-implementation-details",level:3},{value:"Performance Considerations",id:"performance-considerations",level:2},{value:"Optimize Test Discovery",id:"optimize-test-discovery",level:3},{value:"Optimize Test Execution",id:"optimize-test-execution",level:3},{value:"Avoid Slow Operations in Tests",id:"avoid-slow-operations-in-tests",level:3},{value:"Summary",id:"summary",level:2}];function d(e){const s={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(s.header,{children:(0,a.jsx)(s.h1,{id:"best-practices",children:"Best Practices"})}),"\n",(0,a.jsx)(s.p,{children:"This guide covers best practices for writing clean, maintainable, and robust tests with TUnit. Following these patterns will help you create a test suite that's easy to understand and maintain over time."}),"\n",(0,a.jsx)(s.h2,{id:"test-naming",children:"Test Naming"}),"\n",(0,a.jsx)(s.h3,{id:"use-descriptive-names",children:"Use Descriptive Names"}),"\n",(0,a.jsxs)(s.p,{children:["Good test names clearly describe what's being tested and what's expected. A common pattern is ",(0,a.jsx)(s.code,{children:"Method_Scenario_ExpectedBehavior"}),":"]}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-csharp",children:"// \u2705 Good: Clearly describes what's being tested\n[Test]\npublic async Task CalculateTotal_WithDiscount_ReturnsReducedPrice()\n{\n    var calculator = new PriceCalculator();\n    var result = calculator.CalculateTotal(100, discount: 0.2);\n    await Assert.That(result).IsEqualTo(80);\n}\n\n// \u274c Bad: Vague and unclear\n[Test]\npublic async Task Test1()\n{\n    var calculator = new PriceCalculator();\n    var result = calculator.CalculateTotal(100, 0.2);\n    await Assert.That(result).IsEqualTo(80);\n}\n"})}),"\n",(0,a.jsx)(s.h3,{id:"alternative-naming-patterns",children:"Alternative Naming Patterns"}),"\n",(0,a.jsx)(s.p,{children:"You can also use sentence-like names that read naturally:"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-csharp",children:"[Test]\npublic async Task When_discount_is_applied_total_is_reduced()\n{\n    // Test implementation\n}\n\n[Test]\npublic async Task Should_return_reduced_price_when_discount_applied()\n{\n    // Test implementation\n}\n"})}),"\n",(0,a.jsx)(s.p,{children:"Pick a naming convention and stick to it throughout your project for consistency."}),"\n",(0,a.jsx)(s.h2,{id:"test-organization",children:"Test Organization"}),"\n",(0,a.jsx)(s.h3,{id:"one-test-class-per-production-class",children:"One Test Class Per Production Class"}),"\n",(0,a.jsx)(s.p,{children:"Organize your tests to mirror your production code structure:"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{children:"MyApp/\n  Services/\n    OrderService.cs\n    PaymentService.cs\n\nMyApp.Tests/\n  Services/\n    OrderServiceTests.cs\n    PaymentServiceTests.cs\n"})}),"\n",(0,a.jsx)(s.p,{children:"This makes it easy to find tests and keeps your test suite organized as your codebase grows."}),"\n",(0,a.jsx)(s.h3,{id:"group-related-tests",children:"Group Related Tests"}),"\n",(0,a.jsx)(s.p,{children:"Use nested classes or separate test classes to group related test scenarios:"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-csharp",children:"public class OrderServiceTests\n{\n    public class CreateOrder\n    {\n        [Test]\n        public async Task Creates_order_with_valid_data()\n        {\n            // Test implementation\n        }\n\n        [Test]\n        public async Task Throws_exception_when_user_not_found()\n        {\n            // Test implementation\n        }\n    }\n\n    public class CancelOrder\n    {\n        [Test]\n        public async Task Cancels_order_successfully()\n        {\n            // Test implementation\n        }\n\n        [Test]\n        public async Task Throws_when_order_already_shipped()\n        {\n            // Test implementation\n        }\n    }\n}\n"})}),"\n",(0,a.jsx)(s.h3,{id:"keep-test-files-focused",children:"Keep Test Files Focused"}),"\n",(0,a.jsx)(s.p,{children:"Each test file should focus on testing a single class or component. If your test file is getting large (>500 lines), consider splitting it into multiple files or using nested classes."}),"\n",(0,a.jsx)(s.h2,{id:"assertion-best-practices",children:"Assertion Best Practices"}),"\n",(0,a.jsx)(s.h3,{id:"prefer-specific-assertions",children:"Prefer Specific Assertions"}),"\n",(0,a.jsx)(s.p,{children:"Use the most specific assertion available for better failure messages:"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-csharp",children:"// \u2705 Good: Specific assertion with clear failure message\nawait Assert.That(result).IsEqualTo(5);\n// Failure: Expected 5 but was 3\n\n// \u274c Okay but less helpful: Generic boolean assertion\nawait Assert.That(result == 5).IsTrue();\n// Failure: Expected true but was false\n"})}),"\n",(0,a.jsx)(s.h3,{id:"one-logical-assertion-per-test",children:"One Logical Assertion Per Test"}),"\n",(0,a.jsx)(s.p,{children:"Each test should verify one specific behavior. Multiple assertions are fine if they're testing different aspects of the same behavior:"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-csharp",children:'// \u2705 Good: Multiple assertions testing one behavior (user creation)\n[Test]\npublic async Task CreateUser_SetsAllProperties()\n{\n    var user = await userService.CreateUser("john@example.com", "John Doe");\n\n    await Assert.That(user.Email).IsEqualTo("john@example.com");\n    await Assert.That(user.Name).IsEqualTo("John Doe");\n    await Assert.That(user.CreatedAt).IsNotEqualTo(default(DateTime));\n}\n\n// \u274c Bad: Testing multiple unrelated behaviors\n[Test]\npublic async Task UserService_Works()\n{\n    var user = await userService.CreateUser("john@example.com", "John");\n    await Assert.That(user.Email).IsEqualTo("john@example.com");\n\n    await userService.DeleteUser(user.Id);\n    var deleted = await userService.GetUser(user.Id);\n    await Assert.That(deleted).IsNull();\n}\n'})}),"\n",(0,a.jsx)(s.h3,{id:"always-await-assertions",children:"Always Await Assertions"}),"\n",(0,a.jsxs)(s.p,{children:["TUnit assertions are async and must be awaited. Forgetting ",(0,a.jsx)(s.code,{children:"await"})," means the assertion never runs:"]}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-csharp",children:"// \u274c Wrong: Assertion returns Task that's never awaited\n[Test]\npublic async Task MyTest()\n{\n    Assert.That(result).IsEqualTo(5);  // Test passes without checking!\n}\n\n// \u2705 Correct: Assertion is awaited and executed\n[Test]\npublic async Task MyTest()\n{\n    await Assert.That(result).IsEqualTo(5);\n}\n"})}),"\n",(0,a.jsx)(s.p,{children:"The compiler will warn you about unawaited tasks, but watch for this common mistake."}),"\n",(0,a.jsx)(s.h2,{id:"test-lifecycle-management",children:"Test Lifecycle Management"}),"\n",(0,a.jsx)(s.h3,{id:"use-hooks-for-setup-and-cleanup",children:"Use Hooks for Setup and Cleanup"}),"\n",(0,a.jsx)(s.p,{children:"TUnit provides several hooks for test lifecycle management. Use them to keep your test logic clean:"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-csharp",children:"public class DatabaseTests\n{\n    private TestDatabase? _database;\n\n    [Before(Test)]\n    public async Task SetupDatabase()\n    {\n        _database = await TestDatabase.CreateAsync();\n    }\n\n    [After(Test)]\n    public async Task CleanupDatabase()\n    {\n        if (_database != null)\n            await _database.DisposeAsync();\n    }\n\n    [Test]\n    public async Task Can_insert_record()\n    {\n        // Database is ready to use\n        await _database!.InsertAsync(new Record { Id = 1 });\n        var result = await _database.GetAsync(1);\n        await Assert.That(result).IsNotNull();\n    }\n}\n"})}),"\n",(0,a.jsx)(s.h3,{id:"choose-the-right-hook-level",children:"Choose the Right Hook Level"}),"\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.code,{children:"[Before(Test)]"})," / ",(0,a.jsx)(s.code,{children:"[After(Test)]"}),": Runs before/after each test (most common)"]}),"\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.code,{children:"[Before(Class)]"})," / ",(0,a.jsx)(s.code,{children:"[After(Class)]"}),": Runs once per test class"]}),"\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.code,{children:"[Before(Assembly)]"})," / ",(0,a.jsx)(s.code,{children:"[After(Assembly)]"}),": Runs once per test assembly"]}),"\n"]}),"\n",(0,a.jsx)(s.h3,{id:"sharing-expensive-resources",children:"Sharing Expensive Resources"}),"\n",(0,a.jsxs)(s.p,{children:["For expensive setup that needs to be shared across tests (like web servers, databases, or containers), use ",(0,a.jsx)(s.code,{children:"[ClassDataSource<>]"})," with shared types and ",(0,a.jsx)(s.code,{children:"IAsyncInitializer"}),"/",(0,a.jsx)(s.code,{children:"IAsyncDisposable"}),":"]}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-csharp",children:'// \u2705 Best: Shared resource with ClassDataSource\npublic class TestWebServer : IAsyncInitializer, IAsyncDisposable\n{\n    public WebApplicationFactory<Program>? Factory { get; private set; }\n\n    public async Task InitializeAsync()\n    {\n        Factory = new WebApplicationFactory<Program>();\n        await Task.CompletedTask;\n    }\n\n    public async ValueTask DisposeAsync()\n    {\n        if (Factory != null)\n            await Factory.DisposeAsync();\n    }\n}\n\n[ClassDataSource<TestWebServer>(Shared = SharedType.PerTestSession)]\npublic class ApiTests(TestWebServer server)\n{\n    [Test]\n    public async Task Can_call_endpoint()\n    {\n        var client = server.Factory!.CreateClient();\n        var response = await client.GetAsync("/api/health");\n        await Assert.That(response.IsSuccessStatusCode).IsTrue();\n    }\n\n    [Test]\n    public async Task Can_get_users()\n    {\n        var client = server.Factory!.CreateClient();\n        var response = await client.GetAsync("/api/users");\n        await Assert.That(response.IsSuccessStatusCode).IsTrue();\n    }\n}\n'})}),"\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.strong,{children:"Why this is better:"})}),"\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsx)(s.li,{children:"Keeps test files simpler (no static fields or Before/After hooks)"}),"\n",(0,a.jsx)(s.li,{children:"Shared resources work across multiple test classes"}),"\n",(0,a.jsxs)(s.li,{children:["Can share across assemblies using ",(0,a.jsx)(s.code,{children:"SharedType.PerTestSession"})]}),"\n",(0,a.jsxs)(s.li,{children:["Cleaner lifecycle management with ",(0,a.jsx)(s.code,{children:"IAsyncInitializer"}),"/",(0,a.jsx)(s.code,{children:"IAsyncDisposable"})]}),"\n",(0,a.jsx)(s.li,{children:"Type-safe dependency injection into test constructors"}),"\n"]}),"\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.strong,{children:"Shared Type Options:"})}),"\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.code,{children:"SharedType.PerTestSession"}),": One instance for entire test run, shared across assemblies (best for expensive resources)"]}),"\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.code,{children:"SharedType.PerClass"}),": One instance per test class"]}),"\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.code,{children:"SharedType.None"}),": New instance per test (default)"]}),"\n"]}),"\n",(0,a.jsx)(s.p,{children:"You can also use hooks, but they're less flexible:"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-csharp",children:"// \u274c Less flexible: Using hooks for shared setup\npublic class ApiTests\n{\n    private static WebApplicationFactory<Program>? _factory;\n\n    [Before(Class)]\n    public static async Task StartServer()\n    {\n        _factory = new WebApplicationFactory<Program>();\n    }\n\n    [After(Class)]\n    public static async Task StopServer()\n    {\n        _factory?.Dispose();\n    }\n\n    // Tests use static _factory field\n}\n"})}),"\n",(0,a.jsx)(s.h3,{id:"avoid-complex-setup-logic",children:"Avoid Complex Setup Logic"}),"\n",(0,a.jsx)(s.p,{children:"Keep your setup code simple and focused. If setup is complex, extract it to helper methods:"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-csharp",children:'// \u2705 Good: Simple setup with extracted helpers\n[Before(Test)]\npublic async Task Setup()\n{\n    _database = await CreateTestDatabase();\n    _testUser = await CreateTestUser();\n}\n\nprivate async Task<TestDatabase> CreateTestDatabase()\n{\n    var db = await TestDatabase.CreateAsync();\n    await db.SeedDefaultData();\n    return db;\n}\n\n// \u274c Bad: Complex setup logic in hook\n[Before(Test)]\npublic async Task Setup()\n{\n    _database = await TestDatabase.CreateAsync();\n    await _database.ExecuteAsync("CREATE TABLE Users (...)");\n    await _database.ExecuteAsync("INSERT INTO Users VALUES (...)");\n    await _database.ExecuteAsync("CREATE TABLE Orders (...)");\n    // ... lots more setup code\n}\n'})}),"\n",(0,a.jsx)(s.h2,{id:"parallelism-guidance",children:"Parallelism Guidance"}),"\n",(0,a.jsx)(s.h3,{id:"tests-run-in-parallel-by-default",children:"Tests Run in Parallel By Default"}),"\n",(0,a.jsx)(s.p,{children:"TUnit runs tests in parallel for better performance. Write your tests to be independent:"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-csharp",children:"// \u2705 Good: Test is self-contained and independent\n[Test]\npublic async Task Can_create_order()\n{\n    var orderId = Guid.NewGuid();  // Unique ID\n    var order = new Order { Id = orderId, Total = 100 };\n    await orderService.CreateAsync(order);\n\n    var result = await orderService.GetAsync(orderId);\n    await Assert.That(result).IsNotNull();\n}\n"})}),"\n",(0,a.jsx)(s.h3,{id:"use-notinparallel-when-needed",children:"Use NotInParallel When Needed"}),"\n",(0,a.jsxs)(s.p,{children:["Some tests can't run in parallel (database tests, file system tests). Use ",(0,a.jsx)(s.code,{children:"[NotInParallel]"}),":"]}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-csharp",children:'// Tests that modify shared state\n[Test, NotInParallel]\npublic async Task Updates_configuration_file()\n{\n    await ConfigurationManager.SetAsync("key", "value");\n    var result = await ConfigurationManager.GetAsync("key");\n    await Assert.That(result).IsEqualTo("value");\n}\n'})}),"\n",(0,a.jsx)(s.h3,{id:"control-execution-order",children:"Control Execution Order"}),"\n",(0,a.jsxs)(s.p,{children:["When tests need to run in a specific order, use ",(0,a.jsx)(s.code,{children:"[DependsOn]"})," instead of ",(0,a.jsx)(s.code,{children:"NotInParallel"})," with ",(0,a.jsx)(s.code,{children:"Order"}),":"]}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-csharp",children:"// \u2705 Good: Use DependsOn for ordering while maintaining parallelism\n[Test]\npublic async Task Step1_CreateUser()\n{\n    // Runs first\n}\n\n[Test]\n[DependsOn(nameof(Step1_CreateUser))]\npublic async Task Step2_UpdateUser()\n{\n    // Runs after Step1_CreateUser completes\n    // Other unrelated tests can still run in parallel\n}\n\n[Test]\n[DependsOn(nameof(Step2_UpdateUser))]\npublic async Task Step3_DeleteUser()\n{\n    // Runs after Step2_UpdateUser completes\n}\n"})}),"\n",(0,a.jsx)(s.p,{children:(0,a.jsxs)(s.strong,{children:["Why ",(0,a.jsx)(s.code,{children:"[DependsOn]"})," is better:"]})}),"\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsx)(s.li,{children:"More intuitive: explicitly declares dependencies between tests"}),"\n",(0,a.jsx)(s.li,{children:"More flexible: tests can depend on multiple other tests"}),"\n",(0,a.jsx)(s.li,{children:"Maintains parallelism: unrelated tests still run in parallel"}),"\n",(0,a.jsx)(s.li,{children:"Better for complex workflows: clear dependency chains"}),"\n"]}),"\n",(0,a.jsxs)(s.p,{children:["You can also use ",(0,a.jsx)(s.code,{children:"NotInParallel"})," with ",(0,a.jsx)(s.code,{children:"Order"}),", but this forces sequential execution:"]}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-csharp",children:"// \u274c Less flexible: Forces all tests to run sequentially\n[Test, NotInParallel(Order = 1)]\npublic async Task Step1_CreateUser()\n{\n    // Runs first\n}\n\n[Test, NotInParallel(Order = 2)]\npublic async Task Step2_UpdateUser()\n{\n    // Runs second, but blocks all other tests\n}\n"})}),"\n",(0,a.jsxs)(s.p,{children:[(0,a.jsx)(s.strong,{children:"Important:"})," If tests need ordering, they might be too tightly coupled. Consider:"]}),"\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsx)(s.li,{children:"Refactoring into a single test"}),"\n",(0,a.jsx)(s.li,{children:"Using proper setup/teardown"}),"\n",(0,a.jsx)(s.li,{children:"Making tests truly independent"}),"\n"]}),"\n",(0,a.jsx)(s.h3,{id:"use-parallel-groups",children:"Use Parallel Groups"}),"\n",(0,a.jsx)(s.p,{children:"Group related tests that can't run in parallel with each other but can run in parallel with other groups:"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-csharp",children:'public class FileSystemTests\n{\n    // These tests can\'t run in parallel with each other\n    // but can run in parallel with DatabaseTests\n\n    [Test, NotInParallel("FileGroup")]\n    public async Task Test1_WritesFile()\n    {\n        // Test implementation\n    }\n\n    [Test, NotInParallel("FileGroup")]\n    public async Task Test2_ReadsFile()\n    {\n        // Test implementation\n    }\n}\n\npublic class DatabaseTests\n{\n    [Test, NotInParallel("DbGroup")]\n    public async Task Test1_InsertsRecord()\n    {\n        // Runs in parallel with FileSystemTests\n    }\n}\n'})}),"\n",(0,a.jsx)(s.h2,{id:"common-anti-patterns-to-avoid",children:"Common Anti-Patterns to Avoid"}),"\n",(0,a.jsx)(s.h3,{id:"avoid-test-interdependence",children:"Avoid Test Interdependence"}),"\n",(0,a.jsx)(s.p,{children:"Each test should be completely independent and not rely on other tests:"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-csharp",children:'// \u274c Bad: Tests depend on execution order\nprivate static User? _user;\n\n[Test]\npublic async Task Test1_CreateUser()\n{\n    _user = await userService.CreateAsync("john@example.com");\n}\n\n[Test]\npublic async Task Test2_UpdateUser()\n{\n    // Assumes Test1 ran first!\n    _user!.Name = "Jane Doe";\n    await userService.UpdateAsync(_user);\n}\n\n// \u2705 Good: Each test is independent\n[Test]\npublic async Task Can_create_user()\n{\n    var user = await userService.CreateAsync("john@example.com");\n    await Assert.That(user.Email).IsEqualTo("john@example.com");\n}\n\n[Test]\npublic async Task Can_update_user()\n{\n    var user = await userService.CreateAsync("jane@example.com");\n    user.Name = "Jane Doe";\n    await userService.UpdateAsync(user);\n\n    var updated = await userService.GetAsync(user.Id);\n    await Assert.That(updated.Name).IsEqualTo("Jane Doe");\n}\n'})}),"\n",(0,a.jsx)(s.h3,{id:"avoid-shared-instance-state",children:"Avoid Shared Instance State"}),"\n",(0,a.jsxs)(s.p,{children:[(0,a.jsx)(s.strong,{children:"Important:"})," TUnit creates a new instance of your test class for each test method. Don't rely on instance fields to share state:"]}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-csharp",children:"// \u274c Bad: Trying to share instance state between tests\npublic class MyTests\n{\n    private int _value;  // Different instance per test!\n\n    [Test, NotInParallel]\n    public void Test1()\n    {\n        _value = 99;\n    }\n\n    [Test, NotInParallel]\n    public async Task Test2()\n    {\n        await Assert.That(_value).IsEqualTo(99);  // Fails! _value is 0\n    }\n}\n\n// \u2705 Good: Use static fields if you really need shared state\npublic class MyTests\n{\n    private static int _value;  // Shared across all tests\n\n    [Test, NotInParallel]\n    public void Test1()\n    {\n        _value = 99;\n    }\n\n    [Test, NotInParallel]\n    public async Task Test2()\n    {\n        await Assert.That(_value).IsEqualTo(99);  // Works!\n    }\n}\n"})}),"\n",(0,a.jsx)(s.p,{children:"But seriously: if tests need to share state, reconsider your design. It's usually better to make tests independent."}),"\n",(0,a.jsx)(s.h3,{id:"avoid-complex-test-logic",children:"Avoid Complex Test Logic"}),"\n",(0,a.jsx)(s.p,{children:"Tests should be simple and easy to understand. Avoid complex conditionals, loops, or calculations:"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-csharp",children:"// \u274c Bad: Complex logic in test\n[Test]\npublic async Task CalculatesTotals()\n{\n    var items = await GetItems();\n    decimal expected = 0;\n    foreach (var item in items)\n    {\n        if (item.IsDiscounted)\n            expected += item.Price * 0.8m;\n        else\n            expected += item.Price;\n    }\n\n    var result = calculator.CalculateTotal(items);\n    await Assert.That(result).IsEqualTo(expected);\n}\n\n// \u2705 Good: Simple, explicit test\n[Test]\npublic async Task CalculateTotal_WithMixedItems()\n{\n    var items = new[]\n    {\n        new Item { Price = 100, IsDiscounted = false },  // 100\n        new Item { Price = 50, IsDiscounted = true }     // 40\n    };\n\n    var result = calculator.CalculateTotal(items);\n    await Assert.That(result).IsEqualTo(140);\n}\n"})}),"\n",(0,a.jsx)(s.p,{children:"If your test has complex logic, you're essentially writing code to test code. Keep it simple!"}),"\n",(0,a.jsx)(s.h3,{id:"avoid-over-mocking",children:"Avoid Over-Mocking"}),"\n",(0,a.jsx)(s.p,{children:"Don't mock everything. Use real implementations when they're fast and reliable:"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-csharp",children:"// \u274c Bad: Mocking things that don't need mocking\n[Test]\npublic async Task ProcessOrder()\n{\n    var mockLogger = new Mock<ILogger>();\n    var mockValidator = new Mock<IValidator>();\n    var mockCalculator = new Mock<IPriceCalculator>();\n    var mockRepository = new Mock<IOrderRepository>();\n\n    // So much setup...\n}\n\n// \u2705 Good: Only mock expensive or external dependencies\n[Test]\npublic async Task ProcessOrder()\n{\n    var logger = new NullLogger();  // Real lightweight implementation\n    var validator = new OrderValidator();  // Real validator is fast\n    var calculator = new PriceCalculator();  // Simple calculations\n    var mockRepository = new Mock<IOrderRepository>();  // Mock database\n\n    // Much simpler!\n}\n"})}),"\n",(0,a.jsx)(s.p,{children:"Mock external dependencies (databases, APIs, file systems) but use real implementations for simple logic."}),"\n",(0,a.jsx)(s.h3,{id:"avoid-testing-implementation-details",children:"Avoid Testing Implementation Details"}),"\n",(0,a.jsx)(s.p,{children:"Test behavior, not implementation. Your tests should verify what the code does, not how it does it:"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-csharp",children:"// \u274c Bad: Testing internal implementation\n[Test]\npublic async Task ProcessOrder_CallsRepositorySaveMethod()\n{\n    var mockRepository = new Mock<IOrderRepository>();\n    var service = new OrderService(mockRepository.Object);\n\n    await service.ProcessOrder(order);\n\n    // Verifying method calls instead of behavior\n    mockRepository.Verify(r => r.Save(It.IsAny<Order>()), Times.Once);\n}\n\n// \u2705 Good: Testing actual behavior\n[Test]\npublic async Task ProcessOrder_SavesOrderToDatabase()\n{\n    var repository = new InMemoryOrderRepository();\n    var service = new OrderService(repository);\n\n    await service.ProcessOrder(order);\n\n    // Verifying the result\n    var saved = await repository.GetAsync(order.Id);\n    await Assert.That(saved).IsNotNull();\n    await Assert.That(saved.Status).IsEqualTo(OrderStatus.Processed);\n}\n"})}),"\n",(0,a.jsx)(s.p,{children:"Tests that verify implementation details are brittle and break when you refactor."}),"\n",(0,a.jsx)(s.h2,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,a.jsx)(s.p,{children:"TUnit is designed for performance at scale. Follow these guidelines to keep your test suite fast:"}),"\n",(0,a.jsx)(s.h3,{id:"optimize-test-discovery",children:"Optimize Test Discovery"}),"\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsx)(s.li,{children:"Use AOT mode for faster test discovery and lower memory usage"}),"\n",(0,a.jsxs)(s.li,{children:["Keep data sources lightweight (see ",(0,a.jsx)(s.a,{href:"/docs/advanced/performance-best-practices",children:"Performance Best Practices"}),")"]}),"\n",(0,a.jsx)(s.li,{children:"Limit matrix test combinations to avoid test explosion"}),"\n"]}),"\n",(0,a.jsx)(s.h3,{id:"optimize-test-execution",children:"Optimize Test Execution"}),"\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsx)(s.li,{children:"Let tests run in parallel (it's fast!)"}),"\n",(0,a.jsxs)(s.li,{children:["Only use ",(0,a.jsx)(s.code,{children:"[NotInParallel]"})," when absolutely necessary"]}),"\n",(0,a.jsxs)(s.li,{children:["Configure parallelism based on your CPU: ",(0,a.jsx)(s.code,{children:"[assembly: MaxParallelTests(Environment.ProcessorCount)]"})]}),"\n",(0,a.jsxs)(s.li,{children:["Avoid expensive setup in ",(0,a.jsx)(s.code,{children:"[Before(Test)]"})," hooks - use class or assembly-level hooks for shared resources"]}),"\n"]}),"\n",(0,a.jsx)(s.h3,{id:"avoid-slow-operations-in-tests",children:"Avoid Slow Operations in Tests"}),"\n",(0,a.jsx)(s.p,{children:"Tests should be fast. If a test takes more than a few seconds, look for optimization opportunities:"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-csharp",children:'// \u274c Slow: Real HTTP calls\n[Test]\npublic async Task GetUserData()\n{\n    var client = new HttpClient();\n    var response = await client.GetAsync("https://api.example.com/users");\n    // Slow and unreliable\n}\n\n// \u2705 Fast: Use in-memory test doubles\n[Test]\npublic async Task GetUserData()\n{\n    var client = new TestHttpClient();  // In-memory fake\n    var response = await client.GetAsync("/users");\n    // Fast and reliable\n}\n'})}),"\n",(0,a.jsxs)(s.p,{children:["For detailed performance guidance, see ",(0,a.jsx)(s.a,{href:"/docs/advanced/performance-best-practices",children:"Performance Best Practices"}),"."]}),"\n",(0,a.jsx)(s.h2,{id:"summary",children:"Summary"}),"\n",(0,a.jsx)(s.p,{children:"Following these best practices will help you:"}),"\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsx)(s.li,{children:"Write tests that are easy to understand and maintain"}),"\n",(0,a.jsx)(s.li,{children:"Create a fast, reliable test suite that scales"}),"\n",(0,a.jsx)(s.li,{children:"Catch bugs without introducing brittle tests"}),"\n",(0,a.jsx)(s.li,{children:"Make your codebase more maintainable over time"}),"\n"]}),"\n",(0,a.jsx)(s.p,{children:'Remember: good tests are simple, focused, independent, and fast. When in doubt, ask yourself: "Will someone else understand what this test is doing and why it might fail?"'})]})}function u(e={}){const{wrapper:s}={...(0,r.R)(),...e.components};return s?(0,a.jsx)(s,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},8453:(e,s,n)=>{n.d(s,{R:()=>i,x:()=>l});var t=n(6540);const a={},r=t.createContext(a);function i(e){const s=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function l(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),t.createElement(r.Provider,{value:s},e.children)}}}]);