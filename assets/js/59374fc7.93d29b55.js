"use strict";(self.webpackChunktunit_docs_site=self.webpackChunktunit_docs_site||[]).push([[3299],{4177:(e,t,l)=>{l.r(t),l.d(t,{assets:()=>o,contentTitle:()=>r,default:()=>h,frontMatter:()=>n,metadata:()=>a,toc:()=>d});const a=JSON.parse('{"id":"parallelism/parallel-limiter","title":"Parallel Limiter","description":"TUnit allows the user to control the parallel limit on a test, class or assembly level.","source":"@site/docs/parallelism/parallel-limiter.md","sourceDirName":"parallelism","slug":"/parallelism/parallel-limiter","permalink":"/docs/parallelism/parallel-limiter","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":11,"frontMatter":{"sidebar_position":11},"sidebar":"docs","previous":{"title":"Parallel Groups","permalink":"/docs/parallelism/parallel-groups"},"next":{"title":"Extensions","permalink":"/docs/extensions/"}}');var s=l(4848),i=l(8453);const n={sidebar_position:11},r="Parallel Limiter",o={},d=[{value:"Example",id:"example",level:2},{value:"Caveats",id:"caveats",level:2}];function c(e){const t={code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.header,{children:(0,s.jsx)(t.h1,{id:"parallel-limiter",children:"Parallel Limiter"})}),"\n",(0,s.jsx)(t.p,{children:"TUnit allows the user to control the parallel limit on a test, class or assembly level."}),"\n",(0,s.jsxs)(t.p,{children:["To do this, we add a ",(0,s.jsx)(t.code,{children:"[ParallelLimiter<>]"})," attribute."]}),"\n",(0,s.jsxs)(t.p,{children:["You'll notice this has a generic type argument - You must give it a type that implements ",(0,s.jsx)(t.code,{children:"IParallelLimit"})," and has a public empty constructor. That interface requires you to define what the limit is for those tests."]}),"\n",(0,s.jsx)(t.p,{children:"If a class doesn't have a parallel limit defined, it'll try and eagerly run when the .NET thread pool allows it to do so, so the upper limit is unknown."}),"\n",(0,s.jsxs)(t.p,{children:["If it does have a parallel limit defined, be aware that that parallel limit is shared for any tests with that same ",(0,s.jsx)(t.code,{children:"Type"})," of parallel limit."]}),"\n",(0,s.jsxs)(t.p,{children:["In the example below, ",(0,s.jsx)(t.code,{children:"MyParallelLimit"})," has a limit of ",(0,s.jsx)(t.code,{children:"2"}),". Now any test, anywhere in your test suite, that has this parallel limit attribute applied to it, will shared this limit, and so only 2 can be processed at a time."]}),"\n",(0,s.jsx)(t.p,{children:"Other tests without this attribute may run alongside them still."}),"\n",(0,s.jsxs)(t.p,{children:["And other tests with a different ",(0,s.jsx)(t.code,{children:"Type"})," of parallel limit may also run alongside them still, but limited amongst themselves by their shared ",(0,s.jsx)(t.code,{children:"Type"})," and limit."]}),"\n",(0,s.jsxs)(t.p,{children:["So be aware that limits are only shared among tests with that same ",(0,s.jsx)(t.code,{children:"IParallelLimit"})," ",(0,s.jsx)(t.code,{children:"Type"}),"."]}),"\n",(0,s.jsx)(t.p,{children:"So if you wanted to do a global limit on an assembly, you could do:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-csharp",children:"[assembly: ParallelLimiter<MyParallelLimit>]\n"})}),"\n",(0,s.jsx)(t.p,{children:"And as long as that isn't overridden on a test or class, then that will apply to all tests in an assembly and be shared among them all, limiting how many run in parallel."}),"\n",(0,s.jsx)(t.h2,{id:"example",children:"Example"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-csharp",children:"using TUnit.Core;\n\nnamespace MyTestProject;\n\n[ParallelLimiter<MyParallelLimit>]\npublic class MyTestClass\n{\n    [Test, Repeat(10)]\n    public async Task MyTest()\n    {\n        \n    }\n\n    [Test, Repeat(10)]\n    public async Task MyTest2()\n    {\n        \n    }\n}\n\npublic record MyParallelLimit : IParallelLimit\n{\n    public int Limit => 2;\n}\n"})}),"\n",(0,s.jsx)(t.h2,{id:"caveats",children:"Caveats"}),"\n",(0,s.jsxs)(t.p,{children:["If a test uses ",(0,s.jsx)(t.code,{children:"[DependsOn(nameof(OtherTest))]"})," and the other test has its own different parallel limit, this isn't guaranteed to be honoured."]})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},8453:(e,t,l)=>{l.d(t,{R:()=>n,x:()=>r});var a=l(6540);const s={},i=a.createContext(s);function n(e){const t=a.useContext(i);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:n(e.components),a.createElement(i.Provider,{value:t},e.children)}}}]);