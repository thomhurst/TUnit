"use strict";(self.webpackChunktunit_docs_site=self.webpackChunktunit_docs_site||[]).push([[3546],{9258:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"assertions/extensibility/source-generator-assertions","title":"Source Generator Assertions","description":"TUnit provides source generators to simplify creating custom assertions. Instead of manually writing assertion classes and extension methods, you can decorate your methods with attributes and let the generator do the work.","source":"@site/docs/assertions/extensibility/source-generator-assertions.md","sourceDirName":"assertions/extensibility","slug":"/assertions/extensibility/source-generator-assertions","permalink":"/docs/assertions/extensibility/source-generator-assertions","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"docs","previous":{"title":"Custom Assertions","permalink":"/docs/assertions/extensibility/custom-assertions"},"next":{"title":"Chaining and Converting","permalink":"/docs/assertions/extensibility/extensibility-chaining-and-converting"}}');var i=n(4848),r=n(8453);const a={sidebar_position:2},o="Source Generator Assertions",l={},d=[{value:"Overview",id:"overview",level:2},{value:"Method-Level Generation: <code>[GenerateAssertion]</code>",id:"method-level-generation-generateassertion",level:2},{value:"Basic Example",id:"basic-example",level:3},{value:"What Gets Generated",id:"what-gets-generated",level:3},{value:"Custom Expectation Messages",id:"custom-expectation-messages",level:2},{value:"Using Parameters in Messages",id:"using-parameters-in-messages",level:3},{value:"Supported Return Types",id:"supported-return-types",level:2},{value:"1. <code>bool</code> - Simple Pass/Fail",id:"1-bool---simple-passfail",level:3},{value:"2. <code>AssertionResult</code> - Custom Messages",id:"2-assertionresult---custom-messages",level:3},{value:"3. <code>Task&lt;bool&gt;</code> - Async Operations",id:"3-taskbool---async-operations",level:3},{value:"4. <code>Task&lt;AssertionResult&gt;</code> - Async with Custom Messages",id:"4-taskassertionresult---async-with-custom-messages",level:3},{value:"Methods with Parameters",id:"methods-with-parameters",level:2},{value:"Class-Level Generation: <code>[AssertionFrom]</code>",id:"class-level-generation-assertionfrom",level:2},{value:"Basic Usage",id:"basic-usage",level:3},{value:"With Custom Names",id:"with-custom-names",level:3},{value:"Negation Support",id:"negation-support",level:3},{value:"Referencing Methods on Different Types",id:"referencing-methods-on-different-types",level:3},{value:"Method Body Inlining (Advanced)",id:"method-body-inlining-advanced",level:2},{value:"Using <code>InlineMethodBody</code>",id:"using-inlinemethodbody",level:3},{value:"What Gets Generated with Inlining",id:"what-gets-generated-with-inlining",level:3},{value:"Benefits of Inlining",id:"benefits-of-inlining",level:3},{value:"Example with Parameters",id:"example-with-parameters",level:3},{value:"When to Use Inlining",id:"when-to-use-inlining",level:3},{value:"Requirements and Best Practices",id:"requirements-and-best-practices",level:2},{value:"Method Requirements",id:"method-requirements",level:3},{value:"Hiding Helper Methods from IntelliSense",id:"hiding-helper-methods-from-intellisense",level:3},{value:"Recommended Patterns",id:"recommended-patterns",level:3},{value:"Chaining and Composition",id:"chaining-and-composition",level:2},{value:"Complete Example",id:"complete-example",level:2},{value:"See Also",id:"see-also",level:2}];function c(e){const s={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s.header,{children:(0,i.jsx)(s.h1,{id:"source-generator-assertions",children:"Source Generator Assertions"})}),"\n",(0,i.jsx)(s.p,{children:"TUnit provides source generators to simplify creating custom assertions. Instead of manually writing assertion classes and extension methods, you can decorate your methods with attributes and let the generator do the work."}),"\n",(0,i.jsx)(s.h2,{id:"overview",children:"Overview"}),"\n",(0,i.jsx)(s.p,{children:"There are two ways to create assertions with source generators:"}),"\n",(0,i.jsxs)(s.ol,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:(0,i.jsx)(s.code,{children:"[GenerateAssertion]"})})," - Decorate your own methods to generate assertions"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:(0,i.jsx)(s.code,{children:"[AssertionFrom<T>]"})})," - Generate assertions from existing library methods"]}),"\n"]}),"\n",(0,i.jsx)(s.hr,{}),"\n",(0,i.jsxs)(s.h2,{id:"method-level-generation-generateassertion",children:["Method-Level Generation: ",(0,i.jsx)(s.code,{children:"[GenerateAssertion]"})]}),"\n",(0,i.jsxs)(s.p,{children:["The ",(0,i.jsx)(s.code,{children:"[GenerateAssertion]"})," attribute allows you to turn any method into a full assertion with minimal code."]}),"\n",(0,i.jsx)(s.h3,{id:"basic-example",children:"Basic Example"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-csharp",children:'using System.ComponentModel;\nusing TUnit.Assertions.Attributes;\n\npublic static partial class IntAssertionExtensions\n{\n    [EditorBrowsable(EditorBrowsableState.Never)]\n    [GenerateAssertion(ExpectationMessage = "to be positive")]\n    public static bool IsPositive(this int value)\n    {\n        return value > 0;\n    }\n}\n\n// Usage in tests:\nawait Assert.That(5).IsPositive();  // \u2705 Passes\nawait Assert.That(-3).IsPositive(); // \u274c Fails: "Expected to be positive but found -3"\n'})}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"Note:"})," The ",(0,i.jsx)(s.code,{children:"[EditorBrowsable(EditorBrowsableState.Never)]"})," attribute hides the helper method from IntelliSense. Users will only see the generated assertion extension method ",(0,i.jsx)(s.code,{children:"IsPositive()"})," on ",(0,i.jsx)(s.code,{children:"Assert.That(...)"}),", not the underlying helper method on ",(0,i.jsx)(s.code,{children:"int"})," values."]}),"\n",(0,i.jsx)(s.h3,{id:"what-gets-generated",children:"What Gets Generated"}),"\n",(0,i.jsx)(s.p,{children:"The generator creates:"}),"\n",(0,i.jsxs)(s.ol,{children:["\n",(0,i.jsxs)(s.li,{children:["An ",(0,i.jsx)(s.code,{children:"Assertion<T>"})," class containing your logic"]}),"\n",(0,i.jsxs)(s.li,{children:["An extension method on ",(0,i.jsx)(s.code,{children:"IAssertionSource<T>"})]}),"\n",(0,i.jsxs)(s.li,{children:["Full support for chaining with ",(0,i.jsx)(s.code,{children:".And"})," and ",(0,i.jsx)(s.code,{children:".Or"})]}),"\n"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-csharp",children:'// Generated code (simplified):\npublic sealed class IsPositive_Assertion : Assertion<int>\n{\n    protected override async Task<AssertionResult> CheckAsync(EvaluationMetadata<int> metadata)\n    {\n        var result = metadata.Value.IsPositive();\n        return result ? AssertionResult.Passed : AssertionResult.Failed($"found {metadata.Value}");\n    }\n\n    protected override string GetExpectation() => "to be positive";\n}\n\npublic static IsPositive_Assertion IsPositive(this IAssertionSource<int> source)\n{\n    source.Context.ExpressionBuilder.Append(".IsPositive()");\n    return new IsPositive_Assertion(source.Context);\n}\n'})}),"\n",(0,i.jsx)(s.hr,{}),"\n",(0,i.jsx)(s.h2,{id:"custom-expectation-messages",children:"Custom Expectation Messages"}),"\n",(0,i.jsxs)(s.p,{children:["Use the ",(0,i.jsx)(s.code,{children:"ExpectationMessage"})," property to provide clear, readable error messages:"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-csharp",children:'[EditorBrowsable(EditorBrowsableState.Never)]\n[GenerateAssertion(ExpectationMessage = "to be positive")]\npublic static bool IsPositive(this int value) => value > 0;\n\n// Error message: "Expected to be positive but found -3"\n'})}),"\n",(0,i.jsx)(s.h3,{id:"using-parameters-in-messages",children:"Using Parameters in Messages"}),"\n",(0,i.jsxs)(s.p,{children:["You can reference method parameters in your expectation message using ",(0,i.jsx)(s.code,{children:"{paramName}"}),":"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-csharp",children:'[EditorBrowsable(EditorBrowsableState.Never)]\n[GenerateAssertion(ExpectationMessage = "to be between {min} and {max}")]\npublic static bool IsBetween(this int value, int min, int max)\n{\n    return value >= min && value <= max;\n}\n\n// Error message: "Expected to be between 1 and 10 but found 15"\n'})}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Without ExpectationMessage:"})}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["Default: ",(0,i.jsx)(s.code,{children:'"Expected to satisfy IsBetween but found 15"'})]}),"\n"]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"With ExpectationMessage:"})}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["Clear: ",(0,i.jsx)(s.code,{children:'"Expected to be between 1 and 10 but found 15"'})]}),"\n"]}),"\n",(0,i.jsx)(s.hr,{}),"\n",(0,i.jsx)(s.h2,{id:"supported-return-types",children:"Supported Return Types"}),"\n",(0,i.jsxs)(s.h3,{id:"1-bool---simple-passfail",children:["1. ",(0,i.jsx)(s.code,{children:"bool"})," - Simple Pass/Fail"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-csharp",children:'[EditorBrowsable(EditorBrowsableState.Never)]\n[GenerateAssertion(ExpectationMessage = "to be even")]\npublic static bool IsEven(this int value)\n{\n    return value % 2 == 0;\n}\n\n// Usage:\nawait Assert.That(4).IsEven();  // \u2705 Passes\nawait Assert.That(3).IsEven();  // \u274c Fails: "Expected to be even but found 3"\n'})}),"\n",(0,i.jsxs)(s.h3,{id:"2-assertionresult---custom-messages",children:["2. ",(0,i.jsx)(s.code,{children:"AssertionResult"})," - Custom Messages"]}),"\n",(0,i.jsxs)(s.p,{children:["When you need more control over error messages, return ",(0,i.jsx)(s.code,{children:"AssertionResult"}),":"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-csharp",children:'[EditorBrowsable(EditorBrowsableState.Never)]\n[GenerateAssertion(ExpectationMessage = "to be prime")]\npublic static AssertionResult IsPrime(this int value)\n{\n    if (value < 2)\n        return AssertionResult.Failed($"{value} is less than 2");\n\n    for (int i = 2; i <= Math.Sqrt(value); i++)\n    {\n        if (value % i == 0)\n            return AssertionResult.Failed($"{value} is divisible by {i}");\n    }\n\n    return AssertionResult.Passed;\n}\n\n// Usage:\nawait Assert.That(17).IsPrime();  // \u2705 Passes\nawait Assert.That(15).IsPrime();  // \u274c Fails: "Expected to be prime but 15 is divisible by 3"\n'})}),"\n",(0,i.jsxs)(s.h3,{id:"3-taskbool---async-operations",children:["3. ",(0,i.jsx)(s.code,{children:"Task<bool>"})," - Async Operations"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-csharp",children:'[EditorBrowsable(EditorBrowsableState.Never)]\n[GenerateAssertion(ExpectationMessage = "to exist in database")]\npublic static async Task<bool> ExistsInDatabaseAsync(this int userId, DbContext db)\n{\n    return await db.Users.AnyAsync(u => u.Id == userId);\n}\n\n// Usage:\nawait Assert.That(userId).ExistsInDatabaseAsync(dbContext);\n// If fails: "Expected to exist in database but found 123"\n'})}),"\n",(0,i.jsxs)(s.h3,{id:"4-taskassertionresult---async-with-custom-messages",children:["4. ",(0,i.jsx)(s.code,{children:"Task<AssertionResult>"})," - Async with Custom Messages"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-csharp",children:'[EditorBrowsable(EditorBrowsableState.Never)]\n[GenerateAssertion(ExpectationMessage = "to have valid email")]\npublic static async Task<AssertionResult> HasValidEmailAsync(this int userId, DbContext db)\n{\n    var user = await db.Users.FindAsync(userId);\n\n    if (user == null)\n        return AssertionResult.Failed($"User {userId} not found");\n\n    if (!user.Email.Contains("@"))\n        return AssertionResult.Failed($"Email \'{user.Email}\' is invalid");\n\n    return AssertionResult.Passed;\n}\n\n// Usage:\nawait Assert.That(123).HasValidEmailAsync(dbContext);\n// If fails: "Expected to have valid email but User 123 not found"\n'})}),"\n",(0,i.jsx)(s.hr,{}),"\n",(0,i.jsx)(s.h2,{id:"methods-with-parameters",children:"Methods with Parameters"}),"\n",(0,i.jsx)(s.p,{children:"Add parameters to make your assertions flexible:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-csharp",children:'[EditorBrowsable(EditorBrowsableState.Never)]\n[GenerateAssertion(ExpectationMessage = "to be greater than {threshold}")]\npublic static bool IsGreaterThan(this int value, int threshold)\n{\n    return value > threshold;\n}\n\n[EditorBrowsable(EditorBrowsableState.Never)]\n[GenerateAssertion(ExpectationMessage = "to be between {min} and {max}")]\npublic static bool IsBetween(this int value, int min, int max)\n{\n    return value >= min && value <= max;\n}\n\n// Usage:\nawait Assert.That(10).IsGreaterThan(5);  // \u2705 Passes\nawait Assert.That(3).IsGreaterThan(5);   // \u274c Fails: "Expected to be greater than 5 but found 3"\n\nawait Assert.That(7).IsBetween(1, 10);   // \u2705 Passes\nawait Assert.That(15).IsBetween(1, 10);  // \u274c Fails: "Expected to be between 1 and 10 but found 15"\n'})}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Benefits:"})}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["Use ",(0,i.jsx)(s.code,{children:"{paramName}"})," in ",(0,i.jsx)(s.code,{children:"ExpectationMessage"})," to include parameter values"]}),"\n",(0,i.jsxs)(s.li,{children:["Parameters automatically get ",(0,i.jsx)(s.code,{children:"[CallerArgumentExpression]"})," for great error messages"]}),"\n",(0,i.jsx)(s.li,{children:"Each parameter becomes part of the extension method signature"}),"\n",(0,i.jsx)(s.li,{children:"Error messages show actual values with clear context"}),"\n"]}),"\n",(0,i.jsx)(s.hr,{}),"\n",(0,i.jsxs)(s.h2,{id:"class-level-generation-assertionfrom",children:["Class-Level Generation: ",(0,i.jsx)(s.code,{children:"[AssertionFrom]"})]}),"\n",(0,i.jsxs)(s.p,{children:["Use ",(0,i.jsx)(s.code,{children:"[AssertionFrom]"})," to create assertions from existing methods in libraries or your codebase."]}),"\n",(0,i.jsx)(s.h3,{id:"basic-usage",children:"Basic Usage"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-csharp",children:'using TUnit.Assertions.Attributes;\n\n[AssertionFrom<string>(nameof(string.IsNullOrEmpty), ExpectationMessage = "to be null or empty")]\n[AssertionFrom<string>(nameof(string.StartsWith), ExpectationMessage = "to start with {value}")]\n[AssertionFrom<string>(nameof(string.EndsWith), ExpectationMessage = "to end with {value}")]\npublic static partial class StringAssertionExtensions\n{\n}\n\n// Usage:\nawait Assert.That(myString).IsNullOrEmpty();\n// If fails: "Expected to be null or empty but found \'test\'"\n\nawait Assert.That("hello").StartsWith("he");\n// If fails: "Expected to start with \'he\' but found \'hello\'"\n'})}),"\n",(0,i.jsx)(s.h3,{id:"with-custom-names",children:"With Custom Names"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-csharp",children:'[AssertionFrom<string>(nameof(string.Contains), CustomName = "Has", ExpectationMessage = "to have \'{value}\'")]\npublic static partial class StringAssertionExtensions\n{\n}\n\n// Usage:\nawait Assert.That("hello world").Has("world");  // \u2705 Passes\nawait Assert.That("hello").Has("world");        // \u274c Fails: "Expected to have \'world\' but found \'hello\'"\n'})}),"\n",(0,i.jsx)(s.h3,{id:"negation-support",children:"Negation Support"}),"\n",(0,i.jsxs)(s.p,{children:["For ",(0,i.jsx)(s.code,{children:"bool"}),"-returning methods, you can generate negated versions:"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-csharp",children:'[AssertionFrom<string>(nameof(string.Contains), CustomName = "DoesNotContain", NegateLogic = true, ExpectationMessage = "to not contain \'{value}\'")]\npublic static partial class StringAssertionExtensions\n{\n}\n\n// Usage:\nawait Assert.That("hello").DoesNotContain("xyz");  // \u2705 Passes\nawait Assert.That("hello").DoesNotContain("ell");  // \u274c Fails: "Expected to not contain \'ell\' but found \'hello\'"\n'})}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"Note:"})," Negation only works with ",(0,i.jsx)(s.code,{children:"bool"}),"-returning methods. ",(0,i.jsx)(s.code,{children:"AssertionResult"})," methods determine their own pass/fail logic."]}),"\n",(0,i.jsx)(s.h3,{id:"referencing-methods-on-different-types",children:"Referencing Methods on Different Types"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-csharp",children:'// Reference static methods from another type\n[AssertionFrom<string>(typeof(StringHelper), nameof(StringHelper.IsValidEmail), ExpectationMessage = "to be a valid email")]\npublic static partial class StringAssertionExtensions\n{\n}\n\n// Where StringHelper is:\npublic static class StringHelper\n{\n    public static bool IsValidEmail(string value)\n    {\n        return value.Contains("@");\n    }\n}\n\n// Usage:\nawait Assert.That("user@example.com").IsValidEmail();  // \u2705 Passes\nawait Assert.That("invalid-email").IsValidEmail();     // \u274c Fails: "Expected to be a valid email but found \'invalid-email\'"\n'})}),"\n",(0,i.jsx)(s.hr,{}),"\n",(0,i.jsx)(s.h2,{id:"method-body-inlining-advanced",children:"Method Body Inlining (Advanced)"}),"\n",(0,i.jsxs)(s.p,{children:["For cleaner code and better IntelliSense, you can use method body inlining with file-scoped classes. This eliminates the need for ",(0,i.jsx)(s.code,{children:"[EditorBrowsable]"})," attributes entirely."]}),"\n",(0,i.jsxs)(s.h3,{id:"using-inlinemethodbody",children:["Using ",(0,i.jsx)(s.code,{children:"InlineMethodBody"})]}),"\n",(0,i.jsxs)(s.p,{children:["Set ",(0,i.jsx)(s.code,{children:"InlineMethodBody = true"})," to have the generator inline your method body instead of calling it:"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-csharp",children:'using TUnit.Assertions.Attributes;\n\n// File-scoped class - only visible in this file\nfile static class BoolAssertions\n{\n    [GenerateAssertion(ExpectationMessage = "to be true", InlineMethodBody = true)]\n    public static bool IsTrue(this bool value) => value == true;\n\n    [GenerateAssertion(ExpectationMessage = "to be false", InlineMethodBody = true)]\n    public static bool IsFalse(this bool value) => value == false;\n}\n\n// Usage in tests:\nawait Assert.That(myBool).IsTrue();   // \u2705 Clean API, no IntelliSense pollution\n'})}),"\n",(0,i.jsx)(s.h3,{id:"what-gets-generated-with-inlining",children:"What Gets Generated with Inlining"}),"\n",(0,i.jsx)(s.p,{children:"Instead of calling your method, the generator inlines the expression directly:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-csharp",children:'// WITHOUT InlineMethodBody (calls the method):\nprotected override Task<AssertionResult> CheckAsync(EvaluationMetadata<bool> metadata)\n{\n    var value = metadata.Value;\n    var result = value!.IsTrue();  // Method call\n    return Task.FromResult(result ? AssertionResult.Passed : AssertionResult.Failed($"found {value}"));\n}\n\n// WITH InlineMethodBody (inlines the expression):\nprotected override Task<AssertionResult> CheckAsync(EvaluationMetadata<bool> metadata)\n{\n    var value = metadata.Value;\n    var result = value == true;  // Inlined!\n    return Task.FromResult(result ? AssertionResult.Passed : AssertionResult.Failed($"found {value}"));\n}\n'})}),"\n",(0,i.jsx)(s.h3,{id:"benefits-of-inlining",children:"Benefits of Inlining"}),"\n",(0,i.jsxs)(s.p,{children:["\u2705 ",(0,i.jsxs)(s.strong,{children:["No ",(0,i.jsx)(s.code,{children:"[EditorBrowsable]"})," needed"]})," - The helper methods are in a file-scoped class\n\u2705 ",(0,i.jsx)(s.strong,{children:"Cleaner IntelliSense"})," - Helper methods don't appear anywhere in IntelliSense\n\u2705 ",(0,i.jsx)(s.strong,{children:"Type-safe"})," - The generator fully qualifies all type references automatically\n\u2705 ",(0,i.jsx)(s.strong,{children:"Works with parameters"})," - Parameters are automatically substituted"]}),"\n",(0,i.jsx)(s.h3,{id:"example-with-parameters",children:"Example with Parameters"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-csharp",children:'file static class IntAssertions\n{\n    [GenerateAssertion(ExpectationMessage = "to be positive", InlineMethodBody = true)]\n    public static bool IsPositive(this int value) => value > 0;\n\n    [GenerateAssertion(ExpectationMessage = "to be greater than {threshold}", InlineMethodBody = true)]\n    public static bool IsGreaterThan(this int value, int threshold) => value > threshold;\n}\n\n// Generated code inlines with proper parameter substitution:\n// var result = value > 0;\n// var result = value > _threshold;  // Parameter renamed to field\n'})}),"\n",(0,i.jsx)(s.h3,{id:"when-to-use-inlining",children:"When to Use Inlining"}),"\n",(0,i.jsxs)(s.p,{children:["Use ",(0,i.jsx)(s.code,{children:"InlineMethodBody = true"})," when:"]}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["You want cleaner code without ",(0,i.jsx)(s.code,{children:"[EditorBrowsable]"})," attributes"]}),"\n",(0,i.jsx)(s.li,{children:"You're using file-scoped classes (C# 11+)"}),"\n",(0,i.jsx)(s.li,{children:"Your assertion logic is simple (expression-bodied or single return statement)"}),"\n",(0,i.jsx)(s.li,{children:"You want the cleanest possible API surface"}),"\n"]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"Note:"})," Inlining only works with:"]}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["Expression-bodied methods: ",(0,i.jsx)(s.code,{children:"=> expression"})]}),"\n",(0,i.jsxs)(s.li,{children:["Simple block methods with a single return statement: ",(0,i.jsx)(s.code,{children:"{ return expression; }"})]}),"\n"]}),"\n",(0,i.jsx)(s.hr,{}),"\n",(0,i.jsx)(s.h2,{id:"requirements-and-best-practices",children:"Requirements and Best Practices"}),"\n",(0,i.jsx)(s.h3,{id:"method-requirements",children:"Method Requirements"}),"\n",(0,i.jsxs)(s.p,{children:["For ",(0,i.jsx)(s.code,{children:"[GenerateAssertion]"}),", your method must:"]}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["Be ",(0,i.jsx)(s.code,{children:"static"})]}),"\n",(0,i.jsx)(s.li,{children:"Have at least one parameter (the value to assert)"}),"\n",(0,i.jsxs)(s.li,{children:["Return ",(0,i.jsx)(s.code,{children:"bool"}),", ",(0,i.jsx)(s.code,{children:"AssertionResult"}),", ",(0,i.jsx)(s.code,{children:"Task<bool>"}),", or ",(0,i.jsx)(s.code,{children:"Task<AssertionResult>"})]}),"\n"]}),"\n",(0,i.jsx)(s.h3,{id:"hiding-helper-methods-from-intellisense",children:"Hiding Helper Methods from IntelliSense"}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"Important:"})," Always use ",(0,i.jsx)(s.code,{children:"[EditorBrowsable(EditorBrowsableState.Never)]"})," on your ",(0,i.jsx)(s.code,{children:"[GenerateAssertion]"})," methods to prevent IntelliSense pollution."]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-csharp",children:"using System.ComponentModel;\nusing TUnit.Assertions.Attributes;\n\npublic static partial class StringAssertionExtensions\n{\n    // \u2705 GOOD: Hidden from IntelliSense\n    [EditorBrowsable(EditorBrowsableState.Never)]\n    [GenerateAssertion]\n    public static bool IsEmptyString(this string value) => value.Length == 0;\n\n    // \u274c BAD: Will appear in IntelliSense when typing on string values\n    [GenerateAssertion]\n    public static bool IsEmptyString(this string value) => value.Length == 0;\n}\n"})}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"Why?"})," Without ",(0,i.jsx)(s.code,{children:"[EditorBrowsable]"}),", the helper method appears in IntelliSense when users type on the actual type (e.g., ",(0,i.jsx)(s.code,{children:"myString."}),"). With the attribute, users only see the proper assertion method on ",(0,i.jsx)(s.code,{children:"Assert.That(myString)."}),", which is cleaner and less confusing."]}),"\n",(0,i.jsx)(s.h3,{id:"recommended-patterns",children:"Recommended Patterns"}),"\n",(0,i.jsxs)(s.p,{children:["\u2705 ",(0,i.jsx)(s.strong,{children:"DO:"})]}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Always"})," use ",(0,i.jsx)(s.code,{children:"[EditorBrowsable(EditorBrowsableState.Never)]"})," on ",(0,i.jsx)(s.code,{children:"[GenerateAssertion]"})," methods"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Always"})," use ",(0,i.jsx)(s.code,{children:"ExpectationMessage"})," to provide clear error messages"]}),"\n",(0,i.jsxs)(s.li,{children:["Use ",(0,i.jsx)(s.code,{children:"{paramName}"})," in expectation messages to include parameter values"]}),"\n",(0,i.jsx)(s.li,{children:"Use extension methods for cleaner syntax"}),"\n",(0,i.jsxs)(s.li,{children:["Return ",(0,i.jsx)(s.code,{children:"AssertionResult"})," when you need custom error messages"]}),"\n",(0,i.jsx)(s.li,{children:"Use async when performing I/O or database operations"}),"\n",(0,i.jsx)(s.li,{children:"Keep assertion logic simple and focused"}),"\n",(0,i.jsx)(s.li,{children:"Use descriptive method names"}),"\n"]}),"\n",(0,i.jsxs)(s.p,{children:["\u274c ",(0,i.jsx)(s.strong,{children:"DON'T:"})]}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"Put complex business logic in assertions"}),"\n",(0,i.jsx)(s.li,{children:"Make assertions with side effects"}),"\n",(0,i.jsxs)(s.li,{children:["Use ",(0,i.jsx)(s.code,{children:"AssertionResult"})," with negation (it won't work as expected)"]}),"\n",(0,i.jsxs)(s.li,{children:["Forget to make the containing class ",(0,i.jsx)(s.code,{children:"partial"})]}),"\n",(0,i.jsxs)(s.li,{children:["Skip the ",(0,i.jsx)(s.code,{children:"[EditorBrowsable]"})," attribute (causes IntelliSense clutter)"]}),"\n"]}),"\n",(0,i.jsx)(s.hr,{}),"\n",(0,i.jsx)(s.h2,{id:"chaining-and-composition",children:"Chaining and Composition"}),"\n",(0,i.jsx)(s.p,{children:"All generated assertions support chaining:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-csharp",children:'[EditorBrowsable(EditorBrowsableState.Never)]\n[GenerateAssertion(ExpectationMessage = "to be positive")]\npublic static bool IsPositive(this int value) => value > 0;\n\n[EditorBrowsable(EditorBrowsableState.Never)]\n[GenerateAssertion(ExpectationMessage = "to be even")]\npublic static bool IsEven(this int value) => value % 2 == 0;\n\n// Usage:\nawait Assert.That(10)\n    .IsPositive()\n    .And.IsEven();\n\n// Or:\nawait Assert.That(number)\n    .IsEven()\n    .Or.IsPositive();\n'})}),"\n",(0,i.jsx)(s.hr,{}),"\n",(0,i.jsx)(s.h2,{id:"complete-example",children:"Complete Example"}),"\n",(0,i.jsx)(s.p,{children:"Here's a comprehensive example showing all features:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-csharp",children:'using System.ComponentModel;\nusing TUnit.Assertions.Attributes;\nusing TUnit.Assertions.Core;\n\npublic static partial class UserAssertionExtensions\n{\n    // Simple bool\n    [EditorBrowsable(EditorBrowsableState.Never)]\n    [GenerateAssertion(ExpectationMessage = "to have valid ID")]\n    public static bool HasValidId(this User user)\n    {\n        return user.Id > 0;\n    }\n\n    // With parameters\n    [EditorBrowsable(EditorBrowsableState.Never)]\n    [GenerateAssertion(ExpectationMessage = "to have role \'{role}\'")]\n    public static bool HasRole(this User user, string role)\n    {\n        return user.Roles.Contains(role);\n    }\n\n    // Custom messages with AssertionResult\n    [EditorBrowsable(EditorBrowsableState.Never)]\n    [GenerateAssertion(ExpectationMessage = "to have valid email")]\n    public static AssertionResult HasValidEmail(this User user)\n    {\n        if (string.IsNullOrEmpty(user.Email))\n            return AssertionResult.Failed("Email is null or empty");\n\n        if (!user.Email.Contains("@"))\n            return AssertionResult.Failed($"Email \'{user.Email}\' is not valid");\n\n        return AssertionResult.Passed;\n    }\n\n    // Async with database\n    [EditorBrowsable(EditorBrowsableState.Never)]\n    [GenerateAssertion(ExpectationMessage = "to exist in database")]\n    public static async Task<bool> ExistsInDatabaseAsync(this User user, DbContext db)\n    {\n        return await db.Users.AnyAsync(u => u.Id == user.Id);\n    }\n}\n\n// Usage in tests:\n[Test]\npublic async Task ValidateUser()\n{\n    var user = new User { Id = 1, Email = "test@example.com", Roles = ["Admin"] };\n\n    await Assert.That(user).HasValidId();\n    await Assert.That(user).HasRole("Admin");\n    await Assert.That(user).HasValidEmail();\n    await Assert.That(user).ExistsInDatabaseAsync(dbContext);\n\n    // Chaining:\n    await Assert.That(user)\n        .HasValidId()\n        .And.HasValidEmail()\n        .And.HasRole("Admin");\n}\n'})}),"\n",(0,i.jsx)(s.hr,{}),"\n",(0,i.jsx)(s.h2,{id:"see-also",children:"See Also"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.a,{href:"/docs/assertions/extensibility/custom-assertions",children:"Custom Assertions (Manual)"})," - For when you need full control"]}),"\n"]})]})}function h(e={}){const{wrapper:s}={...(0,r.R)(),...e.components};return s?(0,i.jsx)(s,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},8453:(e,s,n)=>{n.d(s,{R:()=>a,x:()=>o});var t=n(6540);const i={},r=t.createContext(i);function a(e){const s=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function o(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),t.createElement(r.Provider,{value:s},e.children)}}}]);