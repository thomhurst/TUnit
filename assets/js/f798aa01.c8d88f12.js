"use strict";(self.webpackChunktunit_docs_site=self.webpackChunktunit_docs_site||[]).push([[910],{1746:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>u,frontMatter:()=>s,metadata:()=>t,toc:()=>a});const t=JSON.parse('{"id":"execution/engine-modes","title":"Engine Modes","description":"TUnit supports two execution modes, providing flexibility for different development and deployment scenarios.","source":"@site/docs/execution/engine-modes.md","sourceDirName":"execution","slug":"/execution/engine-modes","permalink":"/docs/execution/engine-modes","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"docs","previous":{"title":"Executors","permalink":"/docs/execution/executors"},"next":{"title":"Exception Handling","permalink":"/docs/advanced/exception-handling"}}');var o=i(4848),r=i(8453);const s={},l="Engine Modes",c={},a=[{value:"Execution Modes",id:"execution-modes",level:2},{value:"Source Generation Mode (Default)",id:"source-generation-mode-default",level:2},{value:"Reflection Mode",id:"reflection-mode",level:2},{value:"Enabling Reflection Mode",id:"enabling-reflection-mode",level:3},{value:"1. Command-Line Flag (Highest Priority)",id:"1-command-line-flag-highest-priority",level:4},{value:"2. Assembly Attribute (Recommended for Per-Project Configuration)",id:"2-assembly-attribute-recommended-for-per-project-configuration",level:4},{value:"3. Environment Variable (Global Configuration)",id:"3-environment-variable-global-configuration",level:4},{value:"Optimizing Build Performance in Reflection Mode",id:"optimizing-build-performance-in-reflection-mode",level:3},{value:"Native AOT Support",id:"native-aot-support",level:2},{value:"How Source Generation Works",id:"how-source-generation-works",level:2},{value:"Publishing with Native AOT",id:"publishing-with-native-aot",level:2},{value:"Configuration",id:"configuration",level:2},{value:"EditorConfig (.editorconfig)",id:"editorconfig-editorconfig",level:3},{value:"MSBuild Property",id:"msbuild-property",level:3},{value:"Compatibility",id:"compatibility",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"engine-modes",children:"Engine Modes"})}),"\n",(0,o.jsx)(n.p,{children:"TUnit supports two execution modes, providing flexibility for different development and deployment scenarios."}),"\n",(0,o.jsx)(n.h2,{id:"execution-modes",children:"Execution Modes"}),"\n",(0,o.jsx)(n.p,{children:"TUnit can run in two modes:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Source Generation Mode"})," (Default): Uses compile-time source generation for test discovery and execution, providing optimal performance and compile-time safety"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Reflection Mode"}),": Traditional runtime reflection-based test discovery and execution, enabled with the ",(0,o.jsx)(n.code,{children:"--reflection"})," command-line flag"]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"When publishing with Native AOT, the source generation mode provides additional performance benefits and full AOT compatibility."}),"\n",(0,o.jsx)(n.p,{children:"The Reflection mode allows discovery of test cases that have been source generated by something other than TUnit, though, for example .razor files in bUnit."}),"\n",(0,o.jsx)(n.h2,{id:"source-generation-mode-default",children:"Source Generation Mode (Default)"}),"\n",(0,o.jsx)(n.p,{children:"By default, TUnit always uses source generation for test discovery and execution:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Compile-Time Generation"}),": All test discovery logic is generated at compile time"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Better Performance"}),": Faster than reflection-based execution"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Type Safety"}),": Compile-time validation of test configurations and data sources"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"No Runtime Reflection"}),": Eliminates the overhead of runtime type discovery"]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"This is the standard mode used for all builds, whether debugging, running tests, or publishing. When you publish with Native AOT, you get additional performance benefits, but the underlying source generation logic remains the same."}),"\n",(0,o.jsx)(n.h2,{id:"reflection-mode",children:"Reflection Mode"}),"\n",(0,o.jsx)(n.p,{children:"Reflection mode can be explicitly enabled in several ways:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Runtime Discovery"}),": Tests are discovered at runtime using reflection"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Dynamic Execution"}),": Uses traditional reflection-based test invocation"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Compatibility"}),": Useful for scenarios where source generation may not be suitable (e.g., bUnit with Razor components)"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Legacy Support"}),": Maintains compatibility with reflection-dependent test patterns"]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"enabling-reflection-mode",children:"Enabling Reflection Mode"}),"\n",(0,o.jsx)(n.p,{children:"There are three ways to enable reflection mode, listed in priority order:"}),"\n",(0,o.jsx)(n.h4,{id:"1-command-line-flag-highest-priority",children:"1. Command-Line Flag (Highest Priority)"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:"dotnet test -- --reflection\n"})}),"\n",(0,o.jsx)(n.h4,{id:"2-assembly-attribute-recommended-for-per-project-configuration",children:"2. Assembly Attribute (Recommended for Per-Project Configuration)"}),"\n",(0,o.jsxs)(n.p,{children:["Add to any ",(0,o.jsx)(n.code,{children:".cs"})," file in your test project (e.g., ",(0,o.jsx)(n.code,{children:"AssemblyInfo.cs"}),"):"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:"using TUnit.Core;\n\n[assembly: ReflectionMode]\n"})}),"\n",(0,o.jsx)(n.p,{children:"This is the recommended approach when you need reflection mode for a specific test assembly, such as bUnit projects that test Razor components. The configuration is version-controlled and doesn't require external configuration files."}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Example: bUnit Test Project"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:'// Add this to enable reflection mode for your bUnit tests\n[assembly: ReflectionMode]\n\nnamespace MyApp.Tests;\n\npublic class CounterComponentTests : TestContext\n{\n    [Test]\n    public void CounterStartsAtZero()\n    {\n        // Test Razor components that are source-generated at compile time\n        var cut = RenderComponent<Counter>();\n        cut.Find("p").TextContent.ShouldBe("Current count: 0");\n    }\n}\n'})}),"\n",(0,o.jsx)(n.h4,{id:"3-environment-variable-global-configuration",children:"3. Environment Variable (Global Configuration)"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:"# Windows\nset TUNIT_EXECUTION_MODE=reflection\n\n# Linux/macOS\nexport TUNIT_EXECUTION_MODE=reflection\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Alternatively, you can configure this in a ",(0,o.jsx)(n.code,{children:".runsettings"})," file:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-xml",children:"<RunSettings>\n  <RunConfiguration>\n    <EnvironmentVariables>\n      <TUNIT_EXECUTION_MODE>reflection</TUNIT_EXECUTION_MODE>\n    </EnvironmentVariables>\n  </RunConfiguration>\n</RunSettings>\n"})}),"\n",(0,o.jsx)(n.h3,{id:"optimizing-build-performance-in-reflection-mode",children:"Optimizing Build Performance in Reflection Mode"}),"\n",(0,o.jsxs)(n.p,{children:["When using reflection mode exclusively (via ",(0,o.jsx)(n.code,{children:"[assembly: ReflectionMode]"}),"), you can improve build performance by disabling source generation entirely. Since the generated code won't be used at runtime in reflection mode, skipping source generation reduces compile times."]}),"\n",(0,o.jsxs)(n.p,{children:["Add this MSBuild property to your test project file (",(0,o.jsx)(n.code,{children:".csproj"}),"):"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-xml",children:"<PropertyGroup>\n    <EnableTUnitSourceGeneration>false</EnableTUnitSourceGeneration>\n</PropertyGroup>\n"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Example: bUnit Test Project with Optimized Build"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-xml",children:'<Project Sdk="Microsoft.NET.Sdk.Razor">\n  <PropertyGroup>\n    <TargetFramework>net9.0</TargetFramework>\n    \x3c!-- Disable source generation since we\'re using reflection mode --\x3e\n    <EnableTUnitSourceGeneration>false</EnableTUnitSourceGeneration>\n  </PropertyGroup>\n\n  <ItemGroup>\n    <PackageReference Include="bunit" Version="1.x.x" />\n    <PackageReference Include="TUnit" Version="1.x.x" />\n  </ItemGroup>\n</Project>\n'})}),"\n",(0,o.jsx)(n.p,{children:"Then in your code:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:'// Enable reflection mode for Razor component testing\n[assembly: ReflectionMode]\n\nnamespace MyApp.Tests;\n\npublic class CounterComponentTests : TestContext\n{\n    [Test]\n    public void CounterStartsAtZero()\n    {\n        var cut = RenderComponent<Counter>();\n        cut.Find("p").TextContent.ShouldBe("Current count: 0");\n    }\n}\n'})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Benefits:"})}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Faster Builds"}),": Eliminates source generator execution at compile time"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Reduced Compiler Overhead"}),": Less work for the compiler to do"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Clear Intent"}),": Explicitly indicates the project uses reflection mode"]}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Note:"})," This optimization is only beneficial when you're exclusively using reflection mode. If you're using source generation mode (the default), keep ",(0,o.jsx)(n.code,{children:"EnableTUnitSourceGeneration"})," set to ",(0,o.jsx)(n.code,{children:"true"})," (or omit it entirely, as ",(0,o.jsx)(n.code,{children:"true"})," is the default)."]}),"\n",(0,o.jsx)(n.h2,{id:"native-aot-support",children:"Native AOT Support"}),"\n",(0,o.jsx)(n.p,{children:"When publishing with Native AOT, TUnit's source generation mode provides additional benefits:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Full AOT Compatibility"}),": The source-generated code is fully compatible with Native AOT compilation"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Enhanced Performance"}),": Better performance compared to reflection-based execution"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Reduced Binary Size"}),": No reflection metadata needed, resulting in smaller executables"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Faster Startup"}),": No runtime type discovery overhead"]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Note: These AOT-specific benefits only apply when actually publishing with Native AOT. Regular builds use the same source generation logic but without the native compilation optimizations."}),"\n",(0,o.jsx)(n.h2,{id:"how-source-generation-works",children:"How Source Generation Works"}),"\n",(0,o.jsx)(n.p,{children:"TUnit's source generation creates strongly-typed delegates for all test operations at compile time:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Test Invocation"}),": Type-specific delegates instead of generic object arrays"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Data Sources"}),": Specialized factory methods with exact return types"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Property Injection"}),": Generated property setters with dependency resolution"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Hook Methods"}),": Strongly-typed hook delegates with proper async support"]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"publishing-with-native-aot",children:"Publishing with Native AOT"}),"\n",(0,o.jsx)(n.p,{children:"To use TUnit with Native AOT:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-xml",children:"<PropertyGroup>\n    <PublishAot>true</PublishAot>\n</PropertyGroup>\n"})}),"\n",(0,o.jsx)(n.p,{children:"Then publish your project:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:"dotnet publish -c Release\n"})}),"\n",(0,o.jsx)(n.h2,{id:"configuration",children:"Configuration"}),"\n",(0,o.jsx)(n.p,{children:"TUnit uses optimized defaults for all features. The only configurable option is verbose diagnostics for troubleshooting source generation issues:"}),"\n",(0,o.jsx)(n.h3,{id:"editorconfig-editorconfig",children:"EditorConfig (.editorconfig)"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ini",children:"# Enable verbose diagnostics (default: false)\ntunit.enable_verbose_diagnostics = true\n"})}),"\n",(0,o.jsx)(n.h3,{id:"msbuild-property",children:"MSBuild Property"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-xml",children:"<PropertyGroup>\n    <TUnitEnableVerboseDiagnostics>true</TUnitEnableVerboseDiagnostics>\n</PropertyGroup>\n"})}),"\n",(0,o.jsx)(n.h2,{id:"compatibility",children:"Compatibility"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"C# Projects"}),": Full support with source generation\n",(0,o.jsx)(n.strong,{children:"F# Projects"}),": Falls back to reflection mode (source generation not supported)\n",(0,o.jsx)(n.strong,{children:"VB.NET Projects"}),": Falls back to reflection mode (source generation not supported)"]}),"\n",(0,o.jsx)(n.p,{children:"For F# and VB.NET projects, TUnit automatically uses reflection mode since source generation is only available for C# projects. For better performance with F# or VB.NET code, create a separate C# test project that references your F#/VB.NET libraries and write tests there."})]})}function u(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>s,x:()=>l});var t=i(6540);const o={},r=t.createContext(o);function s(e){const n=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);