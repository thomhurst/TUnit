"use strict";(self.webpackChunktunit_docs_site=self.webpackChunktunit_docs_site||[]).push([[7410],{6601:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>d,frontMatter:()=>o,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"tutorial-advanced/fsharp-interactive","title":"F# Interactive","description":"Interactive","source":"@site/docs/tutorial-advanced/fsharp-interactive.md","sourceDirName":"tutorial-advanced","slug":"/tutorial-advanced/fsharp-interactive","permalink":"/docs/tutorial-advanced/fsharp-interactive","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":31,"frontMatter":{"sidebar_position":31},"sidebar":"tutorialSidebar","previous":{"title":"Engine Modes","permalink":"/docs/tutorial-advanced/engine-modes"},"next":{"title":"Tutorial - Assertions","permalink":"/docs/category/tutorial---assertions"}}');var i=t(4848),r=t(8453);const o={sidebar_position:31},a="F# Interactive",c={},l=[{value:"Using F# Interactive with TUnit",id:"using-f-interactive-with-tunit",level:2}];function u(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"f-interactive",children:"F# Interactive"})}),"\n",(0,i.jsx)(n.p,{children:"F# Interactive (FSI) is a REPL (Read-Eval-Print Loop) for F#. It allows you to execute F# code interactively, making it a powerful tool for testing and prototyping.\nIt is included with the F# compiler and can be used in various development environments, including Visual Studio and Visual Studio Code."}),"\n",(0,i.jsx)(n.h2,{id:"using-f-interactive-with-tunit",children:"Using F# Interactive with TUnit"}),"\n",(0,i.jsx)(n.p,{children:"TUnit can be used with F# Interactive to run tests interactively. This is particularly useful for rapid prototyping, testing small code snippets, and running tests in an easy script\nformat. To use TUnit with F# Interactive, follow these steps:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Add TUnit to your fsx script"}),": You need to reference the TUnit library in your F# script. You can do this by adding the following line at the top of your ",(0,i.jsx)(n.code,{children:".fsx"})," file:\nThe following will add the latest version of TUnit to your script:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-fsharp",children:'#r "nuget: TUnit"\n'})}),"\n",(0,i.jsx)(n.p,{children:"Alternatively, you can specify a specific version:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-fsharp",children:'#r "nuget: TUnit, 0.20.16"\n'})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Write your tests"}),": You can write your tests in the same way you would in a regular F# project. For example:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-fsharp",children:'   #r "nuget: TUnit, 0.20.16"\n   #r "nuget: TUnit.Assertions.Fsharp, 0.20.16"\n\n   open System\n   open TUnit\n   open TUnit.Engine\n   open TUnit.Core\n   open TUnit.Assertions\n   open TUnit.Assertions\n   open TUnit.Assertions.Extensions\n   open TUnit.Assertions.FSharp.Operations\n   open TUnit.Engine.Services\n   open System.Collections.Generic\n\n   type tests() =\n      [<Test>]\n      member _.Basic() =\n         Console.WriteLine("This is a basic test")\n\n      [<Test>]\n      [<Arguments(1, 2, 3)>]\n      [<Arguments(2, 3, 5)>]\n      member _.DataDrivenArguments(a: int, b: int, c: int) =\n         async {\n               Console.WriteLine("This one can accept arguments from an attribute")\n               let result = a + b\n               do! check (Assert.That(result).IsEqualTo(c))\n         }\n\n      [<DynamicTestBuilder>]\n      member _.BuildTests(context: DynamicTestBuilderContext) =\n         context.AddTest(DynamicTest<tests>(TestMethod = fun instance -> instance.Basic()))\n\n         context.AddTest(\n               DynamicTest<tests>(\n                  TestMethod = fun instance -> instance.DataDrivenArguments(1, 2, 3) |> Async.RunSynchronously\n               )\n         )\n\n   // Instantiate your test class\n   let testInstance = tests ()\n\n   testInstance.BuildTests\n\n   // Create a test runner and get the results\n   let resultsTask =\n      task {\n         // Set results directory to current working directory\n         let args = [| "--results-directory"; System.IO.Directory.GetCurrentDirectory() |]\n         let! testResults = TUnitRunner.RunTests(args)\n         return testResults\n      }\n\n   printf "Running tests..."\n\n   resultsTask |> Async.AwaitTask |> Async.RunSynchronously\n'})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Run your tests"}),": You can run your tests by executing the script in F# Interactive. The results will be printed to the console.\nTo run the script, you can use the following command"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-powershell",children:"dotnet fsi your_script.fsx\n"})}),"\n"]}),"\n"]})]})}function d(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(u,{...e})}):u(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>a});var s=t(6540);const i={},r=s.createContext(i);function o(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);