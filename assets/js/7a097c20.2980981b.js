"use strict";(self.webpackChunktunit_docs_site=self.webpackChunktunit_docs_site||[]).push([[3154],{3925:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>n,toc:()=>d});const n=JSON.parse('{"id":"guides/philosophy","title":"TUnit Philosophy & Design Decisions","description":"If you\'re wondering why TUnit does things differently from other testing frameworks, this page has the answers. Understanding the reasoning behind TUnit\'s design will help you use it effectively and decide if it\'s right for your project.","source":"@site/docs/guides/philosophy.md","sourceDirName":"guides","slug":"/guides/philosophy","permalink":"/docs/guides/philosophy","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"docs","previous":{"title":"Attributes","permalink":"/docs/comparison/attributes"},"next":{"title":"Performance Benchmarks","permalink":"/docs/benchmarks/"}}');var i=s(4848),r=s(8453);const o={},a="TUnit Philosophy & Design Decisions",l={},d=[{value:"Core Principles",id:"core-principles",level:2},{value:"Performance First",id:"performance-first",level:3},{value:"Modern .NET First",id:"modern-net-first",level:3},{value:"Test Isolation",id:"test-isolation",level:3},{value:"Developer Experience",id:"developer-experience",level:3},{value:"Key Design Decisions",id:"key-design-decisions",level:2},{value:"Why Dual-Mode Execution?",id:"why-dual-mode-execution",level:3},{value:"Why All Assertions Must Be Awaited",id:"why-all-assertions-must-be-awaited",level:3},{value:"Why Microsoft.Testing.Platform?",id:"why-microsofttestingplatform",level:3},{value:"Why Parallel by Default?",id:"why-parallel-by-default",level:3},{value:"Why New Instance Per Test?",id:"why-new-instance-per-test",level:3},{value:"Why Source Generators?",id:"why-source-generators",level:3},{value:"What Problems Does TUnit Solve?",id:"what-problems-does-tunit-solve",level:2},{value:"Slow Test Suites",id:"slow-test-suites",level:3},{value:"Flaky Tests from State Leaks",id:"flaky-tests-from-state-leaks",level:3},{value:"Limited Async Support",id:"limited-async-support",level:3},{value:"Poor AOT Support",id:"poor-aot-support",level:3},{value:"Comparison with Other Frameworks",id:"comparison-with-other-frameworks",level:2},{value:"TUnit vs xUnit",id:"tunit-vs-xunit",level:3},{value:"TUnit vs NUnit",id:"tunit-vs-nunit",level:3},{value:"TUnit vs MSTest",id:"tunit-vs-mstest",level:3},{value:"When to Choose TUnit",id:"when-to-choose-tunit",level:2},{value:"The Bottom Line",id:"the-bottom-line",level:2}];function c(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"tunit-philosophy--design-decisions",children:"TUnit Philosophy & Design Decisions"})}),"\n",(0,i.jsx)(t.p,{children:"If you're wondering why TUnit does things differently from other testing frameworks, this page has the answers. Understanding the reasoning behind TUnit's design will help you use it effectively and decide if it's right for your project."}),"\n",(0,i.jsx)(t.h2,{id:"core-principles",children:"Core Principles"}),"\n",(0,i.jsx)(t.h3,{id:"performance-first",children:"Performance First"}),"\n",(0,i.jsx)(t.p,{children:"TUnit is built for speed at any scale. Whether you have 100 tests or 100,000, they should run as fast as possible. Tests run in parallel by default, using Roslyn source generators to discover tests at compile time instead of expensive runtime reflection. You can choose between source-generated mode (fastest) or reflection mode (more flexible) depending on your needs."}),"\n",(0,i.jsx)(t.p,{children:"Fast tests create faster feedback loops. When tests run quickly, developers actually run them more often. They catch bugs earlier and stay in flow instead of context-switching while waiting for test results."}),"\n",(0,i.jsx)(t.h3,{id:"modern-net-first",children:"Modern .NET First"}),"\n",(0,i.jsx)(t.p,{children:"TUnit embraces modern .NET without compromises. Everything is async by default. Assertions, hooks, all of it. It uses C# 12+ features like collection expressions and file-scoped namespaces. Native AOT and trimming work out of the box. It's built on Microsoft.Testing.Platform instead of the legacy VSTest infrastructure."}),"\n",(0,i.jsx)(t.p,{children:"Modern .NET applications deserve a modern testing framework. While TUnit supports .NET Standard 2.0 (including .NET Framework), it's designed around modern patterns and idioms, not legacy approaches from a decade ago."}),"\n",(0,i.jsx)(t.h3,{id:"test-isolation",children:"Test Isolation"}),"\n",(0,i.jsxs)(t.p,{children:["Every test should be completely independent. TUnit creates a new instance of your test class for each test method, so instance fields can't leak between tests. Tests can run in any order, on any thread, without affecting each other. If you need shared state, you make it explicit with the ",(0,i.jsx)(t.code,{children:"static"})," keyword."]}),"\n",(0,i.jsx)(t.p,{children:"Isolated tests are reliable tests. You never get those mysterious failures where Test B only fails when Test A runs first. Everything is deterministic."}),"\n",(0,i.jsxs)(t.p,{children:["But what about when tests really do need to depend on each other? Use ",(0,i.jsx)(t.code,{children:"[DependsOn]"})," to enforce ordering. It ensures the dependency always runs first, and if it fails, the dependent test gets skipped instead of running with bad state. This reduces flakiness compared to hoping tests run in the right order by accident."]}),"\n",(0,i.jsx)(t.h3,{id:"developer-experience",children:"Developer Experience"}),"\n",(0,i.jsxs)(t.p,{children:["Writing tests should be pleasant, not painful. TUnit has minimal boilerplate\u2014just put ",(0,i.jsx)(t.code,{children:"[Test]"})," on your methods, no class attributes needed. Assertions read naturally: ",(0,i.jsx)(t.code,{children:"await Assert.That(value).IsEqualTo(expected)"}),". Error messages are clear and actionable. You can access test metadata through ",(0,i.jsx)(t.code,{children:"TestContext"})," whenever you need it."]}),"\n",(0,i.jsx)(t.p,{children:"Developers spend a lot of time writing and debugging tests. Small improvements in ergonomics really do add up over time."}),"\n",(0,i.jsx)(t.h2,{id:"key-design-decisions",children:"Key Design Decisions"}),"\n",(0,i.jsx)(t.h3,{id:"why-dual-mode-execution",children:"Why Dual-Mode Execution?"}),"\n",(0,i.jsx)(t.p,{children:"TUnit offers two ways to discover and run tests: source generation (the default) and reflection mode."}),"\n",(0,i.jsx)(t.p,{children:"Source-generated mode discovers tests at compile time using Roslyn source generators. It generates explicit test registration code, which makes it the fastest option. The downside is you need to recompile when tests change, but that's usually not a problem."}),"\n",(0,i.jsx)(t.p,{children:"Reflection mode discovers tests at runtime. It's slightly slower but more flexible for dynamic scenarios. No code generation means it's simpler in some ways, but you lose the performance benefits."}),"\n",(0,i.jsx)(t.p,{children:"Why support both? Different scenarios need different trade-offs. CI/CD pipelines benefit from maximum speed with source generation. AOT scenarios require it. But if you're doing something dynamic or just want the simplicity of runtime discovery, reflection mode is there. Users aren't locked into one approach."}),"\n",(0,i.jsx)(t.h3,{id:"why-all-assertions-must-be-awaited",children:"Why All Assertions Must Be Awaited"}),"\n",(0,i.jsxs)(t.p,{children:["This is probably TUnit's most controversial decision: all assertions return ",(0,i.jsx)(t.code,{children:"Task"})," and must be awaited."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-csharp",children:"// TUnit - must await\nawait Assert.That(result).IsEqualTo(expected);\n\n// Other frameworks - no await\nAssert.Equal(expected, result);\n"})}),"\n",(0,i.jsx)(t.p,{children:"The reasoning: consistency and extensibility. If all assertions work the same way, you never have to remember which ones need await and which don't. Custom assertions can do async work like database queries or HTTP calls. You can chain assertions naturally without blocking threads. And you avoid all the sync-over-async deadlock problems."}),"\n",(0,i.jsx)(t.p,{children:"Yes, it's more verbose. Yes, there's a learning curve. But it enables patterns that just aren't possible with sync assertions:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-csharp",children:'// Custom async assertion\nawait Assert.That(async () => await GetUserAsync(id))\n    .ThrowsAsync<UserNotFoundException>();\n\n// Chained assertions without blocking\nawait Assert.That(user.Email)\n    .IsNotNull()\n    .And.Contains("@example.com");\n'})}),"\n",(0,i.jsxs)(t.p,{children:["The benefits outweigh the extra ",(0,i.jsx)(t.code,{children:"await"})," keyword. Plus, the code fixers handle most of the migration work automatically anyway."]}),"\n",(0,i.jsx)(t.h3,{id:"why-microsofttestingplatform",children:"Why Microsoft.Testing.Platform?"}),"\n",(0,i.jsx)(t.p,{children:"TUnit is built on Microsoft.Testing.Platform instead of the legacy VSTest infrastructure."}),"\n",(0,i.jsxs)(t.p,{children:["The new platform was designed for .NET 5+ from scratch. It's faster, more extensible, and both ",(0,i.jsx)(t.code,{children:"dotnet test"})," and ",(0,i.jsx)(t.code,{children:"dotnet run"})," work well with it. More importantly, it's where Microsoft is investing going forward."]}),"\n",(0,i.jsxs)(t.p,{children:["The downside? Some older tools only work with VSTest. Coverlet is the most notable example. But Microsoft provides ",(0,i.jsx)(t.code,{children:"Microsoft.Testing.Extensions.CodeCoverage"})," as the modern alternative, and it actually works better with the new platform anyway."]}),"\n",(0,i.jsx)(t.h3,{id:"why-parallel-by-default",children:"Why Parallel by Default?"}),"\n",(0,i.jsx)(t.p,{children:"Most testing frameworks make you opt-in to parallelism. TUnit flips that around."}),"\n",(0,i.jsx)(t.p,{children:"Running tests in parallel can improve execution time. Modern CPUs have many cores\u2014TUnit uses them by default. And here's the thing: tests that are safe to run in parallel are usually well-isolated tests. Making parallelism the default encourages better test design."}),"\n",(0,i.jsxs)(t.p,{children:["When do you opt-out? Use ",(0,i.jsx)(t.code,{children:"[NotInParallel]"})," for tests that modify shared files or databases, use global state, must run in a specific order, or access hardware like cameras or GPIO pins."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-csharp",children:"[Test, NotInParallel]\npublic async Task ModifiesConfigFile()\n{\n    // This test modifies a shared config file\n}\n"})}),"\n",(0,i.jsx)(t.h3,{id:"why-new-instance-per-test",children:"Why New Instance Per Test?"}),"\n",(0,i.jsx)(t.p,{children:"TUnit creates a new instance of your test class for each test method."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-csharp",children:"public class MyTests\n{\n    private int _counter = 0;  // Fresh for each test\n\n    [Test]\n    public async Task Test1()\n    {\n        _counter++;\n        await Assert.That(_counter).IsEqualTo(1);  // Always passes\n    }\n\n    [Test]\n    public async Task Test2()\n    {\n        _counter++;\n        await Assert.That(_counter).IsEqualTo(1);  // Always passes\n    }\n}\n"})}),"\n",(0,i.jsxs)(t.p,{children:['This prevents instance fields from leaking between tests. No race conditions on instance data. No mysterious "Test B fails when Test A runs first" issues. If you need shared state, you use ',(0,i.jsx)(t.code,{children:"static"}),", which makes it explicit and obvious in the code."]}),"\n",(0,i.jsx)(t.p,{children:"Coming from NUnit (which shares instances by default)? Yes, this is a breaking change. But it's the right default for test isolation."}),"\n",(0,i.jsx)(t.h3,{id:"why-source-generators",children:"Why Source Generators?"}),"\n",(0,i.jsx)(t.p,{children:"TUnit uses Roslyn source generators for test discovery. No runtime reflection means better performance and Native AOT compatibility. You get compile-time errors for test configuration issues instead of runtime surprises. IDEs understand the generated code, so IntelliSense and refactoring work better."}),"\n",(0,i.jsxs)(t.p,{children:["Source generators do add complexity and can make debugging trickier. But for most users, the performance and AOT benefits are worth it. If you really need more flexibility, reflection mode is always available with ",(0,i.jsx)(t.code,{children:"dotnet test -- --reflection"}),"."]}),"\n",(0,i.jsx)(t.h2,{id:"what-problems-does-tunit-solve",children:"What Problems Does TUnit Solve?"}),"\n",(0,i.jsx)(t.h3,{id:"slow-test-suites",children:"Slow Test Suites"}),"\n",(0,i.jsx)(t.p,{children:"Traditional frameworks run tests sequentially by default and use runtime reflection for discovery. TUnit runs tests in parallel by default and discovers them at compile time with source generators. This can significantly reduce test suite execution time, especially for large test suites."}),"\n",(0,i.jsx)(t.h3,{id:"flaky-tests-from-state-leaks",children:"Flaky Tests from State Leaks"}),"\n",(0,i.jsxs)(t.p,{children:['NUnit shares test class instances. xUnit allows state in constructors. It\'s easy to accidentally share state and get those frustrating "works alone, fails in the suite" bugs. TUnit creates a new instance per test with no way to opt out. If you need shared state, you use ',(0,i.jsx)(t.code,{children:"static"}),", making it explicit. Parallel execution catches state problems early instead of hiding them."]}),"\n",(0,i.jsx)(t.h3,{id:"limited-async-support",children:"Limited Async Support"}),"\n",(0,i.jsxs)(t.p,{children:["Older frameworks have a mix of sync and async APIs. You need ",(0,i.jsx)(t.code,{children:"IAsyncLifetime"})," for async setup. Some parts do sync-over-async. TUnit is async everywhere\u2014hooks, assertions, all of it. No deadlocks, clean code throughout."]}),"\n",(0,i.jsx)(t.h3,{id:"poor-aot-support",children:"Poor AOT Support"}),"\n",(0,i.jsx)(t.p,{children:"Heavy runtime reflection doesn't work with Native AOT. TUnit uses source generation, supports AOT from day one, and has proper trimming annotations. Your tests work with Native AOT deployments."}),"\n",(0,i.jsx)(t.h2,{id:"comparison-with-other-frameworks",children:"Comparison with Other Frameworks"}),"\n",(0,i.jsx)(t.h3,{id:"tunit-vs-xunit",children:"TUnit vs xUnit"}),"\n",(0,i.jsx)(t.p,{children:"xUnit and TUnit have a lot in common\u2014neither requires class attributes, both have modern extensible designs. The main differences: TUnit runs parallel by default with better async control, uses source generation for discovery, has a richer hook system instead of constructor/IDisposable patterns, and uses fluent assertions instead of static methods."}),"\n",(0,i.jsx)(t.h3,{id:"tunit-vs-nunit",children:"TUnit vs NUnit"}),"\n",(0,i.jsxs)(t.p,{children:["Both use ",(0,i.jsx)(t.code,{children:"[Test]"})," attributes and have rich assertion libraries. The biggest difference is isolation: TUnit creates a new instance per test, NUnit shares by default. TUnit also defaults to parallel execution (NUnit defaults to sequential), has async assertions (NUnit is sync), and doesn't need the ",(0,i.jsx)(t.code,{children:"[TestFixture]"})," attribute."]}),"\n",(0,i.jsx)(t.h3,{id:"tunit-vs-mstest",children:"TUnit vs MSTest"}),"\n",(0,i.jsxs)(t.p,{children:["Both are Microsoft-backed with good IDE integration. TUnit drops the class attribute requirement (MSTest needs ",(0,i.jsx)(t.code,{children:"[TestClass]"}),"), runs on the modern testing platform, defaults to parallel execution, and has better async support throughout."]}),"\n",(0,i.jsxs)(t.p,{children:["For detailed comparisons, check out ",(0,i.jsx)(t.a,{href:"/docs/comparison/framework-differences",children:"Framework Differences"}),"."]}),"\n",(0,i.jsx)(t.h2,{id:"when-to-choose-tunit",children:"When to Choose TUnit"}),"\n",(0,i.jsx)(t.p,{children:"TUnit is a good fit when performance matters\u2014you have large test suites that need to run fast. It supports .NET Standard 2.0, so it works with .NET Framework and all modern .NET versions. It works great with Native AOT, and shines when you want parallel test execution. If you're starting a new project without legacy constraints, TUnit is worth considering."}),"\n",(0,i.jsx)(t.p,{children:"When might you want alternatives? If you have an existing huge test suite, migration costs might outweigh the benefits. If your team strongly prefers another framework's style, that's a legitimate reason to stick with what works for you. Or if you absolutely need a tool that only works with VSTest, you'll need to use something else."}),"\n",(0,i.jsx)(t.h2,{id:"the-bottom-line",children:"The Bottom Line"}),"\n",(0,i.jsx)(t.p,{children:"TUnit exists because modern .NET deserves a modern testing framework. One that prioritizes performance, isolation, and developer experience without carrying the baggage of legacy compromises."}),"\n",(0,i.jsx)(t.p,{children:"Every decision\u2014async assertions, parallel-by-default, source generation\u2014flows from wanting tests to be fast, isolated, modern, and pleasant to write. Tests should run in parallel, create new instances per test, support async naturally, and minimize boilerplate."}),"\n",(0,i.jsx)(t.p,{children:"If that resonates with you, TUnit is probably a good fit for your project."}),"\n",(0,i.jsx)(t.p,{children:"For migration details, check out:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"/docs/migration/xunit",children:"xUnit Migration"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"/docs/migration/nunit",children:"NUnit Migration"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"/docs/migration/mstest",children:"MSTest Migration"})}),"\n"]})]})}function h(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},8453:(e,t,s)=>{s.d(t,{R:()=>o,x:()=>a});var n=s(6540);const i={},r=n.createContext(i);function o(e){const t=n.useContext(r);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),n.createElement(r.Provider,{value:t},e.children)}}}]);