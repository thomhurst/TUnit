"use strict";(self.webpackChunktunit_docs_site=self.webpackChunktunit_docs_site||[]).push([[1182],{1193:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>m,frontMatter:()=>o,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"customization-extensibility/argument-formatters","title":"Argument Formatters","description":"When writing data-driven tests, especially with custom classes as arguments, the test explorer may only show the class name, making it hard to distinguish test cases.","source":"@site/docs/customization-extensibility/argument-formatters.md","sourceDirName":"customization-extensibility","slug":"/customization-extensibility/argument-formatters","permalink":"/docs/customization-extensibility/argument-formatters","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"docs","previous":{"title":"Data Source Generators","permalink":"/docs/customization-extensibility/data-source-generators"},"next":{"title":"Logging","permalink":"/docs/customization-extensibility/logging"}}');var r=n(4848),a=n(8453);const o={},i="Argument Formatters",c={},l=[];function u(e){const t={admonition:"admonition",br:"br",code:"code",h1:"h1",header:"header",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"argument-formatters",children:"Argument Formatters"})}),"\n",(0,r.jsxs)(t.p,{children:["When writing data-driven tests, especially with custom classes as arguments, the test explorer may only show the class name, making it hard to distinguish test cases.",(0,r.jsx)(t.br,{}),"\n","Argument formatters let you control how arguments are displayed in test names and test explorers."]}),"\n",(0,r.jsxs)(t.p,{children:["If you want control over how injected arguments appear in the test explorer, you can create a class that inherits from ",(0,r.jsx)(t.code,{children:"ArgumentDisplayFormatter"})," and then decorate your test with the ",(0,r.jsx)(t.code,{children:"[ArgumentDisplayFormatter<T>]"})," attribute."]}),"\n",(0,r.jsx)(t.p,{children:"For example:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-csharp",children:'    [Test]\n    [MethodDataSource(nameof(SomeMethod))]\n    [ArgumentDisplayFormatter<SomeClassFormatter>]\n    public async Task Test(SomeClass)\n    {\n        await Assert.That(TestContext.Current!.GetTestDisplayName()).IsEqualTo("A super important test!");\n    }\n'})}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-csharp",children:'public class MyFormatter : ArgumentDisplayFormatter\n{\n    public override bool CanHandle(object? value)\n    {\n        return value is SomeClass;\n    }\n\n    public override string FormatValue(object? value)\n    {\n        var someClass = (SomeClass)value;\n        return $"One: {someClass.One} | Two: {someClass.Two}";\n    }\n}\n'})}),"\n",(0,r.jsx)(t.admonition,{type:"info",children:(0,r.jsxs)(t.p,{children:["You can apply multiple ",(0,r.jsx)(t.code,{children:"[ArgumentDisplayFormatter<T>]"})," attributes if you have different types to format.",(0,r.jsx)(t.br,{}),"\n","The first formatter whose ",(0,r.jsx)(t.code,{children:"CanHandle"})," returns true will be used."]})})]})}function m(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(u,{...e})}):u(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>i});var s=n(6540);const r={},a=s.createContext(r);function o(e){const t=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),s.createElement(a.Provider,{value:t},e.children)}}}]);