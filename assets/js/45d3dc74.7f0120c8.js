"use strict";(self.webpackChunktunit_docs_site=self.webpackChunktunit_docs_site||[]).push([[2787],{9726:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>r,default:()=>d,frontMatter:()=>c,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"advanced/exception-handling","title":"Exception Handling","description":"TUnit provides a comprehensive exception hierarchy to help you understand and handle different types of failures that can occur during test execution. Understanding these exceptions is crucial for debugging test failures and implementing custom error handling.","source":"@site/docs/advanced/exception-handling.md","sourceDirName":"advanced","slug":"/advanced/exception-handling","permalink":"/docs/advanced/exception-handling","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{}}');var o=t(4848),s=t(8453);const c={},r="Exception Handling",a={},l=[{value:"Exception Hierarchy",id:"exception-hierarchy",level:2},{value:"Common Exception Types",id:"common-exception-types",level:2},{value:"Hook Exceptions",id:"hook-exceptions",level:3},{value:"BeforeTestException / AfterTestException",id:"beforetestexception--aftertestexception",level:4},{value:"BeforeClassException / AfterClassException",id:"beforeclassexception--afterclassexception",level:4},{value:"Framework Exceptions",id:"framework-exceptions",level:3},{value:"TestFailedInitializationException",id:"testfailedinitializationexception",level:4},{value:"DependencyConflictException",id:"dependencyconflictexception",level:4},{value:"InconclusiveTestException",id:"inconclusivetestexception",level:4},{value:"Execution Exceptions",id:"execution-exceptions",level:3},{value:"TimeoutException",id:"timeoutexception",level:4},{value:"SkipTestException",id:"skiptestexception",level:4},{value:"Exception Properties and Information",id:"exception-properties-and-information",level:2},{value:"Stack Trace Enhancement",id:"stack-trace-enhancement",level:3},{value:"Context Information",id:"context-information",level:3},{value:"Handling Exceptions in Custom Extensions",id:"handling-exceptions-in-custom-extensions",level:2},{value:"Test Executor Exception Handling",id:"test-executor-exception-handling",level:3},{value:"Hook Executor Exception Handling",id:"hook-executor-exception-handling",level:3},{value:"Best Practices for Exception Handling",id:"best-practices-for-exception-handling",level:2},{value:"1. Use Specific Exceptions",id:"1-use-specific-exceptions",level:3},{value:"2. Preserve Inner Exceptions",id:"2-preserve-inner-exceptions",level:3},{value:"3. Add Contextual Information",id:"3-add-contextual-information",level:3},{value:"4. Handle Async Exceptions Properly",id:"4-handle-async-exceptions-properly",level:3},{value:"5. Use Exception Filters When Appropriate",id:"5-use-exception-filters-when-appropriate",level:3},{value:"Creating Custom Exceptions",id:"creating-custom-exceptions",level:2},{value:"Exception Handling in Test Results",id:"exception-handling-in-test-results",level:2},{value:"Common Scenarios and Solutions",id:"common-scenarios-and-solutions",level:2},{value:"Scenario: Flaky External Service",id:"scenario-flaky-external-service",level:3},{value:"Scenario: Resource Cleanup on Failure",id:"scenario-resource-cleanup-on-failure",level:3},{value:"Scenario: Conditional Test Execution",id:"scenario-conditional-test-execution",level:3},{value:"Summary",id:"summary",level:2}];function p(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"exception-handling",children:"Exception Handling"})}),"\n",(0,o.jsx)(n.p,{children:"TUnit provides a comprehensive exception hierarchy to help you understand and handle different types of failures that can occur during test execution. Understanding these exceptions is crucial for debugging test failures and implementing custom error handling."}),"\n",(0,o.jsx)(n.h2,{id:"exception-hierarchy",children:"Exception Hierarchy"}),"\n",(0,o.jsxs)(n.p,{children:["All TUnit-specific exceptions inherit from ",(0,o.jsx)(n.code,{children:"TUnitException"}),", which extends ",(0,o.jsx)(n.code,{children:"Exception"}),". This allows you to catch all TUnit-related exceptions with a single catch block if needed."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"Exception\n\u2514\u2500\u2500 TUnitException\n    \u251c\u2500\u2500 Hook Exceptions\n    \u2502   \u251c\u2500\u2500 BeforeTestException\n    \u2502   \u251c\u2500\u2500 AfterTestException\n    \u2502   \u251c\u2500\u2500 BeforeClassException\n    \u2502   \u251c\u2500\u2500 AfterClassException\n    \u2502   \u251c\u2500\u2500 BeforeAssemblyException\n    \u2502   \u251c\u2500\u2500 AfterAssemblyException\n    \u2502   \u251c\u2500\u2500 BeforeTestSessionException\n    \u2502   \u2514\u2500\u2500 AfterTestSessionException\n    \u251c\u2500\u2500 Framework Exceptions\n    \u2502   \u251c\u2500\u2500 TestFailedInitializationException\n    \u2502   \u251c\u2500\u2500 DependencyConflictException\n    \u2502   \u251c\u2500\u2500 InconclusiveTestException\n    \u2502   \u2514\u2500\u2500 TestNotFoundException\n    \u2514\u2500\u2500 Execution Exceptions\n        \u251c\u2500\u2500 TimeoutException\n        \u251c\u2500\u2500 SkipTestException\n        \u2514\u2500\u2500 TestExecutionException\n"})}),"\n",(0,o.jsx)(n.h2,{id:"common-exception-types",children:"Common Exception Types"}),"\n",(0,o.jsx)(n.h3,{id:"hook-exceptions",children:"Hook Exceptions"}),"\n",(0,o.jsx)(n.p,{children:"Hook exceptions are thrown when setup or cleanup operations fail. Each hook type has its own exception to help identify where in the test lifecycle the failure occurred."}),"\n",(0,o.jsx)(n.h4,{id:"beforetestexception--aftertestexception",children:"BeforeTestException / AfterTestException"}),"\n",(0,o.jsxs)(n.p,{children:["Thrown when a ",(0,o.jsx)(n.code,{children:"[Before(HookType.Test)]"})," or ",(0,o.jsx)(n.code,{children:"[After(HookType.Test)]"})," hook fails."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:'[Before(HookType.Test)]\npublic async Task TestSetup()\n{\n    // If this throws, it will be wrapped in BeforeTestException\n    await DatabaseConnection.OpenAsync();\n}\n\n[Test]\npublic async Task MyTest()\n{\n    try\n    {\n        // Test code\n    }\n    catch (BeforeTestException ex)\n    {\n        // The setup failed\n        _logger.LogError($"Test setup failed: {ex.InnerException?.Message}");\n        throw;\n    }\n}\n'})}),"\n",(0,o.jsx)(n.h4,{id:"beforeclassexception--afterclassexception",children:"BeforeClassException / AfterClassException"}),"\n",(0,o.jsx)(n.p,{children:"Thrown when class-level hooks fail. These affect all tests in the class."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:"[Before(HookType.Class)]\npublic static async Task ClassSetup()\n{\n    // If this fails, all tests in the class will be marked as failed\n    // with a BeforeClassException\n}\n"})}),"\n",(0,o.jsx)(n.h3,{id:"framework-exceptions",children:"Framework Exceptions"}),"\n",(0,o.jsx)(n.p,{children:"These exceptions indicate problems with test configuration or framework usage."}),"\n",(0,o.jsx)(n.h4,{id:"testfailedinitializationexception",children:"TestFailedInitializationException"}),"\n",(0,o.jsx)(n.p,{children:"Thrown when a test cannot be initialized properly, often due to constructor failures or missing dependencies."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:"public class MyTests\n{\n    private readonly IService _service;\n    \n    public MyTests(IService service)\n    {\n        _service = service ?? throw new ArgumentNullException(nameof(service));\n        // If DI fails to provide service, TestFailedInitializationException is thrown\n    }\n}\n"})}),"\n",(0,o.jsx)(n.h4,{id:"dependencyconflictexception",children:"DependencyConflictException"}),"\n",(0,o.jsx)(n.p,{children:"Thrown when there are circular dependencies or conflicting test dependencies."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:"[Test]\n[DependsOn(nameof(Test2))]\npublic void Test1() { }\n\n[Test]\n[DependsOn(nameof(Test1))] // Circular dependency!\npublic void Test2() { }\n// Results in DependencyConflictException\n"})}),"\n",(0,o.jsx)(n.h4,{id:"inconclusivetestexception",children:"InconclusiveTestException"}),"\n",(0,o.jsx)(n.p,{children:"Used to mark a test as inconclusive when it cannot determine pass/fail status."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:'[Test]\npublic async Task CheckExternalService()\n{\n    var service = await GetExternalServiceStatus();\n    \n    if (service.IsInMaintenanceMode)\n    {\n        throw new InconclusiveTestException(\n            "Cannot test: service is in maintenance mode");\n    }\n    \n    // Continue with actual test\n}\n'})}),"\n",(0,o.jsx)(n.h3,{id:"execution-exceptions",children:"Execution Exceptions"}),"\n",(0,o.jsx)(n.p,{children:"These exceptions relate to test execution behavior."}),"\n",(0,o.jsx)(n.h4,{id:"timeoutexception",children:"TimeoutException"}),"\n",(0,o.jsx)(n.p,{children:"Thrown when a test exceeds its timeout limit."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:"[Test]\n[Timeout(1000)] // 1 second timeout\npublic async Task LongRunningTest()\n{\n    await Task.Delay(2000); // Will throw TimeoutException\n}\n"})}),"\n",(0,o.jsx)(n.h4,{id:"skiptestexception",children:"SkipTestException"}),"\n",(0,o.jsx)(n.p,{children:"Used to dynamically skip a test during execution."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:'[Test]\npublic async Task ConditionalTest()\n{\n    if (!await CheckPreconditions())\n    {\n        throw new SkipTestException("Preconditions not met");\n    }\n    \n    // Test logic\n}\n'})}),"\n",(0,o.jsx)(n.h2,{id:"exception-properties-and-information",children:"Exception Properties and Information"}),"\n",(0,o.jsx)(n.p,{children:"TUnit exceptions provide rich information to help diagnose issues:"}),"\n",(0,o.jsx)(n.h3,{id:"stack-trace-enhancement",children:"Stack Trace Enhancement"}),"\n",(0,o.jsx)(n.p,{children:"Many TUnit exceptions enhance stack traces to provide more relevant information:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:"public class TUnitException : Exception\n{\n    public override string? StackTrace => \n        EnhancedStackTrace ?? base.StackTrace;\n        \n    protected string? EnhancedStackTrace { get; set; }\n}\n"})}),"\n",(0,o.jsx)(n.h3,{id:"context-information",children:"Context Information"}),"\n",(0,o.jsx)(n.p,{children:"Exceptions often include test context information:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:'catch (BeforeTestException ex)\n{\n    Console.WriteLine($"Hook failed for test: {ex.TestContext.TestName}");\n    Console.WriteLine($"In class: {ex.TestContext.TestClass.FullName}");\n    Console.WriteLine($"Hook method: {ex.HookMethod.Name}");\n}\n'})}),"\n",(0,o.jsx)(n.h2,{id:"handling-exceptions-in-custom-extensions",children:"Handling Exceptions in Custom Extensions"}),"\n",(0,o.jsx)(n.p,{children:"When implementing custom test executors or hook executors, proper exception handling is crucial:"}),"\n",(0,o.jsx)(n.h3,{id:"test-executor-exception-handling",children:"Test Executor Exception Handling"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:"public class SafeTestExecutor : ITestExecutor\n{\n    public async Task ExecuteAsync(TestContext context, Func<Task> testBody)\n    {\n        try\n        {\n            await testBody();\n        }\n        catch (TUnitException)\n        {\n            // TUnit exceptions should generally be rethrown\n            throw;\n        }\n        catch (AssertionException)\n        {\n            // Assertion failures should be rethrown\n            throw;\n        }\n        catch (Exception ex)\n        {\n            // Wrap other exceptions with context\n            throw new TestExecutionException(\n                $\"Test '{context.TestName}' failed with unexpected exception\",\n                ex);\n        }\n    }\n}\n"})}),"\n",(0,o.jsx)(n.h3,{id:"hook-executor-exception-handling",children:"Hook Executor Exception Handling"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:'public class LoggingHookExecutor : IHookExecutor\n{\n    private readonly ILogger _logger;\n    \n    public async Task ExecuteAsync(HookContext context, Func<Task> hookBody)\n    {\n        try\n        {\n            await hookBody();\n        }\n        catch (Exception ex)\n        {\n            _logger.LogError(ex, \n                "Hook {HookType} failed for test {TestName}", \n                context.HookType, \n                context.TestContext.TestName);\n                \n            // Wrap in appropriate hook exception\n            throw context.HookType switch\n            {\n                HookType.BeforeTest => new BeforeTestException(ex),\n                HookType.AfterTest => new AfterTestException(ex),\n                HookType.BeforeClass => new BeforeClassException(ex),\n                HookType.AfterClass => new AfterClassException(ex),\n                _ => ex\n            };\n        }\n    }\n}\n'})}),"\n",(0,o.jsx)(n.h2,{id:"best-practices-for-exception-handling",children:"Best Practices for Exception Handling"}),"\n",(0,o.jsx)(n.h3,{id:"1-use-specific-exceptions",children:"1. Use Specific Exceptions"}),"\n",(0,o.jsx)(n.p,{children:"Throw the most specific exception type for your scenario:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:'// Good\nif (resource == null)\n{\n    throw new TestFailedInitializationException(\n        "Required resource not available");\n}\n\n// Less specific\nif (resource == null)\n{\n    throw new Exception("Required resource not available");\n}\n'})}),"\n",(0,o.jsx)(n.h3,{id:"2-preserve-inner-exceptions",children:"2. Preserve Inner Exceptions"}),"\n",(0,o.jsx)(n.p,{children:"Always preserve the original exception as an inner exception:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:'try\n{\n    await DatabaseSetup();\n}\ncatch (SqlException ex)\n{\n    throw new BeforeTestException(\n        "Database setup failed", \n        ex); // Preserve original exception\n}\n'})}),"\n",(0,o.jsx)(n.h3,{id:"3-add-contextual-information",children:"3. Add Contextual Information"}),"\n",(0,o.jsx)(n.p,{children:"Include relevant context in exception messages:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:'throw new TestNotFoundException(\n    $"Test method \'{methodName}\' with parameters " +\n    $"[{string.Join(", ", parameterTypes)}] not found in class \'{className}\'");\n'})}),"\n",(0,o.jsx)(n.h3,{id:"4-handle-async-exceptions-properly",children:"4. Handle Async Exceptions Properly"}),"\n",(0,o.jsx)(n.p,{children:"Be careful with async exception handling:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:'[Test]\npublic async Task AsyncExceptionTest()\n{\n    try\n    {\n        await AsyncOperation();\n    }\n    catch (AggregateException ae)\n    {\n        // Handle aggregate exceptions from parallel operations\n        foreach (var inner in ae.InnerExceptions)\n        {\n            _logger.LogError(inner, "Parallel operation failed");\n        }\n        throw;\n    }\n}\n'})}),"\n",(0,o.jsx)(n.h3,{id:"5-use-exception-filters-when-appropriate",children:"5. Use Exception Filters When Appropriate"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:"try\n{\n    await TestOperation();\n}\ncatch (TUnitException ex) when (ex.InnerException is SqlException)\n{\n    // Handle database-related test failures specifically\n    await CleanupDatabaseState();\n    throw;\n}\n"})}),"\n",(0,o.jsx)(n.h2,{id:"creating-custom-exceptions",children:"Creating Custom Exceptions"}),"\n",(0,o.jsx)(n.p,{children:"If you need to create custom exceptions for your test extensions:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:'public class CustomTestException : TUnitException\n{\n    public string TestCategory { get; }\n    public int ErrorCode { get; }\n    \n    public CustomTestException(\n        string message, \n        string testCategory, \n        int errorCode, \n        Exception? innerException = null) \n        : base(message, innerException)\n    {\n        TestCategory = testCategory;\n        ErrorCode = errorCode;\n    }\n    \n    public override string ToString()\n    {\n        return $"{base.ToString()}\\n" +\n               $"Category: {TestCategory}\\n" +\n               $"Error Code: {ErrorCode}";\n    }\n}\n'})}),"\n",(0,o.jsx)(n.h2,{id:"exception-handling-in-test-results",children:"Exception Handling in Test Results"}),"\n",(0,o.jsx)(n.p,{children:"Understanding how exceptions affect test results:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:"[Test]\npublic async Task ExceptionResultTest()\n{\n    try\n    {\n        await RiskyOperation();\n    }\n    catch (Exception ex)\n    {\n        // You can access the exception in hooks or event receivers\n        // via TestContext.Result.Exception\n        \n        // The test will be marked as Failed\n        // unless it's a SkipTestException (\u2192 Skipped)\n        // or InconclusiveTestException (\u2192 Inconclusive)\n        throw;\n    }\n}\n\n[After(HookType.Test)]\npublic async Task LogTestExceptions()\n{\n    var result = TestContext.Current?.Result;\n    if (result?.Exception != null)\n    {\n        await LogException(result.Exception);\n    }\n}\n"})}),"\n",(0,o.jsx)(n.h2,{id:"common-scenarios-and-solutions",children:"Common Scenarios and Solutions"}),"\n",(0,o.jsx)(n.h3,{id:"scenario-flaky-external-service",children:"Scenario: Flaky External Service"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:'[Test]\n[Retry(3)]\npublic async Task ExternalServiceTest()\n{\n    try\n    {\n        await CallExternalService();\n    }\n    catch (HttpRequestException ex) when (IsTransient(ex))\n    {\n        // Will be retried automatically due to [Retry] attribute\n        throw;\n    }\n    catch (HttpRequestException ex)\n    {\n        // Non-transient failure - skip instead of fail\n        throw new SkipTestException(\n            $"External service unavailable: {ex.Message}");\n    }\n}\n'})}),"\n",(0,o.jsx)(n.h3,{id:"scenario-resource-cleanup-on-failure",children:"Scenario: Resource Cleanup on Failure"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:'[Test]\npublic async Task ResourceTest()\n{\n    IResource? resource = null;\n    try\n    {\n        resource = await AcquireResource();\n        await UseResource(resource);\n    }\n    catch (Exception ex)\n    {\n        // Log the exception with context\n        _logger.LogError(ex, \n            "Test failed with resource {ResourceId}", \n            resource?.Id);\n        throw;\n    }\n    finally\n    {\n        // Ensure cleanup happens even on exception\n        if (resource != null)\n        {\n            await ReleaseResource(resource);\n        }\n    }\n}\n'})}),"\n",(0,o.jsx)(n.h3,{id:"scenario-conditional-test-execution",children:"Scenario: Conditional Test Execution"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:'[Before(HookType.Test)]\npublic async Task CheckEnvironment()\n{\n    if (!IsCorrectEnvironment())\n    {\n        throw new SkipTestException(\n            "Test requires production-like environment");\n    }\n    \n    if (!await CheckDependencies())\n    {\n        throw new TestFailedInitializationException(\n            "Required dependencies not available");\n    }\n}\n'})}),"\n",(0,o.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,o.jsx)(n.p,{children:"TUnit's exception hierarchy provides clear, specific exception types for different failure scenarios. By understanding and properly using these exceptions, you can:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Write more maintainable tests with clear failure reasons"}),"\n",(0,o.jsx)(n.li,{children:"Implement robust error handling in custom extensions"}),"\n",(0,o.jsx)(n.li,{children:"Provide better debugging information when tests fail"}),"\n",(0,o.jsx)(n.li,{children:"Handle different types of failures appropriately"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Remember to always preserve context, use specific exception types, and handle async exceptions properly for the best testing experience."})]})}function d(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(p,{...e})}):p(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>c,x:()=>r});var i=t(6540);const o={},s=i.createContext(o);function c(e){const n=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:c(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);