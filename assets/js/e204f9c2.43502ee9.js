"use strict";(globalThis.webpackChunktunit_docs_site=globalThis.webpackChunktunit_docs_site||[]).push([[5494],{14104(e,n,i){i.r(n),i.d(n,{assets:()=>d,contentTitle:()=>l,default:()=>h,frontMatter:()=>c,metadata:()=>t,toc:()=>u});const t=JSON.parse('{"id":"test-lifecycle/property-injection","title":"Property Injection","description":"TUnit\'s AOT-compatible property injection system makes it easy to initialize properties on your test class with compile-time safety and excellent performance.","source":"@site/docs/test-lifecycle/property-injection.md","sourceDirName":"test-lifecycle","slug":"/test-lifecycle/property-injection","permalink":"/docs/test-lifecycle/property-injection","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"docs","previous":{"title":"Properties","permalink":"/docs/test-lifecycle/properties"},"next":{"title":"Event Subscribing","permalink":"/docs/test-lifecycle/event-subscribing"}}');var s=i(74848),r=i(28453),a=i(11470),o=i(19365);const c={},l="Property Injection",d={},u=[{value:"AOT-Compatible Property Attributes",id:"aot-compatible-property-attributes",level:2},{value:"Async Property Initialization",id:"async-property-initialization",level:2},{value:"Discovery Phase Initialization",id:"discovery-phase-initialization",level:2},{value:"When Discovery Initialization is Needed",id:"when-discovery-initialization-is-needed",level:3},{value:"Using IAsyncDiscoveryInitializer",id:"using-iasyncdiscoveryinitializer",level:3},{value:"Basic Property Injection Examples",id:"basic-property-injection-examples",level:2},{value:"Nested Property Injection",id:"nested-property-injection",level:2},{value:"How It Works",id:"how-it-works",level:3},{value:"Example: Complex Test Infrastructure",id:"example-complex-test-infrastructure",level:3},{value:"Benefits of Nested Property Injection",id:"benefits-of-nested-property-injection",level:3},{value:"Sharing Strategies",id:"sharing-strategies",level:3},{value:"Best Practices",id:"best-practices",level:3},{value:"Advanced Scenarios",id:"advanced-scenarios",level:3},{value:"Conditional Initialization",id:"conditional-initialization",level:4},{value:"Circular Dependencies",id:"circular-dependencies",level:4}];function p(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"property-injection",children:"Property Injection"})}),"\n",(0,s.jsx)(n.p,{children:"TUnit's AOT-compatible property injection system makes it easy to initialize properties on your test class with compile-time safety and excellent performance."}),"\n",(0,s.jsxs)(n.p,{children:["Your properties must be marked with the ",(0,s.jsx)(n.code,{children:"required"})," keyword and then simply place a data attribute on it.\nThe required keyword keeps your code clean and correct. If a property isn't passed in, you'll get a compiler warning, so you know something has gone wrong. It also gets rid of any pesky nullability warnings."]}),"\n",(0,s.jsx)(n.h2,{id:"aot-compatible-property-attributes",children:"AOT-Compatible Property Attributes"}),"\n",(0,s.jsx)(n.p,{children:"Supported attributes for properties in AOT mode:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"MethodDataSource"})," - Data sources via calling a method"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"ClassDataSource<T>"})})," - A data source that injects in T"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"DataSourceGeneratorAttribute"})," - Source-generated data (first item only)"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["For dependency injection with service providers, inherit from ",(0,s.jsx)(n.code,{children:"DependencyInjectionDataSourceAttribute<TScope>"})," to create custom attributes. See ",(0,s.jsx)(n.a,{href:"/docs/test-lifecycle/dependency-injection",children:"Dependency Injection"})," documentation for details."]}),"\n",(0,s.jsx)(n.p,{children:"The AOT system generates strongly-typed property setters at compile time, eliminating reflection overhead and ensuring Native AOT compatibility."}),"\n",(0,s.jsx)(n.h2,{id:"async-property-initialization",children:"Async Property Initialization"}),"\n",(0,s.jsxs)(n.p,{children:["Properties can implement ",(0,s.jsx)(n.code,{children:"IAsyncInitializer"})," for complex setup scenarios with automatic lifecycle management:"]}),"\n",(0,s.jsxs)(n.admonition,{title:"Discovery Phase vs Execution Phase",type:"warning",children:[(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"IAsyncInitializer"})," runs during ",(0,s.jsx)(n.strong,{children:"test execution"}),", not during ",(0,s.jsx)(n.strong,{children:"test discovery"}),"."]}),(0,s.jsx)(n.p,{children:"Test discovery happens when:"}),(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Your IDE loads/reloads the project"}),"\n",(0,s.jsxs)(n.li,{children:["You run ",(0,s.jsx)(n.code,{children:"dotnet run --list-tests"})]}),"\n",(0,s.jsx)(n.li,{children:"CI/CD systems enumerate tests before running them"}),"\n"]}),(0,s.jsxs)(n.p,{children:["During discovery, ",(0,s.jsx)(n.code,{children:"IAsyncInitializer"})," has ",(0,s.jsx)(n.strong,{children:"not yet run"}),", so properties will be uninitialized. If you use ",(0,s.jsx)(n.code,{children:"InstanceMethodDataSource"})," or similar features that access instance properties during discovery, you may get empty data or no tests generated."]}),(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"When you need discovery-time initialization"}),", use ",(0,s.jsx)(n.code,{children:"IAsyncDiscoveryInitializer"})," instead (see ",(0,s.jsx)(n.a,{href:"#discovery-phase-initialization",children:"Discovery Phase Initialization"})," below)."]})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:'using TUnit.Core;\n\nnamespace MyTestProject;\n\npublic class AsyncPropertyExample : IAsyncInitializer, IAsyncDisposable\n{\n    public bool IsInitialized { get; private set; }\n    public string? ConnectionString { get; private set; }\n\n    public async Task InitializeAsync()\n    {\n        await Task.Delay(10); // Simulate async setup\n        ConnectionString = "Server=localhost;Database=test";\n        IsInitialized = true;\n    }\n\n    public async ValueTask DisposeAsync()\n    {\n        await Task.Delay(1); // Cleanup\n        IsInitialized = false;\n        ConnectionString = null;\n    }\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"discovery-phase-initialization",children:"Discovery Phase Initialization"}),"\n",(0,s.jsx)(n.h3,{id:"when-discovery-initialization-is-needed",children:"When Discovery Initialization is Needed"}),"\n",(0,s.jsx)(n.p,{children:"Most tests don't need discovery-time initialization. Discovery-time initialization is only required when:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["You use ",(0,s.jsx)(n.code,{children:"InstanceMethodDataSource"})," and the data source method returns ",(0,s.jsx)(n.strong,{children:"dynamically loaded data"})," (not predefined values)"]}),"\n",(0,s.jsx)(n.li,{children:"The test case enumeration depends on async-loaded data (e.g., querying a database for test cases)"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Performance Note:"})," Discovery happens frequently (IDE reloads, project switches, ",(0,s.jsx)(n.code,{children:"--list-tests"}),"), so discovery-time initialization runs more often than test execution. Avoid expensive operations in ",(0,s.jsx)(n.code,{children:"IAsyncDiscoveryInitializer"})," when possible."]}),"\n",(0,s.jsx)(n.h3,{id:"using-iasyncdiscoveryinitializer",children:"Using IAsyncDiscoveryInitializer"}),"\n",(0,s.jsxs)(n.p,{children:["When you need data available during discovery, implement ",(0,s.jsx)(n.code,{children:"IAsyncDiscoveryInitializer"})," instead of ",(0,s.jsx)(n.code,{children:"IAsyncInitializer"}),":"]}),"\n","\n",(0,s.jsxs)(a.A,{children:[(0,s.jsx)(o.A,{value:"wrong",label:"\u274c Wrong - Data not available during discovery",default:!0,children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"// This fixture's data won't be available during discovery\npublic class TestDataFixture : IAsyncInitializer, IAsyncDisposable\n{\n    private List<string> _testCases = [];\n\n    public async Task InitializeAsync()\n    {\n        // This runs during EXECUTION, not DISCOVERY\n        _testCases = await LoadTestCasesFromDatabaseAsync();\n    }\n\n    // This will return empty list during discovery!\n    public IEnumerable<string> GetTestCases() => _testCases;\n\n    public async ValueTask DisposeAsync()\n    {\n        _testCases.Clear();\n    }\n}\n\npublic class MyTests\n{\n    [ClassDataSource<TestDataFixture>(Shared = SharedType.PerClass)]\n    public required TestDataFixture Fixture { get; init; }\n\n    // During discovery, Fixture.GetTestCases() returns empty list\n    // Result: No tests are generated!\n    public IEnumerable<string> TestCases => Fixture.GetTestCases();\n\n    [Test]\n    [InstanceMethodDataSource(nameof(TestCases))]\n    public async Task MyTest(string testCase)\n    {\n        // This test is never created because TestCases was empty during discovery\n        await Assert.That(testCase).IsNotNullOrEmpty();\n    }\n}\n"})})}),(0,s.jsx)(o.A,{value:"correct",label:"\u2705 Correct - Uses IAsyncDiscoveryInitializer",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"// This fixture's data IS available during discovery\npublic class TestDataFixture : IAsyncDiscoveryInitializer, IAsyncDisposable\n{\n    private List<string> _testCases = [];\n\n    public async Task InitializeAsync()\n    {\n        // This runs during DISCOVERY, before test enumeration\n        _testCases = await LoadTestCasesFromDatabaseAsync();\n    }\n\n    // This returns populated list during discovery!\n    public IEnumerable<string> GetTestCases() => _testCases;\n\n    public async ValueTask DisposeAsync()\n    {\n        _testCases.Clear();\n    }\n}\n\npublic class MyTests\n{\n    [ClassDataSource<TestDataFixture>(Shared = SharedType.PerClass)]\n    public required TestDataFixture Fixture { get; init; }\n\n    // During discovery, Fixture is already initialized\n    // Result: Tests are generated successfully!\n    public IEnumerable<string> TestCases => Fixture.GetTestCases();\n\n    [Test]\n    [InstanceMethodDataSource(nameof(TestCases))]\n    public async Task MyTest(string testCase)\n    {\n        // This test IS created with each test case from the fixture\n        await Assert.That(testCase).IsNotNullOrEmpty();\n    }\n}\n"})})}),(0,s.jsx)(o.A,{value:"best",label:"\u2705 Best - Predefined data without discovery initialization",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:'// Best approach: Predefined test case IDs, expensive initialization during execution only\npublic class TestDataFixture : IAsyncInitializer, IAsyncDisposable\n{\n    // Test case IDs are predefined - no initialization needed for discovery\n    private static readonly string[] PredefinedTestCases = ["Case1", "Case2", "Case3"];\n\n    private DockerContainer? _container;\n\n    public async Task InitializeAsync()\n    {\n        // Expensive initialization runs during EXECUTION only\n        _container = await StartDockerContainerAsync();\n    }\n\n    // Returns predefined IDs - works during discovery without initialization\n    public IEnumerable<string> GetTestCaseIds() => PredefinedTestCases;\n\n    public async ValueTask DisposeAsync()\n    {\n        if (_container != null)\n            await _container.DisposeAsync();\n    }\n}\n\npublic class MyTests\n{\n    [ClassDataSource<TestDataFixture>(Shared = SharedType.PerClass)]\n    public required TestDataFixture Fixture { get; init; }\n\n    // Returns predefined IDs - no initialization required during discovery\n    public IEnumerable<string> TestCases => Fixture.GetTestCaseIds();\n\n    [Test]\n    [InstanceMethodDataSource(nameof(TestCases))]\n    public async Task MyTest(string testCaseId)\n    {\n        // Fixture IS initialized by the time the test runs\n        // Can now use the expensive resources (Docker container, etc.)\n        await Assert.That(testCaseId).IsNotNullOrEmpty();\n    }\n}\n'})})})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Recommendation:"}),' Prefer the "predefined data" approach when possible. This avoids expensive initialization during discovery, which happens frequently (IDE reloads, ',(0,s.jsx)(n.code,{children:"--list-tests"}),", etc.)."]}),"\n",(0,s.jsxs)(n.p,{children:["For more troubleshooting, see ",(0,s.jsx)(n.a,{href:"/docs/troubleshooting#test-discovery-issues",children:"Test Discovery Issues"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"basic-property-injection-examples",children:"Basic Property Injection Examples"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:'using TUnit.Core;\n\nnamespace MyTestProject;\n\npublic class PropertySetterTests\n{\n    // Static method data source injection\n    [MethodDataSource(nameof(GetMethodData))]\n    public required string Property2 { get; init; }\n\n    // Class-based data source injection\n    [ClassDataSource<InnerModel>]\n    public required InnerModel Property3 { get; init; }\n\n    // Globally shared data source\n    [ClassDataSource<InnerModel>(Shared = SharedType.PerTestSession)]\n    public required InnerModel Property4 { get; init; }\n\n    // Class-scoped shared data source\n    [ClassDataSource<InnerModel>(Shared = SharedType.PerClass)]\n    public required InnerModel Property5 { get; init; }\n\n    // Keyed shared data source\n    [ClassDataSource<InnerModel>(Shared = SharedType.Keyed, Key = "Key")]\n    public required InnerModel Property6 { get; init; }\n\n    // Source-generated data injection\n    [DataSourceGeneratorTests.AutoFixtureGenerator<string>]\n    public required string Property7 { get; init; }\n\n    // Async initialization example (IAsyncInitializer)\n    [ClassDataSource<AsyncPropertyExample>]\n    public required AsyncPropertyExample AsyncService { get; init; }\n\n    [Test]\n    public async Task Test()\n    {\n        // All properties are automatically initialized before this test runs\n        await Assert.That(Property2).IsNotNull();\n        await Assert.That(Property3).IsNotNull();\n        await Assert.That(AsyncService.IsInitialized).IsTrue();\n\n        Console.WriteLine($"Property7: {Property7}");\n    }\n\n    // Static data source method for Property2 - returns a single value for property injection\n    public static string GetMethodData() => "method_data_value";\n}\n\n// Example model for ClassDataSource\npublic class InnerModel\n{\n    public string Name { get; set; } = "";\n    public int Value { get; set; }\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"nested-property-injection",children:"Nested Property Injection"}),"\n",(0,s.jsx)(n.p,{children:"One of TUnit's most powerful features is nested property injection with automatic initialization. This allows you to inject objects into other objects created via data sources, enabling advanced test orchestration with relatively simple code. TUnit handles all the complex aspects like initialization order and object lifetimes."}),"\n",(0,s.jsx)(n.h3,{id:"how-it-works",children:"How It Works"}),"\n",(0,s.jsx)(n.p,{children:"When you use property injection with data source attributes, those injected objects can themselves have injected properties. TUnit will:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Resolve the entire dependency graph"}),"\n",(0,s.jsx)(n.li,{children:"Create objects in the correct order"}),"\n",(0,s.jsxs)(n.li,{children:["Initialize them (if they implement ",(0,s.jsx)(n.code,{children:"IAsyncInitializer"}),")"]}),"\n",(0,s.jsx)(n.li,{children:"Inject them into parent objects"}),"\n",(0,s.jsxs)(n.li,{children:["Dispose of them when appropriate (if they implement ",(0,s.jsx)(n.code,{children:"IAsyncDisposable"}),")"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"example-complex-test-infrastructure",children:"Example: Complex Test Infrastructure"}),"\n",(0,s.jsx)(n.p,{children:"Here's a comprehensive example showing how to orchestrate multiple test containers and a web application:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:'// In-memory SQL container that auto-starts and stops\npublic class InMemorySql : IAsyncInitializer, IAsyncDisposable\n{\n    private TestcontainersContainer? _container;\n\n    public TestcontainersContainer Container => _container\n        ?? throw new InvalidOperationException("Container not initialized");\n\n    public async Task InitializeAsync()\n    {\n        _container = new TestcontainersBuilder<TestcontainersContainer>()\n            .WithImage("postgres:latest")\n            .WithEnvironment("POSTGRES_PASSWORD", "password")\n            .Build();\n\n        await _container.StartAsync();\n    }\n\n    public async ValueTask DisposeAsync()\n    {\n        if (_container != null)\n        {\n            await _container.DisposeAsync();\n        }\n    }\n}\n\n// Redis container with similar pattern\npublic class InMemoryRedis : IAsyncInitializer, IAsyncDisposable\n{\n    private TestcontainersContainer? _container;\n\n    public TestcontainersContainer Container => _container\n        ?? throw new InvalidOperationException("Container not initialized");\n\n    public async Task InitializeAsync()\n    {\n        _container = new TestcontainersBuilder<TestcontainersContainer>()\n            .WithImage("redis:latest")\n            .Build();\n\n        await _container.StartAsync();\n    }\n\n    public async ValueTask DisposeAsync()\n    {\n        if (_container != null)\n        {\n            await _container.DisposeAsync();\n        }\n    }\n}\n\n// Message bus container\npublic class InMemoryMessageBus : IAsyncInitializer, IAsyncDisposable\n{\n    private TestcontainersContainer? _container;\n\n    public TestcontainersContainer Container => _container\n        ?? throw new InvalidOperationException("Container not initialized");\n\n    public async Task InitializeAsync()\n    {\n        _container = new TestcontainersBuilder<TestcontainersContainer>()\n            .WithImage("rabbitmq:3-management")\n            .Build();\n\n        await _container.StartAsync();\n    }\n\n    public async ValueTask DisposeAsync()\n    {\n        if (_container != null)\n        {\n            await _container.DisposeAsync();\n        }\n    }\n}\n\n// UI component that depends on the message bus\npublic class MessageBusUserInterface : IAsyncInitializer, IAsyncDisposable\n{\n    private TestcontainersContainer? _container;\n\n    // Inject the message bus dependency - shared per test session\n    [ClassDataSource<InMemoryMessageBus>(Shared = SharedType.PerTestSession)]\n    public required InMemoryMessageBus MessageBus { get; init; }\n\n    public TestcontainersContainer Container => _container\n        ?? throw new InvalidOperationException("Container not initialized");\n\n    public async Task InitializeAsync()\n    {\n        // The MessageBus property is already initialized when this runs!\n        _container = new MessageBusUIContainerBuilder()\n            .WithConnectionString(MessageBus.Container.GetConnectionString())\n            .Build();\n\n        await _container.StartAsync();\n    }\n\n    public async ValueTask DisposeAsync()\n    {\n        if (_container != null)\n        {\n            await _container.DisposeAsync();\n        }\n    }\n}\n\n// Web application factory that depends on multiple services\npublic class InMemoryWebApplicationFactory : WebApplicationFactory<Program>, IAsyncInitializer\n{\n    // Inject all required infrastructure - all shared per test session\n    [ClassDataSource<InMemorySql>(Shared = SharedType.PerTestSession)]\n    public required InMemorySql Sql { get; init; }\n\n    [ClassDataSource<InMemoryRedis>(Shared = SharedType.PerTestSession)]\n    public required InMemoryRedis Redis { get; init; }\n\n    [ClassDataSource<InMemoryMessageBus>(Shared = SharedType.PerTestSession)]\n    public required InMemoryMessageBus MessageBus { get; init; }\n\n    public Task InitializeAsync()\n    {\n        // Force server creation to validate configuration\n        _ = Server;\n        return Task.CompletedTask;\n    }\n\n    protected override void ConfigureWebHost(IWebHostBuilder builder)\n    {\n        builder.ConfigureAppConfiguration((context, configBuilder) =>\n        {\n            // All injected properties are already initialized!\n            configBuilder.AddInMemoryCollection(new Dictionary<string, string?>\n            {\n                { "MessageBus:ConnectionString", MessageBus.Container.GetConnectionString() },\n                { "Redis:ConnectionString", Redis.Container.GetConnectionString() },\n                { "PostgreSql:ConnectionString", Sql.Container.GetConnectionString() }\n            });\n        });\n    }\n}\n\n// Your test class - clean and simple!\npublic class IntegrationTests\n{\n    // Just inject what you need - TUnit handles the entire dependency graph\n    [ClassDataSource<InMemoryWebApplicationFactory>]\n    public required InMemoryWebApplicationFactory WebApplicationFactory { get; init; }\n\n    [ClassDataSource<MessageBusUserInterface>]\n    public required MessageBusUserInterface MessageBusUI { get; init; }\n\n    [Test]\n    public async Task Full_Integration_Test()\n    {\n        // Everything is initialized in the correct order!\n        var client = WebApplicationFactory.CreateClient();\n\n        // Test your application with all infrastructure running\n        var response = await client.GetAsync("/api/products");\n        await Assert.That(response.IsSuccessStatusCode).IsTrue();\n\n        // The MessageBusUI shares the same MessageBus instance as the WebApplicationFactory\n        // because they both use SharedType.PerTestSession\n    }\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"benefits-of-nested-property-injection",children:"Benefits of Nested Property Injection"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Simplified Test Setup"}),": You only need to declare what you need; TUnit handles the complex orchestration"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Automatic Lifecycle Management"}),": Objects are initialized in dependency order and disposed in reverse order"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Shared Resources"}),": Use ",(0,s.jsx)(n.code,{children:"SharedType"})," to control object lifetime and reuse expensive resources"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Type Safety"}),": Everything is strongly typed with compile-time checking"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Clean Test Code"}),": Your tests focus on testing, not on infrastructure setup"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"sharing-strategies",children:"Sharing Strategies"}),"\n",(0,s.jsxs)(n.p,{children:["When using nested property injection, the ",(0,s.jsx)(n.code,{children:"Shared"})," parameter becomes crucial:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"SharedType.PerTestSession"})}),": Single instance for the entire test run - ideal for expensive resources like containers"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"SharedType.PerAssembly"})}),": Single instance shared for every test in the same assembly as itself."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"SharedType.PerClass"})}),": One instance per test class"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"SharedType.Keyed"})}),": Share instances based on a key value"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"SharedType.None"})}),": New instance for each injection point (default)"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"best-practices",children:"Best Practices"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Use Appropriate Sharing"}),": Share expensive resources like test containers using ",(0,s.jsx)(n.code,{children:"PerTestSession"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Implement IAsyncInitializer"}),": For complex setup that requires async operations"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Implement IAsyncDisposable"}),": Ensure proper cleanup of resources"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Order Independence"}),": Don't rely on initialization order between sibling properties"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Error Handling"}),": Initialization failures will fail the test with clear error messages"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"advanced-scenarios",children:"Advanced Scenarios"}),"\n",(0,s.jsx)(n.h4,{id:"conditional-initialization",children:"Conditional Initialization"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"public class ConditionalService : IAsyncInitializer\n{\n    [ClassDataSource<DatabaseService>(Shared = SharedType.PerTestSession)]\n    public required DatabaseService Database { get; init; }\n\n    public async Task InitializeAsync()\n    {\n        if (await Database.RequiresMigration())\n        {\n            await Database.MigrateAsync();\n        }\n    }\n}\n"})}),"\n",(0,s.jsx)(n.h4,{id:"circular-dependencies",children:"Circular Dependencies"}),"\n",(0,s.jsx)(n.p,{children:"TUnit will detect and report circular dependencies:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"public class ServiceA : IAsyncInitializer\n{\n    [ClassDataSource<ServiceB>]\n    public required ServiceB B { get; init; } // This will fail!\n}\n\npublic class ServiceB : IAsyncInitializer\n{\n    [ClassDataSource<ServiceA>]\n    public required ServiceA A { get; init; } // Circular dependency!\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"This powerful feature makes complex test orchestration simple and maintainable, allowing you to focus on writing tests rather than managing test infrastructure!"})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(p,{...e})}):p(e)}},19365(e,n,i){i.d(n,{A:()=>a});i(96540);var t=i(34164);const s="tabItem_Ymn6";var r=i(74848);function a({children:e,hidden:n,className:i}){return(0,r.jsx)("div",{role:"tabpanel",className:(0,t.A)(s,i),hidden:n,children:e})}},11470(e,n,i){i.d(n,{A:()=>S});var t=i(96540),s=i(34164),r=i(17559),a=i(23104),o=i(56347),c=i(205),l=i(57485),d=i(31682),u=i(70679);function p(e){return t.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,t.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function h(e){const{values:n,children:i}=e;return(0,t.useMemo)((()=>{const e=n??function(e){return p(e).map((({props:{value:e,label:n,attributes:i,default:t}})=>({value:e,label:n,attributes:i,default:t})))}(i);return function(e){const n=(0,d.XI)(e,((e,n)=>e.value===n.value));if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[n,i])}function y({value:e,tabValues:n}){return n.some((n=>n.value===e))}function g({queryString:e=!1,groupId:n}){const i=(0,o.W6)(),s=function({queryString:e=!1,groupId:n}){if("string"==typeof e)return e;if(!1===e)return null;if(!0===e&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:e,groupId:n});return[(0,l.aZ)(s),(0,t.useCallback)((e=>{if(!s)return;const n=new URLSearchParams(i.location.search);n.set(s,e),i.replace({...i.location,search:n.toString()})}),[s,i])]}function b(e){const{defaultValue:n,queryString:i=!1,groupId:s}=e,r=h(e),[a,o]=(0,t.useState)((()=>function({defaultValue:e,tabValues:n}){if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(e){if(!y({value:e,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${e}" but none of its children has the corresponding value. Available values are: ${n.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return e}const i=n.find((e=>e.default))??n[0];if(!i)throw new Error("Unexpected error: 0 tabValues");return i.value}({defaultValue:n,tabValues:r}))),[l,d]=g({queryString:i,groupId:s}),[p,b]=function({groupId:e}){const n=function(e){return e?`docusaurus.tab.${e}`:null}(e),[i,s]=(0,u.Dv)(n);return[i,(0,t.useCallback)((e=>{n&&s.set(e)}),[n,s])]}({groupId:s}),m=(()=>{const e=l??p;return y({value:e,tabValues:r})?e:null})();(0,c.A)((()=>{m&&o(m)}),[m]);return{selectedValue:a,selectValue:(0,t.useCallback)((e=>{if(!y({value:e,tabValues:r}))throw new Error(`Can't select invalid tab value=${e}`);o(e),d(e),b(e)}),[d,b,r]),tabValues:r}}var m=i(92303);const x="tabList__CuJ",j="tabItem_LNqP";var I=i(74848);function v({className:e,block:n,selectedValue:i,selectValue:t,tabValues:r}){const o=[],{blockElementScrollPositionUntilNextRender:c}=(0,a.a_)(),l=e=>{const n=e.currentTarget,s=o.indexOf(n),a=r[s].value;a!==i&&(c(n),t(a))},d=e=>{let n=null;switch(e.key){case"Enter":l(e);break;case"ArrowRight":{const i=o.indexOf(e.currentTarget)+1;n=o[i]??o[0];break}case"ArrowLeft":{const i=o.indexOf(e.currentTarget)-1;n=o[i]??o[o.length-1];break}}n?.focus()};return(0,I.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,s.A)("tabs",{"tabs--block":n},e),children:r.map((({value:e,label:n,attributes:t})=>(0,I.jsx)("li",{role:"tab",tabIndex:i===e?0:-1,"aria-selected":i===e,ref:e=>{o.push(e)},onKeyDown:d,onClick:l,...t,className:(0,s.A)("tabs__item",j,t?.className,{"tabs__item--active":i===e}),children:n??e},e)))})}function f({lazy:e,children:n,selectedValue:i}){const r=(Array.isArray(n)?n:[n]).filter(Boolean);if(e){const e=r.find((e=>e.props.value===i));return e?(0,t.cloneElement)(e,{className:(0,s.A)("margin-top--md",e.props.className)}):null}return(0,I.jsx)("div",{className:"margin-top--md",children:r.map(((e,n)=>(0,t.cloneElement)(e,{key:n,hidden:e.props.value!==i})))})}function T(e){const n=b(e);return(0,I.jsxs)("div",{className:(0,s.A)(r.G.tabs.container,"tabs-container",x),children:[(0,I.jsx)(v,{...n,...e}),(0,I.jsx)(f,{...n,...e})]})}function S(e){const n=(0,m.A)();return(0,I.jsx)(T,{...e,children:p(e.children)},String(n))}},28453(e,n,i){i.d(n,{R:()=>a,x:()=>o});var t=i(96540);const s={},r=t.createContext(s);function a(e){const n=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);