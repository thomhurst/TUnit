"use strict";(self.webpackChunktunit_docs_site=self.webpackChunktunit_docs_site||[]).push([[1753],{3094:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"tutorial-assertions/extensibility/chaining-and-converting","title":"Chaining and Converting","description":"We may want to chain assertions together that change the type of object being asserted, to keep the assertions reading clear and concise, and not having to declare more variables and more boiler-plate assert calls.","source":"@site/docs/tutorial-assertions/extensibility/chaining-and-converting.md","sourceDirName":"tutorial-assertions/extensibility","slug":"/tutorial-assertions/extensibility/chaining-and-converting","permalink":"/docs/tutorial-assertions/extensibility/chaining-and-converting","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"Custom Assertions","permalink":"/docs/tutorial-assertions/extensibility/custom-assertions"},"next":{"title":"Returning Data via await","permalink":"/docs/tutorial-assertions/extensibility/returning-items-from-await"}}');var i=t(4848),o=t(8453);const r={sidebar_position:2},a="Chaining and Converting",l={},c=[];function d(e){const n={code:"code",h1:"h1",header:"header",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"chaining-and-converting",children:"Chaining and Converting"})}),"\n",(0,i.jsx)(n.p,{children:"We may want to chain assertions together that change the type of object being asserted, to keep the assertions reading clear and concise, and not having to declare more variables and more boiler-plate assert calls."}),"\n",(0,i.jsx)(n.p,{children:"This is possible in TUnit."}),"\n",(0,i.jsx)(n.p,{children:"For example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:'        await Assert.That(response)\n            .IsProblemDetails()\n            .And\n            .HasTitle("Invalid Authentication Token")\n            .And\n            .HasDetail("No token provided");\n'})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"response"})," object initially passed in is a ",(0,i.jsx)(n.code,{children:"HttpResponseMessage"}),", but then after we assert it's a ",(0,i.jsx)(n.code,{children:"ProblemDetails"})," object, the chain has changed to that type so that we can further assert with methods specific to ",(0,i.jsx)(n.code,{children:"ProblemDetails"})," instead of ",(0,i.jsx)(n.code,{children:"HttpResponseMessage"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"This involves a few steps and specific types to work."}),"\n",(0,i.jsxs)(n.p,{children:["Firstly, you need to create a custom assert condition that inherits from ",(0,i.jsx)(n.code,{children:"ConvertToAssertCondition<TFromType, TToType>"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"In the example above, that'd look like:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:'public class HttpResponseIsProblemDetailsAssertCondition() : ConvertToAssertCondition<HttpResponseMessage, ProblemDetails>()\n{\n    protected override string GetExpectation()\n    {\n        return $"HTTP response to be in the format of a Problem Details object";\n    }\n\n    public override async ValueTask<(AssertionResult, TToType?)> ConvertValue(HttpResponseMessage value)\n    {\n        var content = await value.Content.ReadFromJsonAsync<ProblemDetails>();\n\n        return \n        (\n            AssertionResult.FailIf(content is null, $"response body is not Problem Details"), \n            content\n        );\n    }\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"As you can see, this returns two objects (via a Tuple) - An assertion result, so we know if it's passed or failed the conversion, and then the actual converted object."}),"\n",(0,i.jsxs)(n.p,{children:["You then need to create an extension method to register this assert condition on your data.\nInstead of calling ",(0,i.jsx)(n.code,{children:"source.RegisterAssertion(...)"})," like we do on standard assertions, we instead call ",(0,i.jsx)(n.code,{children:"source.RegisterConversionAssertion(...)"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"Again, for the above example, that'd look like:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:"public static class HttpResponseAssertionExtensions\n{\n    public static InvokableValueAssertionBuilder<ProblemDetails> IsProblemDetails(this IValueSource<HttpResponseMessage> valueSource)\n    {\n        return valueSource.RegisterConversionAssertion(new HttpResponseIsProblemDetailsAssertCondition());\n    }\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"That's it!"}),"\n",(0,i.jsxs)(n.p,{children:["Now any assertions built for the ",(0,i.jsx)(n.code,{children:"ProblemDetails"})," type will work off of that same chain."]}),"\n",(0,i.jsx)(n.p,{children:"E.g."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:'public static class ProblemDetailsAssertionExtensions\n{\n    public static InvokableValueAssertionBuilder<ProblemDetails> HasTitle(this IValueSource<ProblemDetails> valueSource,\n        string title, [CallerArgumentExpression("title")] string? titleExpression = null)\n    {\n        return valueSource.RegisterAssertion(new ProblemDetailsHasTitleAssertCondition(title), [titleExpression]);\n    }\n    \n    public static InvokableValueAssertionBuilder<ProblemDetails> HasDetail(this IValueSource<ProblemDetails> valueSource,\n        string detail, [CallerArgumentExpression("detail")] string? detailExpression = null)\n    {\n        return valueSource.RegisterAssertion(new ProblemDetailsHasDetailAssertCondition(detail), [detailExpression]);\n    }\n}\n'})})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>a});var s=t(6540);const i={},o=s.createContext(i);function r(e){const n=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),s.createElement(o.Provider,{value:n},e.children)}}}]);