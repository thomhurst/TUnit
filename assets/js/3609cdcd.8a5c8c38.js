"use strict";(self.webpackChunktunit_docs_site=self.webpackChunktunit_docs_site||[]).push([[9069],{1741:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>d,frontMatter:()=>r,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"tutorial-basics/matrix-tests","title":"Matrix Tests","description":"The Matrix data source is a way to specify different arguments per parameter, and then generate every possible combination of all of those arguments.","source":"@site/docs/tutorial-basics/matrix-tests.md","sourceDirName":"tutorial-basics","slug":"/tutorial-basics/matrix-tests","permalink":"/docs/tutorial-basics/matrix-tests","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"sidebar_position":6},"sidebar":"tutorialSidebar","previous":{"title":"Method Data Sources","permalink":"/docs/tutorial-basics/method-data-source"},"next":{"title":"Things to know","permalink":"/docs/tutorial-basics/things-to-know"}}');var i=t(4848),a=t(8453);const r={sidebar_position:6},l="Matrix Tests",o={},c=[{value:"Matrix Range",id:"matrix-range",level:2},{value:"Matrix Method",id:"matrix-method",level:2},{value:"Matrix Exclusions",id:"matrix-exclusions",level:2}];function u(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"matrix-tests",children:"Matrix Tests"})}),"\n",(0,i.jsx)(n.p,{children:"The Matrix data source is a way to specify different arguments per parameter, and then generate every possible combination of all of those arguments."}),"\n",(0,i.jsx)(n.p,{children:"Now bear in mind, that as your number of arguments and/or parameters increase, that the number of test cases will grow exponentially. This means you could very quickly get into the territory of generating thousands of test cases. So use it with caution."}),"\n",(0,i.jsxs)(n.p,{children:["For our arguments, we'll add a ",(0,i.jsx)(n.code,{children:"[Matrix]"})," attribute. Instead of this being added to the test method, it's added to the parameters themselves."]}),"\n",(0,i.jsxs)(n.p,{children:["And for the test method, we'll add a ",(0,i.jsx)(n.code,{children:"[MatrixDataSource]"})," attribute which contains the logic to extract out all the data from those parameter Matrix attributes."]}),"\n",(0,i.jsx)(n.p,{children:"Here's an example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:"using TUnit.Assertions;\nusing TUnit.Assertions.Extensions;\nusing TUnit.Assertions.Extensions.Is;\nusing TUnit.Core;\n\nnamespace MyTestProject;\n\npublic class MyTestClass\n{\n    [Test]\n    [MatrixDataSource]\n    public async Task MyTest(\n        [Matrix(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)] int value1,\n        [Matrix(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)] int value2\n        )\n    {\n        var result = Add(value1, value2);\n\n        await Assert.That(result).IsPositive();\n    }\n\n    private int Add(int x, int y)\n    {\n        return x + y;\n    }\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"That will generate 100 test cases. 10 different values for value1, and 10 different values for value2. 10*10 is 100."}),"\n",(0,i.jsx)(n.h2,{id:"matrix-range",children:"Matrix Range"}),"\n",(0,i.jsxs)(n.p,{children:["You can also use the ",(0,i.jsx)(n.code,{children:"[MatrixRange<T>]"})," for numerical types. It will generated a range between the minimum and maximum, with an optional step parameter to define how far to step between each value. By default, this is 1."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:"using TUnit.Assertions;\nusing TUnit.Assertions.Extensions;\nusing TUnit.Assertions.Extensions.Is;\nusing TUnit.Core;\n\nnamespace MyTestProject;\n\npublic class MyTestClass\n{\n    [Test]\n    [MatrixDataSource]\n    public async Task MyTest(\n        [MatrixRange<int>(1, 10)] int value1,\n        [MatrixRange<int>(1, 10)] int value2\n        )\n    {\n        var result = Add(value1, value2);\n\n        await Assert.That(result).IsPositive();\n    }\n\n    private int Add(int x, int y)\n    {\n        return x + y;\n    }\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"matrix-method",children:"Matrix Method"}),"\n",(0,i.jsxs)(n.p,{children:["You can also specify a method that will return an ",(0,i.jsx)(n.code,{children:"IEnumerable<T>"})," of values."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:"using TUnit.Assertions;\nusing TUnit.Assertions.Extensions;\nusing TUnit.Assertions.Extensions.Is;\nusing TUnit.Core;\n\nnamespace MyTestProject;\n\npublic class MyTestClass\n{\n    [Test]\n    [MatrixDataSource]\n    public async Task MyTest(\n        [MatrixRange<int>(1, 10)] int value1,\n        [MatrixMethod(nameof(Numbers))] int value2\n        )\n    {\n        var result = Add(value1, value2);\n\n        await Assert.That(result).IsPositive();\n    }\n\n    private int Add(int x, int y)\n    {\n        return x + y;\n    }\n\n    private IEnumerable<int> Numbers()\n    {\n        yield return 1;\n        yield return 2;\n        yield return 3;\n        yield return 4;\n        yield return 5;\n        yield return 6;\n        yield return 7;\n        yield return 8;\n        yield return 9;\n        yield return 10;\n    }\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"matrix-exclusions",children:"Matrix Exclusions"}),"\n",(0,i.jsxs)(n.p,{children:["You can also add a ",(0,i.jsx)(n.code,{children:"[MatrixExclusion(...)]"})," attribute to your tests.\nThis works similar to the ",(0,i.jsx)(n.code,{children:"[Arguments(...)]"})," attribute, and if objects match a generated matrix test case, it'll be ignored."]}),"\n",(0,i.jsxs)(n.p,{children:["This helps you exclude specific one-off scenarios without having to complicate your tests with ",(0,i.jsx)(n.code,{children:"if"})," conditions."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:"using TUnit.Assertions;\nusing TUnit.Assertions.Extensions;\nusing TUnit.Assertions.Extensions.Is;\nusing TUnit.Core;\n\nnamespace MyTestProject;\n\npublic class MyTestClass\n{\n    [Test]\n    [MatrixDataSource]\n    [MatrixExclusion(1, 1)]\n    [MatrixExclusion(2, 2)]\n    [MatrixExclusion(3, 3)]\n    public async Task MyTest(\n        [MatrixRange<int>(1, 3)] int value1,\n        [MatrixRange<int>(1, 3)] int value2\n        )\n    {\n        ...\n    }\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"Whereas the above Matrix would usually generate:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"1, 1"}),"\n",(0,i.jsx)(n.li,{children:"1, 2"}),"\n",(0,i.jsx)(n.li,{children:"1, 3"}),"\n",(0,i.jsx)(n.li,{children:"2, 1"}),"\n",(0,i.jsx)(n.li,{children:"2, 2"}),"\n",(0,i.jsx)(n.li,{children:"2, 3"}),"\n",(0,i.jsx)(n.li,{children:"3, 1"}),"\n",(0,i.jsx)(n.li,{children:"3, 2"}),"\n",(0,i.jsx)(n.li,{children:"3, 3"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Because of the exclusion attributes, it'll only generate:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"1, 2"}),"\n",(0,i.jsx)(n.li,{children:"1, 3"}),"\n",(0,i.jsx)(n.li,{children:"2, 1"}),"\n",(0,i.jsx)(n.li,{children:"2, 3"}),"\n",(0,i.jsx)(n.li,{children:"3, 1"}),"\n",(0,i.jsx)(n.li,{children:"3, 2"}),"\n"]})]})}function d(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(u,{...e})}):u(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>l});var s=t(6540);const i={},a=s.createContext(i);function r(e){const n=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);