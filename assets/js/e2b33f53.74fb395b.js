"use strict";(self.webpackChunktunit_docs_site=self.webpackChunktunit_docs_site||[]).push([[8528],{8034:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>a,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"assertions/extensibility/extensibility-returning-items-from-await","title":"Returning Data via await","description":"Sometimes, you may want your assertion to return a value, such as an item found in a collection, so you can use it in further assertions or logic.","source":"@site/docs/assertions/extensibility/extensibility-returning-items-from-await.md","sourceDirName":"assertions/extensibility","slug":"/assertions/extensibility/extensibility-returning-items-from-await","permalink":"/docs/assertions/extensibility/extensibility-returning-items-from-await","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"docs","previous":{"title":"Chaining and Converting","permalink":"/docs/assertions/extensibility/extensibility-chaining-and-converting"},"next":{"title":"FSharp","permalink":"/docs/assertions/fsharp"}}');var i=t(4848),r=t(8453);const a={},o="Returning Data via await",l={},c=[];function u(e){const n={br:"br",code:"code",h1:"h1",header:"header",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsxs)(n.h1,{id:"returning-data-via-await",children:["Returning Data via ",(0,i.jsx)(n.code,{children:"await"})]})}),"\n",(0,i.jsxs)(n.p,{children:["Sometimes, you may want your assertion to return a value, such as an item found in a collection, so you can use it in further assertions or logic.",(0,i.jsx)(n.br,{}),"\n","TUnit supports this by allowing your assertion to return a mapped result when awaited."]}),"\n",(0,i.jsx)(n.p,{children:"This is useful for scenarios where you want to extract a value from an assertion and use it in subsequent test logic, reducing the need for manual extraction or casting."}),"\n",(0,i.jsx)(n.p,{children:"It may make sense for our assertions to return data that is different from the input, based on what the assertion is doing. This can allow more cleanly written tests than have to manually do casting or parsing afterwards."}),"\n",(0,i.jsxs)(n.p,{children:["For example, ",(0,i.jsx)(n.code,{children:"await Assert.That(collection).Contains(item => item.Price < 0.99)"})]}),"\n",(0,i.jsx)(n.p,{children:"We could make that statement return the first item it finds that meets the criteria."}),"\n",(0,i.jsxs)(n.p,{children:["To do this, in your assert condition, in the ",(0,i.jsx)(n.code,{children:"GetResult"})," method where the logic is evaluated, store the item you'll return if the assertion passes within a property."]}),"\n",(0,i.jsx)(n.p,{children:"For the example above:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:'public class EnumerableContainsExpectedFuncAssertCondition<TActual, TInner>(\n    Func<TInner, bool> matcher, string? matcherString)\n    : BaseAssertCondition<TActual>\n    where TActual : IEnumerable<TInner>\n{\n    private bool _wasFound;\n    \n    protected override string GetExpectation() => $"to contain an entry matching {matcherString ?? "null"}";\n    \n    protected override ValueTask<AssertionResult> GetResult(\n        TActual? actualValue, Exception? exception,\n        AssertionMetadata assertionMetadata\n    )\n    {\n        if (actualValue is null)\n        {\n            return FailWithMessage($"{ActualExpression ?? typeof(TActual).Name} is null");\n        }\n\n        foreach (var inner in actualValue)\n        {\n            if (matcher(inner))\n            {\n                _wasFound = true;\n                FoundItem = inner;\n                break;\n            }\n        }\n        \n        return AssertionResult\n            .FailIf(_wasFound is false, "there was no match found in the collection");\n    }\n\n    public TInner? FoundItem { get; private set; }\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["As you can see, if we find an item that matches the predicate, we store it in the ",(0,i.jsx)(n.code,{children:"FoundItem"})," property."]}),"\n",(0,i.jsxs)(n.p,{children:["After that, the extension method to invoke your assertion should return a ",(0,i.jsx)(n.code,{children:"MappableResultAssertionBuilder<TSource, TAssertCondition, TMappedResult>"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"TSource"})," is the original type of the data you're asserting on. For the above, that's an ",(0,i.jsx)(n.code,{children:"IEnumerable<>"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"TAssertCondition"})," is the Assert Condition that you've created, where you've stored the item in the field."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"TMappedResult"})," is the type of object that you'd return from the ",(0,i.jsx)(n.code,{children:"await Assert.That(...)"})]}),"\n",(0,i.jsx)(n.p,{children:"This takes 3 arguments:"}),"\n",(0,i.jsxs)(n.p,{children:["The assertion builder, via ",(0,i.jsx)(n.code,{children:"valueSource.RegisterAssertion(assertCondition)"})," - As per how assertions are normally registered."]}),"\n",(0,i.jsxs)(n.p,{children:["The assert condition object. It is important that you use the same instance that is passed into the ",(0,i.jsx)(n.code,{children:"RegisterAssertion(...)"})," call."]}),"\n",(0,i.jsx)(n.p,{children:"And a mapper to tell the code how to find the item."}),"\n",(0,i.jsx)(n.p,{children:"So for the above example, that looks like this. (It looks like a lot of generics, I know!)"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:"public static MappableResultAssertionBuilder<IEnumerable<TInner>, EnumerableContainsExpectedFuncAssertCondition<IEnumerable<TInner>, TInner>, TInner> Contains<TInner>(this IValueSource<IEnumerable<TInner>> valueSource, Func<TInner, bool> matcher, [CallerArgumentExpression(nameof(matcher))] string doNotPopulateThisValue = null)\n    {\n        var enumerableContainsExpectedFuncAssertCondition = new EnumerableContainsExpectedFuncAssertCondition<IEnumerable<TInner>, TInner>(matcher, doNotPopulateThisValue);\n\n        return new MappableResultAssertionBuilder<IEnumerable<TInner>,\n            EnumerableContainsExpectedFuncAssertCondition<IEnumerable<TInner>, TInner>, TInner>(\n            valueSource.RegisterAssertion(enumerableContainsExpectedFuncAssertCondition, [doNotPopulateThisValue]),\n            enumerableContainsExpectedFuncAssertCondition,\n            (_, assertCondition) => assertCondition.FoundItem\n        );\n    }\n"})})]})}function d(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(u,{...e})}):u(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>o});var s=t(6540);const i={},r=s.createContext(i);function a(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);