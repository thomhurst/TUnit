"use strict";(self.webpackChunktunit_docs_site=self.webpackChunktunit_docs_site||[]).push([[6600],{6742:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>p,frontMatter:()=>i,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"assertions/regex-assertions","title":"Regex Assertions","description":"The .Matches() method allows you to validate strings against regular expressions and assert on capture groups, match positions, and match lengths. This is useful when you need to validate structured text like emails, phone numbers, dates, or extract specific parts of a string.","source":"@site/docs/assertions/regex-assertions.md","sourceDirName":"assertions","slug":"/assertions/regex-assertions","permalink":"/docs/assertions/regex-assertions","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{}}');var a=s(4848),r=s(8453);const i={},o="Regex Assertions",l={},c=[{value:"Basic Usage",id:"basic-usage",level:2},{value:"Group Assertions",id:"group-assertions",level:2},{value:"Named Groups",id:"named-groups",level:3},{value:"Indexed Groups",id:"indexed-groups",level:3},{value:"Multiple Matches",id:"multiple-matches",level:2},{value:"Match Position and Length",id:"match-position-and-length",level:2},{value:"Complex Patterns with Multiple Groups",id:"complex-patterns-with-multiple-groups",level:2},{value:"Product Information Validation",id:"product-information-validation",level:2},{value:"URL Parsing",id:"url-parsing",level:2},{value:"Regex Options",id:"regex-options",level:2},{value:"Source-Generated Regex (Recommended)",id:"source-generated-regex-recommended",level:2},{value:"Optional and Empty Groups",id:"optional-and-empty-groups",level:2},{value:"Complete Example",id:"complete-example",level:2},{value:"Error Handling",id:"error-handling",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"Related Assertions",id:"related-assertions",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"regex-assertions",children:"Regex Assertions"})}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:".Matches()"})," method allows you to validate strings against regular expressions and assert on capture groups, match positions, and match lengths. This is useful when you need to validate structured text like emails, phone numbers, dates, or extract specific parts of a string."]}),"\n",(0,a.jsx)(n.h2,{id:"basic-usage",children:"Basic Usage"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:'[Test]\npublic async Task BasicRegexAssertions()\n{\n    var email = "john.doe@example.com";\n\n    // Assert that string matches a pattern\n    await Assert.That(email).Matches(@"^[\\w.]+@[\\w.]+$");\n\n    // Use a compiled Regex object\n    var emailRegex = new Regex(@"^[\\w.]+@[\\w.]+$");\n    await Assert.That(email).Matches(emailRegex);\n\n    // Use source-generated regex (C# 11+)\n    [GeneratedRegex(@"^[\\w.]+@[\\w.]+$")]\n    static partial Regex EmailRegex();\n\n    await Assert.That(email).Matches(EmailRegex());\n}\n'})}),"\n",(0,a.jsx)(n.h2,{id:"group-assertions",children:"Group Assertions"}),"\n",(0,a.jsxs)(n.p,{children:["The key advantage of regex assertions is the ability to assert on capture groups using ",(0,a.jsx)(n.code,{children:".Group()"}),":"]}),"\n",(0,a.jsx)(n.h3,{id:"named-groups",children:"Named Groups"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:'[Test]\npublic async Task NamedGroupAssertions()\n{\n    var email = "john.doe@example.com";\n    var pattern = @"(?<username>[\\w.]+)@(?<domain>[\\w.]+)";\n\n    // Assert on named capture groups (requires .And before .Group())\n    await Assert.That(email)\n        .Matches(pattern)\n        .And.Group("username", user => user.IsEqualTo("john.doe"))\n        .And.Group("domain", domain => domain.IsEqualTo("example.com"));\n}\n'})}),"\n",(0,a.jsx)(n.h3,{id:"indexed-groups",children:"Indexed Groups"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:'[Test]\npublic async Task IndexedGroupAssertions()\n{\n    var date = "2025-10-28";\n    var pattern = @"(\\d{4})-(\\d{2})-(\\d{2})";\n\n    // Assert on indexed capture groups (1-based, 0 is full match)\n    await Assert.That(date)\n        .Matches(pattern)\n        .And.Group(0, full => full.IsEqualTo("2025-10-28"))\n        .And.Group(1, year => year.IsEqualTo("2025"))\n        .And.Group(2, month => month.IsEqualTo("10"))\n        .And.Group(3, day => day.IsEqualTo("28"));\n}\n'})}),"\n",(0,a.jsx)(n.h2,{id:"multiple-matches",children:"Multiple Matches"}),"\n",(0,a.jsxs)(n.p,{children:["When a regex matches multiple times in a string, you can access specific matches using ",(0,a.jsx)(n.code,{children:".Match(index)"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:'[Test]\npublic async Task MultipleMatchAssertions()\n{\n    var text = "test123 hello456 world789";\n    var pattern = @"\\w+\\d+";\n\n    // Assert on first match\n    await Assert.That(text)\n        .Matches(pattern)\n        .And.Match(0)\n        .And.Group(0, match => match.IsEqualTo("test123"));\n\n    // Use lambda pattern to assert on a specific match\n    await Assert.That(text)\n        .Matches(pattern)\n        .And.Match(1, match => match.Group(0, g => g.IsEqualTo("hello456")));\n}\n'})}),"\n",(0,a.jsx)(n.h2,{id:"match-position-and-length",children:"Match Position and Length"}),"\n",(0,a.jsx)(n.p,{children:"You can assert on where a match occurs and its length:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:'[Test]\npublic async Task PositionAndLengthAssertions()\n{\n    var text = "Hello World 123";\n    var pattern = @"\\d+";\n\n    // Assert that match is at specific index\n    await Assert.That(text)\n        .Matches(pattern)\n        .AtIndex(12);\n\n    // Assert that match has specific length\n    await Assert.That(text)\n        .Matches(pattern)\n        .HasLength(3);\n\n    // Combine with group assertions\n    await Assert.That(text)\n        .Matches(pattern)\n        .AtIndex(12)\n        .And.HasLength(3);\n}\n'})}),"\n",(0,a.jsx)(n.h2,{id:"complex-patterns-with-multiple-groups",children:"Complex Patterns with Multiple Groups"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:'[Test]\npublic async Task ComplexPatternAssertions()\n{\n    var logEntry = "[2025-10-28 14:30:45] ERROR: Connection timeout";\n    var pattern = @"\\[(?<date>\\d{4}-\\d{2}-\\d{2}) (?<time>\\d{2}:\\d{2}:\\d{2})\\] (?<level>\\w+): (?<message>.+)";\n\n    await Assert.That(logEntry)\n        .Matches(pattern)\n        .And.Group("date", date => date.IsEqualTo("2025-10-28"))\n        .And.Group("time", time => time.StartsWith("14"))\n        .And.Group("level", level => level.IsEqualTo("ERROR"))\n        .And.Group("message", msg => msg.Contains("timeout"));\n}\n'})}),"\n",(0,a.jsx)(n.h2,{id:"product-information-validation",children:"Product Information Validation"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:'[Test]\npublic async Task ProductCodeValidation()\n{\n    var product = "Product: ABC-123 Price: $99.99 Stock: 42";\n    var pattern = @"Product:\\s+(?<code>[A-Z]+-\\d+)\\s+Price:\\s+\\$(?<price>[\\d.]+)\\s+Stock:\\s+(?<stock>\\d+)";\n\n    await Assert.That(product)\n        .Matches(pattern)\n        .And.Group("code", code => code.StartsWith("ABC"))\n        .And.Group("price", price => price.Contains(".99"))\n        .And.Group("stock", stock => stock.HasLength(2));\n}\n'})}),"\n",(0,a.jsx)(n.h2,{id:"url-parsing",children:"URL Parsing"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:'[Test]\npublic async Task UrlParsingAssertions()\n{\n    var url = "https://api.example.com:8080/users/123?format=json";\n    var pattern = @"(?<protocol>https?)://(?<host>[\\w.]+):(?<port>\\d+)/(?<path>[^?]+)\\?(?<query>.+)";\n\n    await Assert.That(url)\n        .Matches(pattern)\n        .And.Group("protocol", p => p.IsEqualTo("https"))\n        .And.Group("host", h => h.Contains("api"))\n        .And.Group("port", p => p.IsEqualTo("8080"))\n        .And.Group("path", p => p.StartsWith("users/"))\n        .And.Group("query", q => q.Contains("format=json"));\n}\n'})}),"\n",(0,a.jsx)(n.h2,{id:"regex-options",children:"Regex Options"}),"\n",(0,a.jsxs)(n.p,{children:["Use ",(0,a.jsx)(n.code,{children:".IgnoringCase()"})," or ",(0,a.jsx)(n.code,{children:".WithOptions()"})," for case-insensitive or other regex options:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:'[Test]\npublic async Task RegexOptionsAssertions()\n{\n    var text = "HELLO world";\n\n    // Case-insensitive matching\n    await Assert.That(text)\n        .Matches(@"hello")\n        .IgnoringCase();\n\n    // Custom options\n    await Assert.That(text)\n        .Matches(@"^hello.*world$")\n        .WithOptions(RegexOptions.IgnoreCase | RegexOptions.Singleline);\n}\n'})}),"\n",(0,a.jsx)(n.h2,{id:"source-generated-regex-recommended",children:"Source-Generated Regex (Recommended)"}),"\n",(0,a.jsx)(n.p,{children:"For performance-critical code, use C# 11+ source-generated regex:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:'public partial class MyTests\n{\n    [GeneratedRegex(@"(?<year>\\d{4})-(?<month>\\d{2})-(?<day>\\d{2})")]\n    private static partial Regex DatePattern();\n\n    [Test]\n    public async Task SourceGeneratedRegexAssertions()\n    {\n        var date = "2025-10-28";\n\n        // Source-generated regex provides better performance\n        await Assert.That(date)\n            .Matches(DatePattern())\n            .And.Group("year", y => y.IsEqualTo("2025"))\n            .And.Group("month", m => m.IsEqualTo("10"))\n            .And.Group("day", d => d.IsEqualTo("28"));\n    }\n}\n'})}),"\n",(0,a.jsx)(n.h2,{id:"optional-and-empty-groups",children:"Optional and Empty Groups"}),"\n",(0,a.jsx)(n.p,{children:"Handle optional capture groups that may be empty:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:'[Test]\npublic async Task OptionalGroupAssertions()\n{\n    var phone1 = "(555) 123-4567";\n    var phone2 = "123-4567";\n    var pattern = @"(\\((?<area>\\d{3})\\)\\s+)?(?<prefix>\\d{3})-(?<line>\\d{4})";\n\n    // Phone with area code\n    await Assert.That(phone1)\n        .Matches(pattern)\n        .And.Group("area", area => area.IsEqualTo("555"))\n        .And.Group("prefix", p => p.IsEqualTo("123"));\n\n    // Phone without area code (optional group is empty)\n    await Assert.That(phone2)\n        .Matches(pattern)\n        .And.Group("area", area => area.IsEqualTo(""))\n        .And.Group("prefix", p => p.IsEqualTo("123"));\n}\n'})}),"\n",(0,a.jsx)(n.h2,{id:"complete-example",children:"Complete Example"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:'[Test]\npublic async Task CompleteEmailValidation()\n{\n    var email = "john.doe+test@mail.example.com";\n    var pattern = @"(?<local>[\\w.+-]+)@(?<subdomain>[\\w]+)\\.(?<domain>[\\w]+)\\.(?<tld>\\w+)";\n\n    await Assert.That(email)\n        .Matches(pattern)\n        .And.Group("local", local => local.StartsWith("john"))\n        .And.Group("subdomain", sub => sub.IsEqualTo("mail"))\n        .And.Group("domain", domain => domain.IsEqualTo("example"))\n        .And.Group("tld", tld => tld.HasLength(3))\n        .And.AtIndex(0)\n        .And.HasLength(email.Length);\n}\n'})}),"\n",(0,a.jsx)(n.h2,{id:"error-handling",children:"Error Handling"}),"\n",(0,a.jsx)(n.p,{children:"The regex assertions throw specific exceptions for common error cases:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:'[Test]\npublic async Task RegexAssertionErrors()\n{\n    var text = "Hello123World";\n\n    // Throws ArgumentNullException if text is null\n    await Assert.That((string?)null)\n        .ThrowsAsync<ArgumentNullException>()\n        .When(() => Matches(@"\\d+"));\n\n    // Throws RegexParseException for invalid patterns\n    await Assert.That(text)\n        .ThrowsAsync<RegexParseException>()\n        .When(() => Matches(@"[invalid"));\n\n    // Throws ArgumentOutOfRangeException for invalid group index\n    await Assert.That(text)\n        .Matches(@"Hello(\\d+)World")\n        .ThrowsAsync<ArgumentOutOfRangeException>()\n        .When(m => m.Group(99, g => g.IsEqualTo("123")));\n\n    // Throws ArgumentException for empty group name\n    await Assert.That(text)\n        .Matches(@"Hello(?<num>\\d+)World")\n        .ThrowsAsync<ArgumentException>()\n        .When(m => m.Group("", g => g.IsEqualTo("123")));\n}\n'})}),"\n",(0,a.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Use source-generated regex"})," for better performance and compile-time validation"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Name your capture groups"})," descriptively (e.g., ",(0,a.jsx)(n.code,{children:"username"}),", ",(0,a.jsx)(n.code,{children:"domain"}),", not ",(0,a.jsx)(n.code,{children:"g1"}),", ",(0,a.jsx)(n.code,{children:"g2"}),")"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Chain assertions"})," using ",(0,a.jsx)(n.code,{children:".And"})," to validate multiple aspects in one test"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Handle optional groups"})," explicitly by checking for empty strings"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Test edge cases"})," like empty matches, multiple occurrences, and boundary conditions"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Use raw string literals"})," (",(0,a.jsx)(n.code,{children:'@""'})," or ",(0,a.jsx)(n.code,{children:'"""'}),") to avoid escaping backslashes"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"related-assertions",children:"Related Assertions"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"/docs/assertions/string",children:"String Assertions"})," - Basic string validation"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"/docs/assertions/member-assertions",children:"Member Assertions"})," - Object property validation"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"/docs/assertions/collections",children:"Collection Assertions"})," - Collection validation"]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>i,x:()=>o});var t=s(6540);const a={},r=t.createContext(a);function i(e){const n=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);