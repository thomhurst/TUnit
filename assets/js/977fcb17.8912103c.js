"use strict";(self.webpackChunktunit_docs_site=self.webpackChunktunit_docs_site||[]).push([[2899],{9859:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>i,contentTitle:()=>r,default:()=>p,frontMatter:()=>d,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"tutorial-advanced/depends-on","title":"Depends On","description":"A test can depend on another test. This means that your test will not start unless the other test has finished.","source":"@site/docs/tutorial-advanced/depends-on.md","sourceDirName":"tutorial-advanced","slug":"/tutorial-advanced/depends-on","permalink":"/docs/tutorial-advanced/depends-on","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":11,"frontMatter":{"sidebar_position":11},"sidebar":"tutorialSidebar","previous":{"title":"Not in Parallel","permalink":"/docs/tutorial-advanced/not-in-parallel"},"next":{"title":"Ordering Tests","permalink":"/docs/tutorial-advanced/order"}}');var a=t(4848),o=t(8453);const d={sidebar_position:11},r="Depends On",i={},c=[{value:"Getting other tests",id:"getting-other-tests",level:2},{value:"Failures",id:"failures",level:2}];function l(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"depends-on",children:"Depends On"})}),"\n",(0,a.jsx)(n.p,{children:"A test can depend on another test. This means that your test will not start unless the other test has finished."}),"\n",(0,a.jsxs)(n.p,{children:["To do this, add a  ",(0,a.jsx)(n.code,{children:"[DependsOn]"})," to your test."]}),"\n",(0,a.jsxs)(n.p,{children:["This takes a test name, which you can easily reference by using the ",(0,a.jsx)(n.code,{children:"nameof(TestMethod)"})," keyword. And if your test you depend on has parameters, you must include the types of those too."]}),"\n",(0,a.jsx)(n.p,{children:"e.g.:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:"public void Test1(string value1, int value2) { ... }\n\n[DependsOn(nameof(Test1), [typeof(string), typeof(int)])]\npublic void Test2() { ... }\n"})}),"\n",(0,a.jsx)(n.p,{children:"This means you can create more complex test suites, without having to compromise on parallelism or speed."}),"\n",(0,a.jsx)(n.p,{children:"For example, performing some operations on a database and asserting a count at the end:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:"[Test]\npublic async Task AddUser1() \n{\n    ...\n}\n\n[Test]\npublic async Task AddUser2() \n{\n    ...\n}\n\n[Test]\npublic async Task AddUser3() \n{\n    ...\n}\n\n[Test]\npublic async Task AddUser4() \n{\n    ...\n}\n\n[Test]\npublic async Task AddUser5() \n{\n    ...\n}\n\n[Test, DependsOn(nameof(AddUser1))]\npublic async Task AddItemToBagForUser1() \n{\n    ...\n}\n\n[Test, DependsOn(nameof(AddUser2))]\npublic async Task AddItemToBagForUser2() \n{\n    ...\n}\n\n[Test, DependsOn(nameof(AddUser3))]\npublic async Task AddItemToBagForUser3() \n{\n    ...\n}\n\n[Test]\n[DependsOn(nameof(AddUser4))]\n[DependsOn(nameof(AddUser5))]\n[DependsOn(nameof(AddItemToBagForUser1))]\n[DependsOn(nameof(AddItemToBagForUser2))]\n[DependsOn(nameof(AddItemToBagForUser3))]\npublic async Task AssertItemsInDatabase() \n{\n    ...\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"getting-other-tests",children:"Getting other tests"}),"\n",(0,a.jsx)(n.p,{children:"If your tests depends on another test, it's possible to retrieve that test's context. This allows you to do things like check its result, or retrieve objects from its object bag."}),"\n",(0,a.jsxs)(n.p,{children:["This is done by calling the ",(0,a.jsx)(n.code,{children:"GetTests"})," method on a ",(0,a.jsx)(n.code,{children:"TestContext"})," object. It takes the test's method name (so you can use ",(0,a.jsx)(n.code,{children:"nameof(...)"}),") and optionally the parameter types for if there's multiple overloads."]}),"\n",(0,a.jsx)(n.p,{children:"You'll notice this returns an array - This is because tests may be data driven and be invoked multiple times - If this is the case you'll have to find the one you want yourself."}),"\n",(0,a.jsx)(n.p,{children:"Example:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:'[Test]\npublic async Task AddItemToBag() \n{\n    var itemId = await AddToBag();\n    TestContext.Current!.ObjectBag.Add("ItemId", itemId);\n}\n\n[Test]\n[DependsOn(nameof(AddItemToBag))]\npublic async Task DeleteItemFromBag() \n{\n    var addToBagTestContext = TestContext.Current!.GetTests(nameof(AddItemToBag)).First();\n    var itemId = addToBagTestContext.ObjectBag["ItemId"];\n    await DeleteFromBag(itemId);\n}\n'})}),"\n",(0,a.jsx)(n.h2,{id:"failures",children:"Failures"}),"\n",(0,a.jsxs)(n.p,{children:["If your test depends on another test, by default, if that dependency fails, then your test that depends on it will not start. This can be bypassed by adding the property ",(0,a.jsx)(n.code,{children:"ProceedOnFailure = true"})," to the ",(0,a.jsx)(n.code,{children:"DependsOnAttribute"}),". Your test suite will still fail due to that test, but it allows you to proceed with other tests if you require it. For example, CRUD testing, and wanting to perform a delete after all your other tests, regardless of if they passed."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:"[Test]\npublic async Task Test1() \n{\n    ...\n}\n\n[Test]\n[DependsOn(nameof(Test1), ProceedOnFailure = true)]\npublic async Task Test2() \n{\n    ...\n}\n"})})]})}function p(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>d,x:()=>r});var s=t(6540);const a={},o=s.createContext(a);function d(e){const n=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:d(e.components),s.createElement(o.Provider,{value:n},e.children)}}}]);