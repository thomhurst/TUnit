"use strict";(self.webpackChunktunit_docs_site=self.webpackChunktunit_docs_site||[]).push([[5494],{4104:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>p,frontMatter:()=>a,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"test-lifecycle/property-injection","title":"Property Injection","description":"TUnit\'s AOT-compatible property injection system makes it easy to initialize properties on your test class with compile-time safety and excellent performance.","source":"@site/docs/test-lifecycle/property-injection.md","sourceDirName":"test-lifecycle","slug":"/test-lifecycle/property-injection","permalink":"/docs/test-lifecycle/property-injection","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"docs","previous":{"title":"Test Clean Ups","permalink":"/docs/test-lifecycle/cleanup"},"next":{"title":"Event Subscribing","permalink":"/docs/test-lifecycle/event-subscribing"}}');var s=i(4848),r=i(8453);const a={},o="Property Injection",c={},l=[{value:"AOT-Compatible Property Attributes",id:"aot-compatible-property-attributes",level:2},{value:"Async Property Initialization",id:"async-property-initialization",level:2},{value:"Basic Property Injection Examples",id:"basic-property-injection-examples",level:2},{value:"Nested Property Injection",id:"nested-property-injection",level:2},{value:"How It Works",id:"how-it-works",level:3},{value:"Example: Complex Test Infrastructure",id:"example-complex-test-infrastructure",level:3},{value:"Benefits of Nested Property Injection",id:"benefits-of-nested-property-injection",level:3},{value:"Sharing Strategies",id:"sharing-strategies",level:3},{value:"Best Practices",id:"best-practices",level:3},{value:"Advanced Scenarios",id:"advanced-scenarios",level:3},{value:"Conditional Initialization",id:"conditional-initialization",level:4},{value:"Circular Dependencies",id:"circular-dependencies",level:4}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"property-injection",children:"Property Injection"})}),"\n",(0,s.jsx)(n.p,{children:"TUnit's AOT-compatible property injection system makes it easy to initialize properties on your test class with compile-time safety and excellent performance."}),"\n",(0,s.jsxs)(n.p,{children:["Your properties must be marked with the ",(0,s.jsx)(n.code,{children:"required"})," keyword and then simply place a data attribute on it.\nThe required keyword keeps your code clean and correct. If a property isn't passed in, you'll get a compiler warning, so you know something has gone wrong. It also gets rid of any pesky nullability warnings."]}),"\n",(0,s.jsx)(n.h2,{id:"aot-compatible-property-attributes",children:"AOT-Compatible Property Attributes"}),"\n",(0,s.jsx)(n.p,{children:"Supported attributes for properties in AOT mode:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Argument"})," - Compile-time constant values"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"MethodDataSource"})," - Static method data sources"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"ClassDataSource"})," - Static class-based data sources"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"DataSourceGeneratorAttribute"})," - Source-generated data (first item only)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"DataSourceForProperty"})," - Dependency injection with service provider"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"The AOT system generates strongly-typed property setters at compile time, eliminating reflection overhead and ensuring full Native AOT compatibility."}),"\n",(0,s.jsx)(n.h2,{id:"async-property-initialization",children:"Async Property Initialization"}),"\n",(0,s.jsxs)(n.p,{children:["Properties can implement ",(0,s.jsx)(n.code,{children:"IAsyncInitializable"})," for complex setup scenarios with automatic lifecycle management:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:'using TUnit.Core;\n\nnamespace MyTestProject;\n\npublic class AsyncPropertyExample : IAsyncInitializable, IAsyncDisposable\n{\n    public bool IsInitialized { get; private set; }\n    public string? ConnectionString { get; private set; }\n\n    public async Task InitializeAsync()\n    {\n        await Task.Delay(10); // Simulate async setup\n        ConnectionString = "Server=localhost;Database=test";\n        IsInitialized = true;\n    }\n\n    public async ValueTask DisposeAsync()\n    {\n        await Task.Delay(1); // Cleanup\n        IsInitialized = false;\n        ConnectionString = null;\n    }\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"basic-property-injection-examples",children:"Basic Property Injection Examples"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:'using TUnit.Core;\n\nnamespace MyTestProject;\n\npublic class PropertySetterTests\n{\n    // Compile-time constant injection\n    [Arguments("1")]\n    public required string Property1 { get; init; }\n        \n    // Static method data source injection\n    [MethodDataSource(nameof(GetMethodData))]\n    public required string Property2 { get; init; }\n        \n    // Class-based data source injection\n    [ClassDataSource<InnerModel>]\n    public required InnerModel Property3 { get; init; }\n    \n    // Globally shared data source\n    [ClassDataSource<InnerModel>(Shared = SharedType.Globally)]\n    public required InnerModel Property4 { get; init; }\n    \n    // Class-scoped shared data source\n    [ClassDataSource<InnerModel>(Shared = SharedType.ForClass)]\n    public required InnerModel Property5 { get; init; }\n    \n    // Keyed shared data source\n    [ClassDataSource<InnerModel>(Shared = SharedType.Keyed, Key = "Key")]\n    public required InnerModel Property6 { get; init; }\n        \n    // Source-generated data injection\n    [DataSourceGeneratorTests.AutoFixtureGenerator<string>]\n    public required string Property7 { get; init; }\n\n    // Service provider dependency injection\n    [DataSourceForProperty<AsyncPropertyExample>]\n    public required AsyncPropertyExample AsyncService { get; init; }\n    \n    [Test]\n    public async Task Test()\n    {\n        // All properties are automatically initialized before this test runs\n        await Assert.That(Property1).IsEqualTo("1");\n        await Assert.That(Property2).IsNotNull();\n        await Assert.That(Property3).IsNotNull();\n        await Assert.That(AsyncService.IsInitialized).IsTrue();\n        \n        Console.WriteLine($"Property7: {Property7}");\n    }\n\n    // Static data source method for Property2\n    public static IEnumerable<string> GetMethodData()\n    {\n        yield return "method_data_1";\n        yield return "method_data_2";\n    }\n}\n\n// Example model for ClassDataSource\npublic class InnerModel\n{\n    public string Name { get; set; } = "";\n    public int Value { get; set; }\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"nested-property-injection",children:"Nested Property Injection"}),"\n",(0,s.jsx)(n.p,{children:"One of TUnit's most powerful features is nested property injection with automatic initialization. This allows you to inject objects into other objects created via data sources, enabling advanced test orchestration with relatively simple code. TUnit handles all the complex aspects like initialization order and object lifetimes."}),"\n",(0,s.jsx)(n.h3,{id:"how-it-works",children:"How It Works"}),"\n",(0,s.jsx)(n.p,{children:"When you use property injection with data source attributes, those injected objects can themselves have injected properties. TUnit will:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Resolve the entire dependency graph"}),"\n",(0,s.jsx)(n.li,{children:"Create objects in the correct order"}),"\n",(0,s.jsxs)(n.li,{children:["Initialize them (if they implement ",(0,s.jsx)(n.code,{children:"IAsyncInitializer"}),")"]}),"\n",(0,s.jsx)(n.li,{children:"Inject them into parent objects"}),"\n",(0,s.jsxs)(n.li,{children:["Dispose of them when appropriate (if they implement ",(0,s.jsx)(n.code,{children:"IAsyncDisposable"}),")"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"example-complex-test-infrastructure",children:"Example: Complex Test Infrastructure"}),"\n",(0,s.jsx)(n.p,{children:"Here's a comprehensive example showing how to orchestrate multiple test containers and a web application:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:'// In-memory SQL container that auto-starts and stops\npublic class InMemorySql : IAsyncInitializer, IAsyncDisposable\n{\n    private TestcontainersContainer? _container;\n    \n    public TestcontainersContainer Container => _container \n        ?? throw new InvalidOperationException("Container not initialized");\n\n    public async Task InitializeAsync()\n    {\n        _container = new TestcontainersBuilder<TestcontainersContainer>()\n            .WithImage("postgres:latest")\n            .WithEnvironment("POSTGRES_PASSWORD", "password")\n            .Build();\n            \n        await _container.StartAsync();\n    }\n\n    public async ValueTask DisposeAsync()\n    {\n        if (_container != null)\n        {\n            await _container.DisposeAsync();\n        }\n    }\n}\n\n// Redis container with similar pattern\npublic class InMemoryRedis : IAsyncInitializer, IAsyncDisposable\n{\n    private TestcontainersContainer? _container;\n    \n    public TestcontainersContainer Container => _container \n        ?? throw new InvalidOperationException("Container not initialized");\n\n    public async Task InitializeAsync()\n    {\n        _container = new TestcontainersBuilder<TestcontainersContainer>()\n            .WithImage("redis:latest")\n            .Build();\n            \n        await _container.StartAsync();\n    }\n\n    public async ValueTask DisposeAsync()\n    {\n        if (_container != null)\n        {\n            await _container.DisposeAsync();\n        }\n    }\n}\n\n// Message bus container\npublic class InMemoryMessageBus : IAsyncInitializer, IAsyncDisposable\n{\n    private TestcontainersContainer? _container;\n    \n    public TestcontainersContainer Container => _container \n        ?? throw new InvalidOperationException("Container not initialized");\n\n    public async Task InitializeAsync()\n    {\n        _container = new TestcontainersBuilder<TestcontainersContainer>()\n            .WithImage("rabbitmq:3-management")\n            .Build();\n            \n        await _container.StartAsync();\n    }\n\n    public async ValueTask DisposeAsync()\n    {\n        if (_container != null)\n        {\n            await _container.DisposeAsync();\n        }\n    }\n}\n\n// UI component that depends on the message bus\npublic class MessageBusUserInterface : IAsyncInitializer, IAsyncDisposable\n{\n    private TestcontainersContainer? _container;\n    \n    // Inject the message bus dependency - shared per test session\n    [ClassDataSource<InMemoryMessageBus>(Shared = SharedType.PerTestSession)]\n    public required InMemoryMessageBus MessageBus { get; init; }\n    \n    public TestcontainersContainer Container => _container \n        ?? throw new InvalidOperationException("Container not initialized");\n\n    public async Task InitializeAsync()\n    {\n        // The MessageBus property is already initialized when this runs!\n        _container = new MessageBusUIContainerBuilder()\n            .WithConnectionString(MessageBus.Container.GetConnectionString())\n            .Build();\n\n        await _container.StartAsync();\n    }\n\n    public async ValueTask DisposeAsync()\n    {\n        if (_container != null)\n        {\n            await _container.DisposeAsync();\n        }\n    }\n}\n\n// Web application factory that depends on multiple services\npublic class InMemoryWebApplicationFactory : WebApplicationFactory<Program>, IAsyncInitializer\n{\n    // Inject all required infrastructure - all shared per test session\n    [ClassDataSource<InMemorySql>(Shared = SharedType.PerTestSession)]\n    public required InMemorySql Sql { get; init; }\n\n    [ClassDataSource<InMemoryRedis>(Shared = SharedType.PerTestSession)]\n    public required InMemoryRedis Redis { get; init; }\n\n    [ClassDataSource<InMemoryMessageBus>(Shared = SharedType.PerTestSession)]\n    public required InMemoryMessageBus MessageBus { get; init; }\n\n    public Task InitializeAsync()\n    {\n        // Force server creation to validate configuration\n        _ = Server;\n        return Task.CompletedTask;\n    }\n\n    protected override void ConfigureWebHost(IWebHostBuilder builder)\n    {\n        builder.ConfigureAppConfiguration((context, configBuilder) =>\n        {\n            // All injected properties are already initialized!\n            configBuilder.AddInMemoryCollection(new Dictionary<string, string?>\n            {\n                { "MessageBus:ConnectionString", MessageBus.Container.GetConnectionString() },\n                { "Redis:ConnectionString", Redis.Container.GetConnectionString() },\n                { "PostgreSql:ConnectionString", Sql.Container.GetConnectionString() }\n            });\n        });\n    }\n}\n\n// Your test class - clean and simple!\npublic class IntegrationTests\n{\n    // Just inject what you need - TUnit handles the entire dependency graph\n    [ClassDataSource<InMemoryWebApplicationFactory>]\n    public required InMemoryWebApplicationFactory WebApplicationFactory { get; init; }\n    \n    [ClassDataSource<MessageBusUserInterface>]\n    public required MessageBusUserInterface MessageBusUI { get; init; }\n\n    [Test]\n    public async Task Full_Integration_Test()\n    {\n        // Everything is initialized in the correct order!\n        var client = WebApplicationFactory.CreateClient();\n        \n        // Test your application with all infrastructure running\n        var response = await client.GetAsync("/api/products");\n        await Assert.That(response.IsSuccessStatusCode).IsTrue();\n        \n        // The MessageBusUI shares the same MessageBus instance as the WebApplicationFactory\n        // because they both use SharedType.PerTestSession\n    }\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"benefits-of-nested-property-injection",children:"Benefits of Nested Property Injection"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Simplified Test Setup"}),": You only need to declare what you need; TUnit handles the complex orchestration"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Automatic Lifecycle Management"}),": Objects are initialized in dependency order and disposed in reverse order"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Shared Resources"}),": Use ",(0,s.jsx)(n.code,{children:"SharedType"})," to control object lifetime and reuse expensive resources"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Type Safety"}),": Everything is strongly typed with compile-time checking"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Clean Test Code"}),": Your tests focus on testing, not on infrastructure setup"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"sharing-strategies",children:"Sharing Strategies"}),"\n",(0,s.jsxs)(n.p,{children:["When using nested property injection, the ",(0,s.jsx)(n.code,{children:"Shared"})," parameter becomes crucial:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"SharedType.PerTestSession"})}),": Single instance for the entire test run - ideal for expensive resources like containers"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"SharedType.Globally"})}),": Single instance across all test sessions"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"SharedType.ForClass"})}),": One instance per test class"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"SharedType.Keyed"})}),": Share instances based on a key value"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"No sharing"}),": New instance for each injection point"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"best-practices",children:"Best Practices"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Use Appropriate Sharing"}),": Share expensive resources like test containers using ",(0,s.jsx)(n.code,{children:"PerTestSession"})," or ",(0,s.jsx)(n.code,{children:"Globally"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Implement IAsyncInitializer"}),": For complex setup that requires async operations"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Implement IAsyncDisposable"}),": Ensure proper cleanup of resources"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Order Independence"}),": Don't rely on initialization order between sibling properties"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Error Handling"}),": Initialization failures will fail the test with clear error messages"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"advanced-scenarios",children:"Advanced Scenarios"}),"\n",(0,s.jsx)(n.h4,{id:"conditional-initialization",children:"Conditional Initialization"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"public class ConditionalService : IAsyncInitializer\n{\n    [ClassDataSource<DatabaseService>(Shared = SharedType.PerTestSession)]\n    public required DatabaseService Database { get; init; }\n    \n    public async Task InitializeAsync()\n    {\n        if (await Database.RequiresMigration())\n        {\n            await Database.MigrateAsync();\n        }\n    }\n}\n"})}),"\n",(0,s.jsx)(n.h4,{id:"circular-dependencies",children:"Circular Dependencies"}),"\n",(0,s.jsx)(n.p,{children:"TUnit will detect and report circular dependencies:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"public class ServiceA : IAsyncInitializer\n{\n    [ClassDataSource<ServiceB>]\n    public required ServiceB B { get; init; } // This will fail!\n}\n\npublic class ServiceB : IAsyncInitializer\n{\n    [ClassDataSource<ServiceA>]\n    public required ServiceA A { get; init; } // Circular dependency!\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"This powerful feature makes complex test orchestration simple and maintainable, allowing you to focus on writing tests rather than managing test infrastructure!"})]})}function p(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>o});var t=i(6540);const s={},r=t.createContext(s);function a(e){const n=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);