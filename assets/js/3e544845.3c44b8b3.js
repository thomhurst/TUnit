"use strict";(self.webpackChunktunit_docs_site=self.webpackChunktunit_docs_site||[]).push([[3153],{99994:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>a,default:()=>h,frontMatter:()=>c,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"test-lifecycle/event-subscribing","title":"Event Subscribing","description":"Objects associated with your tests have the ability to subscribe to lifecycle events generated by TUnit.","source":"@site/docs/test-lifecycle/event-subscribing.md","sourceDirName":"test-lifecycle","slug":"/test-lifecycle/event-subscribing","permalink":"/docs/test-lifecycle/event-subscribing","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"docs","previous":{"title":"Property Injection","permalink":"/docs/test-lifecycle/property-injection"},"next":{"title":"Class Constructor Helpers","permalink":"/docs/test-lifecycle/class-constructors"}}');var r=n(74848),i=n(28453);const c={},a="Event Subscribing",o={},l=[{value:"Execution Stage Control",id:"execution-stage-control",level:2},{value:"EventReceiverStage Options",id:"eventreceiverstage-options",level:3},{value:"When to Use Early Stage",id:"when-to-use-early-stage",level:3},{value:"When to Use Late Stage",id:"when-to-use-late-stage",level:3},{value:"Example: Early Stage Event Receiver",id:"example-early-stage-event-receiver",level:3},{value:"Example: Late Stage Event Receiver (Default)",id:"example-late-stage-event-receiver-default",level:3},{value:".NET Framework / .NET Standard 2.0 Behavior",id:"net-framework--net-standard-20-behavior",level:3}];function d(e){const t={blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"event-subscribing",children:"Event Subscribing"})}),"\n",(0,r.jsx)(t.p,{children:"Objects associated with your tests have the ability to subscribe to lifecycle events generated by TUnit."}),"\n",(0,r.jsx)(t.p,{children:"Objects associated with your tests can mean:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"The test class itself"}),"\n",(0,r.jsx)(t.li,{children:"A custom class constructor"}),"\n",(0,r.jsx)(t.li,{children:"Injected class parameter arguments"}),"\n",(0,r.jsx)(t.li,{children:"Injected method parameter arguments"}),"\n",(0,r.jsx)(t.li,{children:"Injected properties"}),"\n",(0,r.jsx)(t.li,{children:"Associated attributes"}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:"The interfaces they can implement are:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"ITestRegisteredEventReceiver"}),"\n",(0,r.jsx)(t.li,{children:"ITestStartEventReceiver"}),"\n",(0,r.jsx)(t.li,{children:"ITestEndEventReceiver"}),"\n",(0,r.jsx)(t.li,{children:"ILastTestInClassEventReceiver"}),"\n",(0,r.jsx)(t.li,{children:"ILastTestInAssemblyEventReceiver"}),"\n",(0,r.jsx)(t.li,{children:"ILastTestInTestSessionEventReceiver"}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:"This can be useful especially when generating data that you need to track and maybe dispose later. By hooking into these events, we can do things like track and dispose our objects when we need."}),"\n",(0,r.jsx)(t.h2,{id:"execution-stage-control",children:"Execution Stage Control"}),"\n",(0,r.jsxs)(t.blockquote,{children:["\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.strong,{children:"Note"}),": This feature is available on .NET 8.0+ only due to default interface member requirements."]}),"\n"]}),"\n",(0,r.jsxs)(t.p,{children:["For ",(0,r.jsx)(t.code,{children:"ITestStartEventReceiver"})," and ",(0,r.jsx)(t.code,{children:"ITestEndEventReceiver"}),", you can control when your event receivers execute relative to instance-level hooks (",(0,r.jsx)(t.code,{children:"[Before(Test)]"})," and ",(0,r.jsx)(t.code,{children:"[After(Test)]"}),") by setting the ",(0,r.jsx)(t.code,{children:"Stage"})," property."]}),"\n",(0,r.jsx)(t.h3,{id:"eventreceiverstage-options",children:"EventReceiverStage Options"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.strong,{children:(0,r.jsx)(t.code,{children:"EventReceiverStage.Early"})}),": Executes before instance-level hooks"]}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["Test start receivers run before ",(0,r.jsx)(t.code,{children:"[Before(Test)]"})," hooks"]}),"\n",(0,r.jsxs)(t.li,{children:["Test end receivers run before ",(0,r.jsx)(t.code,{children:"[After(Test)]"})," hooks"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.strong,{children:(0,r.jsx)(t.code,{children:"EventReceiverStage.Late"})})," (default): Executes after instance-level hooks"]}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["Test start receivers run after ",(0,r.jsx)(t.code,{children:"[Before(Test)]"})," hooks"]}),"\n",(0,r.jsxs)(t.li,{children:["Test end receivers run after ",(0,r.jsx)(t.code,{children:"[After(Test)]"})," hooks"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(t.h3,{id:"when-to-use-early-stage",children:"When to Use Early Stage"}),"\n",(0,r.jsxs)(t.p,{children:["Use ",(0,r.jsx)(t.code,{children:"EventReceiverStage.Early"})," when your event receiver needs to:"]}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Initialize resources that instance-level hooks depend on"}),"\n",(0,r.jsx)(t.li,{children:"Set up test context or environment before any test-specific setup runs"}),"\n",(0,r.jsx)(t.li,{children:"Capture test state before any modifications from hooks"}),"\n"]}),"\n",(0,r.jsx)(t.h3,{id:"when-to-use-late-stage",children:"When to Use Late Stage"}),"\n",(0,r.jsxs)(t.p,{children:["Use ",(0,r.jsx)(t.code,{children:"EventReceiverStage.Late"})," (the default) when your event receiver needs to:"]}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Access resources initialized by instance-level hooks"}),"\n",(0,r.jsx)(t.li,{children:"Clean up after all test-specific teardown completes"}),"\n",(0,r.jsx)(t.li,{children:"Log or report on final test state after all hooks have run"}),"\n"]}),"\n",(0,r.jsx)(t.h3,{id:"example-early-stage-event-receiver",children:"Example: Early Stage Event Receiver"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-csharp",children:'public class DatabaseConnectionAttribute : Attribute, ITestStartEventReceiver\n{\n    private IDbConnection? _connection;\n\n    // Execute before [Before(Test)] hooks so the connection is available to them\n    public EventReceiverStage Stage => EventReceiverStage.Early;\n\n    public async ValueTask OnTestStart(TestContext context)\n    {\n        _connection = new SqlConnection(connectionString);\n        await _connection.OpenAsync();\n\n        // Store connection in test context for use by hooks and test\n        context.StateBag.GetOrAdd("DbConnection", _ => _connection);\n    }\n}\n\npublic class MyTests\n{\n    [Test]\n    [DatabaseConnection] // Runs BEFORE BeforeTest hook\n    public async Task TestWithDatabase()\n    {\n        // Database connection is already open and available\n        TestContext.Current!.StateBag.TryGetValue<IDbConnection>("DbConnection", out var connection);\n        // ... test logic\n    }\n\n    [Before(Test)]\n    public void BeforeTest()\n    {\n        // Database connection is already available here\n        TestContext.Current!.StateBag.TryGetValue<IDbConnection>("DbConnection", out var connection);\n        // ... setup that needs the database\n    }\n}\n'})}),"\n",(0,r.jsx)(t.h3,{id:"example-late-stage-event-receiver-default",children:"Example: Late Stage Event Receiver (Default)"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-csharp",children:"public class TestMetricsAttribute : Attribute, ITestEndEventReceiver\n{\n    // Late stage is the default, so this property is optional\n    public EventReceiverStage Stage => EventReceiverStage.Late;\n\n    public async ValueTask OnTestEnd(TestContext context)\n    {\n        // This runs AFTER all [After(Test)] hooks have completed\n        // So we can capture the final test metrics including cleanup time\n        await LogMetrics(context);\n    }\n}\n"})}),"\n",(0,r.jsx)(t.h3,{id:"net-framework--net-standard-20-behavior",children:".NET Framework / .NET Standard 2.0 Behavior"}),"\n",(0,r.jsxs)(t.p,{children:["On older frameworks that don't support default interface members (.NET Framework, .NET Standard 2.0), the ",(0,r.jsx)(t.code,{children:"Stage"})," property is not available. All event receivers will execute at the ",(0,r.jsx)(t.code,{children:"Late"})," stage (after instance-level hooks), which matches the historical behavior."]}),"\n",(0,r.jsx)(t.p,{children:"Each attribute will be new'd up for each test, so you are able to store state within the fields of your attribute class."}),"\n",(0,r.jsxs)(t.p,{children:["The ",(0,r.jsx)(t.code,{children:"[ClassDataSource<T>]"})," uses these events to do the following:"]}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"On Test Register > Increment Counts for Various Types (Global, Keyed, etc.)"}),"\n",(0,r.jsxs)(t.li,{children:["On Test Start > Initialise any objects if they have the ",(0,r.jsx)(t.code,{children:"IAsyncInitializer"})," interface"]}),"\n",(0,r.jsx)(t.li,{children:"On Test End > If the object isn't shared, dispose it. Otherwise, decrement the count for the type."}),"\n",(0,r.jsx)(t.li,{children:"On Last Test for Class > Dispose the object being used to inject into that specific class"}),"\n",(0,r.jsx)(t.li,{children:"On Last Test for Assembly > Dispose the object being used to inject into that specific assembly"}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:"Here's a simple Dependency Injection Class Constructor class subscribing to the TestEnd event in order to dispose the service scope when the test is finished:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-csharp",children:"public class DependencyInjectionClassConstructor : IClassConstructor, ITestEndEventReceiver\n{\n    private readonly IServiceProvider _serviceProvider = CreateServiceProvider();\n    private AsyncServiceScope _scope;\n\n    public Task<object> Create([DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicConstructors)] Type type, ClassConstructorMetadata classConstructorMetadata)\n    {\n        _scope = _serviceProvider.CreateAsyncScope();\n\n        var instance = ActivatorUtilities.GetServiceOrCreateInstance(_scope.ServiceProvider, type);\n        return Task.FromResult(instance);\n    }\n\n    public ValueTask OnTestEnd(TestContext testContext)\n    {\n        return _scope.DisposeAsync();\n    }\n\n    private static IServiceProvider CreateServiceProvider()\n    {\n        return new ServiceCollection()\n            .AddTransient<Class1>()\n            .AddTransient<Class2>()\n            .AddTransient<Class3>()\n            ...\n            .BuildServiceProvider();\n    }\n}\n"})})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},28453:(e,t,n)=>{n.d(t,{R:()=>c,x:()=>a});var s=n(96540);const r={},i=s.createContext(r);function c(e){const t=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:c(e.components),s.createElement(i.Provider,{value:t},e.children)}}}]);