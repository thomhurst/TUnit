"use strict";(self.webpackChunktunit_docs_site=self.webpackChunktunit_docs_site||[]).push([[4203],{5973:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>o});const s=JSON.parse('{"id":"advanced/test-variants","title":"Test Variants","description":"Test variants enable you to dynamically create additional test cases during test execution based on runtime results. This powerful feature unlocks advanced testing patterns like property-based testing shrinking, mutation testing, adaptive stress testing, and intelligent retry strategies.","source":"@site/docs/advanced/test-variants.md","sourceDirName":"advanced","slug":"/advanced/test-variants","permalink":"/docs/advanced/test-variants","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"docs","previous":{"title":"Extension Points","permalink":"/docs/advanced/extension-points"},"next":{"title":"Data Source Generators","permalink":"/docs/customization-extensibility/data-source-generators"}}');var i=t(4848),r=t(8453);const a={},l="Test Variants",c={},o=[{value:"What Are Test Variants?",id:"what-are-test-variants",level:2},{value:"Test Variants vs Dynamic Tests",id:"test-variants-vs-dynamic-tests",level:3},{value:"Core Concepts",id:"core-concepts",level:2},{value:"TestRelationship Enum",id:"testrelationship-enum",level:3},{value:"DisplayName Parameter",id:"displayname-parameter",level:3},{value:"Properties Dictionary",id:"properties-dictionary",level:3},{value:"Use Cases",id:"use-cases",level:2},{value:"1. Property-Based Testing (PBT) - Shrinking",id:"1-property-based-testing-pbt---shrinking",level:3},{value:"2. Mutation Testing",id:"2-mutation-testing",level:3},{value:"3. Adaptive Stress Testing",id:"3-adaptive-stress-testing",level:3},{value:"4. Exploratory Fuzzing",id:"4-exploratory-fuzzing",level:3},{value:"5. Smart Retry with Parameter Adjustment",id:"5-smart-retry-with-parameter-adjustment",level:3},{value:"6. Chaos Engineering",id:"6-chaos-engineering",level:3},{value:"API Reference",id:"api-reference",level:2},{value:"Method Signature",id:"method-signature",level:3},{value:"Parameters",id:"parameters",level:3},{value:"Return Value",id:"return-value",level:3},{value:"Exceptions",id:"exceptions",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"1. Choose Appropriate TestRelationship",id:"1-choose-appropriate-testrelationship",level:3},{value:"2. Provide Descriptive Display Names",id:"2-provide-descriptive-display-names",level:3},{value:"3. Avoid Infinite Recursion",id:"3-avoid-infinite-recursion",level:3},{value:"4. Use Properties for Metadata",id:"4-use-properties-for-metadata",level:3},{value:"5. Consider Performance",id:"5-consider-performance",level:3},{value:"Limitations",id:"limitations",level:2},{value:"See Also",id:"see-also",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"test-variants",children:"Test Variants"})}),"\n",(0,i.jsx)(n.p,{children:"Test variants enable you to dynamically create additional test cases during test execution based on runtime results. This powerful feature unlocks advanced testing patterns like property-based testing shrinking, mutation testing, adaptive stress testing, and intelligent retry strategies."}),"\n",(0,i.jsx)(n.h2,{id:"what-are-test-variants",children:"What Are Test Variants?"}),"\n",(0,i.jsxs)(n.p,{children:["Test variants are tests that are created ",(0,i.jsx)(n.strong,{children:"during the execution"})," of a parent test, inheriting the parent's test method template but potentially using different arguments, properties, or display names. They appear as distinct tests in the test explorer and can have their own outcomes."]}),"\n",(0,i.jsx)(n.h3,{id:"test-variants-vs-dynamic-tests",children:"Test Variants vs Dynamic Tests"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Feature"}),(0,i.jsxs)(n.th,{children:["Test Variants (",(0,i.jsx)(n.code,{children:"CreateTestVariant"}),")"]}),(0,i.jsxs)(n.th,{children:["Dynamic Tests (",(0,i.jsx)(n.code,{children:"AddDynamicTest"}),")"]})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Created"})}),(0,i.jsx)(n.td,{children:"During test execution"}),(0,i.jsx)(n.td,{children:"During test discovery"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Parent"})}),(0,i.jsx)(n.td,{children:"Always has a parent test"}),(0,i.jsx)(n.td,{children:"Standalone tests"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Template"})}),(0,i.jsx)(n.td,{children:"Reuses parent's test method"}),(0,i.jsx)(n.td,{children:"Requires explicit method definition"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Use Case"})}),(0,i.jsx)(n.td,{children:"Runtime adaptation (shrinking, mutation, stress)"}),(0,i.jsx)(n.td,{children:"Pre-generation of test cases"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"AOT Compatible"})}),(0,i.jsx)(n.td,{children:"No (requires reflection)"}),(0,i.jsx)(n.td,{children:"Yes (with source generators)"})]})]})]}),"\n",(0,i.jsx)(n.h2,{id:"core-concepts",children:"Core Concepts"}),"\n",(0,i.jsx)(n.h3,{id:"testrelationship-enum",children:"TestRelationship Enum"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"TestRelationship"})," enum categorizes how a variant relates to its parent, informing the test runner about execution semantics:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:"public enum TestRelationship\n{\n    None,       // Independent test (no parent)\n    Retry,      // Identical re-run after failure\n    Generated,  // Pre-execution exploration (e.g., initial PBT cases)\n    Derived     // Post-execution analysis (e.g., shrinking, mutation)\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"When to use each:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"Retry"})}),": For identical re-runs, typically handled by ",(0,i.jsx)(n.code,{children:"[Retry]"})," attribute"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"Generated"})}),": For upfront test case generation before execution"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"Derived"})}),": For runtime analysis based on parent results (most common for variants)"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"displayname-parameter",children:"DisplayName Parameter"}),"\n",(0,i.jsxs)(n.p,{children:["The optional ",(0,i.jsx)(n.code,{children:"displayName"})," parameter provides user-facing labels in test explorers and reports. While the ",(0,i.jsx)(n.code,{children:"TestRelationship"})," informs the framework about execution semantics, ",(0,i.jsx)(n.code,{children:"displayName"})," communicates intent to humans:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:'await context.CreateTestVariant(\n    arguments: new object[] { smallerInput },\n    relationship: TestRelationship.Derived,\n    displayName: "Shrink Attempt #3"  // Shows in test explorer\n);\n'})}),"\n",(0,i.jsx)(n.h3,{id:"properties-dictionary",children:"Properties Dictionary"}),"\n",(0,i.jsx)(n.p,{children:"Store metadata for filtering, reporting, or variant logic:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:'await context.CreateTestVariant(\n    arguments: new object[] { mutatedValue },\n    properties: new Dictionary<string, object?>\n    {\n        { "AttemptNumber", 3 },\n        { "ShrinkStrategy", "Binary" },\n        { "OriginalValue", originalInput }\n    },\n    relationship: TestRelationship.Derived,\n    displayName: "Shrink #3 (Binary)"\n);\n'})}),"\n",(0,i.jsx)(n.h2,{id:"use-cases",children:"Use Cases"}),"\n",(0,i.jsx)(n.h3,{id:"1-property-based-testing-pbt---shrinking",children:"1. Property-Based Testing (PBT) - Shrinking"}),"\n",(0,i.jsxs)(n.p,{children:["When a property-based test fails with a complex input, create variants with progressively simpler inputs to find the minimal failing case. Use a custom attribute implementing ",(0,i.jsx)(n.code,{children:"ITestEndEventReceiver"})," to automatically shrink on failure:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:'// Custom attribute that shrinks inputs on test failure\npublic class ShrinkOnFailureAttribute : Attribute, ITestEndEventReceiver\n{\n    private readonly int _maxAttempts;\n\n    public ShrinkOnFailureAttribute(int maxAttempts = 5)\n    {\n        _maxAttempts = maxAttempts;\n    }\n\n    public async ValueTask OnTestEnd(TestContext testContext)\n    {\n        // Only shrink if test failed and it\'s not already a shrink attempt\n        if (testContext.Result?.Status != TestStatus.Failed)\n            return;\n\n        if (testContext.Relationship == TestRelationship.Derived)\n            return; // Don\'t shrink shrink attempts\n\n        // Get the test\'s numeric argument to shrink\n        var args = testContext.TestDetails.TestMethodArguments;\n        if (args.Length == 0 || args[0] is not int size)\n            return;\n\n        if (size <= 1)\n            return; // Can\'t shrink further\n\n        // Create shrink variants\n        var shrinkSize = size / 2;\n        for (int attempt = 1; attempt <= _maxAttempts && shrinkSize > 0; attempt++)\n        {\n            await testContext.CreateTestVariant(\n                arguments: new object[] { shrinkSize },\n                properties: new Dictionary<string, object?>\n                {\n                    { "AttemptNumber", attempt },\n                    { "OriginalSize", size },\n                    { "ShrinkStrategy", "Binary" }\n                },\n                relationship: TestRelationship.Derived,\n                displayName: $"Shrink #{attempt} (size={shrinkSize})"\n            );\n\n            shrinkSize /= 2;\n        }\n    }\n}\n\n// Usage: Just add the attribute - shrinking happens automatically on failure\n[Test]\n[ShrinkOnFailure(maxAttempts: 5)]\n[Arguments(1000)]\n[Arguments(500)]\n[Arguments(100)]\npublic async Task PropertyTest_ListReversal(int size)\n{\n    var list = Enumerable.Range(0, size).ToList();\n\n    // Property: reversing twice should return original\n    var reversed = list.Reverse().Reverse().ToList();\n    await Assert.That(reversed).IsEquivalentTo(list);\n\n    // If this fails, the attribute automatically creates shrink variants\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Why this pattern is better:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Separation of concerns"}),": Test logic stays clean, shrinking is in the attribute"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Reusable"}),": Apply ",(0,i.jsx)(n.code,{children:"[ShrinkOnFailure]"})," to any test with numeric inputs"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Declarative"}),": Intent is clear from the attribute"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Automatic"}),": No try-catch or manual failure detection needed"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"2-mutation-testing",children:"2. Mutation Testing"}),"\n",(0,i.jsx)(n.p,{children:"Create variants that test your test's ability to catch bugs by introducing controlled mutations:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:'[Test]\n[Arguments(5, 10)]\npublic async Task CalculatorTest_Addition(int a, int b)\n{\n    var context = TestContext.Current!;\n    var calculator = new Calculator();\n\n    var result = calculator.Add(a, b);\n    await Assert.That(result).IsEqualTo(a + b);\n\n    // After test passes, create mutants to verify test quality\n    var mutations = new[]\n    {\n        (a + 1, b, "Mutant: Boundary +1 on first arg"),\n        (a, b + 1, "Mutant: Boundary +1 on second arg"),\n        (a - 1, b, "Mutant: Boundary -1 on first arg"),\n        (0, 0, "Mutant: Zero case")\n    };\n\n    foreach (var (mutA, mutB, name) in mutations)\n    {\n        await context.CreateTestVariant(\n            arguments: new object[] { mutA, mutB },\n            relationship: TestRelationship.Derived,\n            displayName: name\n        );\n    }\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"3-adaptive-stress-testing",children:"3. Adaptive Stress Testing"}),"\n",(0,i.jsx)(n.p,{children:"Progressively increase load based on system performance:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:'[Test]\n[Arguments(10)] // Start with low load\npublic async Task LoadTest_ApiEndpoint(int concurrentUsers)\n{\n    var context = TestContext.Current!;\n    var stopwatch = Stopwatch.StartNew();\n\n    // Simulate load\n    var tasks = Enumerable.Range(0, concurrentUsers)\n        .Select(_ => CallApiAsync())\n        .ToArray();\n\n    await Task.WhenAll(tasks);\n    stopwatch.Stop();\n\n    var avgResponseTime = stopwatch.ElapsedMilliseconds / (double)concurrentUsers;\n    context.WriteLine($"Users: {concurrentUsers}, Avg response: {avgResponseTime}ms");\n\n    // If system handled load well, increase it\n    if (avgResponseTime < 200 && concurrentUsers < 1000)\n    {\n        var nextLoad = concurrentUsers * 2;\n        await context.CreateTestVariant(\n            arguments: new object[] { nextLoad },\n            properties: new Dictionary<string, object?>\n            {\n                { "PreviousLoad", concurrentUsers },\n                { "PreviousAvgResponseTime", avgResponseTime }\n            },\n            relationship: TestRelationship.Derived,\n            displayName: $"Load Test ({nextLoad} users)"\n        );\n    }\n\n    await Assert.That(avgResponseTime).IsLessThan(500);\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"4-exploratory-fuzzing",children:"4. Exploratory Fuzzing"}),"\n",(0,i.jsx)(n.p,{children:"Generate additional test cases when edge cases are discovered:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:'[Test]\n[Arguments("normal text")]\npublic async Task InputValidation_SpecialCharacters(string input)\n{\n    var context = TestContext.Current!;\n    var validator = new InputValidator();\n\n    var result = validator.Validate(input);\n    await Assert.That(result.IsValid).IsTrue();\n\n    // If we haven\'t tested special characters yet, generate variants\n    if (!context.ObjectBag.ContainsKey("TestedSpecialChars"))\n    {\n        context.ObjectBag["TestedSpecialChars"] = true;\n\n        var specialInputs = new[]\n        {\n            "<script>alert(\'xss\')<\/script>",\n            "\'; DROP TABLE users; --",\n            "../../../etc/passwd",\n            "\\0\\0\\0null bytes\\0",\n            new string(\'A\', 10000) // Buffer overflow attempt\n        };\n\n        foreach (var specialInput in specialInputs)\n        {\n            await context.CreateTestVariant(\n                arguments: new object[] { specialInput },\n                relationship: TestRelationship.Derived,\n                displayName: $"Fuzz: {specialInput.Substring(0, Math.Min(30, specialInput.Length))}"\n            );\n        }\n    }\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"5-smart-retry-with-parameter-adjustment",children:"5. Smart Retry with Parameter Adjustment"}),"\n",(0,i.jsx)(n.p,{children:"Retry failed tests with adjusted parameters to differentiate transient failures from persistent bugs:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:'[Test]\n[Arguments(TimeSpan.FromSeconds(5))]\npublic async Task ExternalService_WithTimeout(TimeSpan timeout)\n{\n    var context = TestContext.Current!;\n\n    try\n    {\n        using var cts = new CancellationTokenSource(timeout);\n        var result = await _externalService.FetchDataAsync(cts.Token);\n        await Assert.That(result).IsNotNull();\n    }\n    catch (TimeoutException ex)\n    {\n        // If timeout, try with longer timeout to see if it\'s a transient issue\n        if (timeout < TimeSpan.FromSeconds(30))\n        {\n            var longerTimeout = timeout.Add(TimeSpan.FromSeconds(5));\n\n            await context.CreateTestVariant(\n                arguments: new object[] { longerTimeout },\n                properties: new Dictionary<string, object?>\n                {\n                    { "OriginalTimeout", timeout },\n                    { "RetryReason", "Timeout" }\n                },\n                relationship: TestRelationship.Derived,\n                displayName: $"Retry with {longerTimeout.TotalSeconds}s timeout"\n            );\n        }\n\n        throw;\n    }\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"6-chaos-engineering",children:"6. Chaos Engineering"}),"\n",(0,i.jsx)(n.p,{children:"Inject faults and verify system resilience:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:'[Test]\npublic async Task Resilience_DatabaseFailover()\n{\n    var context = TestContext.Current!;\n    var system = new DistributedSystem();\n\n    // Normal operation test\n    var result = await system.ProcessRequestAsync();\n    await Assert.That(result.Success).IsTrue();\n\n    // Create chaos variants\n    var chaosScenarios = new[]\n    {\n        ("primary-db-down", "Primary DB Failure"),\n        ("network-latency-500ms", "High Network Latency"),\n        ("replica-lag-10s", "Replica Lag"),\n        ("cascading-failure", "Cascading Failure")\n    };\n\n    foreach (var (faultType, displayName) in chaosScenarios)\n    {\n        await context.CreateTestVariant(\n            arguments: new object[] { faultType },\n            properties: new Dictionary<string, object?>\n            {\n                { "ChaosType", faultType },\n                { "InjectionPoint", "AfterSuccess" }\n            },\n            relationship: TestRelationship.Derived,\n            displayName: $"Chaos: {displayName}"\n        );\n    }\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"api-reference",children:"API Reference"}),"\n",(0,i.jsx)(n.h3,{id:"method-signature",children:"Method Signature"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:"public static async Task CreateTestVariant(\n    this TestContext context,\n    object?[]? arguments = null,\n    Dictionary<string, object?>? properties = null,\n    TestRelationship relationship = TestRelationship.Derived,\n    string? displayName = null)\n"})}),"\n",(0,i.jsx)(n.h3,{id:"parameters",children:"Parameters"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Parameter"}),(0,i.jsx)(n.th,{children:"Type"}),(0,i.jsx)(n.th,{children:"Required"}),(0,i.jsx)(n.th,{children:"Default"}),(0,i.jsx)(n.th,{children:"Description"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"context"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"TestContext"})}),(0,i.jsx)(n.td,{children:"Yes"}),(0,i.jsx)(n.td,{children:"-"}),(0,i.jsx)(n.td,{children:"The current test context"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"arguments"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"object?[]?"})}),(0,i.jsx)(n.td,{children:"No"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"null"})}),(0,i.jsxs)(n.td,{children:["Method arguments for the variant. If ",(0,i.jsx)(n.code,{children:"null"}),", reuses parent's arguments"]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"properties"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"Dictionary<string, object?>?"})}),(0,i.jsx)(n.td,{children:"No"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"null"})}),(0,i.jsxs)(n.td,{children:["Custom metadata stored in the variant's ",(0,i.jsx)(n.code,{children:"TestContext.ObjectBag"})]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"relationship"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"TestRelationship"})}),(0,i.jsx)(n.td,{children:"No"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"Derived"})}),(0,i.jsx)(n.td,{children:"Categorizes the variant's relationship to its parent"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"displayName"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"string?"})}),(0,i.jsx)(n.td,{children:"No"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"null"})}),(0,i.jsxs)(n.td,{children:["User-facing label shown in test explorers. If ",(0,i.jsx)(n.code,{children:"null"}),", uses default format"]})]})]})]}),"\n",(0,i.jsx)(n.h3,{id:"return-value",children:"Return Value"}),"\n",(0,i.jsxs)(n.p,{children:["Returns ",(0,i.jsx)(n.code,{children:"Task"})," that completes when the variant has been queued for execution."]}),"\n",(0,i.jsx)(n.h3,{id:"exceptions",children:"Exceptions"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"InvalidOperationException"}),": Thrown if ",(0,i.jsx)(n.code,{children:"TestContext.Current"})," is null"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"InvalidOperationException"}),": Thrown if the test method cannot be resolved"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,i.jsx)(n.h3,{id:"1-choose-appropriate-testrelationship",children:"1. Choose Appropriate TestRelationship"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:'// \u2705 Good: Derived for post-execution analysis\nawait context.CreateTestVariant(\n    arguments: [smallerInput],\n    relationship: TestRelationship.Derived,\n    displayName: "Shrink Attempt"\n);\n\n// \u274c Bad: Using None loses parent relationship\nawait context.CreateTestVariant(\n    arguments: [smallerInput],\n    relationship: TestRelationship.None  // Parent link lost!\n);\n'})}),"\n",(0,i.jsx)(n.h3,{id:"2-provide-descriptive-display-names",children:"2. Provide Descriptive Display Names"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:'// \u2705 Good: Clear, specific, actionable\ndisplayName: "Shrink #3 (Binary Search, size=125)"\n\n// \u26a0\ufe0f Okay: Somewhat clear\ndisplayName: "Shrink Attempt 3"\n\n// \u274c Bad: Vague, unhelpful\ndisplayName: "Variant"\n'})}),"\n",(0,i.jsx)(n.h3,{id:"3-avoid-infinite-recursion",children:"3. Avoid Infinite Recursion"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:'[Test]\npublic async Task RecursiveVariant()\n{\n    var context = TestContext.Current!;\n\n    // \u2705 Good: Check depth\n    var depth = context.ObjectBag.TryGetValue("Depth", out var d) ? (int)d : 0;\n    if (depth < 5)\n    {\n        await context.CreateTestVariant(\n            properties: new Dictionary<string, object?> { { "Depth", depth + 1 } },\n            relationship: TestRelationship.Derived\n        );\n    }\n\n    // \u274c Bad: Infinite loop!\n    // await context.CreateTestVariant(relationship: TestRelationship.Derived);\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"4-use-properties-for-metadata",children:"4. Use Properties for Metadata"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:'// \u2705 Good: Structured metadata\nproperties: new Dictionary<string, object?>\n{\n    { "AttemptNumber", 3 },\n    { "Strategy", "BinarySearch" },\n    { "OriginalValue", largeInput },\n    { "Timestamp", DateTime.UtcNow }\n}\n\n// \u274c Bad: Encoding metadata in displayName\ndisplayName: "Attempt=3,Strategy=Binary,Original=1000,Time=2024-01-01"\n'})}),"\n",(0,i.jsx)(n.h3,{id:"5-consider-performance",children:"5. Consider Performance"}),"\n",(0,i.jsx)(n.p,{children:"Creating many variants has overhead. Be strategic:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:"// \u2705 Good: Limited, strategic variants\nif (shouldShrink && attemptCount < 10)\n{\n    await context.CreateTestVariant(...);\n}\n\n// \u274c Bad: Explosion of variants\nfor (int i = 0; i < 10000; i++)  // Creates 10,000 tests!\n{\n    await context.CreateTestVariant(...);\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"limitations",children:"Limitations"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Not AOT Compatible"}),": Test variants require runtime reflection and expression compilation"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Requires Reflection Mode"}),": Must run with reflection-based discovery (not source-generated)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Performance Overhead"}),": Each variant is a full test execution with its own lifecycle"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"No Source Generator Support"}),": Cannot be used in AOT-compiled scenarios"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"see-also",children:"See Also"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/docs/test-lifecycle/test-context",children:"Test Context"})," - Understanding TestContext and ObjectBag"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/docs/experimental/dynamic-tests",children:"Dynamic Tests"})," - Pre-execution test generation"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/docs/execution/retrying",children:"Retrying"})," - Built-in retry mechanism comparison"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/docs/test-lifecycle/properties",children:"Properties"})," - Test metadata and custom properties"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/docs/test-lifecycle/event-subscribing",children:"Event Subscribing"})," - Test lifecycle event receivers"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>l});var s=t(6540);const i={},r=s.createContext(i);function a(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);