"use strict";(self.webpackChunktunit_docs_site=self.webpackChunktunit_docs_site||[]).push([[1463],{1165:(e,s,t)=>{t.r(s),t.d(s,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>r,metadata:()=>n,toc:()=>c});const n=JSON.parse('{"id":"migration/mstest","title":"Migrating from MSTest","description":"Using TUnit\'s Code Fixers","source":"@site/docs/migration/mstest.md","sourceDirName":"migration","slug":"/migration/mstest","permalink":"/docs/migration/mstest","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"docs","previous":{"title":"Migrating from NUnit","permalink":"/docs/migration/nunit"},"next":{"title":"Dynamically Created Tests","permalink":"/docs/experimental/dynamic-tests"}}');var i=t(4848),a=t(8453);const r={},l="Migrating from MSTest",o={},c=[{value:"Using TUnit&#39;s Code Fixers",id:"using-tunits-code-fixers",level:2},{value:"Steps",id:"steps",level:3},{value:"Install the TUnit packages to your test projects",id:"install-the-tunit-packages-to-your-test-projects",level:4},{value:"Remove the automatically added global usings",id:"remove-the-automatically-added-global-usings",level:4},{value:"Rebuild the project",id:"rebuild-the-project",level:4},{value:"Run the code fixer via the dotnet CLI",id:"run-the-code-fixer-via-the-dotnet-cli",level:4},{value:"Revert step <code>Remove the automatically added global usings</code>",id:"revert-step-remove-the-automatically-added-global-usings",level:4},{value:"Perform any manual bits that are still necessary",id:"perform-any-manual-bits-that-are-still-necessary",level:4},{value:"Remove the MSTest packages",id:"remove-the-mstest-packages",level:4},{value:"Done! (Hopefully)",id:"done-hopefully",level:4},{value:"Manual Migration Guide",id:"manual-migration-guide",level:2},{value:"Test Attributes",id:"test-attributes",level:3},{value:"Setup and Teardown",id:"setup-and-teardown",level:3},{value:"Assertions",id:"assertions",level:3},{value:"Basic Assertions",id:"basic-assertions",level:4},{value:"Reference Assertions",id:"reference-assertions",level:4},{value:"Type Assertions",id:"type-assertions",level:4},{value:"Collection Assertions",id:"collection-assertions",level:3},{value:"String Assertions",id:"string-assertions",level:3},{value:"Exception Testing",id:"exception-testing",level:3},{value:"Test Data Sources",id:"test-data-sources",level:3},{value:"DataRow",id:"datarow",level:4},{value:"DynamicData",id:"dynamicdata",level:4},{value:"TestContext Usage",id:"testcontext-usage",level:3},{value:"Assert.Fail",id:"assertfail",level:3},{value:"Inconclusive Tests",id:"inconclusive-tests",level:3},{value:"Key Differences to Note",id:"key-differences-to-note",level:2}];function d(e){const s={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s.header,{children:(0,i.jsx)(s.h1,{id:"migrating-from-mstest",children:"Migrating from MSTest"})}),"\n",(0,i.jsx)(s.h2,{id:"using-tunits-code-fixers",children:"Using TUnit's Code Fixers"}),"\n",(0,i.jsx)(s.p,{children:"TUnit has code fixers to help automate the migration from MSTest to TUnit."}),"\n",(0,i.jsx)(s.p,{children:"These code fixers will handle most common scenarios, but you'll likely still need to do some manual adjustments. If you encounter issues or have suggestions for improvements, please raise an issue."}),"\n",(0,i.jsx)(s.h3,{id:"steps",children:"Steps"}),"\n",(0,i.jsx)(s.h4,{id:"install-the-tunit-packages-to-your-test-projects",children:"Install the TUnit packages to your test projects"}),"\n",(0,i.jsx)(s.p,{children:"Use your IDE or the dotnet CLI to add the TUnit packages to your test projects"}),"\n",(0,i.jsx)(s.h4,{id:"remove-the-automatically-added-global-usings",children:"Remove the automatically added global usings"}),"\n",(0,i.jsx)(s.p,{children:"In your csproj add:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-xml",children:"    <PropertyGroup>\n        <TUnitImplicitUsings>false</TUnitImplicitUsings>\n        <TUnitAssertionsImplicitUsings>false</TUnitAssertionsImplicitUsings>\n    </PropertyGroup>\n"})}),"\n",(0,i.jsx)(s.p,{children:"This is temporary - Just to make sure no types clash, and so the code fixers can distinguish between MSTest and TUnit types with similar names."}),"\n",(0,i.jsx)(s.h4,{id:"rebuild-the-project",children:"Rebuild the project"}),"\n",(0,i.jsx)(s.p,{children:"This ensures the TUnit packages have been restored and the analyzers should be loaded."}),"\n",(0,i.jsx)(s.h4,{id:"run-the-code-fixer-via-the-dotnet-cli",children:"Run the code fixer via the dotnet CLI"}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.code,{children:"dotnet format analyzers --severity info --diagnostics TUMS0001"})}),"\n",(0,i.jsxs)(s.h4,{id:"revert-step-remove-the-automatically-added-global-usings",children:["Revert step ",(0,i.jsx)(s.code,{children:"Remove the automatically added global usings"})]}),"\n",(0,i.jsx)(s.h4,{id:"perform-any-manual-bits-that-are-still-necessary",children:"Perform any manual bits that are still necessary"}),"\n",(0,i.jsx)(s.p,{children:"Review the converted code and make any necessary manual adjustments.\nRaise an issue if you think something could be automated."}),"\n",(0,i.jsx)(s.h4,{id:"remove-the-mstest-packages",children:"Remove the MSTest packages"}),"\n",(0,i.jsx)(s.p,{children:"Simply uninstall them once you've migrated"}),"\n",(0,i.jsx)(s.h4,{id:"done-hopefully",children:"Done! (Hopefully)"}),"\n",(0,i.jsx)(s.h2,{id:"manual-migration-guide",children:"Manual Migration Guide"}),"\n",(0,i.jsx)(s.h3,{id:"test-attributes",children:"Test Attributes"}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"[TestClass]"})," - Remove this attribute (not needed in TUnit)"]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"[TestMethod]"})," becomes ",(0,i.jsx)(s.code,{children:"[Test]"})]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"[DataRow]"})," becomes ",(0,i.jsx)(s.code,{children:"[Arguments]"})]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"[DynamicData]"})," becomes ",(0,i.jsx)(s.code,{children:"[MethodDataSource]"})]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"[TestCategory]"})," becomes ",(0,i.jsx)(s.code,{children:'[Property("Category", "value")]'})]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"[Ignore]"})," becomes ",(0,i.jsx)(s.code,{children:"[Skip]"})]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"[Priority]"})," becomes ",(0,i.jsx)(s.code,{children:'[Property("Priority", "value")]'})]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"[Owner]"})," becomes ",(0,i.jsx)(s.code,{children:'[Property("Owner", "value")]'})]}),"\n",(0,i.jsx)(s.h3,{id:"setup-and-teardown",children:"Setup and Teardown"}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"[TestInitialize]"})," becomes ",(0,i.jsx)(s.code,{children:"[Before(HookType.Test)]"})]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"[TestCleanup]"})," becomes ",(0,i.jsx)(s.code,{children:"[After(HookType.Test)]"})]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"[ClassInitialize]"})," becomes ",(0,i.jsx)(s.code,{children:"[Before(HookType.Class)]"})," and remove the TestContext parameter"]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"[ClassCleanup]"})," becomes ",(0,i.jsx)(s.code,{children:"[After(HookType.Class)]"})]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"[AssemblyInitialize]"})," becomes ",(0,i.jsx)(s.code,{children:"[Before(HookType.Assembly)]"})," and remove the TestContext parameter"]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"[AssemblyCleanup]"})," becomes ",(0,i.jsx)(s.code,{children:"[After(HookType.Assembly)]"})]}),"\n",(0,i.jsx)(s.h3,{id:"assertions",children:"Assertions"}),"\n",(0,i.jsx)(s.h4,{id:"basic-assertions",children:"Basic Assertions"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-csharp",children:"// MSTest\nAssert.AreEqual(expected, actual);\nAssert.AreNotEqual(expected, actual);\nAssert.IsTrue(condition);\nAssert.IsFalse(condition);\nAssert.IsNull(value);\nAssert.IsNotNull(value);\n\n// TUnit\nawait Assert.That(actual).IsEqualTo(expected);\nawait Assert.That(actual).IsNotEqualTo(expected);\nawait Assert.That(condition).IsTrue();\nawait Assert.That(condition).IsFalse();\nawait Assert.That(value).IsNull();\nawait Assert.That(value).IsNotNull();\n"})}),"\n",(0,i.jsx)(s.h4,{id:"reference-assertions",children:"Reference Assertions"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-csharp",children:"// MSTest\nAssert.AreSame(expected, actual);\nAssert.AreNotSame(expected, actual);\n\n// TUnit\nawait Assert.That(actual).IsSameReference(expected);\nawait Assert.That(actual).IsNotSameReference(expected);\n"})}),"\n",(0,i.jsx)(s.h4,{id:"type-assertions",children:"Type Assertions"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-csharp",children:"// MSTest\nAssert.IsInstanceOfType(value, typeof(string));\nAssert.IsNotInstanceOfType(value, typeof(int));\n\n// TUnit\nawait Assert.That(value).IsAssignableTo<string>();\nawait Assert.That(value).IsNotAssignableTo<int>();\n"})}),"\n",(0,i.jsx)(s.h3,{id:"collection-assertions",children:"Collection Assertions"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-csharp",children:"// MSTest\nCollectionAssert.AreEqual(expected, actual);\nCollectionAssert.AreNotEqual(expected, actual);\nCollectionAssert.Contains(collection, item);\nCollectionAssert.DoesNotContain(collection, item);\nCollectionAssert.AllItemsAreNotNull(collection);\n\n// TUnit\nawait Assert.That(actual).IsEquivalentTo(expected);\nawait Assert.That(actual).IsNotEquivalentTo(expected);\nawait Assert.That(collection).Contains(item);\nawait Assert.That(collection).DoesNotContain(item);\nawait Assert.That(collection).AllSatisfy(x => x != null);\n"})}),"\n",(0,i.jsx)(s.h3,{id:"string-assertions",children:"String Assertions"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-csharp",children:"// MSTest\nStringAssert.Contains(text, substring);\nStringAssert.StartsWith(text, prefix);\nStringAssert.EndsWith(text, suffix);\nStringAssert.Matches(text, pattern);\n\n// TUnit\nawait Assert.That(text).Contains(substring);\nawait Assert.That(text).StartsWith(prefix);\nawait Assert.That(text).EndsWith(suffix);\nawait Assert.That(text).Matches(pattern);\n"})}),"\n",(0,i.jsx)(s.h3,{id:"exception-testing",children:"Exception Testing"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-csharp",children:"// MSTest\nAssert.ThrowsException<InvalidOperationException>(() => DoSomething());\nawait Assert.ThrowsExceptionAsync<InvalidOperationException>(() => DoSomethingAsync());\n\n// TUnit\nawait Assert.ThrowsAsync<InvalidOperationException>(() => DoSomething());\nawait Assert.ThrowsAsync<InvalidOperationException>(() => DoSomethingAsync());\n"})}),"\n",(0,i.jsx)(s.h3,{id:"test-data-sources",children:"Test Data Sources"}),"\n",(0,i.jsx)(s.h4,{id:"datarow",children:"DataRow"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-csharp",children:"// MSTest\n[TestMethod]\n[DataRow(1, 2, 3)]\n[DataRow(10, 20, 30)]\npublic void AdditionTest(int a, int b, int expected)\n{\n    Assert.AreEqual(expected, a + b);\n}\n\n// TUnit\n[Test]\n[Arguments(1, 2, 3)]\n[Arguments(10, 20, 30)]\npublic async Task AdditionTest(int a, int b, int expected)\n{\n    await Assert.That(a + b).IsEqualTo(expected);\n}\n"})}),"\n",(0,i.jsx)(s.h4,{id:"dynamicdata",children:"DynamicData"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-csharp",children:'// MSTest\n[TestMethod]\n[DynamicData(nameof(TestData), DynamicDataSourceType.Method)]\npublic void TestMethod(int value, string text)\n{\n    // Test implementation\n}\n\nprivate static IEnumerable<object[]> TestData()\n{\n    yield return new object[] { 1, "one" };\n    yield return new object[] { 2, "two" };\n}\n\n// TUnit\n[Test]\n[MethodDataSource(nameof(TestData))]\npublic async Task TestMethod(int value, string text)\n{\n    // Test implementation\n}\n\nprivate static IEnumerable<(int, string)> TestData()\n{\n    yield return (1, "one");\n    yield return (2, "two");\n}\n'})}),"\n",(0,i.jsx)(s.h3,{id:"testcontext-usage",children:"TestContext Usage"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-csharp",children:'// MSTest\n[TestClass]\npublic class MyTests\n{\n    public TestContext TestContext { get; set; }\n    \n    [TestMethod]\n    public void MyTest()\n    {\n        TestContext.WriteLine("Test output");\n    }\n    \n    [ClassInitialize]\n    public static void ClassInit(TestContext context)\n    {\n        // Setup code\n    }\n}\n\n// TUnit\npublic class MyTests\n{\n    [Test]\n    public async Task MyTest(TestContext context)\n    {\n        context.OutputWriter.WriteLine("Test output");\n    }\n    \n    [Before(HookType.Class)]\n    public static async Task ClassInit()\n    {\n        // Setup code - no TestContext parameter needed\n    }\n}\n'})}),"\n",(0,i.jsx)(s.h3,{id:"assertfail",children:"Assert.Fail"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-csharp",children:'// MSTest\nAssert.Fail("Test failed with reason");\n\n// TUnit\nAssert.Fail("Test failed with reason");\n'})}),"\n",(0,i.jsx)(s.h3,{id:"inconclusive-tests",children:"Inconclusive Tests"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-csharp",children:'// MSTest\nAssert.Inconclusive("Test is inconclusive");\n\n// TUnit\nSkip.Test("Test is inconclusive");\n'})}),"\n",(0,i.jsx)(s.h2,{id:"key-differences-to-note",children:"Key Differences to Note"}),"\n",(0,i.jsxs)(s.ol,{children:["\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"Async by Default"}),": TUnit tests and assertions are async by default. Add ",(0,i.jsx)(s.code,{children:"async Task"})," to your test methods and ",(0,i.jsx)(s.code,{children:"await"})," assertions."]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"No TestClass Required"}),": TUnit doesn't require a ",(0,i.jsx)(s.code,{children:"[TestClass]"})," attribute on test classes."]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"Fluent Assertions"}),": TUnit uses a fluent assertion style with ",(0,i.jsx)(s.code,{children:"Assert.That()"})," as the starting point."]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"TestContext Changes"}),":"]}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"TestContext is injected as a parameter rather than a property"}),"\n",(0,i.jsx)(s.li,{children:"ClassInitialize and AssemblyInitialize don't receive TestContext parameters"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"Dependency Injection"}),": TUnit has built-in support for dependency injection in test classes and methods."]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"Hooks Instead of Initialize/Cleanup"}),": TUnit uses ",(0,i.jsx)(s.code,{children:"[Before]"})," and ",(0,i.jsx)(s.code,{children:"[After]"})," attributes with ",(0,i.jsx)(s.code,{children:"HookType"})," to specify when they run."]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"Static Class-Level Hooks"}),": Class-level setup and teardown methods should be static in TUnit."]}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:s}={...(0,a.R)(),...e.components};return s?(0,i.jsx)(s,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,s,t)=>{t.d(s,{R:()=>r,x:()=>l});var n=t(6540);const i={},a=n.createContext(i);function r(e){const s=n.useContext(a);return n.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function l(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),n.createElement(a.Provider,{value:s},e.children)}}}]);