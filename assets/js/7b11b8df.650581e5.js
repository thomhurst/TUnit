"use strict";(self.webpackChunktunit_docs_site=self.webpackChunktunit_docs_site||[]).push([[6690],{6711:(e,s,t)=>{t.r(s),t.d(s,{assets:()=>o,contentTitle:()=>l,default:()=>d,frontMatter:()=>a,metadata:()=>n,toc:()=>c});const n=JSON.parse('{"id":"getting-started/writing-your-first-test","title":"Writing your first test","description":"Quick Start: Complete Example","source":"@site/docs/getting-started/writing-your-first-test.md","sourceDirName":"getting-started","slug":"/getting-started/writing-your-first-test","permalink":"/docs/getting-started/writing-your-first-test","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"docs","previous":{"title":"Installing TUnit","permalink":"/docs/getting-started/installation"},"next":{"title":"Running your tests","permalink":"/docs/getting-started/running-your-tests"}}');var i=t(4848),r=t(8453);const a={},l="Writing your first test",o={},c=[{value:"Quick Start: Complete Example",id:"quick-start-complete-example",level:2},{value:"Step-by-Step Guide",id:"step-by-step-guide",level:2},{value:"Test Method Signatures",id:"test-method-signatures",level:2},{value:"Common Test Patterns",id:"common-test-patterns",level:2},{value:"Testing Boolean Returns",id:"testing-boolean-returns",level:3},{value:"Testing with Multiple Assertions",id:"testing-with-multiple-assertions",level:3},{value:"Using Statements",id:"using-statements",level:3}];function u(e){const s={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s.header,{children:(0,i.jsx)(s.h1,{id:"writing-your-first-test",children:"Writing your first test"})}),"\n",(0,i.jsx)(s.h2,{id:"quick-start-complete-example",children:"Quick Start: Complete Example"}),"\n",(0,i.jsx)(s.p,{children:"Here's a complete TUnit test class with all necessary using statements:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-csharp",children:"using TUnit.Assertions;\nusing TUnit.Assertions.Extensions;\nusing TUnit.Core;\n\nnamespace MyTestProject;\n\npublic class CalculatorTests\n{\n    [Test]\n    public async Task Add_WithTwoNumbers_ReturnsSum()\n    {\n        // Arrange\n        var calculator = new Calculator();\n\n        // Act\n        var result = calculator.Add(2, 3);\n\n        // Assert\n        await Assert.That(result).IsEqualTo(5);\n    }\n}\n"})}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"Important"}),": TUnit does ",(0,i.jsx)(s.strong,{children:"not"})," require a ",(0,i.jsx)(s.code,{children:"[TestClass]"})," attribute. Unlike MSTest or NUnit, you only need the ",(0,i.jsx)(s.code,{children:"[Test]"})," attribute on your test methods."]}),"\n",(0,i.jsx)(s.h2,{id:"step-by-step-guide",children:"Step-by-Step Guide"}),"\n",(0,i.jsx)(s.p,{children:"Start by creating a new class:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-csharp",children:"namespace MyTestProject;\n\npublic class MyTestClass\n{\n\n}\n"})}),"\n",(0,i.jsxs)(s.p,{children:["Now add a method with a ",(0,i.jsx)(s.code,{children:"[Test]"})," attribute on it:"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-csharp",children:"using TUnit.Core;\n\nnamespace MyTestProject;\n\npublic class MyTestClass\n{\n    [Test]\n    public async Task MyTest()\n    {\n\n    }\n}\n"})}),"\n",(0,i.jsx)(s.p,{children:"That's it. That is your runnable test."}),"\n",(0,i.jsx)(s.p,{children:"We haven't actually made it do anything yet, but we should be able to build our project and run that test."}),"\n",(0,i.jsx)(s.p,{children:"Tests will pass if they execute successfully without any exceptions."}),"\n",(0,i.jsx)(s.h2,{id:"test-method-signatures",children:"Test Method Signatures"}),"\n",(0,i.jsx)(s.p,{children:"Test methods can be either synchronous or asynchronous:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-csharp",children:"[Test]\npublic void SynchronousTest()  // \u2705 Valid - synchronous test\n{\n    var result = Calculate(2, 3);\n    // Simple synchronous test without assertions\n}\n\n[Test]\npublic async Task AsyncTestWithAssertions()  // \u2705 Recommended - asynchronous test\n{\n    var result = Calculate(2, 3);\n    await Assert.That(result).IsEqualTo(5);  // Assertions must be awaited\n}\n"})}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Important Notes:"})}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["If you use TUnit's assertion library (",(0,i.jsx)(s.code,{children:"Assert.That(...)"}),"), your test ",(0,i.jsx)(s.strong,{children:"must"})," be ",(0,i.jsx)(s.code,{children:"async Task"})," because assertions return awaitable objects that must be awaited to execute"]}),"\n",(0,i.jsxs)(s.li,{children:["Synchronous ",(0,i.jsx)(s.code,{children:"void"})," tests are allowed but cannot use assertions"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"async void"})," tests are ",(0,i.jsx)(s.strong,{children:"not allowed"})," and will cause a compiler error"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Best Practice"}),": Use ",(0,i.jsx)(s.code,{children:"async Task"})," for all tests to enable TUnit's assertion library"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Technical Detail"}),": Assertions return custom assertion builder objects with a ",(0,i.jsx)(s.code,{children:"GetAwaiter()"})," method, making them awaitable"]}),"\n"]}),"\n",(0,i.jsx)(s.p,{children:"Let's add some code to show you how a test might look once finished:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-csharp",children:"using TUnit.Assertions;\nusing TUnit.Assertions.Extensions;\nusing TUnit.Core;\n\nnamespace MyTestProject;\n\npublic class MyTestClass\n{\n    [Test]\n    public async Task MyTest()\n    {\n        var result = Add(1, 2);\n\n        await Assert.That(result).IsEqualTo(3);\n    }\n\n    private int Add(int x, int y)\n    {\n        return x + y;\n    }\n}\n"})}),"\n",(0,i.jsx)(s.p,{children:"Here you can see we've executed some code and added an assertion. We'll go more into that later."}),"\n",(0,i.jsx)(s.h2,{id:"common-test-patterns",children:"Common Test Patterns"}),"\n",(0,i.jsx)(s.h3,{id:"testing-boolean-returns",children:"Testing Boolean Returns"}),"\n",(0,i.jsxs)(s.p,{children:["When testing methods that return boolean values, use ",(0,i.jsx)(s.code,{children:"IsTrue()"})," or ",(0,i.jsx)(s.code,{children:"IsFalse()"}),":"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-csharp",children:"using TUnit.Assertions;\nusing TUnit.Assertions.Extensions;\nusing TUnit.Core;\n\nnamespace MyTestProject;\n\npublic class ValidatorTests\n{\n    [Test]\n    public async Task IsPositive_WithNegativeNumber_ReturnsFalse()\n    {\n        // Arrange & Act\n        var result = Validator.IsPositive(-1);\n\n        // Assert\n        await Assert.That(result).IsFalse();\n    }\n\n    [Test]\n    public async Task IsPositive_WithPositiveNumber_ReturnsTrue()\n    {\n        // Arrange & Act\n        var result = Validator.IsPositive(5);\n\n        // Assert\n        await Assert.That(result).IsTrue();\n    }\n}\n\npublic static class Validator\n{\n    public static bool IsPositive(int number)\n    {\n        return number > 0;\n    }\n}\n"})}),"\n",(0,i.jsx)(s.h3,{id:"testing-with-multiple-assertions",children:"Testing with Multiple Assertions"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-csharp",children:'using TUnit.Assertions;\nusing TUnit.Assertions.Extensions;\nusing TUnit.Core;\n\nnamespace MyTestProject;\n\npublic class StringTests\n{\n    [Test]\n    public async Task ProcessString_WithValidInput_ReturnsExpectedResult()\n    {\n        // Arrange\n        var input = "hello";\n\n        // Act\n        var result = input.ToUpper();\n\n        // Assert\n        await Assert.That(result).IsEqualTo("HELLO");\n        await Assert.That(result).HasLength(5);\n        await Assert.That(result.StartsWith("HE")).IsTrue();\n    }\n}\n'})}),"\n",(0,i.jsx)(s.h3,{id:"using-statements",children:"Using Statements"}),"\n",(0,i.jsx)(s.p,{children:"The examples above show explicit using statements for clarity:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-csharp",children:"using TUnit.Core;                    // For [Test] attribute\nusing TUnit.Assertions;              // For Assert.That()\nusing TUnit.Assertions.Extensions;   // For assertion methods like IsEqualTo(), IsTrue(), etc.\n"})}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"However"}),", the TUnit package automatically configures these namespaces as global usings, so in practice you don't need to include them in each test file. Your test classes can be as simple as:"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-csharp",children:"namespace MyTestProject;\n\npublic class ValidatorTests\n{\n    [Test]\n    public async Task IsPositive_WithNegativeNumber_ReturnsFalse()\n    {\n        var result = Validator.IsPositive(-1);\n        await Assert.That(result).IsFalse();\n    }\n}\n"})})]})}function d(e={}){const{wrapper:s}={...(0,r.R)(),...e.components};return s?(0,i.jsx)(s,{...e,children:(0,i.jsx)(u,{...e})}):u(e)}},8453:(e,s,t)=>{t.d(s,{R:()=>a,x:()=>l});var n=t(6540);const i={},r=n.createContext(i);function a(e){const s=n.useContext(r);return n.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function l(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),n.createElement(r.Provider,{value:s},e.children)}}}]);