"use strict";(self.webpackChunktunit_docs_site=self.webpackChunktunit_docs_site||[]).push([[1278],{8619:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"migration/testcontext-interface-organization","title":"TestContext Interface Organization Migration Guide","description":"Overview","source":"@site/docs/migration/testcontext-interface-organization.md","sourceDirName":"migration","slug":"/migration/testcontext-interface-organization","permalink":"/docs/migration/testcontext-interface-organization","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"docs","previous":{"title":"Migrating from MSTest","permalink":"/docs/migration/mstest"},"next":{"title":"Things to know","permalink":"/docs/test-authoring/things-to-know"}}');var i=n(4848),r=n(8453);const a={},o="TestContext Interface Organization Migration Guide",c={},l=[{value:"Overview",id:"overview",level:2},{value:"What Changed",id:"what-changed",level:2},{value:"New Interface Organization",id:"new-interface-organization",level:3},{value:"Property Reorganization",id:"property-reorganization",level:3},{value:"<code>ITestExecution</code> - Execution State and Lifecycle",id:"itestexecution---execution-state-and-lifecycle",level:4},{value:"<code>ITestMetadata</code> - Test Identity and Metadata",id:"itestmetadata---test-identity-and-metadata",level:4},{value:"<code>ITestEvents</code> - Test Event Integration",id:"itestevents---test-event-integration",level:4},{value:"Migration Steps",id:"migration-steps",level:2},{value:"Direct Property Access",id:"direct-property-access",level:3},{value:"Execution-Related Properties",id:"execution-related-properties",level:4},{value:"Metadata-Related Properties",id:"metadata-related-properties",level:4},{value:"Event Access",id:"event-access",level:4},{value:"Custom Hook Executors",id:"custom-hook-executors",level:3},{value:"Test Registration/Building",id:"test-registrationbuilding",level:3},{value:"Cancellation Token Linking",id:"cancellation-token-linking",level:3},{value:"Benefits of the New Organization",id:"benefits-of-the-new-organization",level:2},{value:"1. Better Discoverability",id:"1-better-discoverability",level:3},{value:"2. Clearer Intent",id:"2-clearer-intent",level:3},{value:"3. Interface Segregation Principle",id:"3-interface-segregation-principle",level:3},{value:"4. Zero-Allocation Design",id:"4-zero-allocation-design",level:3},{value:"Complete Interface Reference",id:"complete-interface-reference",level:2},{value:"ITestExecution",id:"itestexecution",level:3},{value:"ITestMetadata",id:"itestmetadata",level:3},{value:"ITestEvents",id:"itestevents",level:3},{value:"Other Interfaces",id:"other-interfaces",level:3},{value:"ITestOutput",id:"itestoutput",level:4},{value:"ITestParallelization",id:"itestparallelization",level:4},{value:"ITestDependencies",id:"itestdependencies",level:4},{value:"ITestStateBag",id:"iteststatebag",level:4},{value:"Summary",id:"summary",level:2}];function d(e){const t={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"testcontext-interface-organization-migration-guide",children:"TestContext Interface Organization Migration Guide"})}),"\n",(0,i.jsx)(t.h2,{id:"overview",children:"Overview"}),"\n",(0,i.jsxs)(t.p,{children:["TUnit has reorganized the ",(0,i.jsx)(t.code,{children:"TestContext"})," API to provide a cleaner, more discoverable interface structure. Properties and methods are now organized into logical, focused interfaces that group related functionality together."]}),"\n",(0,i.jsxs)(t.p,{children:["This migration guide helps you update code that directly accesses ",(0,i.jsx)(t.code,{children:"TestContext"})," properties to use the new interface-based API."]}),"\n",(0,i.jsx)(t.h2,{id:"what-changed",children:"What Changed"}),"\n",(0,i.jsx)(t.h3,{id:"new-interface-organization",children:"New Interface Organization"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.code,{children:"TestContext"})," now exposes its API through focused interface properties:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-csharp",children:"public partial class TestContext :\n    ITestExecution,\n    ITestParallelization,\n    ITestOutput,\n    ITestMetadata,\n    ITestDependencies,\n    ITestStateBag,\n    ITestEvents\n{\n    // Organized API access through interface properties\n    public ITestExecution Execution => this;\n    public ITestParallelization Parallelism => this;\n    public ITestOutput Output => this;\n    public ITestMetadata Metadata => this;\n    public ITestDependencies Dependencies => this;\n    public ITestStateBag StateBag => this;\n    public ITestEvents Events => this;\n\n    // Note: Services property is internal - use dependency injection instead\n}\n"})}),"\n",(0,i.jsx)(t.h3,{id:"property-reorganization",children:"Property Reorganization"}),"\n",(0,i.jsxs)(t.p,{children:["Several properties have been moved from the main ",(0,i.jsx)(t.code,{children:"TestContext"})," class into their appropriate interfaces:"]}),"\n",(0,i.jsxs)(t.h4,{id:"itestexecution---execution-state-and-lifecycle",children:[(0,i.jsx)(t.code,{children:"ITestExecution"})," - Execution State and Lifecycle"]}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"New members:"})}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"CustomHookExecutor"})," - Custom hook executor for test-level hooks"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"ReportResult"})," - Whether test results should be reported"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"AddLinkedCancellationToken()"})," - Link external cancellation tokens"]}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"Existing members:"})}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"Phase"})," - Current test phase (Discovery, Execution, Cleanup, etc.)"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"Result"})," - Test result after execution completes"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"CancellationToken"})," - Cancellation token for this test"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"TestStart"})," - Test execution start timestamp"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"TestEnd"})," - Test execution end timestamp"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"CurrentRetryAttempt"})," - Current retry attempt number"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"SkipReason"})," - Reason why test was skipped"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"RetryFunc"})," - Retry function for failed tests"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"OverrideResult()"})," - Override test result methods"]}),"\n"]}),"\n",(0,i.jsxs)(t.h4,{id:"itestmetadata---test-identity-and-metadata",children:[(0,i.jsx)(t.code,{children:"ITestMetadata"})," - Test Identity and Metadata"]}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"New member:"})}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"DisplayNameFormatter"})," - Custom display name formatter type"]}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"Existing members:"})}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"TestDetails"})," - Detailed metadata about the test"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"TestName"})," - Base name of the test method"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"DisplayName"})," - Display name for the test (get/set)"]}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Note:"})," ",(0,i.jsx)(t.code,{children:"Id"})," is now a public property directly on ",(0,i.jsx)(t.code,{children:"TestContext"}),", not on ",(0,i.jsx)(t.code,{children:"ITestMetadata"}),"."]}),"\n",(0,i.jsxs)(t.h4,{id:"itestevents---test-event-integration",children:[(0,i.jsx)(t.code,{children:"ITestEvents"})," - Test Event Integration"]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"New interface"})," exposing nullable event properties for lazy initialization:"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"OnDispose"})," - Event raised when test context is disposed"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"OnTestRegistered"})," - Event raised when test is registered"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"OnInitialize"})," - Event raised before test initialization"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"OnTestStart"})," - Event raised before test method execution"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"OnTestEnd"})," - Event raised after test method completion"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"OnTestSkipped"})," - Event raised when test is skipped"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"OnTestRetry"})," - Event raised before test retry"]}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["All events are nullable (",(0,i.jsx)(t.code,{children:"AsyncEvent<T>?"}),") to avoid allocating unused event handlers."]}),"\n",(0,i.jsx)(t.h2,{id:"migration-steps",children:"Migration Steps"}),"\n",(0,i.jsx)(t.h3,{id:"direct-property-access",children:"Direct Property Access"}),"\n",(0,i.jsxs)(t.p,{children:["If you were directly accessing properties on ",(0,i.jsx)(t.code,{children:"TestContext"}),", they now need to be accessed through the appropriate interface property."]}),"\n",(0,i.jsx)(t.h4,{id:"execution-related-properties",children:"Execution-Related Properties"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"Before:"})}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-csharp",children:"// \u274c Old - Direct access\nvar customExecutor = TestContext.Current.CustomHookExecutor;\nTestContext.Current.ReportResult = false;\nTestContext.Current.AddLinkedCancellationToken(externalToken);\n"})}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"After:"})}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-csharp",children:"// \u2705 New - Through Execution interface\nvar customExecutor = TestContext.Current.Execution.CustomHookExecutor;\nTestContext.Current.Execution.ReportResult = false;\nTestContext.Current.Execution.AddLinkedCancellationToken(externalToken);\n"})}),"\n",(0,i.jsx)(t.h4,{id:"metadata-related-properties",children:"Metadata-Related Properties"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"Before:"})}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-csharp",children:"// \u274c Old - Direct access\nvar formatter = TestContext.Current.DisplayNameFormatter;\nTestContext.Current.DisplayNameFormatter = typeof(MyFormatter);\n"})}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"After:"})}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-csharp",children:"// \u2705 New - Through Metadata interface\nvar formatter = TestContext.Current.Metadata.DisplayNameFormatter;\nTestContext.Current.Metadata.DisplayNameFormatter = typeof(MyFormatter);\n"})}),"\n",(0,i.jsx)(t.h4,{id:"event-access",children:"Event Access"}),"\n",(0,i.jsxs)(t.p,{children:["Events are now accessed directly through the ",(0,i.jsx)(t.code,{children:"Events"})," interface property, and all events are nullable for lazy initialization:"]}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"Before:"})}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-csharp",children:"// \u274c Old - Accessing through a nested Events property\nTestContext.Current.Events.OnTestStart += handler;\n"})}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"After:"})}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-csharp",children:"// \u2705 New - Direct access to nullable event properties\nTestContext.Current.Events.OnTestStart += handler;\n\n// Events are nullable and lazily initialized\nif (TestContext.Current.Events.OnTestStart != null)\n{\n    await TestContext.Current.Events.OnTestStart.InvokeAsync(testContext, testContext);\n}\n"})}),"\n",(0,i.jsx)(t.h3,{id:"custom-hook-executors",children:"Custom Hook Executors"}),"\n",(0,i.jsx)(t.p,{children:"If you're implementing custom hook executors that access these properties:"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"Before:"})}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-csharp",children:"public class MyHookExecutor : IHookExecutor\n{\n    public async Task ExecuteAsync(TestContext context, Func<Task> hookBody)\n    {\n        // \u274c Old - Direct property access\n        if (context.ReportResult)\n        {\n            await hookBody();\n        }\n    }\n}\n"})}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"After:"})}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-csharp",children:"public class MyHookExecutor : IHookExecutor\n{\n    public async Task ExecuteAsync(TestContext context, Func<Task> hookBody)\n    {\n        // \u2705 New - Through Execution interface\n        if (context.Execution.ReportResult)\n        {\n            await hookBody();\n        }\n    }\n}\n"})}),"\n",(0,i.jsx)(t.h3,{id:"test-registrationbuilding",children:"Test Registration/Building"}),"\n",(0,i.jsx)(t.p,{children:"If you're setting custom hook executors during test registration:"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"Before:"})}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-csharp",children:"public class CustomTestBuilder\n{\n    public void ConfigureTest(TestContext context)\n    {\n        // \u274c Old - Direct property access\n        context.CustomHookExecutor = new MyCustomExecutor();\n        context.DisplayNameFormatter = typeof(MyFormatter);\n    }\n}\n"})}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"After:"})}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-csharp",children:"public class CustomTestBuilder\n{\n    public void ConfigureTest(TestContext context)\n    {\n        // \u2705 New - Through appropriate interfaces\n        context.Execution.CustomHookExecutor = new MyCustomExecutor();\n        context.Metadata.DisplayNameFormatter = typeof(MyFormatter);\n    }\n}\n"})}),"\n",(0,i.jsx)(t.h3,{id:"cancellation-token-linking",children:"Cancellation Token Linking"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"Before:"})}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-csharp",children:"[Before(HookType.Test)]\npublic void Setup()\n{\n    var externalCts = new CancellationTokenSource();\n\n    // \u274c Old - Direct method call\n    TestContext.Current.AddLinkedCancellationToken(externalCts.Token);\n}\n"})}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"After:"})}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-csharp",children:"[Before(HookType.Test)]\npublic void Setup()\n{\n    var externalCts = new CancellationTokenSource();\n\n    // \u2705 New - Through Execution interface\n    TestContext.Current.Execution.AddLinkedCancellationToken(externalCts.Token);\n}\n"})}),"\n",(0,i.jsx)(t.h2,{id:"benefits-of-the-new-organization",children:"Benefits of the New Organization"}),"\n",(0,i.jsx)(t.h3,{id:"1-better-discoverability",children:"1. Better Discoverability"}),"\n",(0,i.jsx)(t.p,{children:"IntelliSense now groups related functionality together, making it easier to find what you need:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-csharp",children:"TestContext.Current.Execution.  // Shows only execution-related members\nTestContext.Current.Metadata.   // Shows only metadata-related members\nTestContext.Current.Output.     // Shows only output-related members\n"})}),"\n",(0,i.jsx)(t.h3,{id:"2-clearer-intent",children:"2. Clearer Intent"}),"\n",(0,i.jsx)(t.p,{children:"Code that accesses interface-specific properties communicates its intent more clearly:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-csharp",children:'// Clear that we\'re dealing with execution lifecycle\ncontext.Execution.OverrideResult(TestState.Passed, "Mocked result");\n\n// Clear that we\'re configuring metadata\ncontext.Metadata.DisplayName = "Custom Test Name";\n\n// Clear that we\'re working with test output\ncontext.Output.WriteLine("Debug information");\n'})}),"\n",(0,i.jsx)(t.h3,{id:"3-interface-segregation-principle",children:"3. Interface Segregation Principle"}),"\n",(0,i.jsxs)(t.p,{children:["Consumers can depend on specific interfaces instead of the full ",(0,i.jsx)(t.code,{children:"TestContext"}),":"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-csharp",children:"// Before: Depends on entire TestContext\npublic class MyService\n{\n    public void ProcessTest(TestContext context) { }\n}\n\n// After: Depends only on what's needed\npublic class MyService\n{\n    public void ProcessTest(ITestMetadata metadata) { }\n    public void HandleExecution(ITestExecution execution) { }\n}\n"})}),"\n",(0,i.jsx)(t.h3,{id:"4-zero-allocation-design",children:"4. Zero-Allocation Design"}),"\n",(0,i.jsxs)(t.p,{children:["The interface properties return ",(0,i.jsx)(t.code,{children:"this"})," cast to the appropriate interface type, ensuring zero allocation overhead:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-csharp",children:"// No new objects created - just interface casting\nITestExecution execution = testContext.Execution;  // Zero allocations\n"})}),"\n",(0,i.jsx)(t.h2,{id:"complete-interface-reference",children:"Complete Interface Reference"}),"\n",(0,i.jsx)(t.h3,{id:"itestexecution",children:"ITestExecution"}),"\n",(0,i.jsx)(t.p,{children:"Test execution state and lifecycle management:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-csharp",children:"public interface ITestExecution\n{\n    TestPhase Phase { get; }\n    TestResult? Result { get; }\n    CancellationToken CancellationToken { get; }\n    DateTimeOffset? TestStart { get; }\n    DateTimeOffset? TestEnd { get; }\n    int CurrentRetryAttempt { get; }\n    string? SkipReason { get; }\n    Func<TestContext, Exception, int, Task<bool>>? RetryFunc { get; }\n    IHookExecutor? CustomHookExecutor { get; set; }\n    bool ReportResult { get; set; }\n\n    void OverrideResult(string reason);\n    void OverrideResult(TestState state, string reason);\n    void AddLinkedCancellationToken(CancellationToken cancellationToken);\n}\n"})}),"\n",(0,i.jsx)(t.h3,{id:"itestmetadata",children:"ITestMetadata"}),"\n",(0,i.jsx)(t.p,{children:"Test metadata and identity:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-csharp",children:"public interface ITestMetadata\n{\n    TestDetails TestDetails { get; }\n    string TestName { get; }\n    string DisplayName { get; set; }\n    Type? DisplayNameFormatter { get; set; }\n}\n"})}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Note:"})," ",(0,i.jsx)(t.code,{children:"Id"})," is available only through the ",(0,i.jsx)(t.code,{children:"ITestMetadata"})," interface (accessed via ",(0,i.jsx)(t.code,{children:"TestContext.Metadata.Id"}),"), not as a direct property on ",(0,i.jsx)(t.code,{children:"TestContext"}),"."]}),"\n",(0,i.jsx)(t.h3,{id:"itestevents",children:"ITestEvents"}),"\n",(0,i.jsx)(t.p,{children:"Test event integration with nullable lazy-initialized event properties:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-csharp",children:"public interface ITestEvents\n{\n    AsyncEvent<TestContext>? OnDispose { get; }\n    AsyncEvent<TestContext>? OnTestRegistered { get; }\n    AsyncEvent<TestContext>? OnInitialize { get; }\n    AsyncEvent<TestContext>? OnTestStart { get; }\n    AsyncEvent<TestContext>? OnTestEnd { get; }\n    AsyncEvent<TestContext>? OnTestSkipped { get; }\n    AsyncEvent<(TestContext TestContext, int RetryAttempt)>? OnTestRetry { get; }\n}\n"})}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Important:"})," All event properties are nullable to enable lazy initialization. Events are only allocated when subscribers are added, avoiding unnecessary allocations for unused events."]}),"\n",(0,i.jsx)(t.h3,{id:"other-interfaces",children:"Other Interfaces"}),"\n",(0,i.jsx)(t.p,{children:"For completeness, here are the other interface properties available:"}),"\n",(0,i.jsx)(t.h4,{id:"itestoutput",children:"ITestOutput"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-csharp",children:"public interface ITestOutput\n{\n    void WriteLine(string message);\n    void WriteError(string message);\n    string GetOutput();\n    string GetErrorOutput();\n}\n"})}),"\n",(0,i.jsx)(t.h4,{id:"itestparallelization",children:"ITestParallelization"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-csharp",children:"public interface ITestParallelization\n{\n    IReadOnlyList<IParallelConstraint> Constraints { get; }\n    Priority ExecutionPriority { get; set; }\n    IParallelLimit? Limiter { get; }  // Read-only - use TestRegisteredContext to set\n    void AddConstraint(IParallelConstraint constraint);\n}\n"})}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Important:"})," The ",(0,i.jsx)(t.code,{children:"Limiter"})," property is ",(0,i.jsx)(t.strong,{children:"read-only"})," on the public interface. To set the parallel limiter, use the phase-specific ",(0,i.jsx)(t.code,{children:"TestRegisteredContext.SetParallelLimiter()"})," method during test registration:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-csharp",children:"[TestRegistered]\npublic static void OnTestRegistered(TestRegisteredContext context)\n{\n    // \u2705 Correct - Use phase-specific context\n    context.SetParallelLimiter(new ParallelLimit3());\n}\n"})}),"\n",(0,i.jsx)(t.h4,{id:"itestdependencies",children:"ITestDependencies"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-csharp",children:"public interface ITestDependencies\n{\n    IReadOnlyList<TestContext> GetTests(Func<TestContext, bool> predicate);\n    IReadOnlyList<TestContext> GetTests(string testName);\n    IReadOnlyList<TestContext> GetTests(string testName, Type classType);\n}\n"})}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Changed:"})," All ",(0,i.jsx)(t.code,{children:"GetTests"})," methods now return ",(0,i.jsx)(t.code,{children:"IReadOnlyList<TestContext>"})," for consistency and to better express the immutable nature of the returned collection."]}),"\n",(0,i.jsx)(t.h4,{id:"iteststatebag",children:"ITestStateBag"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-csharp",children:"public interface ITestStateBag\n{\n    ConcurrentDictionary<string, object?> Items { get; }\n    object? this[string key] { get; set; }\n    int Count { get; }\n    bool ContainsKey(string key);\n    T GetOrAdd<T>(string key, Func<string, T> valueFactory);\n    bool TryGetValue<T>(string key, out T value);\n    bool TryRemove(string key, out object? value);\n}\n"})}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.code,{children:"StateBag"})," interface provides both direct dictionary access via ",(0,i.jsx)(t.code,{children:"Items"})," and type-safe helper methods for common operations."]}),"\n",(0,i.jsx)(t.h2,{id:"summary",children:"Summary"}),"\n",(0,i.jsx)(t.p,{children:"The TestContext interface organization provides:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["\u2705 ",(0,i.jsx)(t.strong,{children:"Better discoverability"})," through grouped functionality"]}),"\n",(0,i.jsxs)(t.li,{children:["\u2705 ",(0,i.jsx)(t.strong,{children:"Clearer code intent"})," with semantic interface names"]}),"\n",(0,i.jsxs)(t.li,{children:["\u2705 ",(0,i.jsx)(t.strong,{children:"Zero performance overhead"})," with allocation-free design"]}),"\n",(0,i.jsxs)(t.li,{children:["\u2705 ",(0,i.jsx)(t.strong,{children:"Backwards compatibility"})," with direct property access"]}),"\n",(0,i.jsxs)(t.li,{children:["\u2705 ",(0,i.jsx)(t.strong,{children:"Future flexibility"})," for interface-based dependencies"]}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"Update your code incrementally, starting with new code and high-value refactorings, while legacy code continues to work unchanged."})]})}function h(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>o});var s=n(6540);const i={},r=s.createContext(i);function a(e){const t=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),s.createElement(r.Provider,{value:t},e.children)}}}]);