[  
#nullable enable

using System;
using System.Runtime.CompilerServices;
using System.Threading.Tasks;
using TUnit.Assertions.Core;
using TUnit.Assertions.Conditions;

namespace TUnit.Assertions.Extensions;

/// <summary>
/// Generated assertion for IsEmpty
/// </summary>
[System.Diagnostics.CodeAnalysis.UnconditionalSuppressMessage("Trimming", "IL2091", Justification = "Generic type parameter is only used for property access, not instantiation")]
public sealed class _IsEmpty_Assertion<T> : Assertion<T[]>
{
    public _IsEmpty_Assertion(AssertionContext<T[]> context)
        : base(context)
    {
    }

    protected override Task<AssertionResult> CheckAsync(EvaluationMetadata<T[]> metadata)
    {
        var value = metadata.Value;
        var exception = metadata.Exception;

        if (exception != null)
        {
            return Task.FromResult(AssertionResult.Failed($"threw {exception.GetType().FullName}"));
        }

        if (value is null)
        {
            return Task.FromResult(AssertionResult.Failed("Actual value is null"));
        }

        var result = value!.Length == 0;
        return Task.FromResult(result
            ? AssertionResult.Passed
            : AssertionResult.Failed($"found {value}"));
    }

    protected override string GetExpectation()
    {
        return "to be an empty array";
    }
}

/// <summary>
/// Generated assertion for IsNotEmpty
/// </summary>
[System.Diagnostics.CodeAnalysis.UnconditionalSuppressMessage("Trimming", "IL2091", Justification = "Generic type parameter is only used for property access, not instantiation")]
public sealed class _IsNotEmpty_Assertion<T> : Assertion<T[]>
{
    public _IsNotEmpty_Assertion(AssertionContext<T[]> context)
        : base(context)
    {
    }

    protected override Task<AssertionResult> CheckAsync(EvaluationMetadata<T[]> metadata)
    {
        var value = metadata.Value;
        var exception = metadata.Exception;

        if (exception != null)
        {
            return Task.FromResult(AssertionResult.Failed($"threw {exception.GetType().FullName}"));
        }

        if (value is null)
        {
            return Task.FromResult(AssertionResult.Failed("Actual value is null"));
        }

        var result = value != null && value!.Length > 0;
        return Task.FromResult(result
            ? AssertionResult.Passed
            : AssertionResult.Failed($"found {value}"));
    }

    protected override string GetExpectation()
    {
        return "to not be an empty array";
    }
}

/// <summary>
/// Generated assertion for IsSingleElement
/// </summary>
[System.Diagnostics.CodeAnalysis.UnconditionalSuppressMessage("Trimming", "IL2091", Justification = "Generic type parameter is only used for property access, not instantiation")]
public sealed class _IsSingleElement_Assertion<T> : Assertion<T[]>
{
    public _IsSingleElement_Assertion(AssertionContext<T[]> context)
        : base(context)
    {
    }

    protected override Task<AssertionResult> CheckAsync(EvaluationMetadata<T[]> metadata)
    {
        var value = metadata.Value;
        var exception = metadata.Exception;

        if (exception != null)
        {
            return Task.FromResult(AssertionResult.Failed($"threw {exception.GetType().FullName}"));
        }

        if (value is null)
        {
            return Task.FromResult(AssertionResult.Failed("Actual value is null"));
        }

        var result = value!.Length == 1;
        return Task.FromResult(result
            ? AssertionResult.Passed
            : AssertionResult.Failed($"found {value}"));
    }

    protected override string GetExpectation()
    {
        return "to be a single-element array";
    }
}

/// <summary>
/// Generated assertion for IsNotSingleElement
/// </summary>
[System.Diagnostics.CodeAnalysis.UnconditionalSuppressMessage("Trimming", "IL2091", Justification = "Generic type parameter is only used for property access, not instantiation")]
public sealed class _IsNotSingleElement_Assertion<T> : Assertion<T[]>
{
    public _IsNotSingleElement_Assertion(AssertionContext<T[]> context)
        : base(context)
    {
    }

    protected override Task<AssertionResult> CheckAsync(EvaluationMetadata<T[]> metadata)
    {
        var value = metadata.Value;
        var exception = metadata.Exception;

        if (exception != null)
        {
            return Task.FromResult(AssertionResult.Failed($"threw {exception.GetType().FullName}"));
        }

        if (value is null)
        {
            return Task.FromResult(AssertionResult.Failed("Actual value is null"));
        }

        var result = value!.Length != 1;
        return Task.FromResult(result
            ? AssertionResult.Passed
            : AssertionResult.Failed($"found {value}"));
    }

    protected override string GetExpectation()
    {
        return "to not be a single-element array";
    }
}

/// <summary>
/// Generated assertion for IsSingleElement
/// </summary>
[System.Diagnostics.CodeAnalysis.UnconditionalSuppressMessage("Trimming", "IL2091", Justification = "Generic type parameter is only used for property access, not instantiation")]
public sealed class IEnumerableT_IsSingleElement_Assertion<T> : Assertion<System.Collections.Generic.IEnumerable<T>>
{
    public IEnumerableT_IsSingleElement_Assertion(AssertionContext<System.Collections.Generic.IEnumerable<T>> context)
        : base(context)
    {
    }

    protected override Task<AssertionResult> CheckAsync(EvaluationMetadata<System.Collections.Generic.IEnumerable<T>> metadata)
    {
        var value = metadata.Value;
        var exception = metadata.Exception;

        if (exception != null)
        {
            return Task.FromResult(AssertionResult.Failed($"threw {exception.GetType().FullName}"));
        }

        if (value is null)
        {
            return Task.FromResult(AssertionResult.Failed("Actual value is null"));
        }

        var result = value != null && value!.Skip(1).Take(1).Any() == false && value!.Any();
        return Task.FromResult(result
            ? AssertionResult.Passed
            : AssertionResult.Failed($"found {value}"));
    }

    protected override string GetExpectation()
    {
        return "to be a single-element collection";
    }
}

/// <summary>
/// Generated assertion for IsNotSingleElement
/// </summary>
[System.Diagnostics.CodeAnalysis.UnconditionalSuppressMessage("Trimming", "IL2091", Justification = "Generic type parameter is only used for property access, not instantiation")]
public sealed class IEnumerableT_IsNotSingleElement_Assertion<T> : Assertion<System.Collections.Generic.IEnumerable<T>>
{
    public IEnumerableT_IsNotSingleElement_Assertion(AssertionContext<System.Collections.Generic.IEnumerable<T>> context)
        : base(context)
    {
    }

    protected override Task<AssertionResult> CheckAsync(EvaluationMetadata<System.Collections.Generic.IEnumerable<T>> metadata)
    {
        var value = metadata.Value;
        var exception = metadata.Exception;

        if (exception != null)
        {
            return Task.FromResult(AssertionResult.Failed($"threw {exception.GetType().FullName}"));
        }

        if (value is null)
        {
            return Task.FromResult(AssertionResult.Failed("Actual value is null"));
        }

        var result = value == null || value!.Skip(1).Take(1).Any() || !value!.Any();
        return Task.FromResult(result
            ? AssertionResult.Passed
            : AssertionResult.Failed($"found {value}"));
    }

    protected override string GetExpectation()
    {
        return "to not be a single-element collection";
    }
}

public static partial class ArrayAssertionExtensions
{
    /// <summary>
    /// Generated extension method for IsEmpty
    /// </summary>
    [System.Diagnostics.CodeAnalysis.UnconditionalSuppressMessage("Trimming", "IL2091", Justification = "Generic type parameter is only used for property access, not instantiation")]
    public static _IsEmpty_Assertion<T> IsEmpty<T>(this IAssertionSource<T[]> source)
    {
        source.Context.ExpressionBuilder.Append(".IsEmpty()");
        return new _IsEmpty_Assertion<T>(source.Context);
    }

    /// <summary>
    /// Generated extension method for IsNotEmpty
    /// </summary>
    [System.Diagnostics.CodeAnalysis.UnconditionalSuppressMessage("Trimming", "IL2091", Justification = "Generic type parameter is only used for property access, not instantiation")]
    public static _IsNotEmpty_Assertion<T> IsNotEmpty<T>(this IAssertionSource<T[]> source)
    {
        source.Context.ExpressionBuilder.Append(".IsNotEmpty()");
        return new _IsNotEmpty_Assertion<T>(source.Context);
    }

    /// <summary>
    /// Generated extension method for IsSingleElement
    /// </summary>
    [System.Diagnostics.CodeAnalysis.UnconditionalSuppressMessage("Trimming", "IL2091", Justification = "Generic type parameter is only used for property access, not instantiation")]
    public static _IsSingleElement_Assertion<T> IsSingleElement<T>(this IAssertionSource<T[]> source)
    {
        source.Context.ExpressionBuilder.Append(".IsSingleElement()");
        return new _IsSingleElement_Assertion<T>(source.Context);
    }

    /// <summary>
    /// Generated extension method for IsNotSingleElement
    /// </summary>
    [System.Diagnostics.CodeAnalysis.UnconditionalSuppressMessage("Trimming", "IL2091", Justification = "Generic type parameter is only used for property access, not instantiation")]
    public static _IsNotSingleElement_Assertion<T> IsNotSingleElement<T>(this IAssertionSource<T[]> source)
    {
        source.Context.ExpressionBuilder.Append(".IsNotSingleElement()");
        return new _IsNotSingleElement_Assertion<T>(source.Context);
    }

    /// <summary>
    /// Generated extension method for IsSingleElement
    /// </summary>
    [System.Diagnostics.CodeAnalysis.UnconditionalSuppressMessage("Trimming", "IL2091", Justification = "Generic type parameter is only used for property access, not instantiation")]
    public static IEnumerableT_IsSingleElement_Assertion<T> IsSingleElement<T>(this IAssertionSource<System.Collections.Generic.IEnumerable<T>> source)
    {
        source.Context.ExpressionBuilder.Append(".IsSingleElement()");
        return new IEnumerableT_IsSingleElement_Assertion<T>(source.Context);
    }

    /// <summary>
    /// Generated extension method for IsNotSingleElement
    /// </summary>
    [System.Diagnostics.CodeAnalysis.UnconditionalSuppressMessage("Trimming", "IL2091", Justification = "Generic type parameter is only used for property access, not instantiation")]
    public static IEnumerableT_IsNotSingleElement_Assertion<T> IsNotSingleElement<T>(this IAssertionSource<System.Collections.Generic.IEnumerable<T>> source)
    {
        source.Context.ExpressionBuilder.Append(".IsNotSingleElement()");
        return new IEnumerableT_IsNotSingleElement_Assertion<T>(source.Context);
    }

}

]