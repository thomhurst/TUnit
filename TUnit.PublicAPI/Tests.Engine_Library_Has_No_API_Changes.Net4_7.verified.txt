[assembly: .(@", PublicKey=0024000004800000940000000602000000240000525341310004000001000100698a70398fa0b2230c5a72e3bd9d56b48f809f6173e49a19fbb942d621be93ad48c5566b47b28faabc359b9ad3ff4e00bbdea88f5bdfa250f391fedd28182b2e37b55d429c0151a42a98ea7a5821818cd15a79fef9903e8607a88304cf3e0317bf86ec96e32e1381535a6582251e5a6eed40b5a3ed82bc444598b1269cce57a7")]
[assembly: .(@", PublicKey=0024000004800000940000000602000000240000525341310004000001000100698a70398fa0b2230c5a72e3bd9d56b48f809f6173e49a19fbb942d621be93ad48c5566b47b28faabc359b9ad3ff4e00bbdea88f5bdfa250f391fedd28182b2e37b55d429c0151a42a98ea7a5821818cd15a79fef9903e8607a88304cf3e0317bf86ec96e32e1381535a6582251e5a6eed40b5a3ed82bc444598b1269cce57a7")]
[assembly: .(".NETStandard,Version=v2.0", FrameworkDisplayName=".NET Standard 2.0")]
namespace .
{
    public interface ITestDataCollector
    {
        .<.<.TestMetadata>> CollectTestsAsync(string testSessionId);
    }
}
namespace .Building
{
    public static class TestDataCollectorFactory
    {
        public static ..ITestDataCollector Create(.? mode = default, .Assembly[]? assembliesToScan = null) { }
        public static .<..ITestDataCollector> CreateAutoDetectAsync(string testSessionId, .Assembly[]? assembliesToScan = null) { }
    }
}
namespace .Capabilities
{
    public class StopExecutionCapability : ..ICapability, .., ..
    {
        public StopExecutionCapability() { }
        public bool IsStopRequested { get; }
        public .AsyncEvent<>? OnStopRequested { get; set; }
        public . StopTestExecutionAsync(.CancellationToken cancellationToken) { }
    }
}
namespace .Configuration
{
    public static class DiscoveryConfiguration
    {
        public static  DataSourceTimeout { get; set; }
        public static  DiscoveryTimeout { get; set; }
        public static bool EnableDiagnostics { get; set; }
        public static void ConfigureFromEnvironment() { }
        public static . CreateCircuitBreaker() { }
    }
}
namespace .Diagnostics
{
    public class TUnitAssertionFailedException : 
    {
        public TUnitAssertionFailedException(string message) { }
        public TUnitAssertionFailedException(string message,  innerException) { }
    }
}
namespace .Discovery
{
    public sealed class ReflectionTestDataCollector : ..ITestDataCollector
    {
        public ReflectionTestDataCollector() { }
        public .<.<.TestMetadata>> CollectTestsAsync(string testSessionId) { }
    }
}
namespace ...Examples
{
    public class GenericTests<T>
    {
        public GenericTests() { }
        [.Test("/home/thomh/dev/TUnit/", 120)]
        public void GenericTest() { }
    }
    public class SimpleTests
    {
        public SimpleTests() { }
        [.Category("Integration")]
        [.Test("/home/thomh/dev/TUnit/", 66)]
        [.Timeout(5000)]
        public . AsyncTestWithAttributes() { }
        [.Arguments(new object[] {
                1,
                2,
                3})]
        [.Arguments(new object[] {
                4,
                5,
                6})]
        [.Test("/home/thomh/dev/TUnit/", 75)]
        public void ParameterizedTest(int a, int b, int c) { }
        [.Test("/home/thomh/dev/TUnit/", 60)]
        public void SimpleTest() { }
        [.Skip("Example of skipped test")]
        [.Test("/home/thomh/dev/TUnit/", 83)]
        public void SkippedTest() { }
    }
    public class TestsWithHooks
    {
        public TestsWithHooks() { }
        [.After(., "/home/thomh/dev/TUnit/", 111)]
        public void AfterEachTest() { }
        [.Before(., "/home/thomh/dev/TUnit/", 99)]
        public void BeforeEachTest() { }
        [.Test("/home/thomh/dev/TUnit/", 105)]
        public void TestWithHooks() { }
        [.Before(., "/home/thomh/dev/TUnit/", 93)]
        public static void BeforeClass() { }
    }
}
namespace .Enums
{
    public enum EngineMode
    {
        SourceGenerated = 0,
        Reflection = 1,
    }
}
namespace .Exceptions
{
    public class HookFailedException : .
    {
        public HookFailedException( exception) { }
        public HookFailedException(string? message, ? innerException) { }
    }
    public abstract class TUnitFailedException : .
    {
        protected TUnitFailedException( exception) { }
        protected TUnitFailedException(string? message, ? innerException) { }
        public override string StackTrace { get; }
    }
    public class TestFailedException : .
    {
        public TestFailedException( exception) { }
        public TestFailedException(string? message, ? innerException) { }
    }
}
namespace .Extensions
{
    public static class JsonExtensions
    {
        public static . ToJsonModel(this  exception) { }
        public static . ToJsonModel(this .AssemblyHookContext context) { }
        public static . ToJsonModel(this .ClassHookContext context) { }
        public static . ToJsonModel(this .TestContext context) { }
        public static . ToJsonModel(this .TestResult result) { }
        public static . ToJsonModel(this .TestSessionContext context) { }
    }
    public static class TestApplicationBuilderExtensions
    {
        public static void AddTUnit(this ..ITestApplicationBuilder testApplicationBuilder) { }
    }
}
namespace 
{
    public class FileArtifact
    {
        public FileArtifact() { }
        public string? Description { get; init; }
        public required string DisplayName { get; init; }
        public required string File { get; init; }
    }
    public interface ITestMetadataScanner
    {
        .<.<.TestMetadata>> ScanAssembly(.Assembly assembly);
    }
    public class PriorityQueue<TElement, TPriority>
        where TPriority : <TPriority>
    {
        public PriorityQueue() { }
        public int Count { get; }
        public TElement Dequeue() { }
        public void Enqueue(TElement value, TPriority priority) { }
        public TElement Peek() { }
        public bool TryDequeue([.(true)] out TElement? value, [.(true)] out TPriority? priority) { }
    }
    public static class TestNodeProperties
    {
        public static readonly string DisplayName;
        public static readonly string FullyQualifiedName;
        public static readonly string TestFileLocation;
        public static readonly string Traits;
    }
    public class Trait
    {
        public Trait(string name, string value) { }
        public string Name { get; }
        public string Value { get; }
    }
}
namespace .Framework
{
    public interface IFilterReceiver
    {
        string? Filter { set; }
    }
    public static class TestingPlatformBuilderHook
    {
        public static void AddExtensions(..ITestApplicationBuilder testApplicationBuilder, string[] _) { }
    }
}
namespace .Helpers
{
    public class DataUnwrapper
    {
        public DataUnwrapper() { }
        public static object?[] Unwrap(object?[] values) { }
    }
    public static class DotNetAssemblyHelper
    {
        public static bool IsDotNetCoreLibrary(byte[]? publicKeyToken) { }
        public static bool IsInDotNetCoreLibrary( type) { }
    }
}
namespace .Interfaces
{
    public interface IDataSourceResolver
    {
        .<.<object?[]>> ResolveDataAsync(.IDataSourceAttribute dataSource);
        .<.<object?[]>> ResolveDataSource(.IDataSourceAttribute dataSource);
        .<object?> ResolvePropertyDataAsync(.PropertyDataSource propertyDataSource);
    }
    public interface IExecutableTestFactory
    {
        .ExecutableTest CreateExecutableTest(string testId, string displayName, object[] arguments, object[] classArguments, .<string, object?> propertyValues, <.TestContext, .CancellationToken, .>[] beforeTestHooks, <.TestContext, .CancellationToken, .>[] afterTestHooks, .TestContext context, .TestMetadata metadata);
    }
    public interface IHookCollectionService
    {
        .<.<<.AssemblyHookContext, .CancellationToken, .>>> CollectAfterAssemblyHooksAsync(.Assembly assembly);
        .<.<<.ClassHookContext, .CancellationToken, .>>> CollectAfterClassHooksAsync( testClassType);
        .<.<<.TestContext, .CancellationToken, .>>> CollectAfterEveryTestHooksAsync( testClassType);
        .<.<<.TestDiscoveryContext, .CancellationToken, .>>> CollectAfterTestDiscoveryHooksAsync();
        .<.<<.TestContext, .CancellationToken, .>>> CollectAfterTestHooksAsync( testClassType);
        .<.<<.TestSessionContext, .CancellationToken, .>>> CollectAfterTestSessionHooksAsync();
        .<.<<.AssemblyHookContext, .CancellationToken, .>>> CollectBeforeAssemblyHooksAsync(.Assembly assembly);
        .<.<<.ClassHookContext, .CancellationToken, .>>> CollectBeforeClassHooksAsync( testClassType);
        .<.<<.TestContext, .CancellationToken, .>>> CollectBeforeEveryTestHooksAsync( testClassType);
        .<.<<.BeforeTestDiscoveryContext, .CancellationToken, .>>> CollectBeforeTestDiscoveryHooksAsync();
        .<.<<.TestContext, .CancellationToken, .>>> CollectBeforeTestHooksAsync( testClassType);
        .<.<<.TestSessionContext, .CancellationToken, .>>> CollectBeforeTestSessionHooksAsync();
    }
    public interface ISingleTestExecutor
    {
        .<..> ExecuteTestAsync(.ExecutableTest test, ..IMessageBus messageBus, .CancellationToken cancellationToken);
        void SetSessionId(..SessionUid sessionUid);
    }
    public interface ITestExecutor
    {
        . ExecuteTests(.<.ExecutableTest> tests, ..ITestExecutionFilter? filter, ..IMessageBus messageBus, .CancellationToken cancellationToken);
    }
    public interface ITestInvoker
    {
        . InvokeTestAsync(object instance, <object, object?[], .> testInvoker, object?[] arguments);
        . InvokeTestAsync(string testMethodKey, object instance, object?[] arguments);
    }
}
namespace .Json
{
    public class ExceptionJson : <.>
    {
        public ExceptionJson() { }
        public required .? InnerException { get; init; }
        public required string Message { get; init; }
        public required string? Stacktrace { get; init; }
        public required string? Type { get; init; }
    }
    public class TestAssemblyJson : <.>
    {
        public TestAssemblyJson() { }
        public required string? AssemblyName { get; init; }
        public required .[] Classes { get; init; }
    }
    public class TestClassJson : <.>
    {
        public TestClassJson() { }
        public required .[] Tests { get; init; }
        public required string? Type { get; init; }
    }
    public class TestJson : <.>
    {
        public TestJson() { }
        public required .<string> Categories { get; init; }
        public required string? ClassType { get; init; }
        public required .<string, .<string>> CustomProperties { get; init; }
        public required string DisplayName { get; set; }
        public required .<string, object?> ObjectBag { get; init; }
        public required .? Result { get; set; }
        public required int RetryLimit { get; init; }
        public required string? ReturnType { get; init; }
        public required object?[]? TestClassArguments { get; init; }
        public required string?[]? TestClassParameterTypes { get; init; }
        public required string TestFilePath { get; init; }
        public required string TestId { get; init; }
        public required int TestLineNumber { get; init; }
        public required object?[]? TestMethodArguments { get; init; }
        public required string?[]? TestMethodParameterTypes { get; init; }
        public required string TestName { get; init; }
        public required ? Timeout { get; init; }
    }
    public class TestResultJson : <.>
    {
        public TestResultJson() { }
        public required string ComputerName { get; init; }
        public required ? Duration { get; init; }
        public required ? End { get; init; }
        public required .? Exception { get; init; }
        public required string? Output { get; init; }
        public required ? Start { get; init; }
        public required .TestState Status { get; init; }
    }
    public class TestSessionJson : <.>
    {
        public TestSessionJson() { }
        public required .[] Assemblies { get; init; }
    }
}
namespace .Logging
{
    public class TUnitFrameworkLogger : ..IExtension, .., .
    {
        public TUnitFrameworkLogger(..IExtension extension, ..IOutputDevice outputDevice, ..ILogger logger, . verbosityService) { }
        public string Description { get; }
        public string DisplayName { get; }
        public string Uid { get; }
        public string Version { get; }
        public bool IsEnabled(. logLevel) { }
        public .<bool> IsEnabledAsync() { }
        public void Log<TState>(. logLevel, TState state, ? exception, <TState, ?, string> formatter) { }
        public . LogAsync<TState>(. logLevel, TState state, ? exception, <TState, ?, string> formatter) { }
        public . LogErrorAsync( exception) { }
        public . LogErrorAsync(string message) { }
    }
    public enum TUnitVerbosity
    {
        Minimal = 0,
        Normal = 1,
        Verbose = 2,
        Debug = 3,
    }
    public static class TUnitVerbosityExtensions
    {
        public static bool Includes(this . current, . level) { }
        public static string ToDisplayString(this . verbosity) { }
    }
}
namespace .Reporters
{
    public class GitHubReporter : ..IExtension, .., .., .., .
    {
        public GitHubReporter(..IExtension extension) { }
        public [] DataTypesConsumed { get; }
        public string Description { get; }
        public string DisplayName { get; }
        public string? Filter { get; set; }
        public string Uid { get; }
        public string Version { get; }
        public . AfterRunAsync(int exitCode, .CancellationToken cancellation) { }
        public . BeforeRunAsync(.CancellationToken cancellationToken) { }
        public . ConsumeAsync(.. dataProducer, .. value, .CancellationToken cancellationToken) { }
        public .<bool> IsEnabledAsync() { }
    }
}
namespace .Scheduling
{
    public interface ITestExecutor
    {
        . ExecuteTestAsync(.ExecutableTest test, .CancellationToken cancellationToken);
    }
    public interface ITestScheduler
    {
        . ScheduleAndExecuteAsync(.<.ExecutableTest> tests, . executor, .CancellationToken cancellationToken);
    }
    public enum ParallelismStrategy
    {
        Fixed = 0,
        Adaptive = 1,
    }
    public sealed class SchedulerConfiguration
    {
        public SchedulerConfiguration() { }
        public int MaxParallelism { get; set; }
        public int MinParallelism { get; set; }
        public  StallTimeout { get; set; }
        public . Strategy { get; set; }
        public  TestTimeout { get; set; }
        public static . Default { get; }
    }
    public sealed class TestExecutionState
    {
        public TestExecutionState(.ExecutableTest test) { }
        public .? Constraint { get; init; }
        public string? ConstraintKey { get; init; }
        public .<string> Dependents { get; }
        public  EnqueueTime { get; set; }
        public int Order { get; init; }
        public . Priority { get; init; }
        public int RemainingDependencies { get; set; }
        public .TestState State { get; set; }
        public .ExecutableTest Test { get; }
        public .CancellationTokenSource? TimeoutCts { get; set; }
        public int DecrementRemainingDependencies() { }
    }
}
namespace .Services
{
    public sealed class DiscoveryCircuitBreaker
    {
        public DiscoveryCircuitBreaker(double maxMemoryPercentage = 0.7, ? maxGenerationTime = default) { }
        public string CreateResourceReport(int testCount) { }
        public void Dispose() { }
        public . GetResourceUsage() { }
        public bool ShouldContinue(int currentTestCount = 0) { }
    }
    public class DiscoveryResourceUsage : <.>
    {
        public DiscoveryResourceUsage() { }
        public  ElapsedTime { get; init; }
        public long MaxMemoryBytes { get; init; }
        public  MaxTime { get; init; }
        public long MemoryGrowthBytes { get; init; }
        public double MemoryUsagePercentage { get; init; }
        public double TimeUsagePercentage { get; init; }
    }
    public class FilterParser
    {
        public FilterParser() { }
        public string? GetTestFilter(.. context) { }
        public static string? StringifyFilter(..ITestExecutionFilter filter) { }
    }
    public class LogLevelProvider
    {
        public LogLevelProvider(..ICommandLineOptions commandLineOptions) { }
        public . LogLevel { get; }
    }
    public static class ParallelismDetector
    {
        public static int DetectOptimalParallelism() { }
    }
    public class TestInvoker : .
    {
        public TestInvoker() { }
        public . InvokeTestAsync(object instance, <object, object?[], .> testInvoker, object?[] arguments) { }
        public . InvokeTestAsync(string testMethodKey, object instance, object?[] arguments) { }
    }
    public sealed class VerbosityService
    {
        public VerbosityService(..ICommandLineOptions commandLineOptions) { }
        public . CurrentVerbosity { get; }
        public bool EnableDiscoveryDiagnostics { get; }
        public bool EnableVerboseSourceGeneratorDiagnostics { get; }
        public bool HideTestOutput { get; }
        public bool ShowDetailedStackTrace { get; }
        public bool ShowDiscoveryProgress { get; }
        public bool ShowExecutionTiming { get; }
        public bool ShowLogo { get; }
        public bool ShowParallelExecutionDetails { get; }
        public bool ShowResourceUsage { get; }
        public string CreateVerbositySummary() { }
    }
}