[assembly: .(".NETStandard,Version=v2.0", FrameworkDisplayName=".NET Standard 2.0")]
namespace .Abstractions
{
    public interface ICollectionAdapter<out TItem> : ., .<TItem>
    {
        string? Description { get; }
    }
    public interface IContainsCheck<TItem>
    {
        bool Contains(TItem item, .<TItem>? comparer = null);
    }
    public interface ICountable
    {
        int Count { get; }
        bool IsEmpty { get; }
    }
    public interface IDictionaryAdapter<TKey, TValue> : .<.<TKey, TValue>>, ., .<.<TKey, TValue>>, .<TKey>, .<TKey, TValue> { }
    public interface IIndexable<out TItem>
    {
        TItem this[int index] { get; }
        int Length { get; }
    }
    public interface IItemSequence<out TItem>
    {
        .<TItem> AsEnumerable();
    }
    public interface IKeyLookup<in TKey>
    {
        bool ContainsKey(TKey key);
    }
    public interface IKeyValueAccess<TKey, TValue> : .<TKey>
    {
        .<TKey> Keys { get; }
        .<TValue> Values { get; }
        bool ContainsValue(TValue value, .<TValue>? comparer = null);
        bool TryGetValue(TKey key, out TValue? value);
    }
    public interface ISetAdapter<TItem> : .<TItem>, .<TItem>, ., .<TItem>, .<TItem> { }
    public interface ISetOperations<TItem>
    {
        bool IsProperSubsetOf(.<TItem> other);
        bool IsProperSupersetOf(.<TItem> other);
        bool IsSubsetOf(.<TItem> other);
        bool IsSupersetOf(.<TItem> other);
        bool Overlaps(.<TItem> other);
        bool SetEquals(.<TItem> other);
    }
}
namespace .Adapters
{
    public readonly struct DictionaryAdapter<TKey, TValue> : .<.<TKey, TValue>>, ., .<TKey, TValue>, .<.<TKey, TValue>>, .<TKey>, .<TKey, TValue>
        where TKey :  notnull
    {
        public DictionaryAdapter(.<TKey, TValue>? source) { }
        public int Count { get; }
        public string? Description { get; }
        public bool IsEmpty { get; }
        public .<TKey> Keys { get; }
        public .<TValue> Values { get; }
        public .<.<TKey, TValue>> AsEnumerable() { }
        public bool ContainsKey(TKey key) { }
        public bool ContainsValue(TValue value, .<TValue>? comparer = null) { }
        public bool TryGetValue(TKey key, out TValue? value) { }
    }
    public readonly struct EnumerableAdapter<TItem> : .<TItem>, .<TItem>, ., .<TItem>
    {
        public EnumerableAdapter(.<TItem>? source) { }
        public int Count { get; }
        public string? Description { get; }
        public bool IsEmpty { get; }
        public .<TItem> AsEnumerable() { }
        public bool Contains(TItem item, .<TItem>? comparer = null) { }
    }
    public readonly struct ReadOnlyDictionaryAdapter<TKey, TValue> : .<.<TKey, TValue>>, ., .<TKey, TValue>, .<.<TKey, TValue>>, .<TKey>, .<TKey, TValue>
        where TKey :  notnull
    {
        public ReadOnlyDictionaryAdapter(.<TKey, TValue>? source) { }
        public int Count { get; }
        public string? Description { get; }
        public bool IsEmpty { get; }
        public .<TKey> Keys { get; }
        public .<TValue> Values { get; }
        public .<.<TKey, TValue>> AsEnumerable() { }
        public bool ContainsKey(TKey key) { }
        public bool ContainsValue(TValue value, .<TValue>? comparer = null) { }
        public bool TryGetValue(TKey key, out TValue? value) { }
    }
    public readonly struct SetAdapter<TItem> : .<TItem>, .<TItem>, ., .<TItem>, .<TItem>, .<TItem>
    {
        public SetAdapter(.<TItem>? source) { }
        public int Count { get; }
        public string? Description { get; }
        public bool IsEmpty { get; }
        public .<TItem> AsEnumerable() { }
        public bool Contains(TItem item, .<TItem>? comparer = null) { }
        public bool IsProperSubsetOf(.<TItem> other) { }
        public bool IsProperSupersetOf(.<TItem> other) { }
        public bool IsSubsetOf(.<TItem> other) { }
        public bool IsSupersetOf(.<TItem> other) { }
        public bool Overlaps(.<TItem> other) { }
        public bool SetEquals(.<TItem> other) { }
    }
}
namespace 
{
    public static class Assert
    {
        public static void Fail(string reason) { }
        public static  Multiple() { }
        public static void NotNull<T>([.] T? value, [.("value")] string? expression = null)
            where T :  class { }
        public static void NotNull<T>([.] T? value, [.("value")] string? expression = null)
            where T :  struct { }
        public static void Null<T>(T? value, [.("value")] string? expression = null)
            where T :  class { }
        public static void Null<T>(T? value, [.("value")] string? expression = null)
            where T :  struct { }
        public static . That( action, [.("action")] string? expression = null) { }
        public static .<object?> That(.IEnumerable value, [.("value")] string? expression = null) { }
        public static . That(<.> action, [.("action")] string? expression = null) { }
        public static . That(. task, [.("task")] string? expression = null) { }
        public static .<string> That(string? value, [.("value")] string? expression = null) { }
        public static .<TItem> That<TItem>(.<TItem> value, [.("value")] string? expression = null) { }
        public static .<TItem> That<TItem>(.<TItem>? value, [.("value")] string? expression = null) { }
        public static .<TItem> That<TItem>(.<TItem> value, [.("value")] string? expression = null) { }
        public static .<TItem> That<TItem>(<.<TItem>?> func, [.("func")] string? expression = null) { }
        public static .<TItem> That<TItem>(<.<.<TItem>?>> func, [.("func")] string? expression = null) { }
        public static .<TValue> That<TValue>(<.<TValue?>> func, [.("func")] string? expression = null) { }
        public static .<TValue> That<TValue>(<TValue?> func, [.("func")] string? expression = null) { }
        public static .<TValue> That<TValue>(.<TValue> task, [.("task")] string? expression = null) { }
        public static .<TValue> That<TValue>(TValue? value, [.("value")] string? expression = null) { }
        public static .<TKey, TValue> That<TKey, TValue>(.<TKey, TValue> value, [.("value")] string? expression = null)
            where TKey :  notnull { }
        public static .<TKey, TValue> That<TKey, TValue>(.<TKey, TValue> value, [.("value")] string? expression = null)
            where TKey :  notnull { }
        public static  Throws( exceptionType,  action) { }
        public static TException Throws<TException>( action)
            where TException :  { }
        public static TException Throws<TException>(string parameterName,  action)
            where TException :  { }
        public static .<> ThrowsAsync(<.> action) { }
        public static .<> ThrowsAsync(. task) { }
        public static .<> ThrowsAsync(. task) { }
        public static .<?> ThrowsAsync( exceptionType, <.> action) { }
        public static .<TException> ThrowsAsync<TException>(<.> action)
            where TException :  { }
        public static .<TException> ThrowsAsync<TException>(string parameterName, <.> action)
            where TException :  { }
        public static TException ThrowsExactly<TException>( action)
            where TException :  { }
        public static TException ThrowsExactly<TException>(string parameterName,  action)
            where TException :  { }
        public static .<TException> ThrowsExactlyAsync<TException>(<.> action)
            where TException :  { }
        public static .<TException> ThrowsExactlyAsync<TException>(string parameterName, <.> action)
            where TException :  { }
    }
    public static class Fail
    {
        public static void Test(string reason) { }
        public static void Unless([.(false)] bool condition, string reason) { }
        public static void When([.(true)] bool condition, string reason) { }
    }
    public class StringMatcher
    {
        public .StringMatcher IgnoringCase() { }
        public bool IsMatch(string? input) { }
        public override string ToString() { }
        public static .StringMatcher AsRegex(string pattern) { }
        public static .StringMatcher AsWildcard(string pattern) { }
    }
}
namespace .
{
    public class DoesNotHaveFlagAssertion<TEnum> : .<TEnum>
        where TEnum :  struct, 
    {
        public DoesNotHaveFlagAssertion(.<TEnum> context, TEnum unexpectedFlag) { }
        protected override .<.> CheckAsync(.<TEnum> metadata) { }
        protected override string GetExpectation() { }
    }
    public class DoesNotHaveSameNameAsAssertion<TEnum> : .<TEnum>
        where TEnum :  struct, 
    {
        public DoesNotHaveSameNameAsAssertion(.<TEnum> context,  otherEnumValue) { }
        protected override .<.> CheckAsync(.<TEnum> metadata) { }
        protected override string GetExpectation() { }
    }
    public class DoesNotHaveSameValueAsAssertion<TEnum> : .<TEnum>
        where TEnum :  struct, 
    {
        public DoesNotHaveSameValueAsAssertion(.<TEnum> context,  otherEnumValue) { }
        protected override .<.> CheckAsync(.<TEnum> metadata) { }
        protected override string GetExpectation() { }
    }
    public class HasFlagAssertion<TEnum> : .<TEnum>
        where TEnum :  struct, 
    {
        public HasFlagAssertion(.<TEnum> context, TEnum expectedFlag) { }
        protected override .<.> CheckAsync(.<TEnum> metadata) { }
        protected override string GetExpectation() { }
    }
    public class HasSameNameAsAssertion<TEnum> : .<TEnum>
        where TEnum :  struct, 
    {
        public HasSameNameAsAssertion(.<TEnum> context,  otherEnumValue) { }
        protected override .<.> CheckAsync(.<TEnum> metadata) { }
        protected override string GetExpectation() { }
    }
    public class HasSameValueAsAssertion<TEnum> : .<TEnum>
        where TEnum :  struct, 
    {
        public HasSameValueAsAssertion(.<TEnum> context,  otherEnumValue) { }
        protected override .<.> CheckAsync(.<TEnum> metadata) { }
        protected override string GetExpectation() { }
    }
    public class IsDefinedAssertion<TEnum> : .<TEnum>
        where TEnum :  struct, 
    {
        public IsDefinedAssertion(.<TEnum> context) { }
        protected override .<.> CheckAsync(.<TEnum> metadata) { }
        protected override string GetExpectation() { }
    }
    public class IsNotDefinedAssertion<TEnum> : .<TEnum>
        where TEnum :  struct, 
    {
        public IsNotDefinedAssertion(.<TEnum> context) { }
        protected override .<.> CheckAsync(.<TEnum> metadata) { }
        protected override string GetExpectation() { }
    }
}
namespace .Assertions
{
    public class PropertyAssertionResult<TObject> : ., .<TObject>
    {
        public .<TObject> Context { get; }
        public .<TObject?> GetAwaiter() { }
        public .<TTarget, TObject> IsAssignableTo<TTarget>() { }
        public .<TTarget, TObject> IsNotAssignableTo<TTarget>() { }
        public .<TObject, TExpected> IsNotTypeOf<TExpected>() { }
        public .<TObject, TExpected> IsTypeOf<TExpected>() { }
    }
    public class PropertyAssertion<TObject, TProperty>
    {
        public .<TObject> IsEqualTo(TProperty expected) { }
        public .<TObject> IsNotEqualTo(TProperty expected) { }
        public .<TObject> IsNotNull() { }
        public .<TObject> IsNull() { }
    }
}
namespace .
{
    public class GroupAssertion : .<..RegexMatchCollection>
    {
        protected override .<.> CheckAsync(.<..RegexMatchCollection> metadata) { }
        protected override string GetExpectation() { }
    }
    public class MatchAssertion : .<..RegexMatchCollection>
    {
        protected override .<.> CheckAsync(.<..RegexMatchCollection> metadata) { }
        protected override string GetExpectation() { }
    }
    public class MatchGroupAssertion : .<..RegexMatch>
    {
        protected override .<.> CheckAsync(.<..RegexMatch> metadata) { }
        protected override string GetExpectation() { }
    }
    public class MatchIndexAssertion : .<..RegexMatch>
    {
        protected override .<.> CheckAsync(.<..RegexMatch> metadata) { }
        protected override string GetExpectation() { }
    }
    public class RegexMatch
    {
        public int Index { get; }
        public int Length { get; }
        public string Value { get; }
        public string GetGroup(int groupIndex) { }
        public string GetGroup(string groupName) { }
    }
    public class RegexMatchCollection : .<..RegexMatch>, .<..RegexMatch>, .<..RegexMatch>, .IEnumerable
    {
        public int Count { get; }
        public ..RegexMatch First { get; }
        public ..RegexMatch this[int index] { get; }
        public .<..RegexMatch> GetEnumerator() { }
    }
}
namespace .
{
    public class IsNotParsableIntoAssertion<T> : .<string>
    {
        public IsNotParsableIntoAssertion(.<string> context) { }
        protected override .<.> CheckAsync(.<string> metadata) { }
        protected override string GetExpectation() { }
        public ..IsNotParsableIntoAssertion<T> WithFormatProvider( formatProvider) { }
    }
    public class IsParsableIntoAssertion<T> : .<string>
    {
        public IsParsableIntoAssertion(.<string> context) { }
        protected override .<.> CheckAsync(.<string> metadata) { }
        protected override string GetExpectation() { }
        public ..IsParsableIntoAssertion<T> WithFormatProvider( formatProvider) { }
    }
    public class WhenParsedIntoAssertion<T> : .<T>, ., .<T>
    {
        public WhenParsedIntoAssertion(.<string> stringContext, ? formatProvider = null) { }
        protected override .<.> CheckAsync(.<T> metadata) { }
        protected override string GetExpectation() { }
        public .<TTarget, T> IsAssignableTo<TTarget>() { }
        public .<TTarget, T> IsNotAssignableTo<TTarget>() { }
        public .<T, TExpected> IsNotTypeOf<TExpected>() { }
        public .<T, TExpected> IsTypeOf<TExpected>() { }
        public ..WhenParsedIntoAssertion<T> WithFormatProvider( formatProvider) { }
    }
}
namespace .Attributes
{
    [(.Class, AllowMultiple=false)]
    public class AssertionExtensionAttribute : 
    {
        public AssertionExtensionAttribute(string methodName) { }
        public string MethodName { get; }
        public string? NegatedMethodName { get; set; }
        public int OverloadResolutionPriority { get; set; }
    }
    [(.Class, AllowMultiple=true, Inherited=false)]
    public class AssertionFromAttribute : 
    {
        public AssertionFromAttribute( targetType, string methodName) { }
        public AssertionFromAttribute( targetType,  containingType, string methodName) { }
        public ? ContainingType { get; }
        public string? CustomName { get; set; }
        public string? ExpectationMessage { get; set; }
        public string MethodName { get; }
        public bool NegateLogic { get; set; }
        public bool RequiresGenericTypeParameter { get; set; }
        public  TargetType { get; }
        public bool TreatAsInstance { get; set; }
    }
    [(.Class, AllowMultiple=true, Inherited=false)]
    public sealed class AssertionFromAttribute<TTarget> : 
    {
        public AssertionFromAttribute(string methodName) { }
        public AssertionFromAttribute( containingType, string methodName) { }
        public ? ContainingType { get; }
        public string? CustomName { get; set; }
        public string? ExpectationMessage { get; set; }
        public string MethodName { get; }
        public bool NegateLogic { get; set; }
        public bool RequiresGenericTypeParameter { get; set; }
        public  TargetType { get; }
        public bool TreatAsInstance { get; set; }
    }
    [(.Method, AllowMultiple=false, Inherited=false)]
    public sealed class GenerateAssertionAttribute : 
    {
        public GenerateAssertionAttribute() { }
        public string? ExpectationMessage { get; set; }
        public bool InlineMethodBody { get; set; }
    }
}
namespace .Chaining
{
    public class AndAssertion<TValue> : .<TValue>
    {
        public AndAssertion(.<TValue> first, .<TValue> second) { }
        public new .<TValue> Or { get; }
        public override .<TValue?> AssertAsync() { }
        protected override string GetExpectation() { }
    }
    public class OrAssertion<TValue> : .<TValue>
    {
        public OrAssertion(.<TValue> first, .<TValue> second) { }
        public new .<TValue> And { get; }
        public override .<TValue?> AssertAsync() { }
        protected override string GetExpectation() { }
    }
}
namespace .Collections
{
    public static class CollectionChecks
    {
        public static . CheckAll<TItem>(.<TItem> adapter, <TItem, bool> predicate, string predicateExpression) { }
        public static . CheckAllKeys<TKey, TValue>(.<TKey, TValue> adapter, <TKey, bool> predicate) { }
        public static . CheckAllValues<TKey, TValue>(.<TKey, TValue> adapter, <TValue, bool> predicate) { }
        public static . CheckAny<TItem>(.<TItem> adapter, <TItem, bool> predicate) { }
        public static . CheckAnyKey<TKey, TValue>(.<TKey, TValue> adapter, <TKey, bool> predicate) { }
        public static . CheckAnyValue<TKey, TValue>(.<TKey, TValue> adapter, <TValue, bool> predicate) { }
        public static . CheckContains<TItem>(.<TItem> adapter, TItem expected, .<TItem>? comparer = null) { }
        public static . CheckContainsKey<TKey, TValue>(.<TKey, TValue> adapter, TKey key) { }
        public static . CheckContainsKeyWithValue<TKey, TValue>(.<TKey, TValue> adapter, TKey key, TValue expectedValue, .<TValue>? comparer = null) { }
        public static . CheckContainsPredicate<TItem>(.<TItem> adapter, <TItem, bool> predicate, out TItem? foundItem) { }
        public static . CheckContainsValue<TKey, TValue>(.<TKey, TValue> adapter, TValue value, .<TValue>? comparer = null) { }
        public static . CheckCount<TItem>(.<TItem> adapter, int expected) { }
        public static . CheckDoesNotContain<TItem>(.<TItem> adapter, TItem expected, .<TItem>? comparer = null) { }
        public static . CheckDoesNotContainKey<TKey, TValue>(.<TKey, TValue> adapter, TKey key) { }
        public static . CheckDoesNotContainPredicate<TItem>(.<TItem> adapter, <TItem, bool> predicate) { }
        public static . CheckDoesNotContainValue<TKey, TValue>(.<TKey, TValue> adapter, TValue value, .<TValue>? comparer = null) { }
        public static . CheckDoesNotOverlap<TItem>(.<TItem> adapter, .<TItem> other) { }
        public static . CheckHasDistinctItems<TItem>(.<TItem> adapter, .<TItem>? comparer = null) { }
        public static . CheckHasSingleItem<TItem>(.<TItem> adapter) { }
        public static . CheckIsEmpty<TItem>(.<TItem> adapter) { }
        public static . CheckIsInDescendingOrder<TItem>(.<TItem> adapter, .<TItem>? comparer = null) { }
        public static . CheckIsInOrder<TItem>(.<TItem> adapter, .<TItem>? comparer = null) { }
        public static . CheckIsNotEmpty<TItem>(.<TItem> adapter) { }
        public static . CheckIsProperSubsetOf<TItem>(.<TItem> adapter, .<TItem> other) { }
        public static . CheckIsProperSupersetOf<TItem>(.<TItem> adapter, .<TItem> other) { }
        public static . CheckIsSubsetOf<TItem>(.<TItem> adapter, .<TItem> other) { }
        public static . CheckIsSupersetOf<TItem>(.<TItem> adapter, .<TItem> other) { }
        public static . CheckOverlaps<TItem>(.<TItem> adapter, .<TItem> other) { }
        public static . CheckSetEquals<TItem>(.<TItem> adapter, .<TItem> other) { }
    }
}
namespace .Conditions
{
    public class AssertionSourceAdapter<T> : ., .<T>
    {
        public AssertionSourceAdapter(.<T> context) { }
        public .<T> Context { get; }
        public .<TTarget, T> IsAssignableTo<TTarget>() { }
        public .<TTarget, T> IsNotAssignableTo<TTarget>() { }
        public .<T, TExpected> IsNotTypeOf<TExpected>() { }
        public .<T, TExpected> IsTypeOf<TExpected>() { }
    }
    public class AsyncMappedSatisfiesAssertion<TValue, TMapped> : .<TValue>
    {
        public AsyncMappedSatisfiesAssertion(.<TValue> context, <TValue?, .<TMapped>> selector, <.<TMapped>, .?> assertions, string selectorDescription) { }
        protected override .<.> CheckAsync(.<TValue> metadata) { }
        protected override string GetExpectation() { }
    }
    public abstract class BaseThrowsAssertion<TException, TSelf> : .<TException>
        where TException : 
        where TSelf : .<TException, TSelf>
    {
        protected BaseThrowsAssertion(.<TException> context, bool allowSubclasses) { }
        protected abstract bool IsExactTypeMatch { get; }
        protected override sealed .<.> CheckAsync(.<TException> metadata) { }
        protected abstract bool CheckExceptionType( actualException, out string? errorMessage);
        protected override string GetExpectation() { }
    }
    [.("IsBetween")]
    public class BetweenAssertion<TValue> : .<TValue>
        where TValue : <TValue>
    {
        public BetweenAssertion(.<TValue> context, TValue minimum, TValue maximum) { }
        protected override .<.> CheckAsync(.<TValue> metadata) { }
        public .<TValue> Exclusive() { }
        protected override string GetExpectation() { }
        public .<TValue> Inclusive() { }
        public .<TValue> InclusiveMaximum() { }
        public .<TValue> InclusiveMinimum() { }
    }
    [.<.BigInteger>("IsEven", CustomName="IsNotEven", ExpectationMessage="be even", NegateLogic=true)]
    [.<.BigInteger>("IsEven", ExpectationMessage="be even")]
    [.<.BigInteger>("IsZero", CustomName="IsNotZero", ExpectationMessage="be zero", NegateLogic=true)]
    [.<.BigInteger>("IsZero", ExpectationMessage="be zero")]
    public static class BigIntegerAssertionExtensions { }
    [.<char>("IsControl", CustomName="IsNotControl", ExpectationMessage="be a control character", NegateLogic=true)]
    [.<char>("IsControl", ExpectationMessage="be a control character")]
    [.<char>("IsDigit", CustomName="IsNotDigit", ExpectationMessage="be a digit", NegateLogic=true)]
    [.<char>("IsDigit", ExpectationMessage="be a digit")]
    [.<char>("IsHighSurrogate", CustomName="IsNotHighSurrogate", ExpectationMessage="be a high surrogate", NegateLogic=true)]
    [.<char>("IsHighSurrogate", ExpectationMessage="be a high surrogate")]
    [.<char>("IsLetter", CustomName="IsNotLetter", ExpectationMessage="be a letter", NegateLogic=true)]
    [.<char>("IsLetter", ExpectationMessage="be a letter")]
    [.<char>("IsLetterOrDigit", CustomName="IsNotLetterOrDigit", ExpectationMessage="be a letter or digit", NegateLogic=true)]
    [.<char>("IsLetterOrDigit", ExpectationMessage="be a letter or digit")]
    [.<char>("IsLowSurrogate", CustomName="IsNotLowSurrogate", ExpectationMessage="be a low surrogate", NegateLogic=true)]
    [.<char>("IsLowSurrogate", ExpectationMessage="be a low surrogate")]
    [.<char>("IsLower", CustomName="IsNotLower", ExpectationMessage="be lowercase", NegateLogic=true)]
    [.<char>("IsLower", ExpectationMessage="be lowercase")]
    [.<char>("IsNumber", CustomName="IsNotNumber", ExpectationMessage="be a number", NegateLogic=true)]
    [.<char>("IsNumber", ExpectationMessage="be a number")]
    [.<char>("IsPunctuation", CustomName="IsNotPunctuation", ExpectationMessage="be punctuation", NegateLogic=true)]
    [.<char>("IsPunctuation", ExpectationMessage="be punctuation")]
    [.<char>("IsSeparator", CustomName="IsNotSeparator", ExpectationMessage="be a separator", NegateLogic=true)]
    [.<char>("IsSeparator", ExpectationMessage="be a separator")]
    [.<char>("IsSurrogate", CustomName="IsNotSurrogate", ExpectationMessage="be a surrogate", NegateLogic=true)]
    [.<char>("IsSurrogate", ExpectationMessage="be a surrogate")]
    [.<char>("IsSymbol", CustomName="IsNotSymbol", ExpectationMessage="be a symbol", NegateLogic=true)]
    [.<char>("IsSymbol", ExpectationMessage="be a symbol")]
    [.<char>("IsUpper", CustomName="IsNotUpper", ExpectationMessage="be uppercase", NegateLogic=true)]
    [.<char>("IsUpper", ExpectationMessage="be uppercase")]
    [.<char>("IsWhiteSpace", CustomName="IsNotWhiteSpace", ExpectationMessage="be whitespace", NegateLogic=true)]
    [.<char>("IsWhiteSpace", ExpectationMessage="be whitespace")]
    public static class CharAssertionExtensions { }
    [.("All")]
    public class CollectionAllAssertion<TCollection, TItem> : .<TCollection, TItem>
        where TCollection : .<TItem>
    {
        public CollectionAllAssertion(.<TCollection> context, <TItem, bool> predicate, string predicateDescription) { }
        protected override .<.> CheckAsync(.<TCollection> metadata) { }
        protected override string GetExpectation() { }
    }
    public class CollectionAllSatisfyAssertion<TCollection, TItem> : .<TCollection, TItem>
        where TCollection : .<TItem>
    {
        public CollectionAllSatisfyAssertion(.<TCollection> context, <.<TItem>, .<TItem>?> assertion, string assertionDescription) { }
        protected override .<.> CheckAsync(.<TCollection> metadata) { }
        protected override string GetExpectation() { }
    }
    public class CollectionAllSatisfyHelper<TCollection, TItem>
        where TCollection : .<TItem>
    {
        public CollectionAllSatisfyHelper(.<TCollection> context) { }
        public .<TCollection, TItem> Satisfy(<.<TItem>, .<TItem>?> assertion, [.("assertion")] string? expression = null) { }
        public .<TCollection, TItem, TMapped> Satisfy<TMapped>(<TItem, TMapped> mapper, <.<TMapped>, .<TMapped>?> assertion, [.("mapper")] string? mapperExpression = null, [.("assertion")] string? assertionExpression = null) { }
    }
    public class CollectionAllSatisfyMappedAssertion<TCollection, TItem, TMapped> : .<TCollection, TItem>
        where TCollection : .<TItem>
    {
        public CollectionAllSatisfyMappedAssertion(.<TCollection> context, <TItem, TMapped> mapper, <.<TMapped>, .<TMapped>?> assertion, string mapperDescription, string assertionDescription) { }
        protected override .<.> CheckAsync(.<TCollection> metadata) { }
        protected override string GetExpectation() { }
    }
    [.("Any")]
    public class CollectionAnyAssertion<TCollection, TItem> : .<TCollection, TItem>
        where TCollection : .<TItem>
    {
        public CollectionAnyAssertion(.<TCollection> context, <TItem, bool> predicate, string predicateDescription) { }
        protected override .<.> CheckAsync(.<TCollection> metadata) { }
        protected override string GetExpectation() { }
    }
    public abstract class CollectionComparerBasedAssertion<TCollection, TItem> : .<TCollection, TItem>
        where TCollection : .<TItem>
    {
        protected .<TItem>? Comparer;
        protected CollectionComparerBasedAssertion(.<TCollection> context) { }
        protected .<TItem> GetComparer() { }
        protected void SetComparer(.<TItem> comparer) { }
    }
    [.("Contains")]
    public class CollectionContainsAssertion<TCollection, TItem> : .<TCollection, TItem>
        where TCollection : .<TItem>
    {
        public CollectionContainsAssertion(.<TCollection> context, TItem expected, .<TItem>? comparer = null) { }
        protected override .<.> CheckAsync(.<TCollection> metadata) { }
        protected override string GetExpectation() { }
    }
    [.("Contains")]
    public class CollectionContainsPredicateAssertion<TCollection, TItem> : .<TCollection, TItem>
        where TCollection : .<TItem>
    {
        public CollectionContainsPredicateAssertion(.<TCollection> context, <TItem, bool> predicate) { }
        protected override .<.> CheckAsync(.<TCollection> metadata) { }
        public .<TItem> GetAwaiter() { }
        protected override string GetExpectation() { }
    }
    public class CollectionCountAssertion<TCollection, TItem> : .<TCollection, TItem>
        where TCollection : .<TItem>
    {
        public CollectionCountAssertion(.<TCollection> context, int expectedCount) { }
        protected override .<.> CheckAsync(.<TCollection> metadata) { }
        protected override string GetExpectation() { }
    }
    public class CollectionCountEqualsAssertion<TCollection, TItem> : .<TCollection, TItem>
        where TCollection : .<TItem>
    {
        protected override .<.> CheckAsync(.<TCollection> metadata) { }
        protected override string GetExpectation() { }
    }
    public class CollectionCountSource<TCollection, TItem>
        where TCollection : .<TItem>
    {
        public CollectionCountSource(.<TCollection> collectionContext, <.<TItem>, .<TItem>?>? assertion) { }
        public .<TCollection, TItem> IsEqualTo(int expected, [.("expected")] string? expression = null) { }
        public .<TCollection, TItem> IsGreaterThan(int expected, [.("expected")] string? expression = null) { }
        public .<TCollection, TItem> IsGreaterThanOrEqualTo(int expected, [.("expected")] string? expression = null) { }
        public .<TCollection, TItem> IsLessThan(int expected, [.("expected")] string? expression = null) { }
        public .<TCollection, TItem> IsLessThanOrEqualTo(int expected, [.("expected")] string? expression = null) { }
        public .<TCollection, TItem> IsNotEqualTo(int expected, [.("expected")] string? expression = null) { }
        public .<TCollection, TItem> IsPositive() { }
        public .<TCollection, TItem> IsZero() { }
    }
    public class CollectionCountWithInlineAssertionAssertion<TCollection, TItem> : .<TCollection, TItem>
        where TCollection : .<TItem>
    {
        protected override .<.> CheckAsync(.<TCollection> metadata) { }
        protected override string GetExpectation() { }
    }
    [.("DoesNotContain")]
    public class CollectionDoesNotContainAssertion<TCollection, TItem> : .<TCollection, TItem>
        where TCollection : .<TItem>
    {
        public CollectionDoesNotContainAssertion(.<TCollection> context, TItem expected, .<TItem>? comparer = null) { }
        protected override .<.> CheckAsync(.<TCollection> metadata) { }
        protected override string GetExpectation() { }
    }
    [.("DoesNotContain")]
    public class CollectionDoesNotContainPredicateAssertion<TCollection, TItem> : .<TCollection, TItem>
        where TCollection : .<TItem>
    {
        public CollectionDoesNotContainPredicateAssertion(.<TCollection> context, <TItem, bool> predicate, string predicateDescription) { }
        protected override .<.> CheckAsync(.<TCollection> metadata) { }
        protected override string GetExpectation() { }
    }
    public class CollectionIsEmptyAssertion<TCollection, TItem> : .<TCollection, TItem>
        where TCollection : .<TItem>
    {
        public CollectionIsEmptyAssertion(.<TCollection> context) { }
        protected override .<.> CheckAsync(.<TCollection> metadata) { }
        protected override string GetExpectation() { }
    }
    [.("IsInDescendingOrder")]
    public class CollectionIsInDescendingOrderAssertion<TCollection, TItem> : .<TCollection, TItem>
        where TCollection : .<TItem>
    {
        public CollectionIsInDescendingOrderAssertion(.<TCollection> context) { }
        protected override .<.> CheckAsync(.<TCollection> metadata) { }
        protected override string GetExpectation() { }
    }
    [.("IsInOrder")]
    public class CollectionIsInOrderAssertion<TCollection, TItem> : .<TCollection, TItem>
        where TCollection : .<TItem>
    {
        public CollectionIsInOrderAssertion(.<TCollection> context) { }
        protected override .<.> CheckAsync(.<TCollection> metadata) { }
        protected override string GetExpectation() { }
    }
    public class CollectionIsNotEmptyAssertion<TCollection, TItem> : .<TCollection, TItem>
        where TCollection : .<TItem>
    {
        public CollectionIsNotEmptyAssertion(.<TCollection> context) { }
        protected override .<.> CheckAsync(.<TCollection> metadata) { }
        protected override string GetExpectation() { }
    }
    public class CollectionIsOrderedByAssertion<TCollection, TItem, TKey> : .<TCollection, TItem>
        where TCollection : .<TItem>
    {
        public CollectionIsOrderedByAssertion(.<TCollection> context, <TItem, TKey> keySelector, .<TKey>? comparer = null) { }
        protected override .<.> CheckAsync(.<TCollection> metadata) { }
        protected override string GetExpectation() { }
    }
    public class CollectionIsOrderedByDescendingAssertion<TCollection, TItem, TKey> : .<TCollection, TItem>
        where TCollection : .<TItem>
    {
        public CollectionIsOrderedByDescendingAssertion(.<TCollection> context, <TItem, TKey> keySelector, .<TKey>? comparer = null) { }
        protected override .<.> CheckAsync(.<TCollection> metadata) { }
        protected override string GetExpectation() { }
    }
    public class CollectionMemberAssertionAdapter<TCollection, TItem> : .<TCollection, TItem>
        where TCollection : .<TItem> { }
    public class CollectionNotNullAssertion<TCollection, TItem> : .<TCollection, TItem>
        where TCollection : .<TItem>
    {
        public CollectionNotNullAssertion(.<TCollection> context) { }
        protected override .<.> CheckAsync(.<TCollection> metadata) { }
        protected override string GetExpectation() { }
    }
    public abstract class ComparerBasedAssertion<TValue, TItem> : .<TValue>
    {
        protected ComparerBasedAssertion(.<TValue> context) { }
        protected .<TItem> GetComparer() { }
        protected bool HasCustomComparer() { }
        protected void SetComparer(.<TItem> comparer) { }
    }
    public class CompletesWithinActionAssertion : .<object?>
    {
        public CompletesWithinActionAssertion( action,  timeout, .<object?>? context = null) { }
        protected override .<.> CheckAsync(.<object?> metadata) { }
        protected override string GetExpectation() { }
    }
    public class CompletesWithinAsyncAssertion : .<object?>
    {
        public CompletesWithinAsyncAssertion(<.> asyncAction,  timeout, .<object?>? context = null) { }
        protected override .<.> CheckAsync(.<object?> metadata) { }
        protected override string GetExpectation() { }
    }
    [.<.Cookie>("Expired", CustomName="IsNotExpired", ExpectationMessage="be expired", NegateLogic=true)]
    [.<.Cookie>("Expired", ExpectationMessage="be expired")]
    [.<.Cookie>("HttpOnly", CustomName="IsNotHttpOnly", ExpectationMessage="be HTTP-only", NegateLogic=true)]
    [.<.Cookie>("HttpOnly", ExpectationMessage="be HTTP-only")]
    [.<.Cookie>("Secure", CustomName="IsNotSecure", ExpectationMessage="be secure", NegateLogic=true)]
    [.<.Cookie>("Secure", ExpectationMessage="be secure")]
    public static class CookieAssertionExtensions { }
    [.("IsEqualTo", OverloadResolutionPriority=2)]
    public class DateTimeEqualsAssertion : .<, >
    {
        public DateTimeEqualsAssertion(.<> context,  expected) { }
        protected override bool AreExactlyEqual( actual,  expected) { }
        protected override object CalculateDifference( actual,  expected) { }
        protected override string FormatDifferenceMessage( actual, object difference) { }
        protected override string GetExpectation() { }
        protected override bool HasToleranceValue() { }
        protected override bool IsWithinTolerance( actual,  expected,  tolerance) { }
    }
    [.("EqualsExact")]
    public class DateTimeEqualsExactAssertion : .<>
    {
        public DateTimeEqualsExactAssertion(.<> context,  expected) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    [.("IsEqualTo", OverloadResolutionPriority=2)]
    public class DateTimeOffsetEqualsAssertion : .<, >
    {
        public DateTimeOffsetEqualsAssertion(.<> context,  expected) { }
        protected override bool AreExactlyEqual( actual,  expected) { }
        protected override object CalculateDifference( actual,  expected) { }
        protected override bool HasToleranceValue() { }
        protected override bool IsWithinTolerance( actual,  expected,  tolerance) { }
    }
    [.("IsEqualTo", OverloadResolutionPriority=2)]
    public class DecimalEqualsAssertion : .<decimal, decimal>
    {
        public DecimalEqualsAssertion(.<decimal> context, decimal expected) { }
        protected override bool AreExactlyEqual(decimal actual, decimal expected) { }
        protected override object CalculateDifference(decimal actual, decimal expected) { }
        protected override bool HasToleranceValue() { }
        protected override bool IsWithinTolerance(decimal actual, decimal expected, decimal tolerance) { }
    }
    public class DictionaryAllKeysAssertion<TDictionary, TKey, TValue> : .<TDictionary, TKey, TValue>
        where TDictionary : .<TKey, TValue>
        where TKey :  notnull
    {
        public DictionaryAllKeysAssertion(.<TDictionary> context, <TKey, bool> predicate) { }
        protected override .<.> CheckAsync(.<TDictionary> metadata) { }
        protected override string GetExpectation() { }
    }
    public class DictionaryAllValuesAssertion<TDictionary, TKey, TValue> : .<TDictionary, TKey, TValue>
        where TDictionary : .<TKey, TValue>
        where TKey :  notnull
    {
        public DictionaryAllValuesAssertion(.<TDictionary> context, <TValue, bool> predicate) { }
        protected override .<.> CheckAsync(.<TDictionary> metadata) { }
        protected override string GetExpectation() { }
    }
    public class DictionaryAnyKeyAssertion<TDictionary, TKey, TValue> : .<TDictionary, TKey, TValue>
        where TDictionary : .<TKey, TValue>
        where TKey :  notnull
    {
        public DictionaryAnyKeyAssertion(.<TDictionary> context, <TKey, bool> predicate) { }
        protected override .<.> CheckAsync(.<TDictionary> metadata) { }
        protected override string GetExpectation() { }
    }
    public class DictionaryAnyValueAssertion<TDictionary, TKey, TValue> : .<TDictionary, TKey, TValue>
        where TDictionary : .<TKey, TValue>
        where TKey :  notnull
    {
        public DictionaryAnyValueAssertion(.<TDictionary> context, <TValue, bool> predicate) { }
        protected override .<.> CheckAsync(.<TDictionary> metadata) { }
        protected override string GetExpectation() { }
    }
    public class DictionaryContainsKeyAssertion<TDictionary, TKey, TValue> : .<TDictionary, TKey, TValue>
        where TDictionary : .<TKey, TValue>
        where TKey :  notnull
    {
        public DictionaryContainsKeyAssertion(.<TDictionary> context, TKey expectedKey, .<TKey>? comparer = null) { }
        protected override .<.> CheckAsync(.<TDictionary> metadata) { }
        protected override string GetExpectation() { }
        public .<TDictionary, TKey, TValue> Using(.<TKey> comparer) { }
        public .<TDictionary, TKey, TValue> Using(<TKey?, TKey?, bool> equalityPredicate) { }
    }
    public class DictionaryContainsKeyWithValueAssertion<TDictionary, TKey, TValue> : .<TDictionary, TKey, TValue>
        where TDictionary : .<TKey, TValue>
        where TKey :  notnull
    {
        public DictionaryContainsKeyWithValueAssertion(.<TDictionary> context, TKey expectedKey, TValue expectedValue, .<TValue>? comparer = null) { }
        protected override .<.> CheckAsync(.<TDictionary> metadata) { }
        protected override string GetExpectation() { }
    }
    public class DictionaryContainsValueAssertion<TDictionary, TKey, TValue> : .<TDictionary, TKey, TValue>
        where TDictionary : .<TKey, TValue>
        where TKey :  notnull
    {
        public DictionaryContainsValueAssertion(.<TDictionary> context, TValue expectedValue, .<TValue>? comparer = null) { }
        protected override .<.> CheckAsync(.<TDictionary> metadata) { }
        protected override string GetExpectation() { }
    }
    public class DictionaryDoesNotContainKeyAssertion<TDictionary, TKey, TValue> : .<TDictionary, TKey, TValue>
        where TDictionary : .<TKey, TValue>
        where TKey :  notnull
    {
        public DictionaryDoesNotContainKeyAssertion(.<TDictionary> context, TKey expectedKey) { }
        protected override .<.> CheckAsync(.<TDictionary> metadata) { }
        protected override string GetExpectation() { }
    }
    public class DictionaryDoesNotContainValueAssertion<TDictionary, TKey, TValue> : .<TDictionary, TKey, TValue>
        where TDictionary : .<TKey, TValue>
        where TKey :  notnull
    {
        public DictionaryDoesNotContainValueAssertion(.<TDictionary> context, TValue expectedValue, .<TValue>? comparer = null) { }
        protected override .<.> CheckAsync(.<TDictionary> metadata) { }
        protected override string GetExpectation() { }
    }
    public class DictionaryMemberAssertionAdapter<TDictionary, TKey, TValue> : .<TDictionary, TKey, TValue>
        where TDictionary : .<TKey, TValue>
        where TKey :  notnull { }
    [.("HasFiles")]
    public class DirectoryHasFilesAssertion : .<.DirectoryInfo>
    {
        public DirectoryHasFilesAssertion(.<.DirectoryInfo> context) { }
        protected override .<.> CheckAsync(.<.DirectoryInfo> metadata) { }
        protected override string GetExpectation() { }
    }
    [.("HasNoSubdirectories")]
    public class DirectoryHasNoSubdirectoriesAssertion : .<.DirectoryInfo>
    {
        public DirectoryHasNoSubdirectoriesAssertion(.<.DirectoryInfo> context) { }
        protected override .<.> CheckAsync(.<.DirectoryInfo> metadata) { }
        protected override string GetExpectation() { }
    }
    [.<double>("IsInfinity", CustomName="IsNotInfinity", ExpectationMessage="be infinity", NegateLogic=true)]
    [.<double>("IsInfinity", ExpectationMessage="be infinity")]
    [.<double>("IsNaN", CustomName="IsNotNaN", ExpectationMessage="be NaN", NegateLogic=true)]
    [.<double>("IsNaN", ExpectationMessage="be NaN")]
    [.<double>("IsNegativeInfinity", CustomName="IsNotNegativeInfinity", ExpectationMessage="be negative infinity", NegateLogic=true)]
    [.<double>("IsNegativeInfinity", ExpectationMessage="be negative infinity")]
    [.<double>("IsPositiveInfinity", CustomName="IsNotPositiveInfinity", ExpectationMessage="be positive infinity", NegateLogic=true)]
    [.<double>("IsPositiveInfinity", ExpectationMessage="be positive infinity")]
    public static class DoubleAssertionExtensions { }
    [.("IsEqualTo", OverloadResolutionPriority=2)]
    public class DoubleEqualsAssertion : .<double, double>
    {
        public DoubleEqualsAssertion(.<double> context, double expected) { }
        protected override bool AreExactlyEqual(double actual, double expected) { }
        protected override object CalculateDifference(double actual, double expected) { }
        protected override bool HasToleranceValue() { }
        protected override bool IsWithinTolerance(double actual, double expected, double tolerance) { }
    }
    [.("IsEqualTo")]
    public class EqualsAssertion<TValue> : .<TValue>
    {
        public EqualsAssertion(.<TValue> context, TValue? expected) { }
        public EqualsAssertion(.<TValue> context, TValue? expected, .<TValue> comparer) { }
        public TValue Expected { get; }
        protected override .<.> CheckAsync(.<TValue> metadata) { }
        protected override string GetExpectation() { }
        public .<TValue> IgnoringType( type) { }
        public .<TValue> IgnoringType<TIgnore>() { }
    }
    [.("IsEquatableTo")]
    public class EquatableAssertion<TActual, TExpected> : .<TActual>
        where TActual : <TExpected>
    {
        public EquatableAssertion(.<TActual> context, TExpected expected) { }
        protected override .<.> CheckAsync(.<TActual> metadata) { }
        protected override string GetExpectation() { }
    }
    public class ExceptionMessageContainsAssertion<TException> : .<TException>
        where TException : 
    {
        public ExceptionMessageContainsAssertion(.<TException> context, string expectedSubstring,  comparison = 4) { }
        protected override .<.> CheckAsync(.<TException> metadata) { }
        protected override string GetExpectation() { }
    }
    public class ExceptionMessageEqualsAssertion<TException> : .<TException>
        where TException : 
    {
        public ExceptionMessageEqualsAssertion(.<TException> context, string expectedMessage,  comparison = 4) { }
        protected override .<.> CheckAsync(.<TException> metadata) { }
        protected override string GetExpectation() { }
    }
    public class ExceptionMessageMatchesAssertion<TException> : .<TException>
        where TException : 
    {
        public ExceptionMessageMatchesAssertion(.<TException> context, .StringMatcher matcher) { }
        protected override .<.> CheckAsync(.<TException> metadata) { }
        protected override string GetExpectation() { }
    }
    public class ExceptionMessageMatchesPatternAssertion<TException> : .<TException>
        where TException : 
    {
        public ExceptionMessageMatchesPatternAssertion(.<TException> context, string pattern) { }
        protected override .<.> CheckAsync(.<TException> metadata) { }
        protected override string GetExpectation() { }
    }
    public class ExceptionMessageNotContainsAssertion<TException> : .<TException>
        where TException : 
    {
        public ExceptionMessageNotContainsAssertion(.<TException> context, string notExpectedSubstring,  comparison = 4) { }
        protected override .<.> CheckAsync(.<TException> metadata) { }
        protected override string GetExpectation() { }
    }
    public class ExceptionParameterNameAssertion<TException> : .<TException>
        where TException : 
    {
        public ExceptionParameterNameAssertion(.<TException> context, string expectedParameterName, bool requireExactType = false) { }
        protected override .<.> CheckAsync(.<TException> metadata) { }
        protected override string GetExpectation() { }
    }
    [.("IsNotExecutable")]
    public class FileIsNotExecutableAssertion : .<.FileInfo>
    {
        public FileIsNotExecutableAssertion(.<.FileInfo> context) { }
        protected override .<.> CheckAsync(.<.FileInfo> metadata) { }
        protected override string GetExpectation() { }
    }
    [.("IsNotSystem")]
    public class FileIsNotSystemAssertion : .<.FileInfo>
    {
        public FileIsNotSystemAssertion(.<.FileInfo> context) { }
        protected override .<.> CheckAsync(.<.FileInfo> metadata) { }
        protected override string GetExpectation() { }
    }
    [.("IsEqualTo", OverloadResolutionPriority=2)]
    public class FloatEqualsAssertion : .<float, float>
    {
        public FloatEqualsAssertion(.<float> context, float expected) { }
        protected override bool AreExactlyEqual(float actual, float expected) { }
        protected override object CalculateDifference(float actual, float expected) { }
        protected override bool HasToleranceValue() { }
        protected override bool IsWithinTolerance(float actual, float expected, float tolerance) { }
    }
    [.("IsGreaterThan")]
    public class GreaterThanAssertion<TValue> : .<TValue>
        where TValue : <TValue>
    {
        public GreaterThanAssertion(.<TValue> context, TValue minimum) { }
        protected override .<.> CheckAsync(.<TValue> metadata) { }
        protected override string GetExpectation() { }
    }
    [.("IsGreaterThanOrEqualTo")]
    public class GreaterThanOrEqualAssertion<TValue> : .<TValue>
        where TValue : <TValue>
    {
        public GreaterThanOrEqualAssertion(.<TValue> context, TValue minimum) { }
        protected override .<.> CheckAsync(.<TValue> metadata) { }
        protected override string GetExpectation() { }
    }
    public class HasDistinctItemsAssertion<TCollection, TItem> : .<TCollection, TItem>
        where TCollection : .<TItem>
    {
        public HasDistinctItemsAssertion(.<TCollection> context) { }
        protected override .<.> CheckAsync(.<TCollection> metadata) { }
        protected override string GetExpectation() { }
    }
    public class HasMessageContainingAssertion<TValue> : .<TValue>
    {
        public HasMessageContainingAssertion(.<TValue> context, string expectedSubstring,  comparison = 4) { }
        protected override .<.> CheckAsync(.<TValue> metadata) { }
        protected override string GetExpectation() { }
    }
    public class HasMessageEqualToAssertion<TValue> : .<TValue>
    {
        public HasMessageEqualToAssertion(.<TValue> context, string expectedMessage,  comparison = 4) { }
        protected override .<.> CheckAsync(.<TValue> metadata) { }
        protected override string GetExpectation() { }
    }
    public class HasMessageStartingWithAssertion<TValue> : .<TValue>
    {
        public HasMessageStartingWithAssertion(.<TValue> context, string expectedPrefix,  comparison = 4) { }
        protected override .<.> CheckAsync(.<TValue> metadata) { }
        protected override string GetExpectation() { }
    }
    [.("HasSingleItem")]
    public class HasSingleItemAssertion<TCollection, TItem> : .<TCollection, TItem>
        where TCollection : .<TItem>
    {
        public HasSingleItemAssertion(.<TCollection> context) { }
        protected override .<.> CheckAsync(.<TCollection> metadata) { }
        public .<TItem> GetAwaiter() { }
        protected override string GetExpectation() { }
    }
    [.<.>("IsSuccessStatusCode", CustomName="IsNotSuccessStatusCode", ExpectationMessage="have a success status code", NegateLogic=true)]
    [.<.>("IsSuccessStatusCode", ExpectationMessage="have a success status code")]
    public static class HttpResponseMessageAssertionExtensions { }
    [.<.IPAddress>("IsIPv4MappedToIPv6", CustomName="IsNotIPv4MappedToIPv6", ExpectationMessage="be an IPv4-mapped IPv6 address", NegateLogic=true)]
    [.<.IPAddress>("IsIPv4MappedToIPv6", ExpectationMessage="be an IPv4-mapped IPv6 address")]
    [.<.IPAddress>("IsIPv6LinkLocal", CustomName="IsNotIPv6LinkLocal", ExpectationMessage="be an IPv6 link-local address", NegateLogic=true)]
    [.<.IPAddress>("IsIPv6LinkLocal", ExpectationMessage="be an IPv6 link-local address")]
    [.<.IPAddress>("IsIPv6Multicast", CustomName="IsNotIPv6Multicast", ExpectationMessage="be an IPv6 multicast address", NegateLogic=true)]
    [.<.IPAddress>("IsIPv6Multicast", ExpectationMessage="be an IPv6 multicast address")]
    [.<.IPAddress>("IsIPv6SiteLocal", CustomName="IsNotIPv6SiteLocal", ExpectationMessage="be an IPv6 site-local address", NegateLogic=true)]
    [.<.IPAddress>("IsIPv6SiteLocal", ExpectationMessage="be an IPv6 site-local address")]
    [.<.IPAddress>("IsIPv6Teredo", CustomName="IsNotIPv6Teredo", ExpectationMessage="be an IPv6 Teredo address", NegateLogic=true)]
    [.<.IPAddress>("IsIPv6Teredo", ExpectationMessage="be an IPv6 Teredo address")]
    public static class IPAddressAssertionExtensions { }
    [.("IsEqualTo", OverloadResolutionPriority=2)]
    public class IntEqualsAssertion : .<int>
    {
        public IntEqualsAssertion(.<int> context, int expected) { }
        protected override .<.> CheckAsync(.<int> metadata) { }
        protected override string GetExpectation() { }
        public . Within(int tolerance) { }
    }
    public class IsAssignableToAssertion<TTarget, TValue> : .<TValue>
    {
        public IsAssignableToAssertion(.<TValue> context) { }
        protected override .<.> CheckAsync(.<TValue> metadata) { }
        protected override string GetExpectation() { }
    }
    [.("IsDefault")]
    public class IsDefaultAssertion<TValue> : .<TValue>
        where TValue :  struct
    {
        public IsDefaultAssertion(.<TValue> context) { }
        protected override .<.> CheckAsync(.<TValue> metadata) { }
        protected override string GetExpectation() { }
    }
    [.("IsDefault")]
    public class IsDefaultNullableAssertion<TValue> : .<TValue?>
        where TValue :  struct
    {
        public IsDefaultNullableAssertion(.<TValue?> context) { }
        protected override .<.> CheckAsync(.<TValue?> metadata) { }
        protected override string GetExpectation() { }
    }
    [.("IsDefault")]
    public class IsDefaultReferenceAssertion<TValue> : .<TValue>
        where TValue :  class
    {
        public IsDefaultReferenceAssertion(.<TValue> context) { }
        protected override .<.> CheckAsync(.<TValue> metadata) { }
        protected override string GetExpectation() { }
    }
    [.("IsEquatableOrEqualTo")]
    public class IsEquatableOrEqualToAssertion<TValue> : .<TValue, TValue>
    {
        public IsEquatableOrEqualToAssertion(.<TValue> context, TValue expected) { }
        protected override .<.> CheckAsync(.<TValue> metadata) { }
        protected override string GetExpectation() { }
        public .<TValue> Using(.<TValue> comparer) { }
        public .<TValue> Using(<TValue?, TValue?, bool> equalityPredicate) { }
    }
    [.("IsEquivalentTo")]
    public class IsEquivalentToAssertion<TCollection, TItem> : .<TCollection, TItem>
        where TCollection : .<TItem>
    {
        public IsEquivalentToAssertion(.<TCollection> context, .<TItem> expected, . ordering = 0) { }
        public IsEquivalentToAssertion(.<TCollection> context, .<TItem> expected, .<TItem> comparer, . ordering = 0) { }
        protected override .<.> CheckAsync(.<TCollection> metadata) { }
        protected override string GetExpectation() { }
        public .<TCollection, TItem> Using(.<TItem> comparer) { }
        public .<TCollection, TItem> Using(<TItem?, TItem?, bool> equalityPredicate) { }
    }
    public class IsNotAssignableToAssertion<TTarget, TValue> : .<TValue>
    {
        public IsNotAssignableToAssertion(.<TValue> context) { }
        protected override .<.> CheckAsync(.<TValue> metadata) { }
        protected override string GetExpectation() { }
    }
    [.("IsNotDefault")]
    public class IsNotDefaultAssertion<TValue> : .<TValue>
        where TValue :  struct
    {
        public IsNotDefaultAssertion(.<TValue> context) { }
        protected override .<.> CheckAsync(.<TValue> metadata) { }
        protected override string GetExpectation() { }
    }
    [.("IsNotDefault")]
    public class IsNotDefaultNullableAssertion<TValue> : .<TValue?>
        where TValue :  struct
    {
        public IsNotDefaultNullableAssertion(.<TValue?> context) { }
        protected override .<.> CheckAsync(.<TValue?> metadata) { }
        protected override string GetExpectation() { }
    }
    [.("IsNotDefault")]
    public class IsNotDefaultReferenceAssertion<TValue> : .<TValue>
        where TValue :  class
    {
        public IsNotDefaultReferenceAssertion(.<TValue> context) { }
        protected override .<.> CheckAsync(.<TValue> metadata) { }
        protected override string GetExpectation() { }
    }
    public class IsNotTypeOfAssertion<TValue, TExpected> : .<TValue>
    {
        public IsNotTypeOfAssertion(.<TValue> context) { }
        protected override .<.> CheckAsync(.<TValue> metadata) { }
        protected override string GetExpectation() { }
    }
    public class IsTypeOfRuntimeAssertion<TValue> : .<TValue>
    {
        public IsTypeOfRuntimeAssertion(.<TValue> context,  expectedType) { }
        protected override .<.> CheckAsync(.<TValue> metadata) { }
        protected override string GetExpectation() { }
    }
    [.("IsLessThan")]
    public class LessThanAssertion<TValue> : .<TValue>
        where TValue : <TValue>
    {
        public LessThanAssertion(.<TValue> context, TValue maximum) { }
        protected override .<.> CheckAsync(.<TValue> metadata) { }
        protected override string GetExpectation() { }
    }
    [.("IsLessThanOrEqualTo")]
    public class LessThanOrEqualAssertion<TValue> : .<TValue>
        where TValue : <TValue>
    {
        public LessThanOrEqualAssertion(.<TValue> context, TValue maximum) { }
        protected override .<.> CheckAsync(.<TValue> metadata) { }
        protected override string GetExpectation() { }
    }
    [.("IsEqualTo", OverloadResolutionPriority=2)]
    public class LongEqualsAssertion : .<long, long>
    {
        public LongEqualsAssertion(.<long> context, long expected) { }
        protected override bool AreExactlyEqual(long actual, long expected) { }
        protected override object CalculateDifference(long actual, long expected) { }
        protected override bool HasToleranceValue() { }
        protected override bool IsWithinTolerance(long actual, long expected, long tolerance) { }
    }
    public class MappedSatisfiesAssertion<TValue, TMapped> : .<TValue>
    {
        public MappedSatisfiesAssertion(.<TValue> context, <TValue?, TMapped> selector, <.<TMapped>, .?> assertions, string selectorDescription) { }
        protected override .<.> CheckAsync(.<TValue> metadata) { }
        protected override string GetExpectation() { }
    }
    public class MemberAssertionResult<TObject> : .
    {
        public .<TObject> And { get; }
        public .<TObject> Or { get; }
        public .<TObject?> GetAwaiter() { }
        public static .<TObject> op_Implicit(.<TObject> result) { }
    }
    public class MutableDictionaryAllKeysAssertion<TDictionary, TKey, TValue> : .<TDictionary, TKey, TValue>
        where TDictionary : .<TKey, TValue>
        where TKey :  notnull
    {
        public MutableDictionaryAllKeysAssertion(.<TDictionary> context, <TKey, bool> predicate) { }
        protected override .<.> CheckAsync(.<TDictionary> metadata) { }
        protected override string GetExpectation() { }
    }
    public class MutableDictionaryAllValuesAssertion<TDictionary, TKey, TValue> : .<TDictionary, TKey, TValue>
        where TDictionary : .<TKey, TValue>
        where TKey :  notnull
    {
        public MutableDictionaryAllValuesAssertion(.<TDictionary> context, <TValue, bool> predicate) { }
        protected override .<.> CheckAsync(.<TDictionary> metadata) { }
        protected override string GetExpectation() { }
    }
    public class MutableDictionaryAnyKeyAssertion<TDictionary, TKey, TValue> : .<TDictionary, TKey, TValue>
        where TDictionary : .<TKey, TValue>
        where TKey :  notnull
    {
        public MutableDictionaryAnyKeyAssertion(.<TDictionary> context, <TKey, bool> predicate) { }
        protected override .<.> CheckAsync(.<TDictionary> metadata) { }
        protected override string GetExpectation() { }
    }
    public class MutableDictionaryAnyValueAssertion<TDictionary, TKey, TValue> : .<TDictionary, TKey, TValue>
        where TDictionary : .<TKey, TValue>
        where TKey :  notnull
    {
        public MutableDictionaryAnyValueAssertion(.<TDictionary> context, <TValue, bool> predicate) { }
        protected override .<.> CheckAsync(.<TDictionary> metadata) { }
        protected override string GetExpectation() { }
    }
    public class MutableDictionaryContainsKeyAssertion<TDictionary, TKey, TValue> : .<TDictionary, TKey, TValue>
        where TDictionary : .<TKey, TValue>
        where TKey :  notnull
    {
        public MutableDictionaryContainsKeyAssertion(.<TDictionary> context, TKey expectedKey, .<TKey>? comparer = null) { }
        protected override .<.> CheckAsync(.<TDictionary> metadata) { }
        protected override string GetExpectation() { }
        public .<TDictionary, TKey, TValue> Using(.<TKey> comparer) { }
        public .<TDictionary, TKey, TValue> Using(<TKey?, TKey?, bool> equalityPredicate) { }
    }
    public class MutableDictionaryContainsKeyWithValueAssertion<TDictionary, TKey, TValue> : .<TDictionary, TKey, TValue>
        where TDictionary : .<TKey, TValue>
        where TKey :  notnull
    {
        public MutableDictionaryContainsKeyWithValueAssertion(.<TDictionary> context, TKey expectedKey, TValue expectedValue) { }
        protected override .<.> CheckAsync(.<TDictionary> metadata) { }
        protected override string GetExpectation() { }
    }
    public class MutableDictionaryContainsValueAssertion<TDictionary, TKey, TValue> : .<TDictionary, TKey, TValue>
        where TDictionary : .<TKey, TValue>
        where TKey :  notnull
    {
        public MutableDictionaryContainsValueAssertion(.<TDictionary> context, TValue expectedValue) { }
        protected override .<.> CheckAsync(.<TDictionary> metadata) { }
        protected override string GetExpectation() { }
    }
    public class MutableDictionaryDoesNotContainKeyAssertion<TDictionary, TKey, TValue> : .<TDictionary, TKey, TValue>
        where TDictionary : .<TKey, TValue>
        where TKey :  notnull
    {
        public MutableDictionaryDoesNotContainKeyAssertion(.<TDictionary> context, TKey expectedKey) { }
        protected override .<.> CheckAsync(.<TDictionary> metadata) { }
        protected override string GetExpectation() { }
    }
    public class MutableDictionaryDoesNotContainValueAssertion<TDictionary, TKey, TValue> : .<TDictionary, TKey, TValue>
        where TDictionary : .<TKey, TValue>
        where TKey :  notnull
    {
        public MutableDictionaryDoesNotContainValueAssertion(.<TDictionary> context, TValue expectedValue) { }
        protected override .<.> CheckAsync(.<TDictionary> metadata) { }
        protected override string GetExpectation() { }
    }
    [.("IsNotEqualTo")]
    public class NotEqualsAssertion<TValue> : .<TValue>
    {
        public NotEqualsAssertion(.<TValue> context, TValue notExpected, .<TValue>? comparer = null) { }
        protected override .<.> CheckAsync(.<TValue> metadata) { }
        protected override string GetExpectation() { }
        public .<TValue> IgnoringType( type) { }
        public .<TValue> IgnoringType<TIgnore>() { }
    }
    [.("IsNotEquivalentTo")]
    public class NotEquivalentToAssertion<TCollection, TItem> : .<TCollection, TItem>
        where TCollection : .<TItem>
    {
        public NotEquivalentToAssertion(.<TCollection> context, .<TItem> notExpected, . ordering = 0) { }
        public NotEquivalentToAssertion(.<TCollection> context, .<TItem> notExpected, .<TItem> comparer, . ordering = 0) { }
        protected override .<.> CheckAsync(.<TCollection> metadata) { }
        protected override string GetExpectation() { }
        public .<TCollection, TItem> Using(.<TItem> comparer) { }
        public .<TCollection, TItem> Using(<TItem?, TItem?, bool> equalityPredicate) { }
    }
    public class NotNullAssertion<TValue> : .<TValue>
    {
        public NotNullAssertion(.<TValue> context) { }
        protected override .<.> CheckAsync(.<TValue> metadata) { }
        public new .<TValue> GetAwaiter() { }
        protected override string GetExpectation() { }
    }
    [.("IsNotSameReferenceAs")]
    public class NotSameReferenceAssertion<TValue> : .<TValue>
    {
        public NotSameReferenceAssertion(.<TValue> context, object? expected) { }
        protected override .<.> CheckAsync(.<TValue> metadata) { }
        protected override string GetExpectation() { }
    }
    public class NotStructuralEquivalencyAssertion<TValue> : .<TValue>
    {
        public NotStructuralEquivalencyAssertion(.<TValue> context, object? notExpected, string? notExpectedExpression = null) { }
        protected override .<.> CheckAsync(.<TValue> metadata) { }
        protected override string GetExpectation() { }
        public .<TValue> IgnoringMember(string memberPath) { }
        public .<TValue> IgnoringType( type) { }
        public .<TValue> IgnoringType<T>() { }
        public .<TValue> WithPartialEquivalency() { }
    }
    [.("IsNull")]
    public class NullAssertion<TValue> : .<TValue>
    {
        public NullAssertion(.<TValue> context) { }
        protected override .<.> CheckAsync(.<TValue> metadata) { }
        protected override string GetExpectation() { }
    }
    [.(typeof(int?), "HasValue", CustomName="DoesNotHaveValue", ExpectationMessage="have a value", NegateLogic=true)]
    [.(typeof(int?), "HasValue", ExpectationMessage="have a value")]
    public static class NullableAssertionExtensions { }
    [.("IsEquatableTo")]
    public class NullableEquatableAssertion<TActual, TExpected> : .<TActual?>
        where TActual :  struct, <TExpected>
    {
        public NullableEquatableAssertion(.<TActual?> context, TExpected expected) { }
        protected override .<.> CheckAsync(.<TActual?> metadata) { }
        protected override string GetExpectation() { }
    }
    [.<.Process>("EnableRaisingEvents", CustomName="DoesNotHaveEventRaisingEnabled", ExpectationMessage="have event raising enabled", NegateLogic=true)]
    [.<.Process>("EnableRaisingEvents", ExpectationMessage="have event raising enabled")]
    [.<.Process>("HasExited", CustomName="HasNotExited", ExpectationMessage="have exited", NegateLogic=true)]
    [.<.Process>("HasExited", ExpectationMessage="have exited")]
    [.<.Process>("Responding", CustomName="IsNotResponding", ExpectationMessage="be responding", NegateLogic=true)]
    [.<.Process>("Responding", ExpectationMessage="be responding")]
    public static class ProcessAssertionExtensions { }
    [.("IsSameReferenceAs")]
    public class SameReferenceAssertion<TValue> : .<TValue>
    {
        public SameReferenceAssertion(.<TValue> context, object? expected) { }
        protected override .<.> CheckAsync(.<TValue> metadata) { }
        protected override string GetExpectation() { }
    }
    public class SatisfiesAssertion<TValue> : .<TValue>
    {
        public SatisfiesAssertion(.<TValue> context, <TValue?, bool> predicate, string predicateDescription) { }
        protected override .<.> CheckAsync(.<TValue> metadata) { }
        protected override string GetExpectation() { }
    }
    public class SetDoesNotOverlapAssertion<TSet, TItem> : .<TSet, TItem>
        where TSet : .<TItem>
    {
        public SetDoesNotOverlapAssertion(.<TSet> context, <TSet, .<TItem>> adapterFactory, .<TItem> other) { }
        protected override .<.> CheckAsync(.<TSet> metadata) { }
        protected override .<TItem> CreateSetAdapter(TSet value) { }
        protected override string GetExpectation() { }
    }
    public class SetEqualsAssertion<TSet, TItem> : .<TSet, TItem>
        where TSet : .<TItem>
    {
        public SetEqualsAssertion(.<TSet> context, <TSet, .<TItem>> adapterFactory, .<TItem> other) { }
        protected override .<.> CheckAsync(.<TSet> metadata) { }
        protected override .<TItem> CreateSetAdapter(TSet value) { }
        protected override string GetExpectation() { }
    }
    public class SetIsProperSubsetOfAssertion<TSet, TItem> : .<TSet, TItem>
        where TSet : .<TItem>
    {
        public SetIsProperSubsetOfAssertion(.<TSet> context, <TSet, .<TItem>> adapterFactory, .<TItem> other) { }
        protected override .<.> CheckAsync(.<TSet> metadata) { }
        protected override .<TItem> CreateSetAdapter(TSet value) { }
        protected override string GetExpectation() { }
    }
    public class SetIsProperSupersetOfAssertion<TSet, TItem> : .<TSet, TItem>
        where TSet : .<TItem>
    {
        public SetIsProperSupersetOfAssertion(.<TSet> context, <TSet, .<TItem>> adapterFactory, .<TItem> other) { }
        protected override .<.> CheckAsync(.<TSet> metadata) { }
        protected override .<TItem> CreateSetAdapter(TSet value) { }
        protected override string GetExpectation() { }
    }
    public class SetIsSubsetOfAssertion<TSet, TItem> : .<TSet, TItem>
        where TSet : .<TItem>
    {
        public SetIsSubsetOfAssertion(.<TSet> context, <TSet, .<TItem>> adapterFactory, .<TItem> other) { }
        protected override .<.> CheckAsync(.<TSet> metadata) { }
        protected override .<TItem> CreateSetAdapter(TSet value) { }
        protected override string GetExpectation() { }
    }
    public class SetIsSupersetOfAssertion<TSet, TItem> : .<TSet, TItem>
        where TSet : .<TItem>
    {
        public SetIsSupersetOfAssertion(.<TSet> context, <TSet, .<TItem>> adapterFactory, .<TItem> other) { }
        protected override .<.> CheckAsync(.<TSet> metadata) { }
        protected override .<TItem> CreateSetAdapter(TSet value) { }
        protected override string GetExpectation() { }
    }
    public class SetOverlapsAssertion<TSet, TItem> : .<TSet, TItem>
        where TSet : .<TItem>
    {
        public SetOverlapsAssertion(.<TSet> context, <TSet, .<TItem>> adapterFactory, .<TItem> other) { }
        protected override .<.> CheckAsync(.<TSet> metadata) { }
        protected override .<TItem> CreateSetAdapter(TSet value) { }
        protected override string GetExpectation() { }
    }
    [.<float>("IsInfinity", CustomName="IsNotInfinity", ExpectationMessage="be infinity", NegateLogic=true)]
    [.<float>("IsInfinity", ExpectationMessage="be infinity")]
    [.<float>("IsNaN", CustomName="IsNotNaN", ExpectationMessage="be NaN", NegateLogic=true)]
    [.<float>("IsNaN", ExpectationMessage="be NaN")]
    [.<float>("IsNegativeInfinity", CustomName="IsNotNegativeInfinity", ExpectationMessage="be negative infinity", NegateLogic=true)]
    [.<float>("IsNegativeInfinity", ExpectationMessage="be negative infinity")]
    [.<float>("IsPositiveInfinity", CustomName="IsNotPositiveInfinity", ExpectationMessage="be positive infinity", NegateLogic=true)]
    [.<float>("IsPositiveInfinity", ExpectationMessage="be positive infinity")]
    public static class SingleAssertionExtensions { }
    [.("Contains")]
    public class StringContainsAssertion : .<string>
    {
        public StringContainsAssertion(.<string> context, string expected) { }
        public StringContainsAssertion(.<string> context, string expected,  comparison) { }
        protected override .<.> CheckAsync(.<string> metadata) { }
        protected override string GetExpectation() { }
        public . IgnoringCase() { }
        public . IgnoringWhitespace() { }
        public . WithComparison( comparison) { }
        public . WithTrimming() { }
    }
    [.("DoesNotContain")]
    public class StringDoesNotContainAssertion : .<string>
    {
        public StringDoesNotContainAssertion(.<string> context, string expected) { }
        public StringDoesNotContainAssertion(.<string> context, string expected,  comparison) { }
        protected override .<.> CheckAsync(.<string> metadata) { }
        protected override string GetExpectation() { }
        public . IgnoringCase() { }
        public . WithComparison( comparison) { }
    }
    [.("DoesNotMatch")]
    public class StringDoesNotMatchAssertion : .<string>
    {
        public StringDoesNotMatchAssertion(.<string> context, . regex) { }
        public StringDoesNotMatchAssertion(.<string> context, string pattern) { }
        protected override .<.> CheckAsync(.<string> metadata) { }
        protected override string GetExpectation() { }
        public . IgnoringCase() { }
        public . WithOptions(. options) { }
    }
    [.("EndsWith")]
    public class StringEndsWithAssertion : .<string>
    {
        public StringEndsWithAssertion(.<string> context, string expected) { }
        public StringEndsWithAssertion(.<string> context, string expected,  comparison) { }
        protected override .<.> CheckAsync(.<string> metadata) { }
        protected override string GetExpectation() { }
        public . IgnoringCase() { }
        public . WithComparison( comparison) { }
    }
    [.("IsEqualTo")]
    public class StringEqualsAssertion<TActual> : .<TActual>
    {
        public StringEqualsAssertion(.<TActual> context, string? expected) { }
        public StringEqualsAssertion(.<TActual> context, string? expected,  comparison) { }
        protected override .<.> CheckAsync(.<TActual> metadata) { }
        protected override string GetExpectation() { }
        public .<TActual> IgnoringCase() { }
        public .<TActual> IgnoringWhitespace() { }
        public .<TActual> WithComparison( comparison) { }
        public .<TActual> WithNullAndEmptyEquality() { }
        public .<TActual> WithTrimming() { }
    }
    [.("IsEmpty")]
    public class StringIsEmptyAssertion : .<string>
    {
        public StringIsEmptyAssertion(.<string> context) { }
        protected override .<.> CheckAsync(.<string> metadata) { }
        protected override string GetExpectation() { }
    }
    [.("IsNotEmpty")]
    public class StringIsNotEmptyAssertion : .<string>
    {
        public StringIsNotEmptyAssertion(.<string> context) { }
        protected override .<.> CheckAsync(.<string> metadata) { }
        protected override string GetExpectation() { }
    }
    public class StringLengthAssertion : .<string>
    {
        public StringLengthAssertion(.<string> context, int expectedLength) { }
        protected override .<.> CheckAsync(.<string> metadata) { }
        protected override string GetExpectation() { }
    }
    public class StringLengthValueAssertion : .<int>
    {
        public StringLengthValueAssertion(.<string> stringContext) { }
    }
    public class StringMatchesAssertion : .<..RegexMatchCollection>
    {
        public StringMatchesAssertion(.<string> context, . regex) { }
        public StringMatchesAssertion(.<string> context, string pattern) { }
        protected override .<.> CheckAsync(.<..RegexMatchCollection> metadata) { }
        protected override string GetExpectation() { }
        public . IgnoringCase() { }
        public . WithOptions(. options) { }
    }
    [.("StartsWith")]
    public class StringStartsWithAssertion : .<string>
    {
        public StringStartsWithAssertion(.<string> context, string expected) { }
        public StringStartsWithAssertion(.<string> context, string expected,  comparison) { }
        protected override .<.> CheckAsync(.<string> metadata) { }
        protected override string GetExpectation() { }
        public . IgnoringCase() { }
        public . WithComparison( comparison) { }
    }
    [.<string>("IsNullOrEmpty", CustomName="IsNotNullOrEmpty", ExpectationMessage="be null or empty", NegateLogic=true)]
    [.<string>("IsNullOrEmpty", ExpectationMessage="be null or empty")]
    [.<string>("IsNullOrWhiteSpace", CustomName="IsNotNullOrWhiteSpace", ExpectationMessage="be null, empty, or whitespace", NegateLogic=true)]
    [.<string>("IsNullOrWhiteSpace", ExpectationMessage="be null, empty, or whitespace")]
    public static class StringStaticMethodAssertions { }
    public class StructuralEquivalencyAssertion<TValue> : .<TValue>
    {
        public StructuralEquivalencyAssertion(.<TValue> context, object? expected, string? expectedExpression = null) { }
        protected override .<.> CheckAsync(.<TValue> metadata) { }
        protected override string GetExpectation() { }
        public .<TValue> IgnoringMember(string memberPath) { }
        public .<TValue> IgnoringType( type) { }
        public .<TValue> IgnoringType<T>() { }
        public .<TValue> WithPartialEquivalency() { }
    }
    [.<.>("IsCanceled", CustomName="IsNotCanceled", ExpectationMessage="be canceled", NegateLogic=true)]
    [.<.>("IsCanceled", ExpectationMessage="be canceled")]
    [.<.>("IsCompleted", CustomName="IsNotCompleted", ExpectationMessage="be completed", NegateLogic=true)]
    [.<.>("IsCompleted", ExpectationMessage="be completed")]
    [.<.>("IsFaulted", CustomName="IsNotFaulted", ExpectationMessage="be faulted", NegateLogic=true)]
    [.<.>("IsFaulted", ExpectationMessage="be faulted")]
    public static class TaskAssertionExtensions { }
    [.<.Thread>("IsAlive", CustomName="IsNotAlive", ExpectationMessage="be alive", NegateLogic=true)]
    [.<.Thread>("IsAlive", ExpectationMessage="be alive")]
    [.<.Thread>("IsBackground", CustomName="IsNotBackground", ExpectationMessage="be a background thread", NegateLogic=true)]
    [.<.Thread>("IsBackground", ExpectationMessage="be a background thread")]
    [.<.Thread>("IsThreadPoolThread", CustomName="IsNotThreadPoolThread", ExpectationMessage="be a thread pool thread", NegateLogic=true)]
    [.<.Thread>("IsThreadPoolThread", ExpectationMessage="be a thread pool thread")]
    public static class ThreadAssertionExtensions { }
    public class ThrowsAssertion<TException> : .<TException, .<TException>>
        where TException : 
    {
        public ThrowsAssertion(.<TException> context) { }
        protected override bool IsExactTypeMatch { get; }
        protected override bool CheckExceptionType( actualException, out string? errorMessage) { }
        public .<?> WithExceptionType( expectedExceptionType) { }
        public .<> WithInnerException() { }
        public .<TException> WithMessage(string expectedMessage) { }
        public .<TException> WithMessage(string expectedMessage,  comparison) { }
        public .<TException> WithMessageContaining(string expectedSubstring) { }
        public .<TException> WithMessageContaining(string expectedSubstring,  comparison) { }
        public .<TException> WithMessageMatching(.StringMatcher matcher) { }
        public .<TException> WithMessageMatching(string pattern) { }
        public .<TException> WithMessageNotContaining(string notExpectedSubstring) { }
        public .<TException> WithMessageNotContaining(string notExpectedSubstring,  comparison) { }
        public .<TException> WithParameterName(string expectedParameterName) { }
    }
    public class ThrowsExactlyAssertion<TException> : .<TException, .<TException>>
        where TException : 
    {
        public ThrowsExactlyAssertion(.<TException> context) { }
        protected override bool IsExactTypeMatch { get; }
        protected override bool CheckExceptionType( actualException, out string? errorMessage) { }
        public .<TException> WithMessage(string expectedMessage) { }
        public .<TException> WithMessage(string expectedMessage,  comparison) { }
        public .<TException> WithMessageContaining(string expectedSubstring) { }
        public .<TException> WithMessageContaining(string expectedSubstring,  comparison) { }
        public .<TException> WithMessageMatching(.StringMatcher matcher) { }
        public .<TException> WithMessageMatching(string pattern) { }
        public .<TException> WithMessageNotContaining(string notExpectedSubstring) { }
        public .<TException> WithMessageNotContaining(string notExpectedSubstring,  comparison) { }
        public .<TException> WithParameterName(string expectedParameterName) { }
    }
    public class ThrowsNothingAssertion<TValue> : .<TValue>
    {
        public ThrowsNothingAssertion(.<TValue> context) { }
        protected override .<.> CheckAsync(.<TValue> metadata) { }
        protected override string GetExpectation() { }
    }
    [.("IsEqualTo", OverloadResolutionPriority=2)]
    public class TimeSpanEqualsAssertion : .<>
    {
        public TimeSpanEqualsAssertion(.<> context,  expected) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
        public . Within( tolerance) { }
    }
    [.<>("SupportsDaylightSavingTime", CustomName="DoesNotSupportDaylightSavingTime", ExpectationMessage="support daylight saving time", NegateLogic=true)]
    [.<>("SupportsDaylightSavingTime", ExpectationMessage="support daylight saving time")]
    public static class TimeZoneInfoAssertionExtensions { }
    public abstract class ToleranceBasedEqualsAssertion<TValue, TTolerance> : .<TValue>
    {
        protected ToleranceBasedEqualsAssertion(.<TValue> context, TValue expected) { }
        protected abstract bool AreExactlyEqual(TValue actual, TValue expected);
        protected abstract object CalculateDifference(TValue actual, TValue expected);
        protected override .<.> CheckAsync(.<TValue> metadata) { }
        protected virtual string FormatDifferenceMessage(TValue actual, object difference) { }
        protected override string GetExpectation() { }
        protected abstract bool HasToleranceValue();
        protected abstract bool IsWithinTolerance(TValue actual, TValue expected, TTolerance tolerance);
        public .<TValue, TTolerance> Within(TTolerance tolerance) { }
    }
    [.<>("ContainsGenericParameters", CustomName="DoesNotContainGenericParameters", ExpectationMessage="contain generic parameters", NegateLogic=true)]
    [.<>("ContainsGenericParameters", ExpectationMessage="contain generic parameters")]
    [.<>("IsAbstract", CustomName="IsNotAbstract", ExpectationMessage="be abstract", NegateLogic=true)]
    [.<>("IsAbstract", ExpectationMessage="be abstract")]
    [.<>("IsArray", CustomName="IsNotArray", ExpectationMessage="be an array", NegateLogic=true)]
    [.<>("IsArray", ExpectationMessage="be an array")]
    [.<>("IsByRef", CustomName="IsNotByRef", ExpectationMessage="be a by-ref type", NegateLogic=true)]
    [.<>("IsByRef", ExpectationMessage="be a by-ref type")]
    [.<>("IsCOMObject", CustomName="IsNotCOMObject", ExpectationMessage="be a COM object", NegateLogic=true)]
    [.<>("IsCOMObject", ExpectationMessage="be a COM object")]
    [.<>("IsClass", CustomName="IsNotClass", ExpectationMessage="be a class", NegateLogic=true)]
    [.<>("IsClass", ExpectationMessage="be a class")]
    [.<>("IsConstructedGenericType", CustomName="IsNotConstructedGenericType", ExpectationMessage="be a constructed generic type", NegateLogic=true)]
    [.<>("IsConstructedGenericType", ExpectationMessage="be a constructed generic type")]
    [.<>("IsEnum", CustomName="IsNotEnum", ExpectationMessage="be an enum", NegateLogic=true)]
    [.<>("IsEnum", ExpectationMessage="be an enum")]
    [.<>("IsGenericType", CustomName="IsNotGenericType", ExpectationMessage="be a generic type", NegateLogic=true)]
    [.<>("IsGenericType", ExpectationMessage="be a generic type")]
    [.<>("IsGenericTypeDefinition", CustomName="IsNotGenericTypeDefinition", ExpectationMessage="be a generic type definition", NegateLogic=true)]
    [.<>("IsGenericTypeDefinition", ExpectationMessage="be a generic type definition")]
    [.<>("IsInterface", CustomName="IsNotInterface", ExpectationMessage="be an interface", NegateLogic=true)]
    [.<>("IsInterface", ExpectationMessage="be an interface")]
    [.<>("IsNested", CustomName="IsNotNested", ExpectationMessage="be a nested type", NegateLogic=true)]
    [.<>("IsNested", ExpectationMessage="be a nested type")]
    [.<>("IsNestedAssembly", CustomName="IsNotNestedAssembly", ExpectationMessage="be a nested assembly type", NegateLogic=true)]
    [.<>("IsNestedAssembly", ExpectationMessage="be a nested assembly type")]
    [.<>("IsNestedFamily", CustomName="IsNotNestedFamily", ExpectationMessage="be a nested family type", NegateLogic=true)]
    [.<>("IsNestedFamily", ExpectationMessage="be a nested family type")]
    [.<>("IsNestedPrivate", CustomName="IsNotNestedPrivate", ExpectationMessage="be a nested private type", NegateLogic=true)]
    [.<>("IsNestedPrivate", ExpectationMessage="be a nested private type")]
    [.<>("IsNestedPublic", CustomName="IsNotNestedPublic", ExpectationMessage="be a nested public type", NegateLogic=true)]
    [.<>("IsNestedPublic", ExpectationMessage="be a nested public type")]
    [.<>("IsPointer", CustomName="IsNotPointer", ExpectationMessage="be a pointer type", NegateLogic=true)]
    [.<>("IsPointer", ExpectationMessage="be a pointer type")]
    [.<>("IsPrimitive", CustomName="IsNotPrimitive", ExpectationMessage="be a primitive type", NegateLogic=true)]
    [.<>("IsPrimitive", ExpectationMessage="be a primitive type")]
    [.<>("IsPublic", CustomName="IsNotPublic", ExpectationMessage="be public", NegateLogic=true)]
    [.<>("IsPublic", ExpectationMessage="be public")]
    [.<>("IsSealed", CustomName="IsNotSealed", ExpectationMessage="be sealed", NegateLogic=true)]
    [.<>("IsSealed", ExpectationMessage="be sealed")]
    [.<>("IsSerializable", CustomName="IsNotSerializable", ExpectationMessage="be serializable", NegateLogic=true)]
    [.<>("IsSerializable", ExpectationMessage="be serializable")]
    [.<>("IsValueType", CustomName="IsNotValueType", ExpectationMessage="be a value type", NegateLogic=true)]
    [.<>("IsValueType", ExpectationMessage="be a value type")]
    [.<>("IsVisible", CustomName="IsNotVisible", ExpectationMessage="be visible", NegateLogic=true)]
    [.<>("IsVisible", ExpectationMessage="be visible")]
    public static class TypeAssertionExtensions { }
    public class TypeOfAssertion<TFrom, TTo> : .<TTo>
    {
        public TypeOfAssertion(.<TFrom> parentContext) { }
        protected override .<.> CheckAsync(.<TTo> metadata) { }
        protected override string GetExpectation() { }
    }
    [.<>("IsAbsoluteUri", CustomName="IsNotAbsoluteUri", ExpectationMessage="be an absolute URI", NegateLogic=true)]
    [.<>("IsAbsoluteUri", ExpectationMessage="be an absolute URI")]
    [.<>("IsDefaultPort", CustomName="IsNotDefaultPort", ExpectationMessage="use the default port", NegateLogic=true)]
    [.<>("IsDefaultPort", ExpectationMessage="use the default port")]
    [.<>("IsFile", CustomName="IsNotFile", ExpectationMessage="be a file URI", NegateLogic=true)]
    [.<>("IsFile", ExpectationMessage="be a file URI")]
    [.<>("IsLoopback", CustomName="IsNotLoopback", ExpectationMessage="be a loopback URI", NegateLogic=true)]
    [.<>("IsLoopback", ExpectationMessage="be a loopback URI")]
    [.<>("IsUnc", CustomName="IsNotUnc", ExpectationMessage="be a UNC URI", NegateLogic=true)]
    [.<>("IsUnc", ExpectationMessage="be a UNC URI")]
    [.<>("UserEscaped", CustomName="IsNotUserEscaped", ExpectationMessage="be user-escaped", NegateLogic=true)]
    [.<>("UserEscaped", ExpectationMessage="be user-escaped")]
    public static class UriAssertionExtensions { }
    [.<.>("IsCanceled", CustomName="IsNotCanceled", ExpectationMessage="be canceled", NegateLogic=true)]
    [.<.>("IsCanceled", ExpectationMessage="be canceled")]
    [.<.>("IsCompleted", CustomName="IsNotCompleted", ExpectationMessage="be completed", NegateLogic=true)]
    [.<.>("IsCompleted", ExpectationMessage="be completed")]
    [.<.>("IsCompletedSuccessfully", CustomName="IsNotCompletedSuccessfully", ExpectationMessage="be completed successfully", NegateLogic=true)]
    [.<.>("IsCompletedSuccessfully", ExpectationMessage="be completed successfully")]
    [.<.>("IsFaulted", CustomName="IsNotFaulted", ExpectationMessage="be faulted", NegateLogic=true)]
    [.<.>("IsFaulted", ExpectationMessage="be faulted")]
    public static class ValueTaskAssertionExtensions { }
    public class WaitsForAssertion<TValue> : .<TValue>
    {
        public WaitsForAssertion(.<TValue> context, <.<TValue>, .<TValue>> assertionBuilder,  timeout, ? pollingInterval = default) { }
        public override .<TValue?> AssertAsync() { }
        protected override .<.> CheckAsync(.<TValue> metadata) { }
        protected override string GetExpectation() { }
    }
    [.<>("IsAlive", CustomName="IsNotAlive", ExpectationMessage="be alive", NegateLogic=true)]
    [.<>("IsAlive", ExpectationMessage="be alive")]
    [.<>("TrackResurrection", CustomName="DoesNotTrackResurrection", ExpectationMessage="track resurrection", NegateLogic=true)]
    [.<>("TrackResurrection", ExpectationMessage="track resurrection")]
    public static class WeakReferenceAssertionExtensions { }
}
namespace .
{
    public sealed class ReferenceEqualityComparer<T> : .<T>
        where T :  class
    {
        public static readonly ..ReferenceEqualityComparer<T> Instance;
        public bool Equals(T? x, T? y) { }
        public int GetHashCode(T obj) { }
    }
    public sealed class StructuralEqualityComparer<T> : .<T>
    {
        public static readonly ..StructuralEqualityComparer<T> Instance;
        public bool Equals(T? x, T? y) { }
        public int GetHashCode(T obj) { }
    }
}
namespace .
{
    public static class JsonElementAssertionExtensions
    {
        [.(ExpectationMessage="to not have property \'{propertyName}\'", InlineMethodBody=true)]
        public static bool DoesNotHaveProperty(this . value, string propertyName) { }
        [.(ExpectationMessage="to have property \'{propertyName}\'", InlineMethodBody=true)]
        public static bool HasProperty(this . value, string propertyName) { }
        [.(ExpectationMessage="to be a JSON array", InlineMethodBody=true)]
        public static bool IsArray(this . value) { }
        [.(ExpectationMessage="to be a JSON boolean", InlineMethodBody=true)]
        public static bool IsBoolean(this . value) { }
        [.(ExpectationMessage="to not be JSON null", InlineMethodBody=true)]
        public static bool IsNotNull(this . value) { }
        [.(ExpectationMessage="to be JSON null", InlineMethodBody=true)]
        public static bool IsNull(this . value) { }
        [.(ExpectationMessage="to be a JSON number", InlineMethodBody=true)]
        public static bool IsNumber(this . value) { }
        [.(ExpectationMessage="to be a JSON object", InlineMethodBody=true)]
        public static bool IsObject(this . value) { }
        [.(ExpectationMessage="to be a JSON string", InlineMethodBody=true)]
        public static bool IsString(this . value) { }
    }
    public static class JsonNodeAssertionExtensions
    {
        [.(ExpectationMessage="to not have property \'{propertyName}\'")]
        public static . DoesNotHaveJsonProperty(this ..JsonNode? value, string propertyName) { }
        [.(ExpectationMessage="to have {expected} elements")]
        public static . HasJsonArrayCount(this ..JsonNode? value, int expected) { }
        [.(ExpectationMessage="to have property \'{propertyName}\'")]
        public static . HasJsonProperty(this ..JsonNode? value, string propertyName) { }
        [.(ExpectationMessage="to be a JsonArray")]
        public static . IsJsonArray(this ..JsonNode? value) { }
        [.(ExpectationMessage="to be an empty JSON array")]
        public static . IsJsonArrayEmpty(this ..JsonNode? value) { }
        [.(ExpectationMessage="to not be an empty JSON array")]
        public static . IsJsonArrayNotEmpty(this ..JsonNode? value) { }
        [.(ExpectationMessage="to be a JsonObject")]
        public static . IsJsonObject(this ..JsonNode? value) { }
        [.(ExpectationMessage="to be a JsonValue")]
        public static . IsJsonValue(this ..JsonNode? value) { }
    }
    public static class JsonStringAssertionExtensions
    {
        [.(ExpectationMessage="to not be valid JSON")]
        public static . IsNotValidJson(this string value) { }
        [.(ExpectationMessage="to be valid JSON")]
        public static . IsValidJson(this string value) { }
        [.(ExpectationMessage="to be a valid JSON array")]
        public static . IsValidJsonArray(this string value) { }
        [.(ExpectationMessage="to be a valid JSON object")]
        public static . IsValidJsonObject(this string value) { }
    }
}
namespace .
{
    public class CountWrapper<TCollection, TItem> : ., .<TCollection>
        where TCollection : .<TItem>
    {
        public CountWrapper(.<TCollection> context) { }
        public .<int> Between(int minimum, int maximum, [.("minimum")] string? minExpression = null, [.("maximum")] string? maxExpression = null) { }
        public .<TCollection, TItem> EqualTo(int expectedCount, [.("expectedCount")] string? expression = null) { }
        public .<int> GreaterThan(int expected, [.("expected")] string? expression = null) { }
        public .<int> GreaterThanOrEqualTo(int expected, [.("expected")] string? expression = null) { }
        public .<int> LessThan(int expected, [.("expected")] string? expression = null) { }
        public .<int> LessThanOrEqualTo(int expected, [.("expected")] string? expression = null) { }
        public .<int> NotEqualTo(int expected, [.("expected")] string? expression = null) { }
        public .<int> Positive() { }
        public .<TCollection, TItem> Zero() { }
    }
    public class LengthWrapper : ., .<string>
    {
        public LengthWrapper(.<string> context) { }
        public . EqualTo(int expectedLength, [.("expectedLength")] string? expression = null) { }
    }
}
namespace .Core
{
    public class AndContinuation<TValue> : .<TValue> { }
    public sealed class AssertionContext<TValue>
    {
        public AssertionContext(.<TValue> evaluation, .StringBuilder expressionBuilder) { }
        public AssertionContext(TValue? value, .StringBuilder expressionBuilder) { }
        public .<TValue> Evaluation { get; }
        public .StringBuilder ExpressionBuilder { get; }
        [return: .(new string[] {
                "Value",
                "Exception"})]
        public .<<TValue?, ?>> GetAsync() { }
        [return: .(new string[] {
                "Start",
                "End"})]
        public <, > GetTiming() { }
        public .<TNew> Map<TNew>(<.<TValue>, .<TNew>> evaluationFactory) { }
        public .<TNew> Map<TNew>(<TValue?, .<TNew?>> asyncMapper) { }
        public .<TNew> Map<TNew>(<TValue?, TNew?> mapper) { }
        public .<TException> MapException<TException>()
            where TException :  { }
    }
    public readonly struct AssertionResult
    {
        public bool IsPassed { get; }
        public string Message { get; }
        public static . Passed { get; }
        public static . FailIf(bool condition, string message) { }
        public static . Failed(string message) { }
    }
    public abstract class Assertion<TValue> : .
    {
        protected readonly .<TValue> Context;
        protected Assertion(.<TValue> context) { }
        public .<TValue> And { get; }
        protected .<TValue>? InternalWrappedExecution { get; }
        public .<TValue> Or { get; }
        protected void AppendExpression(string expression) { }
        public virtual .<TValue?> AssertAsync() { }
        public .<TValue> Because(string message) { }
        protected virtual .<.> CheckAsync(.<TValue> metadata) { }
        protected  CreateException(. result) { }
        public .<TValue?> GetAwaiter() { }
        protected abstract string GetExpectation();
        protected void ThrowIfMixingCombiner<TCombinerToAvoid>()
            where TCombinerToAvoid : .<TValue> { }
    }
    public enum ChainType
    {
        None = 0,
        And = 1,
        Or = 2,
    }
    public class CollectionAndContinuation<TCollection, TItem> : .<TCollection, TItem>
        where TCollection : .<TItem> { }
    public class CollectionOrContinuation<TCollection, TItem> : .<TCollection, TItem>
        where TCollection : .<TItem> { }
    public class DictionaryAndContinuation<TDictionary, TKey, TValue> : .<TDictionary, TKey, TValue>
        where TDictionary : .<TKey, TValue>
        where TKey :  notnull { }
    public class DictionaryOrContinuation<TDictionary, TKey, TValue> : .<TDictionary, TKey, TValue>
        where TDictionary : .<TKey, TValue>
        where TKey :  notnull { }
    public sealed class EvaluationContext<TValue>
    {
        public EvaluationContext(<.<<TValue?, ?>>> evaluator) { }
        public EvaluationContext(TValue? value) { }
        [return: .(new string?[]?[] {
                "Value",
                "Exception"})]
        public .<<TValue?, ?>> GetAsync() { }
        [return: .(new string[] {
                "Start",
                "End"})]
        public <, > GetTiming() { }
        public .<TNew> Map<TNew>(<TValue?, .<TNew?>> asyncMapper) { }
        public .<TNew> Map<TNew>(<TValue?, TNew?> mapper) { }
        public .<TException> MapException<TException>()
            where TException :  { }
        [return: .(new string?[]?[] {
                "Value",
                "Exception"})]
        public .<<TValue?, ?>> ReevaluateAsync() { }
    }
    public readonly struct EvaluationMetadata<TValue>
    {
        public EvaluationMetadata(TValue? value, ? exception,  startTime,  endTime) { }
        public  Duration { get; }
        public  EndTime { get; }
        public ? Exception { get; }
        public  StartTime { get; }
        public TValue Value { get; }
    }
    public interface IAssertion
    {
        . AssertAsync();
    }
    public interface IAssertionSource { }
    public interface IAssertionSource<TValue> : .
    {
        .<TValue> Context { get; }
        .<TExpected, TValue> IsAssignableTo<TExpected>();
        .<TExpected, TValue> IsNotAssignableTo<TExpected>();
        .<TValue, TExpected> IsNotTypeOf<TExpected>();
        .<TValue, TExpected> IsTypeOf<TExpected>();
    }
    public interface IDelegateAssertionSource<TValue> : ., .<TValue> { }
    public class MutableDictionaryAndContinuation<TDictionary, TKey, TValue> : .<TDictionary, TKey, TValue>
        where TDictionary : .<TKey, TValue>
        where TKey :  notnull { }
    public class MutableDictionaryOrContinuation<TDictionary, TKey, TValue> : .<TDictionary, TKey, TValue>
        where TDictionary : .<TKey, TValue>
        where TKey :  notnull { }
    public class OrContinuation<TValue> : .<TValue> { }
}
namespace .Enums
{
    public enum CollectionOrdering
    {
        Any = 0,
        Matching = 1,
    }
}
namespace .Exceptions
{
    public class AssertionException : .
    {
        public AssertionException(string? message) { }
        public AssertionException(string? message,  innerException) { }
    }
    public class BaseAssertionException : 
    {
        public BaseAssertionException() { }
        public BaseAssertionException(string? message) { }
        public BaseAssertionException(string? message, ? innerException) { }
    }
    public class MaybeCaughtException : 
    {
        public MaybeCaughtException( exception) { }
    }
    public class MixedAndOrAssertionsException : .
    {
        public MixedAndOrAssertionsException() { }
    }
}
namespace .Extensions
{
    public static class ArrayAssertionExtensions
    {
        public static .Extensions._IsEmpty_Assertion<T> IsEmpty<T>(this .<T[]> source) { }
        public static .Extensions._IsNotEmpty_Assertion<T> IsNotEmpty<T>(this .<T[]> source) { }
        public static ._IsNotSingleElement_Assertion<T> IsNotSingleElement<T>(this .<.<T>> source) { }
        public static .Extensions._IsNotSingleElement_Assertion<T> IsNotSingleElement<T>(this .<T[]> source) { }
        public static ._IsSingleElement_Assertion<T> IsSingleElement<T>(this .<.<T>> source) { }
        public static .Extensions._IsSingleElement_Assertion<T> IsSingleElement<T>(this .<T[]> source) { }
    }
    public static class AssemblyAssertionExtensions
    {
        public static . IsDynamic(this .<.Assembly> source) { }
        public static . IsFullyTrusted(this .<.Assembly> source) { }
        public static . IsNotDynamic(this .<.Assembly> source) { }
        public static . IsNotFullyTrusted(this .<.Assembly> source) { }
        public static ._IsNotSigned_Assertion IsNotSigned(this .<.Assembly> source) { }
        public static ._IsSigned_Assertion IsSigned(this .<.Assembly> source) { }
    }
    public class AssemblyIsDynamicAssertion : .<.Assembly>
    {
        public AssemblyIsDynamicAssertion(.<.Assembly> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<.Assembly> metadata) { }
        protected override string GetExpectation() { }
    }
    public class AssemblyIsFullyTrustedAssertion : .<.Assembly>
    {
        public AssemblyIsFullyTrustedAssertion(.<.Assembly> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<.Assembly> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class Assembly_IsNotSigned_Assertion : .<.Assembly>
    {
        public Assembly_IsNotSigned_Assertion(.<.Assembly> context) { }
        protected override .<.> CheckAsync(.<.Assembly> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class Assembly_IsSigned_Assertion : .<.Assembly>
    {
        public Assembly_IsSigned_Assertion(.<.Assembly> context) { }
        protected override .<.> CheckAsync(.<.Assembly> metadata) { }
        protected override string GetExpectation() { }
    }
    public static class AssertionExtensions
    {
        public static . CompletesWithin(this . source,  timeout, [.("timeout")] string? expression = null) { }
        public static . CompletesWithin(this . source,  timeout, [.("timeout")] string? expression = null) { }
        public static ..DoesNotHaveFlagAssertion<TEnum> DoesNotHaveFlag<TEnum>(this .<TEnum> source, TEnum unexpectedFlag, [.("unexpectedFlag")] string? expression = null)
            where TEnum :  struct,  { }
        public static ..DoesNotHaveSameNameAsAssertion<TEnum> DoesNotHaveSameNameAs<TEnum>(this .<TEnum> source,  otherEnumValue, [.("otherEnumValue")] string? expression = null)
            where TEnum :  struct,  { }
        public static ..DoesNotHaveSameValueAsAssertion<TEnum> DoesNotHaveSameValueAs<TEnum>(this .<TEnum> source,  otherEnumValue, [.("otherEnumValue")] string? expression = null)
            where TEnum :  struct,  { }
        public static .<TValue> EqualTo<TValue>(this .<TValue> source, TValue? expected, [.("expected")] string? expression = null) { }
        public static ..HasFlagAssertion<TEnum> HasFlag<TEnum>(this .<TEnum> source, TEnum expectedFlag, [.("expectedFlag")] string? expression = null)
            where TEnum :  struct,  { }
        [("Use Length() instead, which provides all numeric assertion methods. Example: Asse" +
            "(str).Length().IsGreaterThan(5)")]
        public static ..LengthWrapper HasLength(this .<string> source) { }
        [("Use Length().IsEqualTo(expectedLength) instead.")]
        public static . HasLength(this .<string> source, int expectedLength, [.("expectedLength")] string? expression = null) { }
        public static .<TException> HasMessageContaining<TException>(this .<TException> source, string expectedSubstring, [.("expectedSubstring")] string? expression = null)
            where TException :  { }
        public static .<TException> HasMessageContaining<TException>(this .<TException> source, string expectedSubstring,  comparison, [.("expectedSubstring")] string? expression = null)
            where TException :  { }
        public static .<TValue> HasMessageEqualTo<TValue>(this .<TValue> source, string expectedMessage) { }
        public static .<TValue> HasMessageEqualTo<TValue>(this .<TValue> source, string expectedMessage,  comparison) { }
        public static .<TValue> HasMessageStartingWith<TValue>(this .<TValue> source, string expectedPrefix) { }
        public static .<TValue> HasMessageStartingWith<TValue>(this .<TValue> source, string expectedPrefix,  comparison) { }
        public static ..HasSameNameAsAssertion<TEnum> HasSameNameAs<TEnum>(this .<TEnum> source,  otherEnumValue, [.("otherEnumValue")] string? expression = null)
            where TEnum :  struct,  { }
        public static ..HasSameValueAsAssertion<TEnum> HasSameValueAs<TEnum>(this .<TEnum> source,  otherEnumValue, [.("otherEnumValue")] string? expression = null)
            where TEnum :  struct,  { }
        public static .<> IsAfter(this .<> source,  expected, [.("expected")] string? expression = null) { }
        public static .<> IsAfter(this .<> source,  expected, [.("expected")] string? expression = null) { }
        public static .<> IsAfterOrEqualTo(this .<> source,  expected, [.("expected")] string? expression = null) { }
        public static .<> IsAfterOrEqualTo(this .<> source,  expected, [.("expected")] string? expression = null) { }
        public static .<> IsBefore(this .<> source,  expected, [.("expected")] string? expression = null) { }
        public static .<> IsBefore(this .<> source,  expected, [.("expected")] string? expression = null) { }
        public static .<> IsBeforeOrEqualTo(this .<> source,  expected, [.("expected")] string? expression = null) { }
        public static .<> IsBeforeOrEqualTo(this .<> source,  expected, [.("expected")] string? expression = null) { }
        public static ..IsDefinedAssertion<TEnum> IsDefined<TEnum>(this .<TEnum> source)
            where TEnum :  struct,  { }
        public static .<TValue> IsEquivalentTo<TValue>(this .<TValue> source, object? expected, [.("expected")] string? expression = null) { }
        public static .<TValue> IsNegative<TValue>(this .<TValue> source)
            where TValue : <TValue> { }
        public static .<TValue> IsNegative<TValue>(this .<TValue?> source)
            where TValue :  struct, <TValue> { }
        public static ..IsNotDefinedAssertion<TEnum> IsNotDefined<TEnum>(this .<TEnum> source)
            where TEnum :  struct,  { }
        public static .<TValue> IsNotEquivalentTo<TValue>(this .<TValue> source, object? expected, [.("expected")] string? expression = null) { }
        public static .<TValue> IsNotNull<TValue>(this .<TValue> source)
            where TValue :  class { }
        public static .<TValue> IsNotNull<TValue>(this .<TValue?> source)
            where TValue :  struct { }
        public static .<TCollection, TItem> IsNotNull<TCollection, TItem>(this .<TCollection, TItem> source)
            where TCollection :  class, .<TItem> { }
        public static ..IsNotParsableIntoAssertion<T> IsNotParsableInto<T>(this .<string> source) { }
        public static .<TValue> IsOfType<TValue>(this .<TValue> source,  expectedType, [.("expectedType")] string? expression = null) { }
        public static ..IsParsableIntoAssertion<T> IsParsableInto<T>(this .<string> source) { }
        public static .<TValue> IsPositive<TValue>(this .<TValue> source)
            where TValue : <TValue> { }
        public static .<TValue> IsPositive<TValue>(this .<TValue?> source)
            where TValue :  struct, <TValue> { }
        public static . Length(this .<string> source) { }
        public static .<TObject> Member<TObject, TItem>(this .<TObject> source, .<<TObject, .<TItem>>> memberSelector, <.<.<TItem>, TItem>, .<.<TItem>>> assertions) { }
        public static .<TObject> Member<TObject, TItem>(this .<TObject> source, .<<TObject, .<TItem>>> memberSelector, <.<.<TItem>, TItem>, object> assertions) { }
        public static .<TObject> Member<TObject, TMember>(this .<TObject> source, .<<TObject, TMember>> memberSelector, <.<TMember>, .<TMember>> assertions) { }
        public static .<TObject> Member<TObject, TMember>(this .<TObject> source, .<<TObject, TMember>> memberSelector, <.<TMember>, object> assertions) { }
        public static .<TObject> Member<TObject, TItem, TTransformed>(this .<TObject> source, .<<TObject, .<TItem>>> memberSelector, <.<.<TItem>, TItem>, .<TTransformed>> assertions) { }
        public static .<TObject> Member<TObject, TKey, TValue>(this .<TObject> source, .<<TObject, .<TKey, TValue>>> memberSelector, <.<.<TKey, TValue>, TKey, TValue>, .<.<TKey, TValue>>> assertions)
            where TKey :  notnull { }
        public static .<TObject> Member<TObject, TKey, TValue>(this .<TObject> source, .<<TObject, .<TKey, TValue>>> memberSelector, <.<.<TKey, TValue>, TKey, TValue>, object> assertions)
            where TKey :  notnull { }
        public static .<TObject> Member<TObject, TMember, TTransformed>(this .<TObject> source, .<<TObject, TMember>> memberSelector, <.<TMember>, .<TTransformed>> assertions) { }
        public static .<TObject> Member<TObject, TKey, TValue, TTransformed>(this .<TObject> source, .<<TObject, .<TKey, TValue>>> memberSelector, <.<.<TKey, TValue>, TKey, TValue>, .<TTransformed>> assertions)
            where TKey :  notnull { }
        public static .<TValue> Satisfies<TValue>(this .<TValue> source, <TValue?, bool> predicate, [.("predicate")] string? expression = null) { }
        public static .<TValue, TMapped> Satisfies<TValue, TMapped>(this .<TValue> source, <TValue?, TMapped> selector, <.<TMapped>, .?> assertions, [.("selector")] string? selectorExpression = null) { }
        public static .<TValue, TMapped> SatisfiesAsync<TValue, TMapped>(this .<TValue> source, <TValue?, .<TMapped?>> selector, <.<TMapped>, .?> assertions, [.("selector")] string? selectorExpression = null) { }
        public static .<TException> Throws<TException>(this . source)
            where TException :  { }
        public static .<TException> Throws<TException>(this . source)
            where TException :  { }
        public static .<TException> Throws<TException, TValue>(this .<TValue> source)
            where TException :  { }
        public static .<TException> ThrowsAsync<TValue, TException>(this .<TValue> source)
            where TException :  { }
        public static .<TException> ThrowsExactly<TException>(this . source)
            where TException :  { }
        public static .<TException> ThrowsExactly<TException>(this . source)
            where TException :  { }
        public static .<TException> ThrowsExactly<TException, TValue>(this .<TValue> source)
            where TException :  { }
        public static .<> ThrowsException<TValue>(this .<TValue> source) { }
        public static .<TException> ThrowsException<TException, TValue>(this .<TValue> source)
            where TException :  { }
        public static .<TValue> ThrowsNothing<TValue>(this .<TValue> source) { }
        public static .<TValue> WaitsFor<TValue>(this .<TValue> source, <.<TValue>, .<TValue>> assertionBuilder,  timeout, ? pollingInterval = default, [.("timeout")] string? timeoutExpression = null, [.("pollingInterval")] string? pollingIntervalExpression = null) { }
        public static ..WhenParsedIntoAssertion<T> WhenParsedInto<T>(this .<string> source) { }
        public static .<TException> WithMessage<TException>(this .<TException> source, string expectedMessage, [.("expectedMessage")] string? expression = null)
            where TException :  { }
        public static .<TException> WithMessage<TException>(this .<TException> source, string expectedMessage,  comparison, [.("expectedMessage")] string? expression = null)
            where TException :  { }
        public static .<TException> WithMessageContaining<TException>(this .<TException> source, string expectedSubstring, [.("expectedSubstring")] string? expression = null)
            where TException :  { }
        public static .<TException> WithMessageContaining<TException>(this .<TException> source, string expectedSubstring,  comparison, [.("expectedSubstring")] string? expression = null)
            where TException :  { }
        public static .<TException> WithMessageMatching<TException>(this .<TException> source, .StringMatcher matcher, [.("matcher")] string? expression = null)
            where TException :  { }
        public static .<TException> WithMessageMatching<TException>(this .<TException> source, string pattern, [.("pattern")] string? expression = null)
            where TException :  { }
        public static .<TException> WithMessageNotContaining<TException>(this .<TException> source, string notExpectedSubstring, [.("notExpectedSubstring")] string? expression = null)
            where TException :  { }
        public static .<TException> WithMessageNotContaining<TException>(this .<TException> source, string notExpectedSubstring,  comparison, [.("notExpectedSubstring")] string? expression = null)
            where TException :  { }
        public static .<TException> WithParameterName<TException>(this .<TException> source, string expectedParameterName, [.("expectedParameterName")] string? expression = null)
            where TException :  { }
    }
    public static class BetweenAssertionExtensions
    {
        public static .<TValue> IsBetween<TValue>(this .<TValue> source, TValue minimum, TValue maximum, [.("minimum")] string? minimumExpression = null, [.("maximum")] string? maximumExpression = null)
            where TValue : <TValue> { }
    }
    public static class BigIntegerAssertionExtensions
    {
        public static . IsEven(this .<.BigInteger> source) { }
        public static . IsNotEven(this .<.BigInteger> source) { }
        public static . IsNotZero(this .<.BigInteger> source) { }
        public static . IsZero(this .<.BigInteger> source) { }
    }
    public class BigIntegerIsEvenAssertion : .<.BigInteger>
    {
        public BigIntegerIsEvenAssertion(.<.BigInteger> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<.BigInteger> metadata) { }
        protected override string GetExpectation() { }
    }
    public class BigIntegerIsZeroAssertion : .<.BigInteger>
    {
        public BigIntegerIsZeroAssertion(.<.BigInteger> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<.BigInteger> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class Bool_IsFalse_Assertion : .<bool>
    {
        public Bool_IsFalse_Assertion(.<bool> context) { }
        protected override .<.> CheckAsync(.<bool> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class Bool_IsTrue_Assertion : .<bool>
    {
        public Bool_IsTrue_Assertion(.<bool> context) { }
        protected override .<.> CheckAsync(.<bool> metadata) { }
        protected override string GetExpectation() { }
    }
    public static class BooleanAssertionExtensions
    {
        public static ._IsFalse_Assertion IsFalse(this .<bool> source) { }
        public static ._IsFalse_Assertion IsFalse(this .<bool?> source) { }
        public static ._IsTrue_Assertion IsTrue(this .<bool> source) { }
        public static ._IsTrue_Assertion IsTrue(this .<bool?> source) { }
    }
    public static class ByteAssertions
    {
        public static ._IsEven_Assertion IsEven(this .<byte> source) { }
        public static ._IsNotZero_Assertion IsNotZero(this .<byte> source) { }
        public static ._IsOdd_Assertion IsOdd(this .<byte> source) { }
        public static ._IsZero_Assertion IsZero(this .<byte> source) { }
    }
    public sealed class Byte_IsEven_Assertion : .<byte>
    {
        public Byte_IsEven_Assertion(.<byte> context) { }
        protected override .<.> CheckAsync(.<byte> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class Byte_IsNotZero_Assertion : .<byte>
    {
        public Byte_IsNotZero_Assertion(.<byte> context) { }
        protected override .<.> CheckAsync(.<byte> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class Byte_IsOdd_Assertion : .<byte>
    {
        public Byte_IsOdd_Assertion(.<byte> context) { }
        protected override .<.> CheckAsync(.<byte> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class Byte_IsZero_Assertion : .<byte>
    {
        public Byte_IsZero_Assertion(.<byte> context) { }
        protected override .<.> CheckAsync(.<byte> metadata) { }
        protected override string GetExpectation() { }
    }
    public static class CancellationTokenAssertionExtensions
    {
        public static . CanBeCanceled(this .<.CancellationToken> source) { }
        public static . CannotBeCanceled(this .<.CancellationToken> source) { }
        public static . IsCancellationRequested(this .<.CancellationToken> source) { }
        public static ._IsNone_Assertion IsNone(this .<.CancellationToken> source) { }
        public static . IsNotCancellationRequested(this .<.CancellationToken> source) { }
        public static ._IsNotNone_Assertion IsNotNone(this .<.CancellationToken> source) { }
    }
    public class CancellationTokenCanBeCanceledAssertion : .<.CancellationToken>
    {
        public CancellationTokenCanBeCanceledAssertion(.<.CancellationToken> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<.CancellationToken> metadata) { }
        protected override string GetExpectation() { }
    }
    public class CancellationTokenIsCancellationRequestedAssertion : .<.CancellationToken>
    {
        public CancellationTokenIsCancellationRequestedAssertion(.<.CancellationToken> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<.CancellationToken> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class CancellationToken_IsNone_Assertion : .<.CancellationToken>
    {
        public CancellationToken_IsNone_Assertion(.<.CancellationToken> context) { }
        protected override .<.> CheckAsync(.<.CancellationToken> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class CancellationToken_IsNotNone_Assertion : .<.CancellationToken>
    {
        public CancellationToken_IsNotNone_Assertion(.<.CancellationToken> context) { }
        protected override .<.> CheckAsync(.<.CancellationToken> metadata) { }
        protected override string GetExpectation() { }
    }
    public static class CharAssertionExtensions
    {
        public static . IsControl(this .<char> source) { }
        public static . IsDigit(this .<char> source) { }
        public static . IsHighSurrogate(this .<char> source) { }
        public static . IsLetter(this .<char> source) { }
        public static . IsLetterOrDigit(this .<char> source) { }
        public static . IsLowSurrogate(this .<char> source) { }
        public static . IsLower(this .<char> source) { }
        public static . IsNotControl(this .<char> source) { }
        public static . IsNotDigit(this .<char> source) { }
        public static . IsNotHighSurrogate(this .<char> source) { }
        public static . IsNotLetter(this .<char> source) { }
        public static . IsNotLetterOrDigit(this .<char> source) { }
        public static . IsNotLowSurrogate(this .<char> source) { }
        public static . IsNotLower(this .<char> source) { }
        public static . IsNotNumber(this .<char> source) { }
        public static . IsNotPunctuation(this .<char> source) { }
        public static . IsNotSeparator(this .<char> source) { }
        public static . IsNotSurrogate(this .<char> source) { }
        public static . IsNotSymbol(this .<char> source) { }
        public static . IsNotUpper(this .<char> source) { }
        public static . IsNotWhiteSpace(this .<char> source) { }
        public static . IsNumber(this .<char> source) { }
        public static . IsPunctuation(this .<char> source) { }
        public static . IsSeparator(this .<char> source) { }
        public static . IsSurrogate(this .<char> source) { }
        public static . IsSymbol(this .<char> source) { }
        public static . IsUpper(this .<char> source) { }
        public static . IsWhiteSpace(this .<char> source) { }
    }
    public class CharIsControlWithCharAssertion : .<char>
    {
        public CharIsControlWithCharAssertion(.<char> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<char> metadata) { }
        protected override string GetExpectation() { }
    }
    public class CharIsDigitWithCharAssertion : .<char>
    {
        public CharIsDigitWithCharAssertion(.<char> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<char> metadata) { }
        protected override string GetExpectation() { }
    }
    public class CharIsHighSurrogateWithCharAssertion : .<char>
    {
        public CharIsHighSurrogateWithCharAssertion(.<char> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<char> metadata) { }
        protected override string GetExpectation() { }
    }
    public class CharIsLetterOrDigitWithCharAssertion : .<char>
    {
        public CharIsLetterOrDigitWithCharAssertion(.<char> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<char> metadata) { }
        protected override string GetExpectation() { }
    }
    public class CharIsLetterWithCharAssertion : .<char>
    {
        public CharIsLetterWithCharAssertion(.<char> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<char> metadata) { }
        protected override string GetExpectation() { }
    }
    public class CharIsLowSurrogateWithCharAssertion : .<char>
    {
        public CharIsLowSurrogateWithCharAssertion(.<char> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<char> metadata) { }
        protected override string GetExpectation() { }
    }
    public class CharIsLowerWithCharAssertion : .<char>
    {
        public CharIsLowerWithCharAssertion(.<char> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<char> metadata) { }
        protected override string GetExpectation() { }
    }
    public class CharIsNumberWithCharAssertion : .<char>
    {
        public CharIsNumberWithCharAssertion(.<char> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<char> metadata) { }
        protected override string GetExpectation() { }
    }
    public class CharIsPunctuationWithCharAssertion : .<char>
    {
        public CharIsPunctuationWithCharAssertion(.<char> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<char> metadata) { }
        protected override string GetExpectation() { }
    }
    public class CharIsSeparatorWithCharAssertion : .<char>
    {
        public CharIsSeparatorWithCharAssertion(.<char> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<char> metadata) { }
        protected override string GetExpectation() { }
    }
    public class CharIsSurrogateWithCharAssertion : .<char>
    {
        public CharIsSurrogateWithCharAssertion(.<char> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<char> metadata) { }
        protected override string GetExpectation() { }
    }
    public class CharIsSymbolWithCharAssertion : .<char>
    {
        public CharIsSymbolWithCharAssertion(.<char> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<char> metadata) { }
        protected override string GetExpectation() { }
    }
    public class CharIsUpperWithCharAssertion : .<char>
    {
        public CharIsUpperWithCharAssertion(.<char> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<char> metadata) { }
        protected override string GetExpectation() { }
    }
    public class CharIsWhiteSpaceWithCharAssertion : .<char>
    {
        public CharIsWhiteSpaceWithCharAssertion(.<char> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<char> metadata) { }
        protected override string GetExpectation() { }
    }
    public static class CollectionAllAssertionExtensions
    {
        public static .<TCollection, TItem> All<TCollection, TItem>(this .<TCollection> source, <TItem, bool> predicate, string predicateDescription, [.("predicate")] string? predicateExpression = null, [.("predicateDescription")] string? predicateDescriptionExpression = null)
            where TCollection : .<TItem> { }
    }
    public static class CollectionAnyAssertionExtensions
    {
        public static .<TCollection, TItem> Any<TCollection, TItem>(this .<TCollection> source, <TItem, bool> predicate, string predicateDescription, [.("predicate")] string? predicateExpression = null, [.("predicateDescription")] string? predicateDescriptionExpression = null)
            where TCollection : .<TItem> { }
    }
    public static class CollectionContainsAssertionExtensions
    {
        public static .<TCollection, TItem> Contains<TCollection, TItem>(this .<TCollection> source, TItem expected, .<TItem>? comparer = null, [.("expected")] string? expectedExpression = null, [.("comparer")] string? comparerExpression = null)
            where TCollection : .<TItem> { }
    }
    public static class CollectionContainsPredicateAssertionExtensions
    {
        public static .<TCollection, TItem> Contains<TCollection, TItem>(this .<TCollection> source, <TItem, bool> predicate, [.("predicate")] string? predicateExpression = null)
            where TCollection : .<TItem> { }
    }
    public static class CollectionDoesNotContainAssertionExtensions
    {
        public static .<TCollection, TItem> DoesNotContain<TCollection, TItem>(this .<TCollection> source, TItem expected, .<TItem>? comparer = null, [.("expected")] string? expectedExpression = null, [.("comparer")] string? comparerExpression = null)
            where TCollection : .<TItem> { }
    }
    public static class CollectionDoesNotContainPredicateAssertionExtensions
    {
        public static .<TCollection, TItem> DoesNotContain<TCollection, TItem>(this .<TCollection> source, <TItem, bool> predicate, string predicateDescription, [.("predicate")] string? predicateExpression = null, [.("predicateDescription")] string? predicateDescriptionExpression = null)
            where TCollection : .<TItem> { }
    }
    public static class CollectionIsInDescendingOrderAssertionExtensions
    {
        public static .<TCollection, TItem> IsInDescendingOrder<TCollection, TItem>(this .<TCollection> source)
            where TCollection : .<TItem> { }
    }
    public static class CollectionIsInOrderAssertionExtensions
    {
        public static .<TCollection, TItem> IsInOrder<TCollection, TItem>(this .<TCollection> source)
            where TCollection : .<TItem> { }
    }
    public static class CookieAssertionExtensions
    {
        public static . Expired(this .<.Cookie> source) { }
        public static . HttpOnly(this .<.Cookie> source) { }
        public static . IsNotExpired(this .<.Cookie> source) { }
        public static . IsNotHttpOnly(this .<.Cookie> source) { }
        public static . IsNotSecure(this .<.Cookie> source) { }
        public static . Secure(this .<.Cookie> source) { }
    }
    public class CookieExpiredAssertion : .<.Cookie>
    {
        public CookieExpiredAssertion(.<.Cookie> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<.Cookie> metadata) { }
        protected override string GetExpectation() { }
    }
    public class CookieHttpOnlyAssertion : .<.Cookie>
    {
        public CookieHttpOnlyAssertion(.<.Cookie> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<.Cookie> metadata) { }
        protected override string GetExpectation() { }
    }
    public class CookieSecureAssertion : .<.Cookie>
    {
        public CookieSecureAssertion(.<.Cookie> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<.Cookie> metadata) { }
        protected override string GetExpectation() { }
    }
    public static class CultureInfoAssertionExtensions
    {
        public static ._IsEnglish_Assertion IsEnglish(this .<.CultureInfo> source) { }
        public static ._IsInvariant_Assertion IsInvariant(this .<.CultureInfo> source) { }
        public static ._IsLeftToRight_Assertion IsLeftToRight(this .<.CultureInfo> source) { }
        public static . IsNeutralCulture(this .<.CultureInfo> source) { }
        public static ._IsNotEnglish_Assertion IsNotEnglish(this .<.CultureInfo> source) { }
        public static ._IsNotInvariant_Assertion IsNotInvariant(this .<.CultureInfo> source) { }
        public static . IsNotNeutralCulture(this .<.CultureInfo> source) { }
        public static . IsReadOnly(this .<.CultureInfo> source) { }
        public static ._IsRightToLeft_Assertion IsRightToLeft(this .<.CultureInfo> source) { }
    }
    public class CultureInfoIsNeutralCultureAssertion : .<.CultureInfo>
    {
        public CultureInfoIsNeutralCultureAssertion(.<.CultureInfo> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<.CultureInfo> metadata) { }
        protected override string GetExpectation() { }
    }
    public class CultureInfoIsReadOnlyAssertion : .<.CultureInfo>
    {
        public CultureInfoIsReadOnlyAssertion(.<.CultureInfo> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<.CultureInfo> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class CultureInfo_IsEnglish_Assertion : .<.CultureInfo>
    {
        public CultureInfo_IsEnglish_Assertion(.<.CultureInfo> context) { }
        protected override .<.> CheckAsync(.<.CultureInfo> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class CultureInfo_IsInvariant_Assertion : .<.CultureInfo>
    {
        public CultureInfo_IsInvariant_Assertion(.<.CultureInfo> context) { }
        protected override .<.> CheckAsync(.<.CultureInfo> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class CultureInfo_IsLeftToRight_Assertion : .<.CultureInfo>
    {
        public CultureInfo_IsLeftToRight_Assertion(.<.CultureInfo> context) { }
        protected override .<.> CheckAsync(.<.CultureInfo> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class CultureInfo_IsNotEnglish_Assertion : .<.CultureInfo>
    {
        public CultureInfo_IsNotEnglish_Assertion(.<.CultureInfo> context) { }
        protected override .<.> CheckAsync(.<.CultureInfo> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class CultureInfo_IsNotInvariant_Assertion : .<.CultureInfo>
    {
        public CultureInfo_IsNotInvariant_Assertion(.<.CultureInfo> context) { }
        protected override .<.> CheckAsync(.<.CultureInfo> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class CultureInfo_IsRightToLeft_Assertion : .<.CultureInfo>
    {
        public CultureInfo_IsRightToLeft_Assertion(.<.CultureInfo> context) { }
        protected override .<.> CheckAsync(.<.CultureInfo> metadata) { }
        protected override string GetExpectation() { }
    }
    public static class DateTimeAssertionExtensions
    {
        public static . IsDaylightSavingTime(this .<> source) { }
        public static ._IsInFuture_Assertion IsInFuture(this .<> source) { }
        public static ._IsInFutureUtc_Assertion IsInFutureUtc(this .<> source) { }
        public static ._IsInPast_Assertion IsInPast(this .<> source) { }
        public static ._IsInPastUtc_Assertion IsInPastUtc(this .<> source) { }
        public static ._IsLeapYear_Assertion IsLeapYear(this .<> source) { }
        public static . IsNotDaylightSavingTime(this .<> source) { }
        public static ._IsNotLeapYear_Assertion IsNotLeapYear(this .<> source) { }
        public static ._IsNotToday_Assertion IsNotToday(this .<> source) { }
        public static ._IsNotUtc_Assertion IsNotUtc(this .<> source) { }
        public static ._IsOnWeekday_Assertion IsOnWeekday(this .<> source) { }
        public static ._IsOnWeekend_Assertion IsOnWeekend(this .<> source) { }
        public static ._IsToday_Assertion IsToday(this .<> source) { }
        public static ._IsUtc_Assertion IsUtc(this .<> source) { }
    }
    public static class DateTimeEqualsAssertionExtensions
    {
        public static . IsEqualTo(this .<> source,  expected, [.("expected")] string? expectedExpression = null) { }
    }
    public static class DateTimeEqualsExactAssertionExtensions
    {
        public static . EqualsExact(this .<> source,  expected, [.("expected")] string? expectedExpression = null) { }
    }
    public class DateTimeIsDaylightSavingTimeAssertion : .<>
    {
        public DateTimeIsDaylightSavingTimeAssertion(.<> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public static class DateTimeOffsetAssertionExtensions
    {
        public static ._IsInFuture_Assertion IsInFuture(this .<> source) { }
        public static ._IsInFutureUtc_Assertion IsInFutureUtc(this .<> source) { }
        public static ._IsInPast_Assertion IsInPast(this .<> source) { }
        public static ._IsInPastUtc_Assertion IsInPastUtc(this .<> source) { }
        public static ._IsLeapYear_Assertion IsLeapYear(this .<> source) { }
        public static ._IsNotLeapYear_Assertion IsNotLeapYear(this .<> source) { }
        public static ._IsNotToday_Assertion IsNotToday(this .<> source) { }
        public static ._IsNotUtc_Assertion IsNotUtc(this .<> source) { }
        public static ._IsOnWeekday_Assertion IsOnWeekday(this .<> source) { }
        public static ._IsOnWeekend_Assertion IsOnWeekend(this .<> source) { }
        public static ._IsToday_Assertion IsToday(this .<> source) { }
        public static ._IsUtc_Assertion IsUtc(this .<> source) { }
    }
    public static class DateTimeOffsetEqualsAssertionExtensions
    {
        public static . IsEqualTo(this .<> source,  expected, [.("expected")] string? expectedExpression = null) { }
    }
    public sealed class DateTimeOffset_IsInFutureUtc_Assertion : .<>
    {
        public DateTimeOffset_IsInFutureUtc_Assertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class DateTimeOffset_IsInFuture_Assertion : .<>
    {
        public DateTimeOffset_IsInFuture_Assertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class DateTimeOffset_IsInPastUtc_Assertion : .<>
    {
        public DateTimeOffset_IsInPastUtc_Assertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class DateTimeOffset_IsInPast_Assertion : .<>
    {
        public DateTimeOffset_IsInPast_Assertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class DateTimeOffset_IsLeapYear_Assertion : .<>
    {
        public DateTimeOffset_IsLeapYear_Assertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class DateTimeOffset_IsNotLeapYear_Assertion : .<>
    {
        public DateTimeOffset_IsNotLeapYear_Assertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class DateTimeOffset_IsNotToday_Assertion : .<>
    {
        public DateTimeOffset_IsNotToday_Assertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class DateTimeOffset_IsNotUtc_Assertion : .<>
    {
        public DateTimeOffset_IsNotUtc_Assertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class DateTimeOffset_IsOnWeekday_Assertion : .<>
    {
        public DateTimeOffset_IsOnWeekday_Assertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class DateTimeOffset_IsOnWeekend_Assertion : .<>
    {
        public DateTimeOffset_IsOnWeekend_Assertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class DateTimeOffset_IsToday_Assertion : .<>
    {
        public DateTimeOffset_IsToday_Assertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class DateTimeOffset_IsUtc_Assertion : .<>
    {
        public DateTimeOffset_IsUtc_Assertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class DateTime_IsInFutureUtc_Assertion : .<>
    {
        public DateTime_IsInFutureUtc_Assertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class DateTime_IsInFuture_Assertion : .<>
    {
        public DateTime_IsInFuture_Assertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class DateTime_IsInPastUtc_Assertion : .<>
    {
        public DateTime_IsInPastUtc_Assertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class DateTime_IsInPast_Assertion : .<>
    {
        public DateTime_IsInPast_Assertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class DateTime_IsLeapYear_Assertion : .<>
    {
        public DateTime_IsLeapYear_Assertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class DateTime_IsNotLeapYear_Assertion : .<>
    {
        public DateTime_IsNotLeapYear_Assertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class DateTime_IsNotToday_Assertion : .<>
    {
        public DateTime_IsNotToday_Assertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class DateTime_IsNotUtc_Assertion : .<>
    {
        public DateTime_IsNotUtc_Assertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class DateTime_IsOnWeekday_Assertion : .<>
    {
        public DateTime_IsOnWeekday_Assertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class DateTime_IsOnWeekend_Assertion : .<>
    {
        public DateTime_IsOnWeekend_Assertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class DateTime_IsToday_Assertion : .<>
    {
        public DateTime_IsToday_Assertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class DateTime_IsUtc_Assertion : .<>
    {
        public DateTime_IsUtc_Assertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public static class DayOfWeekAssertionExtensions
    {
        public static ._IsFriday_Assertion IsFriday(this .<> source) { }
        public static ._IsMonday_Assertion IsMonday(this .<> source) { }
        public static ._IsWeekday_Assertion IsWeekday(this .<> source) { }
        public static ._IsWeekend_Assertion IsWeekend(this .<> source) { }
    }
    public sealed class DayOfWeek_IsFriday_Assertion : .<>
    {
        public DayOfWeek_IsFriday_Assertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class DayOfWeek_IsMonday_Assertion : .<>
    {
        public DayOfWeek_IsMonday_Assertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class DayOfWeek_IsWeekday_Assertion : .<>
    {
        public DayOfWeek_IsWeekday_Assertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class DayOfWeek_IsWeekend_Assertion : .<>
    {
        public DayOfWeek_IsWeekend_Assertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public static class DecimalAssertions
    {
        public static ._IsNotZero_Assertion IsNotZero(this .<decimal> source) { }
        public static ._IsZero_Assertion IsZero(this .<decimal> source) { }
    }
    public static class DecimalEqualsAssertionExtensions
    {
        public static . IsEqualTo(this .<decimal> source, decimal expected, [.("expected")] string? expectedExpression = null) { }
    }
    public sealed class Decimal_IsNotZero_Assertion : .<decimal>
    {
        public Decimal_IsNotZero_Assertion(.<decimal> context) { }
        protected override .<.> CheckAsync(.<decimal> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class Decimal_IsZero_Assertion : .<decimal>
    {
        public Decimal_IsZero_Assertion(.<decimal> context) { }
        protected override .<.> CheckAsync(.<decimal> metadata) { }
        protected override string GetExpectation() { }
    }
    public static class DirectoryHasFilesAssertionExtensions
    {
        public static . HasFiles(this .<.DirectoryInfo> source) { }
    }
    public static class DirectoryHasNoSubdirectoriesAssertionExtensions
    {
        public static . HasNoSubdirectories(this .<.DirectoryInfo> source) { }
    }
    public static class DirectoryInfoAssertionExtensions
    {
        public static . DoesNotExist(this .<.DirectoryInfo> source) { }
        public static . Exists(this .<.DirectoryInfo> source) { }
        public static ._IsEmpty_Assertion IsEmpty(this .<.DirectoryInfo> source) { }
        public static ._IsHidden_Assertion IsHidden(this .<.DirectoryInfo> source) { }
        public static ._IsNotEmpty_Assertion IsNotEmpty(this .<.DirectoryInfo> source) { }
        public static ._IsNotHidden_Assertion IsNotHidden(this .<.DirectoryInfo> source) { }
        public static ._IsNotRoot_Assertion IsNotRoot(this .<.DirectoryInfo> source) { }
        public static ._IsRoot_Assertion IsRoot(this .<.DirectoryInfo> source) { }
        public static ._IsSystemDirectory_Assertion IsSystemDirectory(this .<.DirectoryInfo> source) { }
    }
    public class DirectoryInfoExistsAssertion : .<.DirectoryInfo>
    {
        public DirectoryInfoExistsAssertion(.<.DirectoryInfo> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<.DirectoryInfo> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class DirectoryInfo_IsEmpty_Assertion : .<.DirectoryInfo>
    {
        public DirectoryInfo_IsEmpty_Assertion(.<.DirectoryInfo> context) { }
        protected override .<.> CheckAsync(.<.DirectoryInfo> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class DirectoryInfo_IsHidden_Assertion : .<.DirectoryInfo>
    {
        public DirectoryInfo_IsHidden_Assertion(.<.DirectoryInfo> context) { }
        protected override .<.> CheckAsync(.<.DirectoryInfo> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class DirectoryInfo_IsNotEmpty_Assertion : .<.DirectoryInfo>
    {
        public DirectoryInfo_IsNotEmpty_Assertion(.<.DirectoryInfo> context) { }
        protected override .<.> CheckAsync(.<.DirectoryInfo> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class DirectoryInfo_IsNotHidden_Assertion : .<.DirectoryInfo>
    {
        public DirectoryInfo_IsNotHidden_Assertion(.<.DirectoryInfo> context) { }
        protected override .<.> CheckAsync(.<.DirectoryInfo> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class DirectoryInfo_IsNotRoot_Assertion : .<.DirectoryInfo>
    {
        public DirectoryInfo_IsNotRoot_Assertion(.<.DirectoryInfo> context) { }
        protected override .<.> CheckAsync(.<.DirectoryInfo> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class DirectoryInfo_IsRoot_Assertion : .<.DirectoryInfo>
    {
        public DirectoryInfo_IsRoot_Assertion(.<.DirectoryInfo> context) { }
        protected override .<.> CheckAsync(.<.DirectoryInfo> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class DirectoryInfo_IsSystemDirectory_Assertion : .<.DirectoryInfo>
    {
        public DirectoryInfo_IsSystemDirectory_Assertion(.<.DirectoryInfo> context) { }
        protected override .<.> CheckAsync(.<.DirectoryInfo> metadata) { }
        protected override string GetExpectation() { }
    }
    public static class DoubleAssertionExtensions
    {
        public static . IsInfinity(this .<double> source) { }
        public static . IsNaN(this .<double> source) { }
        public static . IsNegativeInfinity(this .<double> source) { }
        public static . IsNotInfinity(this .<double> source) { }
        public static . IsNotNaN(this .<double> source) { }
        public static . IsNotNegativeInfinity(this .<double> source) { }
        public static . IsNotPositiveInfinity(this .<double> source) { }
        public static . IsPositiveInfinity(this .<double> source) { }
    }
    public static class DoubleAssertions
    {
        public static ._IsNotZero_Assertion IsNotZero(this .<double> source) { }
        public static ._IsZero_Assertion IsZero(this .<double> source) { }
    }
    public static class DoubleEqualsAssertionExtensions
    {
        public static . IsEqualTo(this .<double> source, double expected, [.("expected")] string? expectedExpression = null) { }
    }
    public class DoubleIsInfinityWithDoubleAssertion : .<double>
    {
        public DoubleIsInfinityWithDoubleAssertion(.<double> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<double> metadata) { }
        protected override string GetExpectation() { }
    }
    public class DoubleIsNaNWithDoubleAssertion : .<double>
    {
        public DoubleIsNaNWithDoubleAssertion(.<double> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<double> metadata) { }
        protected override string GetExpectation() { }
    }
    public class DoubleIsNegativeInfinityWithDoubleAssertion : .<double>
    {
        public DoubleIsNegativeInfinityWithDoubleAssertion(.<double> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<double> metadata) { }
        protected override string GetExpectation() { }
    }
    public class DoubleIsPositiveInfinityWithDoubleAssertion : .<double>
    {
        public DoubleIsPositiveInfinityWithDoubleAssertion(.<double> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<double> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class Double_IsNotZero_Assertion : .<double>
    {
        public Double_IsNotZero_Assertion(.<double> context) { }
        protected override .<.> CheckAsync(.<double> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class Double_IsZero_Assertion : .<double>
    {
        public Double_IsZero_Assertion(.<double> context) { }
        protected override .<.> CheckAsync(.<double> metadata) { }
        protected override string GetExpectation() { }
    }
    public static class EncodingAssertionExtensions
    {
        public static ._IsASCII_Assertion IsASCII(this .<.Encoding> source) { }
        public static ._IsBigEndianUnicode_Assertion IsBigEndianUnicode(this .<.Encoding> source) { }
        public static . IsNotSingleByte(this .<.Encoding> source) { }
        public static ._IsNotUTF8_Assertion IsNotUTF8(this .<.Encoding> source) { }
        public static . IsSingleByte(this .<.Encoding> source) { }
        public static ._IsUTF32_Assertion IsUTF32(this .<.Encoding> source) { }
        public static ._IsUTF8_Assertion IsUTF8(this .<.Encoding> source) { }
        public static ._IsUnicode_Assertion IsUnicode(this .<.Encoding> source) { }
    }
    public class EncodingIsSingleByteAssertion : .<.Encoding>
    {
        public EncodingIsSingleByteAssertion(.<.Encoding> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<.Encoding> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class Encoding_IsASCII_Assertion : .<.Encoding>
    {
        public Encoding_IsASCII_Assertion(.<.Encoding> context) { }
        protected override .<.> CheckAsync(.<.Encoding> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class Encoding_IsBigEndianUnicode_Assertion : .<.Encoding>
    {
        public Encoding_IsBigEndianUnicode_Assertion(.<.Encoding> context) { }
        protected override .<.> CheckAsync(.<.Encoding> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class Encoding_IsNotUTF8_Assertion : .<.Encoding>
    {
        public Encoding_IsNotUTF8_Assertion(.<.Encoding> context) { }
        protected override .<.> CheckAsync(.<.Encoding> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class Encoding_IsUTF32_Assertion : .<.Encoding>
    {
        public Encoding_IsUTF32_Assertion(.<.Encoding> context) { }
        protected override .<.> CheckAsync(.<.Encoding> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class Encoding_IsUTF8_Assertion : .<.Encoding>
    {
        public Encoding_IsUTF8_Assertion(.<.Encoding> context) { }
        protected override .<.> CheckAsync(.<.Encoding> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class Encoding_IsUnicode_Assertion : .<.Encoding>
    {
        public Encoding_IsUnicode_Assertion(.<.Encoding> context) { }
        protected override .<.> CheckAsync(.<.Encoding> metadata) { }
        protected override string GetExpectation() { }
    }
    public static class EqualsAssertionExtensions
    {
        public static .<TValue> IsEqualTo<TValue>(this .<TValue> source, TValue? expected, [.("expected")] string? expectedExpression = null) { }
        public static .<TValue> IsEqualTo<TValue>(this .<TValue> source, TValue? expected, .<TValue> comparer, [.("expected")] string? expectedExpression = null, [.("comparer")] string? comparerExpression = null) { }
    }
    public static class EquatableAssertionExtensions
    {
        public static .<TActual, TExpected> IsEquatableTo<TActual, TExpected>(this .<TActual> source, TExpected expected, [.("expected")] string? expectedExpression = null)
            where TActual : <TExpected> { }
    }
    public static class ExceptionAssertionExtensions
    {
        public static ._HasHelpLink_Assertion HasHelpLink(this .<> source) { }
        public static ._HasInnerException_Assertion HasInnerException(this .<> source) { }
        public static ._HasNoData_Assertion HasNoData(this .<> source) { }
        public static ._HasNoHelpLink_Assertion HasNoHelpLink(this .<> source) { }
        public static ._HasNoInnerException_Assertion HasNoInnerException(this .<> source) { }
        public static ._HasNoSource_Assertion HasNoSource(this .<> source) { }
        public static ._HasNoTargetSite_Assertion HasNoTargetSite(this .<> source) { }
        public static ._HasSource_Assertion HasSource(this .<> source) { }
        public static ._HasStackTrace_Assertion HasStackTrace(this .<> source) { }
        public static ._HasTargetSite_Assertion HasTargetSite(this .<> source) { }
    }
    public sealed class Exception_HasHelpLink_Assertion : .<>
    {
        public Exception_HasHelpLink_Assertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class Exception_HasInnerException_Assertion : .<>
    {
        public Exception_HasInnerException_Assertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class Exception_HasNoData_Assertion : .<>
    {
        public Exception_HasNoData_Assertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class Exception_HasNoHelpLink_Assertion : .<>
    {
        public Exception_HasNoHelpLink_Assertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class Exception_HasNoInnerException_Assertion : .<>
    {
        public Exception_HasNoInnerException_Assertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class Exception_HasNoSource_Assertion : .<>
    {
        public Exception_HasNoSource_Assertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class Exception_HasNoTargetSite_Assertion : .<>
    {
        public Exception_HasNoTargetSite_Assertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class Exception_HasSource_Assertion : .<>
    {
        public Exception_HasSource_Assertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class Exception_HasStackTrace_Assertion : .<>
    {
        public Exception_HasStackTrace_Assertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class Exception_HasTargetSite_Assertion : .<>
    {
        public Exception_HasTargetSite_Assertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public static class FileInfoAssertionExtensions
    {
        public static . DoesNotExist(this .<.FileInfo> source) { }
        public static . Exists(this .<.FileInfo> source) { }
        public static ._HasExtension_Assertion HasExtension(this .<.FileInfo> source) { }
        public static ._HasNoExtension_Assertion HasNoExtension(this .<.FileInfo> source) { }
        public static ._IsArchived_Assertion IsArchived(this .<.FileInfo> source) { }
        public static ._IsEmpty_Assertion IsEmpty(this .<.FileInfo> source) { }
        public static ._IsHidden_Assertion IsHidden(this .<.FileInfo> source) { }
        public static ._IsNotEmpty_Assertion IsNotEmpty(this .<.FileInfo> source) { }
        public static ._IsNotHidden_Assertion IsNotHidden(this .<.FileInfo> source) { }
        public static . IsNotReadOnly(this .<.FileInfo> source) { }
        public static . IsReadOnly(this .<.FileInfo> source) { }
        public static ._IsSystemFile_Assertion IsSystemFile(this .<.FileInfo> source) { }
    }
    public class FileInfoExistsAssertion : .<.FileInfo>
    {
        public FileInfoExistsAssertion(.<.FileInfo> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<.FileInfo> metadata) { }
        protected override string GetExpectation() { }
    }
    public class FileInfoIsReadOnlyAssertion : .<.FileInfo>
    {
        public FileInfoIsReadOnlyAssertion(.<.FileInfo> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<.FileInfo> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class FileInfo_HasExtension_Assertion : .<.FileInfo>
    {
        public FileInfo_HasExtension_Assertion(.<.FileInfo> context) { }
        protected override .<.> CheckAsync(.<.FileInfo> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class FileInfo_HasNoExtension_Assertion : .<.FileInfo>
    {
        public FileInfo_HasNoExtension_Assertion(.<.FileInfo> context) { }
        protected override .<.> CheckAsync(.<.FileInfo> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class FileInfo_IsArchived_Assertion : .<.FileInfo>
    {
        public FileInfo_IsArchived_Assertion(.<.FileInfo> context) { }
        protected override .<.> CheckAsync(.<.FileInfo> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class FileInfo_IsEmpty_Assertion : .<.FileInfo>
    {
        public FileInfo_IsEmpty_Assertion(.<.FileInfo> context) { }
        protected override .<.> CheckAsync(.<.FileInfo> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class FileInfo_IsHidden_Assertion : .<.FileInfo>
    {
        public FileInfo_IsHidden_Assertion(.<.FileInfo> context) { }
        protected override .<.> CheckAsync(.<.FileInfo> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class FileInfo_IsNotEmpty_Assertion : .<.FileInfo>
    {
        public FileInfo_IsNotEmpty_Assertion(.<.FileInfo> context) { }
        protected override .<.> CheckAsync(.<.FileInfo> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class FileInfo_IsNotHidden_Assertion : .<.FileInfo>
    {
        public FileInfo_IsNotHidden_Assertion(.<.FileInfo> context) { }
        protected override .<.> CheckAsync(.<.FileInfo> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class FileInfo_IsSystemFile_Assertion : .<.FileInfo>
    {
        public FileInfo_IsSystemFile_Assertion(.<.FileInfo> context) { }
        protected override .<.> CheckAsync(.<.FileInfo> metadata) { }
        protected override string GetExpectation() { }
    }
    public static class FileIsNotExecutableAssertionExtensions
    {
        public static . IsNotExecutable(this .<.FileInfo> source) { }
    }
    public static class FileIsNotSystemAssertionExtensions
    {
        public static . IsNotSystem(this .<.FileInfo> source) { }
    }
    public static class FloatAssertions
    {
        public static ._IsNotZero_Assertion IsNotZero(this .<float> source) { }
        public static ._IsZero_Assertion IsZero(this .<float> source) { }
    }
    public static class FloatEqualsAssertionExtensions
    {
        public static . IsEqualTo(this .<float> source, float expected, [.("expected")] string? expectedExpression = null) { }
    }
    public class FloatIsInfinityWithFloatAssertion : .<float>
    {
        public FloatIsInfinityWithFloatAssertion(.<float> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<float> metadata) { }
        protected override string GetExpectation() { }
    }
    public class FloatIsNaNWithFloatAssertion : .<float>
    {
        public FloatIsNaNWithFloatAssertion(.<float> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<float> metadata) { }
        protected override string GetExpectation() { }
    }
    public class FloatIsNegativeInfinityWithFloatAssertion : .<float>
    {
        public FloatIsNegativeInfinityWithFloatAssertion(.<float> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<float> metadata) { }
        protected override string GetExpectation() { }
    }
    public class FloatIsPositiveInfinityWithFloatAssertion : .<float>
    {
        public FloatIsPositiveInfinityWithFloatAssertion(.<float> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<float> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class Float_IsNotZero_Assertion : .<float>
    {
        public Float_IsNotZero_Assertion(.<float> context) { }
        protected override .<.> CheckAsync(.<float> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class Float_IsZero_Assertion : .<float>
    {
        public Float_IsZero_Assertion(.<float> context) { }
        protected override .<.> CheckAsync(.<float> metadata) { }
        protected override string GetExpectation() { }
    }
    public static class GenericAssertions
    {
        public static .Extensions.T_IsIn__Assertion<T> IsIn<T>(this .<T> source, params T[] collection) { }
        public static .Extensions.T_IsIn_IEnumerableT_Assertion<T> IsIn<T>(this .<T> source, .<T> collection, [.("collection")] string? collectionExpression = null) { }
        public static .Extensions.T_IsNotIn__Assertion<T> IsNotIn<T>(this .<T> source, params T[] collection) { }
        public static .Extensions.T_IsNotIn_IEnumerableT_Assertion<T> IsNotIn<T>(this .<T> source, .<T> collection, [.("collection")] string? collectionExpression = null) { }
    }
    public static class GreaterThanAssertionExtensions
    {
        public static .<TValue> IsGreaterThan<TValue>(this .<TValue> source, TValue minimum, [.("minimum")] string? minimumExpression = null)
            where TValue : <TValue> { }
    }
    public static class GreaterThanOrEqualAssertionExtensions
    {
        public static .<TValue> IsGreaterThanOrEqualTo<TValue>(this .<TValue> source, TValue minimum, [.("minimum")] string? minimumExpression = null)
            where TValue : <TValue> { }
    }
    public static class GuidAssertionExtensions
    {
        public static ._IsEmptyGuid_Assertion IsEmptyGuid(this .<> source) { }
        public static ._IsNotEmptyGuid_Assertion IsNotEmptyGuid(this .<> source) { }
    }
    public sealed class Guid_IsEmptyGuid_Assertion : .<>
    {
        public Guid_IsEmptyGuid_Assertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class Guid_IsNotEmptyGuid_Assertion : .<>
    {
        public Guid_IsNotEmptyGuid_Assertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public static class HasSingleItemAssertionExtensions
    {
        public static .<TCollection, TItem> HasSingleItem<TCollection, TItem>(this .<TCollection> source)
            where TCollection : .<TItem> { }
    }
    public static class HttpResponseMessageAssertionExtensions
    {
        public static . IsNotSuccessStatusCode(this .<.> source) { }
        public static . IsSuccessStatusCode(this .<.> source) { }
    }
    public class HttpResponseMessageIsSuccessStatusCodeAssertion : .<.>
    {
        public HttpResponseMessageIsSuccessStatusCodeAssertion(.<.> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<.> metadata) { }
        protected override string GetExpectation() { }
    }
    public static class HttpStatusCodeAssertionExtensions
    {
        public static ._IsClientError_Assertion IsClientError(this .<.HttpStatusCode> source) { }
        public static ._IsError_Assertion IsError(this .<.HttpStatusCode> source) { }
        public static ._IsInformational_Assertion IsInformational(this .<.HttpStatusCode> source) { }
        public static ._IsNotSuccess_Assertion IsNotSuccess(this .<.HttpStatusCode> source) { }
        public static ._IsRedirection_Assertion IsRedirection(this .<.HttpStatusCode> source) { }
        public static ._IsServerError_Assertion IsServerError(this .<.HttpStatusCode> source) { }
        public static ._IsSuccess_Assertion IsSuccess(this .<.HttpStatusCode> source) { }
    }
    public sealed class HttpStatusCode_IsClientError_Assertion : .<.HttpStatusCode>
    {
        public HttpStatusCode_IsClientError_Assertion(.<.HttpStatusCode> context) { }
        protected override .<.> CheckAsync(.<.HttpStatusCode> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class HttpStatusCode_IsError_Assertion : .<.HttpStatusCode>
    {
        public HttpStatusCode_IsError_Assertion(.<.HttpStatusCode> context) { }
        protected override .<.> CheckAsync(.<.HttpStatusCode> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class HttpStatusCode_IsInformational_Assertion : .<.HttpStatusCode>
    {
        public HttpStatusCode_IsInformational_Assertion(.<.HttpStatusCode> context) { }
        protected override .<.> CheckAsync(.<.HttpStatusCode> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class HttpStatusCode_IsNotSuccess_Assertion : .<.HttpStatusCode>
    {
        public HttpStatusCode_IsNotSuccess_Assertion(.<.HttpStatusCode> context) { }
        protected override .<.> CheckAsync(.<.HttpStatusCode> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class HttpStatusCode_IsRedirection_Assertion : .<.HttpStatusCode>
    {
        public HttpStatusCode_IsRedirection_Assertion(.<.HttpStatusCode> context) { }
        protected override .<.> CheckAsync(.<.HttpStatusCode> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class HttpStatusCode_IsServerError_Assertion : .<.HttpStatusCode>
    {
        public HttpStatusCode_IsServerError_Assertion(.<.HttpStatusCode> context) { }
        protected override .<.> CheckAsync(.<.HttpStatusCode> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class HttpStatusCode_IsSuccess_Assertion : .<.HttpStatusCode>
    {
        public HttpStatusCode_IsSuccess_Assertion(.<.HttpStatusCode> context) { }
        protected override .<.> CheckAsync(.<.HttpStatusCode> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class IEnumerableT_IsNotSingleElement_Assertion<T> : .<.<T>>
    {
        public IEnumerableT_IsNotSingleElement_Assertion(.<.<T>> context) { }
        protected override .<.> CheckAsync(.<.<T>> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class IEnumerableT_IsSingleElement_Assertion<T> : .<.<T>>
    {
        public IEnumerableT_IsSingleElement_Assertion(.<.<T>> context) { }
        protected override .<.> CheckAsync(.<.<T>> metadata) { }
        protected override string GetExpectation() { }
    }
    public static class IPAddressAssertionExtensions
    {
        public static .4MappedToIPv6Assertion IsIPv4MappedToIPv6(this .<.IPAddress> source) { }
        public static .6LinkLocalAssertion IsIPv6LinkLocal(this .<.IPAddress> source) { }
        public static .6MulticastAssertion IsIPv6Multicast(this .<.IPAddress> source) { }
        public static .6SiteLocalAssertion IsIPv6SiteLocal(this .<.IPAddress> source) { }
        public static .6TeredoAssertion IsIPv6Teredo(this .<.IPAddress> source) { }
        public static .4MappedToIPv6Assertion IsNotIPv4MappedToIPv6(this .<.IPAddress> source) { }
        public static .6LinkLocalAssertion IsNotIPv6LinkLocal(this .<.IPAddress> source) { }
        public static .6MulticastAssertion IsNotIPv6Multicast(this .<.IPAddress> source) { }
        public static .6SiteLocalAssertion IsNotIPv6SiteLocal(this .<.IPAddress> source) { }
        public static .6TeredoAssertion IsNotIPv6Teredo(this .<.IPAddress> source) { }
    }
    public class IPAddressIsIPv4MappedToIPv6Assertion : .<.IPAddress>
    {
        public IPAddressIsIPv4MappedToIPv6Assertion(.<.IPAddress> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<.IPAddress> metadata) { }
        protected override string GetExpectation() { }
    }
    public class IPAddressIsIPv6LinkLocalAssertion : .<.IPAddress>
    {
        public IPAddressIsIPv6LinkLocalAssertion(.<.IPAddress> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<.IPAddress> metadata) { }
        protected override string GetExpectation() { }
    }
    public class IPAddressIsIPv6MulticastAssertion : .<.IPAddress>
    {
        public IPAddressIsIPv6MulticastAssertion(.<.IPAddress> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<.IPAddress> metadata) { }
        protected override string GetExpectation() { }
    }
    public class IPAddressIsIPv6SiteLocalAssertion : .<.IPAddress>
    {
        public IPAddressIsIPv6SiteLocalAssertion(.<.IPAddress> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<.IPAddress> metadata) { }
        protected override string GetExpectation() { }
    }
    public class IPAddressIsIPv6TeredoAssertion : .<.IPAddress>
    {
        public IPAddressIsIPv6TeredoAssertion(.<.IPAddress> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<.IPAddress> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class Int16_IsEven_Assertion : .<short>
    {
        public Int16_IsEven_Assertion(.<short> context) { }
        protected override .<.> CheckAsync(.<short> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class Int16_IsNotZero_Assertion : .<short>
    {
        public Int16_IsNotZero_Assertion(.<short> context) { }
        protected override .<.> CheckAsync(.<short> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class Int16_IsOdd_Assertion : .<short>
    {
        public Int16_IsOdd_Assertion(.<short> context) { }
        protected override .<.> CheckAsync(.<short> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class Int16_IsZero_Assertion : .<short>
    {
        public Int16_IsZero_Assertion(.<short> context) { }
        protected override .<.> CheckAsync(.<short> metadata) { }
        protected override string GetExpectation() { }
    }
    public static class IntAssertions
    {
        public static ._IsEven_Assertion IsEven(this .<int> source) { }
        public static ._IsNotZero_Assertion IsNotZero(this .<int> source) { }
        public static ._IsOdd_Assertion IsOdd(this .<int> source) { }
        public static ._IsZero_Assertion IsZero(this .<int> source) { }
    }
    public static class IntEqualsAssertionExtensions
    {
        public static . IsEqualTo(this .<int> source, int expected, [.("expected")] string? expectedExpression = null) { }
    }
    public sealed class Int_IsEven_Assertion : .<int>
    {
        public Int_IsEven_Assertion(.<int> context) { }
        protected override .<.> CheckAsync(.<int> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class Int_IsNotZero_Assertion : .<int>
    {
        public Int_IsNotZero_Assertion(.<int> context) { }
        protected override .<.> CheckAsync(.<int> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class Int_IsOdd_Assertion : .<int>
    {
        public Int_IsOdd_Assertion(.<int> context) { }
        protected override .<.> CheckAsync(.<int> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class Int_IsZero_Assertion : .<int>
    {
        public Int_IsZero_Assertion(.<int> context) { }
        protected override .<.> CheckAsync(.<int> metadata) { }
        protected override string GetExpectation() { }
    }
    public static class IsDefaultAssertionExtensions
    {
        public static .<TValue> IsDefault<TValue>(this .<TValue> source)
            where TValue :  struct { }
    }
    public static class IsDefaultNullableAssertionExtensions
    {
        public static .<TValue> IsDefault<TValue>(this .<TValue?> source)
            where TValue :  struct { }
    }
    public static class IsDefaultReferenceAssertionExtensions
    {
        public static .<TValue> IsDefault<TValue>(this .<TValue> source)
            where TValue :  class { }
    }
    public static class IsEquatableOrEqualToAssertionExtensions
    {
        public static .<TValue> IsEquatableOrEqualTo<TValue>(this .<TValue> source, TValue expected, [.("expected")] string? expectedExpression = null) { }
    }
    public static class IsEquivalentToAssertionExtensions
    {
        public static .<TCollection, TItem> IsEquivalentTo<TCollection, TItem>(this .<TCollection> source, .<TItem> expected, . ordering = 0, [.("expected")] string? expectedExpression = null, [.("ordering")] string? orderingExpression = null)
            where TCollection : .<TItem> { }
        public static .<TCollection, TItem> IsEquivalentTo<TCollection, TItem>(this .<TCollection> source, .<TItem> expected, .<TItem> comparer, . ordering = 0, [.("expected")] string? expectedExpression = null, [.("comparer")] string? comparerExpression = null, [.("ordering")] string? orderingExpression = null)
            where TCollection : .<TItem> { }
    }
    public static class IsNotDefaultAssertionExtensions
    {
        public static .<TValue> IsNotDefault<TValue>(this .<TValue> source)
            where TValue :  struct { }
    }
    public static class IsNotDefaultNullableAssertionExtensions
    {
        public static .<TValue> IsNotDefault<TValue>(this .<TValue?> source)
            where TValue :  struct { }
    }
    public static class IsNotDefaultReferenceAssertionExtensions
    {
        public static .<TValue> IsNotDefault<TValue>(this .<TValue> source)
            where TValue :  class { }
    }
    public static class JsonElementAssertionExtensions
    {
        public static ._DoesNotHaveProperty_String_Assertion DoesNotHaveProperty(this .<.> source, string propertyName, [.("propertyName")] string? propertyNameExpression = null) { }
        public static ._HasProperty_String_Assertion HasProperty(this .<.> source, string propertyName, [.("propertyName")] string? propertyNameExpression = null) { }
        public static ._IsArray_Assertion IsArray(this .<.> source) { }
        public static ._IsBoolean_Assertion IsBoolean(this .<.> source) { }
        public static ._IsNotNull_Assertion IsNotNull(this .<.> source) { }
        public static ._IsNull_Assertion IsNull(this .<.> source) { }
        public static ._IsNumber_Assertion IsNumber(this .<.> source) { }
        public static ._IsObject_Assertion IsObject(this .<.> source) { }
        public static ._IsString_Assertion IsString(this .<.> source) { }
    }
    public sealed class JsonElement_DoesNotHaveProperty_String_Assertion : .<.>
    {
        public JsonElement_DoesNotHaveProperty_String_Assertion(.<.> context, string propertyName) { }
        protected override .<.> CheckAsync(.<.> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class JsonElement_HasProperty_String_Assertion : .<.>
    {
        public JsonElement_HasProperty_String_Assertion(.<.> context, string propertyName) { }
        protected override .<.> CheckAsync(.<.> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class JsonElement_IsArray_Assertion : .<.>
    {
        public JsonElement_IsArray_Assertion(.<.> context) { }
        protected override .<.> CheckAsync(.<.> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class JsonElement_IsBoolean_Assertion : .<.>
    {
        public JsonElement_IsBoolean_Assertion(.<.> context) { }
        protected override .<.> CheckAsync(.<.> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class JsonElement_IsNotNull_Assertion : .<.>
    {
        public JsonElement_IsNotNull_Assertion(.<.> context) { }
        protected override .<.> CheckAsync(.<.> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class JsonElement_IsNull_Assertion : .<.>
    {
        public JsonElement_IsNull_Assertion(.<.> context) { }
        protected override .<.> CheckAsync(.<.> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class JsonElement_IsNumber_Assertion : .<.>
    {
        public JsonElement_IsNumber_Assertion(.<.> context) { }
        protected override .<.> CheckAsync(.<.> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class JsonElement_IsObject_Assertion : .<.>
    {
        public JsonElement_IsObject_Assertion(.<.> context) { }
        protected override .<.> CheckAsync(.<.> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class JsonElement_IsString_Assertion : .<.>
    {
        public JsonElement_IsString_Assertion(.<.> context) { }
        protected override .<.> CheckAsync(.<.> metadata) { }
        protected override string GetExpectation() { }
    }
    public static class JsonNodeAssertionExtensions
    {
        public static ._DoesNotHaveJsonProperty_String_Assertion DoesNotHaveJsonProperty(this .<..JsonNode?> source, string propertyName, [.("propertyName")] string? propertyNameExpression = null) { }
        public static ._HasJsonArrayCount_Int_Assertion HasJsonArrayCount(this .<..JsonNode?> source, int expected, [.("expected")] string? expectedExpression = null) { }
        public static ._HasJsonProperty_String_Assertion HasJsonProperty(this .<..JsonNode?> source, string propertyName, [.("propertyName")] string? propertyNameExpression = null) { }
        public static ._IsJsonArray_Assertion IsJsonArray(this .<..JsonNode?> source) { }
        public static ._IsJsonArrayEmpty_Assertion IsJsonArrayEmpty(this .<..JsonNode?> source) { }
        public static ._IsJsonArrayNotEmpty_Assertion IsJsonArrayNotEmpty(this .<..JsonNode?> source) { }
        public static ._IsJsonObject_Assertion IsJsonObject(this .<..JsonNode?> source) { }
        public static ._IsJsonValue_Assertion IsJsonValue(this .<..JsonNode?> source) { }
    }
    public sealed class JsonNode_DoesNotHaveJsonProperty_String_Assertion : .<..JsonNode?>
    {
        public JsonNode_DoesNotHaveJsonProperty_String_Assertion(.<..JsonNode?> context, string propertyName) { }
        protected override .<.> CheckAsync(.<..JsonNode?> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class JsonNode_HasJsonArrayCount_Int_Assertion : .<..JsonNode?>
    {
        public JsonNode_HasJsonArrayCount_Int_Assertion(.<..JsonNode?> context, int expected) { }
        protected override .<.> CheckAsync(.<..JsonNode?> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class JsonNode_HasJsonProperty_String_Assertion : .<..JsonNode?>
    {
        public JsonNode_HasJsonProperty_String_Assertion(.<..JsonNode?> context, string propertyName) { }
        protected override .<.> CheckAsync(.<..JsonNode?> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class JsonNode_IsJsonArrayEmpty_Assertion : .<..JsonNode?>
    {
        public JsonNode_IsJsonArrayEmpty_Assertion(.<..JsonNode?> context) { }
        protected override .<.> CheckAsync(.<..JsonNode?> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class JsonNode_IsJsonArrayNotEmpty_Assertion : .<..JsonNode?>
    {
        public JsonNode_IsJsonArrayNotEmpty_Assertion(.<..JsonNode?> context) { }
        protected override .<.> CheckAsync(.<..JsonNode?> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class JsonNode_IsJsonArray_Assertion : .<..JsonNode?>
    {
        public JsonNode_IsJsonArray_Assertion(.<..JsonNode?> context) { }
        protected override .<.> CheckAsync(.<..JsonNode?> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class JsonNode_IsJsonObject_Assertion : .<..JsonNode?>
    {
        public JsonNode_IsJsonObject_Assertion(.<..JsonNode?> context) { }
        protected override .<.> CheckAsync(.<..JsonNode?> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class JsonNode_IsJsonValue_Assertion : .<..JsonNode?>
    {
        public JsonNode_IsJsonValue_Assertion(.<..JsonNode?> context) { }
        protected override .<.> CheckAsync(.<..JsonNode?> metadata) { }
        protected override string GetExpectation() { }
    }
    public static class JsonStringAssertionExtensions
    {
        public static ._IsNotValidJson_Assertion IsNotValidJson(this .<string> source) { }
        public static ._IsValidJson_Assertion IsValidJson(this .<string> source) { }
        public static ._IsValidJsonArray_Assertion IsValidJsonArray(this .<string> source) { }
        public static ._IsValidJsonObject_Assertion IsValidJsonObject(this .<string> source) { }
    }
    public static class LazyAssertionExtensions
    {
        public static ._IsValueCreated_Assertion<T> IsValueCreated<T>(this .<<T>> source) { }
        public static ._IsValueNotCreated_Assertion<T> IsValueNotCreated<T>(this .<<T>> source) { }
    }
    public sealed class LazyT_IsValueCreated_Assertion<T> : .<<T>>
    {
        public LazyT_IsValueCreated_Assertion(.<<T>> context) { }
        protected override .<.> CheckAsync(.<<T>> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class LazyT_IsValueNotCreated_Assertion<T> : .<<T>>
    {
        public LazyT_IsValueNotCreated_Assertion(.<<T>> context) { }
        protected override .<.> CheckAsync(.<<T>> metadata) { }
        protected override string GetExpectation() { }
    }
    public static class LessThanAssertionExtensions
    {
        public static .<TValue> IsLessThan<TValue>(this .<TValue> source, TValue maximum, [.("maximum")] string? maximumExpression = null)
            where TValue : <TValue> { }
    }
    public static class LessThanOrEqualAssertionExtensions
    {
        public static .<TValue> IsLessThanOrEqualTo<TValue>(this .<TValue> source, TValue maximum, [.("maximum")] string? maximumExpression = null)
            where TValue : <TValue> { }
    }
    public static class LongAssertions
    {
        public static ._IsEven_Assertion IsEven(this .<long> source) { }
        public static ._IsNotZero_Assertion IsNotZero(this .<long> source) { }
        public static ._IsOdd_Assertion IsOdd(this .<long> source) { }
        public static ._IsZero_Assertion IsZero(this .<long> source) { }
    }
    public static class LongEqualsAssertionExtensions
    {
        public static . IsEqualTo(this .<long> source, long expected, [.("expected")] string? expectedExpression = null) { }
    }
    public sealed class Long_IsEven_Assertion : .<long>
    {
        public Long_IsEven_Assertion(.<long> context) { }
        protected override .<.> CheckAsync(.<long> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class Long_IsNotZero_Assertion : .<long>
    {
        public Long_IsNotZero_Assertion(.<long> context) { }
        protected override .<.> CheckAsync(.<long> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class Long_IsOdd_Assertion : .<long>
    {
        public Long_IsOdd_Assertion(.<long> context) { }
        protected override .<.> CheckAsync(.<long> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class Long_IsZero_Assertion : .<long>
    {
        public Long_IsZero_Assertion(.<long> context) { }
        protected override .<.> CheckAsync(.<long> metadata) { }
        protected override string GetExpectation() { }
    }
    public static class NotEqualsAssertionExtensions
    {
        public static .<TValue> IsNotEqualTo<TValue>(this .<TValue> source, TValue notExpected, .<TValue>? comparer = null, [.("notExpected")] string? notExpectedExpression = null, [.("comparer")] string? comparerExpression = null) { }
    }
    public static class NotEquivalentToAssertionExtensions
    {
        public static .<TCollection, TItem> IsNotEquivalentTo<TCollection, TItem>(this .<TCollection> source, .<TItem> notExpected, . ordering = 0, [.("notExpected")] string? notExpectedExpression = null, [.("ordering")] string? orderingExpression = null)
            where TCollection : .<TItem> { }
        public static .<TCollection, TItem> IsNotEquivalentTo<TCollection, TItem>(this .<TCollection> source, .<TItem> notExpected, .<TItem> comparer, . ordering = 0, [.("notExpected")] string? notExpectedExpression = null, [.("comparer")] string? comparerExpression = null, [.("ordering")] string? orderingExpression = null)
            where TCollection : .<TItem> { }
    }
    public static class NotSameReferenceAssertionExtensions
    {
        public static .<TValue> IsNotSameReferenceAs<TValue>(this .<TValue> source, object? expected, [.("expected")] string? expectedExpression = null) { }
    }
    public static class NullAssertionExtensions
    {
        public static .<TValue> IsNull<TValue>(this .<TValue> source) { }
    }
    public static class NullableAssertionExtensions
    {
        public static . DoesNotHaveValue(this .<int?> source) { }
        public static . HasValue(this .<int?> source) { }
    }
    public sealed class NullableBool_IsFalse_Assertion : .<bool?>
    {
        public NullableBool_IsFalse_Assertion(.<bool?> context) { }
        protected override .<.> CheckAsync(.<bool?> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class NullableBool_IsTrue_Assertion : .<bool?>
    {
        public NullableBool_IsTrue_Assertion(.<bool?> context) { }
        protected override .<.> CheckAsync(.<bool?> metadata) { }
        protected override string GetExpectation() { }
    }
    public static class NullableEquatableAssertionExtensions
    {
        public static .<TActual, TExpected> IsEquatableTo<TActual, TExpected>(this .<TActual?> source, TExpected expected, [.("expected")] string? expectedExpression = null)
            where TActual :  struct, <TExpected> { }
    }
    public class NullableHasValueAssertion : .<int?>
    {
        public NullableHasValueAssertion(.<int?> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<int?> metadata) { }
        protected override string GetExpectation() { }
    }
    public static class ProcessAssertionExtensions
    {
        public static . DoesNotHaveEventRaisingEnabled(this .<.Process> source) { }
        public static . EnableRaisingEvents(this .<.Process> source) { }
        public static . HasExited(this .<.Process> source) { }
        public static . HasNotExited(this .<.Process> source) { }
        public static . IsNotResponding(this .<.Process> source) { }
        public static . Responding(this .<.Process> source) { }
    }
    public class ProcessEnableRaisingEventsAssertion : .<.Process>
    {
        public ProcessEnableRaisingEventsAssertion(.<.Process> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<.Process> metadata) { }
        protected override string GetExpectation() { }
    }
    public class ProcessHasExitedAssertion : .<.Process>
    {
        public ProcessHasExitedAssertion(.<.Process> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<.Process> metadata) { }
        protected override string GetExpectation() { }
    }
    public class ProcessRespondingAssertion : .<.Process>
    {
        public ProcessRespondingAssertion(.<.Process> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<.Process> metadata) { }
        protected override string GetExpectation() { }
    }
    public static class PropertyAssertionExtensions
    {
        public static .<TObject, TProperty> HasProperty<TObject, TProperty>(this .<TObject> source, .<<TObject, TProperty>> propertySelector) { }
        public static .<TObject> HasProperty<TObject, TProperty>(this .<TObject> source, .<<TObject, TProperty>> propertySelector, TProperty expectedValue, [.("expectedValue")] string? expression = null) { }
    }
    public static class RegexAssertionExtensions
    {
        public static ..MatchGroupAssertion Group(this .<..RegexMatch> continuation, int groupIndex, <.<string>, .<string>?> assertion) { }
        public static ..MatchGroupAssertion Group(this .<..RegexMatch> continuation, string groupName, <.<string>, .<string>?> assertion) { }
        public static ..GroupAssertion Group(this .<..RegexMatchCollection> continuation, int groupIndex, <.<string>, .<string>?> assertion) { }
        public static ..GroupAssertion Group(this .<..RegexMatchCollection> continuation, string groupName, <.<string>, .<string>?> assertion) { }
        public static ..MatchGroupAssertion Group(this .<..RegexMatch> source, int groupIndex, <.<string>, .<string>?> assertion) { }
        public static ..MatchGroupAssertion Group(this .<..RegexMatch> source, string groupName, <.<string>, .<string>?> assertion) { }
        public static ..MatchIndexAssertion Match(this .<..RegexMatchCollection> continuation, int index) { }
        public static ..MatchAssertion Match(this .<..RegexMatchCollection> continuation, int index, <.<..RegexMatch>, .<..RegexMatch>?> assertion) { }
        public static . Matches(this .<string> source, . regex, [.("regex")] string? regexExpression = null) { }
        public static . Matches(this .<string> source, string pattern, [.("pattern")] string? patternExpression = null) { }
    }
    public sealed class SByte_IsEven_Assertion : .<sbyte>
    {
        public SByte_IsEven_Assertion(.<sbyte> context) { }
        protected override .<.> CheckAsync(.<sbyte> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class SByte_IsNotZero_Assertion : .<sbyte>
    {
        public SByte_IsNotZero_Assertion(.<sbyte> context) { }
        protected override .<.> CheckAsync(.<sbyte> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class SByte_IsOdd_Assertion : .<sbyte>
    {
        public SByte_IsOdd_Assertion(.<sbyte> context) { }
        protected override .<.> CheckAsync(.<sbyte> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class SByte_IsZero_Assertion : .<sbyte>
    {
        public SByte_IsZero_Assertion(.<sbyte> context) { }
        protected override .<.> CheckAsync(.<sbyte> metadata) { }
        protected override string GetExpectation() { }
    }
    public static class SameReferenceAssertionExtensions
    {
        public static .<TValue> IsSameReferenceAs<TValue>(this .<TValue> source, object? expected, [.("expected")] string? expectedExpression = null) { }
    }
    public static class SbyteAssertions
    {
        public static ._IsEven_Assertion IsEven(this .<sbyte> source) { }
        public static ._IsNotZero_Assertion IsNotZero(this .<sbyte> source) { }
        public static ._IsOdd_Assertion IsOdd(this .<sbyte> source) { }
        public static ._IsZero_Assertion IsZero(this .<sbyte> source) { }
    }
    public static class ShortAssertions
    {
        public static .16_IsEven_Assertion IsEven(this .<short> source) { }
        public static .16_IsNotZero_Assertion IsNotZero(this .<short> source) { }
        public static .16_IsOdd_Assertion IsOdd(this .<short> source) { }
        public static .16_IsZero_Assertion IsZero(this .<short> source) { }
    }
    public static class SingleAssertionExtensions
    {
        public static . IsInfinity(this .<float> source) { }
        public static . IsNaN(this .<float> source) { }
        public static . IsNegativeInfinity(this .<float> source) { }
        public static . IsNotInfinity(this .<float> source) { }
        public static . IsNotNaN(this .<float> source) { }
        public static . IsNotNegativeInfinity(this .<float> source) { }
        public static . IsNotPositiveInfinity(this .<float> source) { }
        public static . IsPositiveInfinity(this .<float> source) { }
    }
    public static class StreamAssertionExtensions
    {
        public static . CanRead(this .<.Stream> source) { }
        public static . CanSeek(this .<.Stream> source) { }
        public static . CanTimeout(this .<.Stream> source) { }
        public static . CanWrite(this .<.Stream> source) { }
        public static . CannotRead(this .<.Stream> source) { }
        public static . CannotSeek(this .<.Stream> source) { }
        public static . CannotTimeout(this .<.Stream> source) { }
        public static . CannotWrite(this .<.Stream> source) { }
        public static ._IsAtEnd_Assertion IsAtEnd(this .<.Stream> source) { }
        public static ._IsAtStart_Assertion IsAtStart(this .<.Stream> source) { }
        public static ._IsEmpty_Assertion IsEmpty(this .<.Stream> source) { }
        public static ._IsNotEmpty_Assertion IsNotEmpty(this .<.Stream> source) { }
    }
    public class StreamCanReadAssertion : .<.Stream>
    {
        public StreamCanReadAssertion(.<.Stream> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<.Stream> metadata) { }
        protected override string GetExpectation() { }
    }
    public class StreamCanSeekAssertion : .<.Stream>
    {
        public StreamCanSeekAssertion(.<.Stream> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<.Stream> metadata) { }
        protected override string GetExpectation() { }
    }
    public class StreamCanTimeoutAssertion : .<.Stream>
    {
        public StreamCanTimeoutAssertion(.<.Stream> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<.Stream> metadata) { }
        protected override string GetExpectation() { }
    }
    public class StreamCanWriteAssertion : .<.Stream>
    {
        public StreamCanWriteAssertion(.<.Stream> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<.Stream> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class Stream_IsAtEnd_Assertion : .<.Stream>
    {
        public Stream_IsAtEnd_Assertion(.<.Stream> context) { }
        protected override .<.> CheckAsync(.<.Stream> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class Stream_IsAtStart_Assertion : .<.Stream>
    {
        public Stream_IsAtStart_Assertion(.<.Stream> context) { }
        protected override .<.> CheckAsync(.<.Stream> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class Stream_IsEmpty_Assertion : .<.Stream>
    {
        public Stream_IsEmpty_Assertion(.<.Stream> context) { }
        protected override .<.> CheckAsync(.<.Stream> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class Stream_IsNotEmpty_Assertion : .<.Stream>
    {
        public Stream_IsNotEmpty_Assertion(.<.Stream> context) { }
        protected override .<.> CheckAsync(.<.Stream> metadata) { }
        protected override string GetExpectation() { }
    }
    public static class StringBuilderAssertionExtensions
    {
        public static ._HasExcessCapacity_Assertion HasExcessCapacity(this .<.StringBuilder> source) { }
        public static ._IsEmpty_Assertion IsEmpty(this .<.StringBuilder> source) { }
        public static ._IsNotEmpty_Assertion IsNotEmpty(this .<.StringBuilder> source) { }
    }
    public sealed class StringBuilder_HasExcessCapacity_Assertion : .<.StringBuilder>
    {
        public StringBuilder_HasExcessCapacity_Assertion(.<.StringBuilder> context) { }
        protected override .<.> CheckAsync(.<.StringBuilder> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class StringBuilder_IsEmpty_Assertion : .<.StringBuilder>
    {
        public StringBuilder_IsEmpty_Assertion(.<.StringBuilder> context) { }
        protected override .<.> CheckAsync(.<.StringBuilder> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class StringBuilder_IsNotEmpty_Assertion : .<.StringBuilder>
    {
        public StringBuilder_IsNotEmpty_Assertion(.<.StringBuilder> context) { }
        protected override .<.> CheckAsync(.<.StringBuilder> metadata) { }
        protected override string GetExpectation() { }
    }
    public static class StringContainsAssertionExtensions
    {
        public static . Contains(this .<string> source, string expected, [.("expected")] string? expectedExpression = null) { }
        public static . Contains(this .<string> source, string expected,  comparison, [.("expected")] string? expectedExpression = null, [.("comparison")] string? comparisonExpression = null) { }
    }
    public static class StringDoesNotContainAssertionExtensions
    {
        public static . DoesNotContain(this .<string> source, string expected, [.("expected")] string? expectedExpression = null) { }
        public static . DoesNotContain(this .<string> source, string expected,  comparison, [.("expected")] string? expectedExpression = null, [.("comparison")] string? comparisonExpression = null) { }
    }
    public static class StringDoesNotMatchAssertionExtensions
    {
        public static . DoesNotMatch(this .<string> source, . regex, [.("regex")] string? regexExpression = null) { }
        public static . DoesNotMatch(this .<string> source, string pattern, [.("pattern")] string? patternExpression = null) { }
    }
    public static class StringEndsWithAssertionExtensions
    {
        public static . EndsWith(this .<string> source, string expected, [.("expected")] string? expectedExpression = null) { }
        public static . EndsWith(this .<string> source, string expected,  comparison, [.("expected")] string? expectedExpression = null, [.("comparison")] string? comparisonExpression = null) { }
    }
    public static class StringEqualsAssertionExtensions
    {
        public static .<TActual> IsEqualTo<TActual>(this .<TActual> source, string? expected, [.("expected")] string? expectedExpression = null) { }
        public static .<TActual> IsEqualTo<TActual>(this .<TActual> source, string? expected,  comparison, [.("expected")] string? expectedExpression = null, [.("comparison")] string? comparisonExpression = null) { }
    }
    public static class StringIsEmptyAssertionExtensions
    {
        public static . IsEmpty(this .<string> source) { }
    }
    public static class StringIsNotEmptyAssertionExtensions
    {
        public static . IsNotEmpty(this .<string> source) { }
    }
    public class StringIsNullOrEmptyWithStringAssertion : .<string>
    {
        public StringIsNullOrEmptyWithStringAssertion(.<string> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<string> metadata) { }
        protected override string GetExpectation() { }
    }
    public class StringIsNullOrWhiteSpaceWithStringAssertion : .<string>
    {
        public StringIsNullOrWhiteSpaceWithStringAssertion(.<string> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<string> metadata) { }
        protected override string GetExpectation() { }
    }
    public static class StringStartsWithAssertionExtensions
    {
        public static . StartsWith(this .<string> source, string expected, [.("expected")] string? expectedExpression = null) { }
        public static . StartsWith(this .<string> source, string expected,  comparison, [.("expected")] string? expectedExpression = null, [.("comparison")] string? comparisonExpression = null) { }
    }
    public static class StringStaticMethodAssertions
    {
        public static . IsNotNullOrEmpty(this .<string> source) { }
        public static . IsNotNullOrWhiteSpace(this .<string> source) { }
        public static . IsNullOrEmpty(this .<string> source) { }
        public static . IsNullOrWhiteSpace(this .<string> source) { }
    }
    public sealed class String_IsNotValidJson_Assertion : .<string>
    {
        public String_IsNotValidJson_Assertion(.<string> context) { }
        protected override .<.> CheckAsync(.<string> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class String_IsValidJsonArray_Assertion : .<string>
    {
        public String_IsValidJsonArray_Assertion(.<string> context) { }
        protected override .<.> CheckAsync(.<string> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class String_IsValidJsonObject_Assertion : .<string>
    {
        public String_IsValidJsonObject_Assertion(.<string> context) { }
        protected override .<.> CheckAsync(.<string> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class String_IsValidJson_Assertion : .<string>
    {
        public String_IsValidJson_Assertion(.<string> context) { }
        protected override .<.> CheckAsync(.<string> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class T_IsIn_IEnumerableT_Assertion<T> : .<T>
    {
        public T_IsIn_IEnumerableT_Assertion(.<T> context, .<T> collection) { }
        protected override .<.> CheckAsync(.<T> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class T_IsIn__Assertion<T> : .<T>
    {
        public T_IsIn__Assertion(.<T> context, T[] collection) { }
        protected override .<.> CheckAsync(.<T> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class T_IsNotIn_IEnumerableT_Assertion<T> : .<T>
    {
        public T_IsNotIn_IEnumerableT_Assertion(.<T> context, .<T> collection) { }
        protected override .<.> CheckAsync(.<T> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class T_IsNotIn__Assertion<T> : .<T>
    {
        public T_IsNotIn__Assertion(.<T> context, T[] collection) { }
        protected override .<.> CheckAsync(.<T> metadata) { }
        protected override string GetExpectation() { }
    }
    public static class TaskAssertionExtensions
    {
        public static .<TTask> IsCanceled<TTask>(this .<TTask> source)
            where TTask : . { }
        public static .<TTask> IsCompleted<TTask>(this .<TTask> source)
            where TTask : . { }
        public static .<TTask> IsFaulted<TTask>(this .<TTask> source)
            where TTask : . { }
        public static .<TTask> IsNotCanceled<TTask>(this .<TTask> source)
            where TTask : . { }
        public static .<TTask> IsNotCompleted<TTask>(this .<TTask> source)
            where TTask : . { }
        public static .<TTask> IsNotFaulted<TTask>(this .<TTask> source)
            where TTask : . { }
    }
    public class TaskIsCanceledAssertion<TTask> : .<TTask>
        where TTask : .
    {
        public TaskIsCanceledAssertion(.<TTask> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<TTask> metadata) { }
        protected override string GetExpectation() { }
    }
    public class TaskIsCompletedAssertion<TTask> : .<TTask>
        where TTask : .
    {
        public TaskIsCompletedAssertion(.<TTask> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<TTask> metadata) { }
        protected override string GetExpectation() { }
    }
    public class TaskIsFaultedAssertion<TTask> : .<TTask>
        where TTask : .
    {
        public TaskIsFaultedAssertion(.<TTask> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<TTask> metadata) { }
        protected override string GetExpectation() { }
    }
    public static class ThreadAssertionExtensions
    {
        public static . IsAlive(this .<.Thread> source) { }
        public static . IsBackground(this .<.Thread> source) { }
        public static . IsNotAlive(this .<.Thread> source) { }
        public static . IsNotBackground(this .<.Thread> source) { }
        public static . IsNotThreadPoolThread(this .<.Thread> source) { }
        public static . IsThreadPoolThread(this .<.Thread> source) { }
    }
    public class ThreadIsAliveAssertion : .<.Thread>
    {
        public ThreadIsAliveAssertion(.<.Thread> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<.Thread> metadata) { }
        protected override string GetExpectation() { }
    }
    public class ThreadIsBackgroundAssertion : .<.Thread>
    {
        public ThreadIsBackgroundAssertion(.<.Thread> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<.Thread> metadata) { }
        protected override string GetExpectation() { }
    }
    public class ThreadIsThreadPoolThreadAssertion : .<.Thread>
    {
        public ThreadIsThreadPoolThreadAssertion(.<.Thread> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<.Thread> metadata) { }
        protected override string GetExpectation() { }
    }
    public static class TimeSpanAssertionExtensions
    {
        public static ._IsNegative_Assertion IsNegative(this .<> source) { }
        public static ._IsNonNegative_Assertion IsNonNegative(this .<> source) { }
        public static ._IsNonPositive_Assertion IsNonPositive(this .<> source) { }
        public static ._IsNotZero_Assertion IsNotZero(this .<> source) { }
        public static ._IsPositive_Assertion IsPositive(this .<> source) { }
        public static ._IsZero_Assertion IsZero(this .<> source) { }
    }
    public static class TimeSpanEqualsAssertionExtensions
    {
        public static . IsEqualTo(this .<> source,  expected, [.("expected")] string? expectedExpression = null) { }
    }
    public sealed class TimeSpan_IsNegative_Assertion : .<>
    {
        public TimeSpan_IsNegative_Assertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class TimeSpan_IsNonNegative_Assertion : .<>
    {
        public TimeSpan_IsNonNegative_Assertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class TimeSpan_IsNonPositive_Assertion : .<>
    {
        public TimeSpan_IsNonPositive_Assertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class TimeSpan_IsNotZero_Assertion : .<>
    {
        public TimeSpan_IsNotZero_Assertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class TimeSpan_IsPositive_Assertion : .<>
    {
        public TimeSpan_IsPositive_Assertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class TimeSpan_IsZero_Assertion : .<>
    {
        public TimeSpan_IsZero_Assertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public static class TimeZoneInfoAssertionExtensions
    {
        public static . DoesNotSupportDaylightSavingTime(this .<> source) { }
        public static . SupportsDaylightSavingTime(this .<> source) { }
    }
    public class TimeZoneInfoSupportsDaylightSavingTimeAssertion : .<>
    {
        public TimeZoneInfoSupportsDaylightSavingTimeAssertion(.<> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public static class TypeAssertionExtensions
    {
        public static . ContainsGenericParameters(this .<> source) { }
        public static . DoesNotContainGenericParameters(this .<> source) { }
        public static . IsAbstract(this .<> source) { }
        public static . IsArray(this .<> source) { }
        public static . IsByRef(this .<> source) { }
        public static . IsCOMObject(this .<> source) { }
        public static . IsClass(this .<> source) { }
        public static . IsConstructedGenericType(this .<> source) { }
        public static . IsEnum(this .<> source) { }
        public static . IsGenericType(this .<> source) { }
        public static . IsGenericTypeDefinition(this .<> source) { }
        public static . IsInterface(this .<> source) { }
        public static . IsNested(this .<> source) { }
        public static . IsNestedAssembly(this .<> source) { }
        public static . IsNestedFamily(this .<> source) { }
        public static . IsNestedPrivate(this .<> source) { }
        public static . IsNestedPublic(this .<> source) { }
        public static . IsNotAbstract(this .<> source) { }
        public static . IsNotArray(this .<> source) { }
        public static . IsNotByRef(this .<> source) { }
        public static . IsNotCOMObject(this .<> source) { }
        public static . IsNotClass(this .<> source) { }
        public static . IsNotConstructedGenericType(this .<> source) { }
        public static . IsNotEnum(this .<> source) { }
        public static . IsNotGenericType(this .<> source) { }
        public static . IsNotGenericTypeDefinition(this .<> source) { }
        public static . IsNotInterface(this .<> source) { }
        public static . IsNotNested(this .<> source) { }
        public static . IsNotNestedAssembly(this .<> source) { }
        public static . IsNotNestedFamily(this .<> source) { }
        public static . IsNotNestedPrivate(this .<> source) { }
        public static . IsNotNestedPublic(this .<> source) { }
        public static . IsNotPointer(this .<> source) { }
        public static . IsNotPrimitive(this .<> source) { }
        public static . IsNotPublic(this .<> source) { }
        public static . IsNotSealed(this .<> source) { }
        public static . IsNotSerializable(this .<> source) { }
        public static . IsNotValueType(this .<> source) { }
        public static . IsNotVisible(this .<> source) { }
        public static . IsPointer(this .<> source) { }
        public static . IsPrimitive(this .<> source) { }
        public static . IsPublic(this .<> source) { }
        public static . IsSealed(this .<> source) { }
        public static . IsSerializable(this .<> source) { }
        public static . IsValueType(this .<> source) { }
        public static . IsVisible(this .<> source) { }
    }
    public class TypeContainsGenericParametersAssertion : .<>
    {
        public TypeContainsGenericParametersAssertion(.<> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public class TypeIsAbstractAssertion : .<>
    {
        public TypeIsAbstractAssertion(.<> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public class TypeIsArrayAssertion : .<>
    {
        public TypeIsArrayAssertion(.<> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public class TypeIsByRefAssertion : .<>
    {
        public TypeIsByRefAssertion(.<> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public class TypeIsCOMObjectAssertion : .<>
    {
        public TypeIsCOMObjectAssertion(.<> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public class TypeIsClassAssertion : .<>
    {
        public TypeIsClassAssertion(.<> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public class TypeIsConstructedGenericTypeAssertion : .<>
    {
        public TypeIsConstructedGenericTypeAssertion(.<> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public class TypeIsEnumAssertion : .<>
    {
        public TypeIsEnumAssertion(.<> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public class TypeIsGenericTypeAssertion : .<>
    {
        public TypeIsGenericTypeAssertion(.<> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public class TypeIsGenericTypeDefinitionAssertion : .<>
    {
        public TypeIsGenericTypeDefinitionAssertion(.<> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public class TypeIsInterfaceAssertion : .<>
    {
        public TypeIsInterfaceAssertion(.<> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public class TypeIsNestedAssemblyAssertion : .<>
    {
        public TypeIsNestedAssemblyAssertion(.<> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public class TypeIsNestedAssertion : .<>
    {
        public TypeIsNestedAssertion(.<> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public class TypeIsNestedFamilyAssertion : .<>
    {
        public TypeIsNestedFamilyAssertion(.<> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public class TypeIsNestedPrivateAssertion : .<>
    {
        public TypeIsNestedPrivateAssertion(.<> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public class TypeIsNestedPublicAssertion : .<>
    {
        public TypeIsNestedPublicAssertion(.<> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public class TypeIsPointerAssertion : .<>
    {
        public TypeIsPointerAssertion(.<> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public class TypeIsPrimitiveAssertion : .<>
    {
        public TypeIsPrimitiveAssertion(.<> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public class TypeIsPublicAssertion : .<>
    {
        public TypeIsPublicAssertion(.<> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public class TypeIsSealedAssertion : .<>
    {
        public TypeIsSealedAssertion(.<> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public class TypeIsSerializableAssertion : .<>
    {
        public TypeIsSerializableAssertion(.<> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public class TypeIsValueTypeAssertion : .<>
    {
        public TypeIsValueTypeAssertion(.<> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public class TypeIsVisibleAssertion : .<>
    {
        public TypeIsVisibleAssertion(.<> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class UInt16_IsEven_Assertion : .<ushort>
    {
        public UInt16_IsEven_Assertion(.<ushort> context) { }
        protected override .<.> CheckAsync(.<ushort> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class UInt16_IsNotZero_Assertion : .<ushort>
    {
        public UInt16_IsNotZero_Assertion(.<ushort> context) { }
        protected override .<.> CheckAsync(.<ushort> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class UInt16_IsOdd_Assertion : .<ushort>
    {
        public UInt16_IsOdd_Assertion(.<ushort> context) { }
        protected override .<.> CheckAsync(.<ushort> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class UInt16_IsZero_Assertion : .<ushort>
    {
        public UInt16_IsZero_Assertion(.<ushort> context) { }
        protected override .<.> CheckAsync(.<ushort> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class UInt32_IsEven_Assertion : .<uint>
    {
        public UInt32_IsEven_Assertion(.<uint> context) { }
        protected override .<.> CheckAsync(.<uint> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class UInt32_IsNotZero_Assertion : .<uint>
    {
        public UInt32_IsNotZero_Assertion(.<uint> context) { }
        protected override .<.> CheckAsync(.<uint> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class UInt32_IsOdd_Assertion : .<uint>
    {
        public UInt32_IsOdd_Assertion(.<uint> context) { }
        protected override .<.> CheckAsync(.<uint> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class UInt32_IsZero_Assertion : .<uint>
    {
        public UInt32_IsZero_Assertion(.<uint> context) { }
        protected override .<.> CheckAsync(.<uint> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class UInt64_IsEven_Assertion : .<ulong>
    {
        public UInt64_IsEven_Assertion(.<ulong> context) { }
        protected override .<.> CheckAsync(.<ulong> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class UInt64_IsNotZero_Assertion : .<ulong>
    {
        public UInt64_IsNotZero_Assertion(.<ulong> context) { }
        protected override .<.> CheckAsync(.<ulong> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class UInt64_IsOdd_Assertion : .<ulong>
    {
        public UInt64_IsOdd_Assertion(.<ulong> context) { }
        protected override .<.> CheckAsync(.<ulong> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class UInt64_IsZero_Assertion : .<ulong>
    {
        public UInt64_IsZero_Assertion(.<ulong> context) { }
        protected override .<.> CheckAsync(.<ulong> metadata) { }
        protected override string GetExpectation() { }
    }
    public static class UintAssertions
    {
        public static .32_IsEven_Assertion IsEven(this .<uint> source) { }
        public static .32_IsNotZero_Assertion IsNotZero(this .<uint> source) { }
        public static .32_IsOdd_Assertion IsOdd(this .<uint> source) { }
        public static .32_IsZero_Assertion IsZero(this .<uint> source) { }
    }
    public static class UlongAssertions
    {
        public static .64_IsEven_Assertion IsEven(this .<ulong> source) { }
        public static .64_IsNotZero_Assertion IsNotZero(this .<ulong> source) { }
        public static .64_IsOdd_Assertion IsOdd(this .<ulong> source) { }
        public static .64_IsZero_Assertion IsZero(this .<ulong> source) { }
    }
    public static class UriAssertionExtensions
    {
        public static . IsAbsoluteUri(this .<> source) { }
        public static . IsDefaultPort(this .<> source) { }
        public static . IsFile(this .<> source) { }
        public static . IsLoopback(this .<> source) { }
        public static . IsNotAbsoluteUri(this .<> source) { }
        public static . IsNotDefaultPort(this .<> source) { }
        public static . IsNotFile(this .<> source) { }
        public static . IsNotLoopback(this .<> source) { }
        public static . IsNotUnc(this .<> source) { }
        public static . IsNotUserEscaped(this .<> source) { }
        public static . IsUnc(this .<> source) { }
        public static . UserEscaped(this .<> source) { }
    }
    public class UriIsAbsoluteUriAssertion : .<>
    {
        public UriIsAbsoluteUriAssertion(.<> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public class UriIsDefaultPortAssertion : .<>
    {
        public UriIsDefaultPortAssertion(.<> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public class UriIsFileAssertion : .<>
    {
        public UriIsFileAssertion(.<> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public class UriIsLoopbackAssertion : .<>
    {
        public UriIsLoopbackAssertion(.<> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public class UriIsUncAssertion : .<>
    {
        public UriIsUncAssertion(.<> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public class UriUserEscapedAssertion : .<>
    {
        public UriUserEscapedAssertion(.<> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public static class UshortAssertions
    {
        public static .16_IsEven_Assertion IsEven(this .<ushort> source) { }
        public static .16_IsNotZero_Assertion IsNotZero(this .<ushort> source) { }
        public static .16_IsOdd_Assertion IsOdd(this .<ushort> source) { }
        public static .16_IsZero_Assertion IsZero(this .<ushort> source) { }
    }
    public static class ValueTaskAssertionExtensions
    {
        public static . IsCanceled(this .<.> source) { }
        public static . IsCompleted(this .<.> source) { }
        public static . IsCompletedSuccessfully(this .<.> source) { }
        public static . IsFaulted(this .<.> source) { }
        public static . IsNotCanceled(this .<.> source) { }
        public static . IsNotCompleted(this .<.> source) { }
        public static . IsNotCompletedSuccessfully(this .<.> source) { }
        public static . IsNotFaulted(this .<.> source) { }
    }
    public class ValueTaskIsCanceledAssertion : .<.>
    {
        public ValueTaskIsCanceledAssertion(.<.> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<.> metadata) { }
        protected override string GetExpectation() { }
    }
    public class ValueTaskIsCompletedAssertion : .<.>
    {
        public ValueTaskIsCompletedAssertion(.<.> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<.> metadata) { }
        protected override string GetExpectation() { }
    }
    public class ValueTaskIsCompletedSuccessfullyAssertion : .<.>
    {
        public ValueTaskIsCompletedSuccessfullyAssertion(.<.> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<.> metadata) { }
        protected override string GetExpectation() { }
    }
    public class ValueTaskIsFaultedAssertion : .<.>
    {
        public ValueTaskIsFaultedAssertion(.<.> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<.> metadata) { }
        protected override string GetExpectation() { }
    }
    public static class VersionAssertionExtensions
    {
        public static ._HasBuildNumber_Assertion HasBuildNumber(this .<> source) { }
        public static ._HasNoBuildNumber_Assertion HasNoBuildNumber(this .<> source) { }
        public static ._HasNoRevisionNumber_Assertion HasNoRevisionNumber(this .<> source) { }
        public static ._HasRevisionNumber_Assertion HasRevisionNumber(this .<> source) { }
        public static ._IsMajorVersion_Assertion IsMajorVersion(this .<> source) { }
        public static ._IsNotMajorVersion_Assertion IsNotMajorVersion(this .<> source) { }
    }
    public sealed class Version_HasBuildNumber_Assertion : .<>
    {
        public Version_HasBuildNumber_Assertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class Version_HasNoBuildNumber_Assertion : .<>
    {
        public Version_HasNoBuildNumber_Assertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class Version_HasNoRevisionNumber_Assertion : .<>
    {
        public Version_HasNoRevisionNumber_Assertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class Version_HasRevisionNumber_Assertion : .<>
    {
        public Version_HasRevisionNumber_Assertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class Version_IsMajorVersion_Assertion : .<>
    {
        public Version_IsMajorVersion_Assertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class Version_IsNotMajorVersion_Assertion : .<>
    {
        public Version_IsNotMajorVersion_Assertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public static class WeakReferenceAssertionExtensions
    {
        public static . DoesNotTrackResurrection(this .<> source) { }
        public static . IsAlive(this .<> source) { }
        public static . IsNotAlive(this .<> source) { }
        public static . TrackResurrection(this .<> source) { }
    }
    public class WeakReferenceIsAliveAssertion : .<>
    {
        public WeakReferenceIsAliveAssertion(.<> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public class WeakReferenceTrackResurrectionAssertion : .<>
    {
        public WeakReferenceTrackResurrectionAssertion(.<> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class _IsEmpty_Assertion<T> : .<T[]>
    {
        public _IsEmpty_Assertion(.<T[]> context) { }
        protected override .<.> CheckAsync(.<T[]> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class _IsNotEmpty_Assertion<T> : .<T[]>
    {
        public _IsNotEmpty_Assertion(.<T[]> context) { }
        protected override .<.> CheckAsync(.<T[]> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class _IsNotSingleElement_Assertion<T> : .<T[]>
    {
        public _IsNotSingleElement_Assertion(.<T[]> context) { }
        protected override .<.> CheckAsync(.<T[]> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class _IsSingleElement_Assertion<T> : .<T[]>
    {
        public _IsSingleElement_Assertion(.<T[]> context) { }
        protected override .<.> CheckAsync(.<T[]> metadata) { }
        protected override string GetExpectation() { }
    }
}
namespace .Sources
{
    public class AsyncDelegateAssertion : ., .<object?>, .<.>, .<object?>
    {
        public AsyncDelegateAssertion(<.> action, string? expression) { }
        public .<object?> Context { get; }
        public .<TTarget, object?> IsAssignableTo<TTarget>() { }
        public .<.> IsCanceled() { }
        public .<.> IsCompleted() { }
        public .<.> IsFaulted() { }
        public .<TTarget, object?> IsNotAssignableTo<TTarget>() { }
        public .<.> IsNotCanceled() { }
        public .<.> IsNotCompleted() { }
        public .<.> IsNotFaulted() { }
        public .<object?, TExpected> IsNotTypeOf<TExpected>() { }
        public .<object?, TExpected> IsTypeOf<TExpected>() { }
        public .<?> Throws( exceptionType) { }
        public .<TException> Throws<TException>()
            where TException :  { }
        public .<TException> ThrowsExactly<TException>()
            where TException :  { }
        public .<TException> ThrowsExactly<TException>(string parameterName)
            where TException :  { }
    }
    public class AsyncFuncAssertion<TValue> : ., .<TValue>, .<TValue>
    {
        public AsyncFuncAssertion(<.<TValue?>> func, string? expression) { }
        public .<TValue> Context { get; }
        public .<TTarget, TValue> IsAssignableTo<TTarget>() { }
        public .<TTarget, TValue> IsNotAssignableTo<TTarget>() { }
        public .<TValue, TExpected> IsNotTypeOf<TExpected>() { }
        public .<TValue, TExpected> IsTypeOf<TExpected>() { }
        public .<TException> Throws<TException>()
            where TException :  { }
        public .<TException> ThrowsExactly<TException>()
            where TException :  { }
    }
    public class AsyncFuncCollectionAssertion<TItem> : .<.<TItem>, TItem>, ., .<.<TItem>>, .<.<TItem>>
    {
        public AsyncFuncCollectionAssertion(<.<.<TItem>?>> func, string? expression) { }
        public .<TException> Throws<TException>()
            where TException :  { }
        public .<TException> ThrowsExactly<TException>()
            where TException :  { }
    }
    public abstract class CollectionAssertionBase<TCollection, TItem> : .<TCollection>, ., .<TCollection>
        where TCollection : .<TItem>
    {
        protected CollectionAssertionBase(.<TCollection> context) { }
        public new .<TCollection, TItem> And { get; }
        public new .<TCollection, TItem> Or { get; }
        public .<TCollection, TItem> All() { }
        public .<TCollection, TItem> All(<TItem, bool> predicate, [.("predicate")] string? expression = null) { }
        public .<TCollection, TItem> Any(<TItem, bool> predicate, [.("predicate")] string? expression = null) { }
        public .<TCollection, TItem> Contains(<TItem, bool> predicate, [.("predicate")] string? expression = null) { }
        public .<TCollection, TItem> Contains(TItem expected, [.("expected")] string? expression = null) { }
        public .<TCollection, TItem> ContainsOnly(<TItem, bool> predicate, [.("predicate")] string? expression = null) { }
        public .<TCollection, TItem> Count() { }
        public .<TCollection, TItem> Count(<.<TItem>, .<TItem>?> itemAssertion, [.("itemAssertion")] string? expression = null) { }
        public .<TCollection, TItem> Count(<.<int>, .<int>?> countAssertion, [.("countAssertion")] string? expression = null) { }
        public .<TCollection, TItem> DoesNotContain(<TItem, bool> predicate, [.("predicate")] string? expression = null) { }
        public .<TCollection, TItem> DoesNotContain(TItem expected, [.("expected")] string? expression = null) { }
        protected override string GetExpectation() { }
        [("Use Count() instead, which provides all numeric assertion methods. Example: Asser" +
            "(list).Count().IsGreaterThan(5)")]
        public ..CountWrapper<TCollection, TItem> HasCount() { }
        [("Use Count().IsEqualTo(expectedCount) instead.")]
        public .<TCollection, TItem> HasCount(int expectedCount, [.("expectedCount")] string? expression = null) { }
        public .<TCollection, TItem> HasDistinctItems() { }
        public .<TCollection, TItem> HasSingleItem() { }
        public .<TTarget, TCollection> IsAssignableTo<TTarget>() { }
        public .<TCollection, TItem> IsEmpty() { }
        public .<TCollection, TItem> IsInDescendingOrder() { }
        public .<TCollection, TItem> IsInOrder() { }
        public .<TTarget, TCollection> IsNotAssignableTo<TTarget>() { }
        public .<TCollection, TItem> IsNotEmpty() { }
        public .<TCollection, TExpected> IsNotTypeOf<TExpected>() { }
        public .<TCollection, TItem, TKey> IsOrderedBy<TKey>(<TItem, TKey> keySelector, [.("keySelector")] string? expression = null) { }
        public .<TCollection, TItem, TKey> IsOrderedBy<TKey>(<TItem, TKey> keySelector, .<TKey>? comparer, [.("keySelector")] string? selectorExpression = null, [.("comparer")] string? comparerExpression = null) { }
        public .<TCollection, TItem, TKey> IsOrderedByDescending<TKey>(<TItem, TKey> keySelector, [.("keySelector")] string? expression = null) { }
        public .<TCollection, TItem, TKey> IsOrderedByDescending<TKey>(<TItem, TKey> keySelector, .<TKey>? comparer, [.("keySelector")] string? selectorExpression = null, [.("comparer")] string? comparerExpression = null) { }
        public .<TCollection, TExpected> IsTypeOf<TExpected>() { }
    }
    public class CollectionAssertion<TItem> : .<.<TItem>, TItem>
    {
        public CollectionAssertion(.<TItem> value, string? expression) { }
    }
    public class DelegateAssertion : ., .<object?>, .<object?>
    {
        public DelegateAssertion( action, string? expression) { }
        public .<object?> Context { get; }
        public .<TTarget, object?> IsAssignableTo<TTarget>() { }
        public .<TTarget, object?> IsNotAssignableTo<TTarget>() { }
        public .<object?, TExpected> IsNotTypeOf<TExpected>() { }
        public .<object?, TExpected> IsTypeOf<TExpected>() { }
        public .<TException> Throws<TException>()
            where TException :  { }
        public .<TException> ThrowsExactly<TException>()
            where TException :  { }
    }
    public abstract class DictionaryAssertionBase<TDictionary, TKey, TValue> : .<TDictionary, .<TKey, TValue>>
        where TDictionary : .<TKey, TValue>
        where TKey :  notnull
    {
        protected DictionaryAssertionBase(.<TDictionary> context) { }
        public new .<TDictionary, TKey, TValue> And { get; }
        public new .<TDictionary, TKey, TValue> Or { get; }
        public .<TDictionary, TKey, TValue> AllKeys(<TKey, bool> predicate, [.("predicate")] string? expression = null) { }
        public .<TDictionary, TKey, TValue> AllValues(<TValue, bool> predicate, [.("predicate")] string? expression = null) { }
        public .<TDictionary, TKey, TValue> AnyKey(<TKey, bool> predicate, [.("predicate")] string? expression = null) { }
        public .<TDictionary, TKey, TValue> AnyValue(<TValue, bool> predicate, [.("predicate")] string? expression = null) { }
        public .<TDictionary, TKey, TValue> ContainsKey(TKey expectedKey, [.("expectedKey")] string? expression = null) { }
        public .<TDictionary, TKey, TValue> ContainsKey(TKey expectedKey, .<TKey>? comparer, [.("expectedKey")] string? keyExpression = null, [.("comparer")] string? comparerExpression = null) { }
        public .<TDictionary, TKey, TValue> ContainsKeyWithValue(TKey expectedKey, TValue expectedValue, [.("expectedKey")] string? keyExpression = null, [.("expectedValue")] string? valueExpression = null) { }
        public .<TDictionary, TKey, TValue> ContainsValue(TValue expectedValue, [.("expectedValue")] string? expression = null) { }
        public .<TDictionary, TKey, TValue> DoesNotContainKey(TKey expectedKey, [.("expectedKey")] string? expression = null) { }
        public .<TDictionary, TKey, TValue> DoesNotContainValue(TValue expectedValue, [.("expectedValue")] string? expression = null) { }
        protected override string GetExpectation() { }
    }
    public class DictionaryAssertion<TKey, TValue> : .<.<TKey, TValue>, TKey, TValue>
        where TKey :  notnull
    {
        public DictionaryAssertion(.<TKey, TValue> value, string? expression) { }
    }
    public class FuncAssertion<TValue> : ., .<TValue>, .<TValue>
    {
        public FuncAssertion(<TValue?> func, string? expression) { }
        public .<TValue> Context { get; }
        public .<TTarget, TValue> IsAssignableTo<TTarget>() { }
        public .<TTarget, TValue> IsNotAssignableTo<TTarget>() { }
        public .<TValue, TExpected> IsNotTypeOf<TExpected>() { }
        public .<TValue, TExpected> IsTypeOf<TExpected>() { }
        public .<TException> Throws<TException>()
            where TException :  { }
        public .<TException> ThrowsExactly<TException>()
            where TException :  { }
    }
    public class FuncCollectionAssertion<TItem> : .<.<TItem>, TItem>, ., .<.<TItem>>, .<.<TItem>>
    {
        public FuncCollectionAssertion(<.<TItem>?> func, string? expression) { }
        public .<TException> Throws<TException>()
            where TException :  { }
        public .<TException> ThrowsExactly<TException>()
            where TException :  { }
    }
    public class HashSetAssertion<TItem> : .<.<TItem>, TItem>, ., .<.<TItem>>
    {
        public HashSetAssertion(.<TItem> value, string expression) { }
        protected override .<TItem> CreateSetAdapter(.<TItem> value) { }
    }
    public abstract class MutableDictionaryAssertionBase<TDictionary, TKey, TValue> : .<TDictionary, .<TKey, TValue>>
        where TDictionary : .<TKey, TValue>
        where TKey :  notnull
    {
        protected MutableDictionaryAssertionBase(.<TDictionary> context) { }
        public new .<TDictionary, TKey, TValue> And { get; }
        public new .<TDictionary, TKey, TValue> Or { get; }
        public .<TDictionary, TKey, TValue> AllKeys(<TKey, bool> predicate, [.("predicate")] string? expression = null) { }
        public .<TDictionary, TKey, TValue> AllValues(<TValue, bool> predicate, [.("predicate")] string? expression = null) { }
        public .<TDictionary, TKey, TValue> AnyKey(<TKey, bool> predicate, [.("predicate")] string? expression = null) { }
        public .<TDictionary, TKey, TValue> AnyValue(<TValue, bool> predicate, [.("predicate")] string? expression = null) { }
        public .<TDictionary, TKey, TValue> ContainsKey(TKey expectedKey, [.("expectedKey")] string? expression = null) { }
        public .<TDictionary, TKey, TValue> ContainsKey(TKey expectedKey, .<TKey>? comparer, [.("expectedKey")] string? keyExpression = null, [.("comparer")] string? comparerExpression = null) { }
        public .<TDictionary, TKey, TValue> ContainsKeyWithValue(TKey expectedKey, TValue expectedValue, [.("expectedKey")] string? keyExpression = null, [.("expectedValue")] string? valueExpression = null) { }
        public .<TDictionary, TKey, TValue> ContainsValue(TValue expectedValue, [.("expectedValue")] string? expression = null) { }
        public .<TDictionary, TKey, TValue> DoesNotContainKey(TKey expectedKey, [.("expectedKey")] string? expression = null) { }
        public .<TDictionary, TKey, TValue> DoesNotContainValue(TValue expectedValue, [.("expectedValue")] string? expression = null) { }
        protected override string GetExpectation() { }
    }
    public class MutableDictionaryAssertion<TKey, TValue> : .<.<TKey, TValue>, TKey, TValue>
        where TKey :  notnull
    {
        public MutableDictionaryAssertion(.<TKey, TValue> value, string? expression) { }
    }
    public class SetAndContinuation<TSet, TItem> : .<TSet, TItem>
        where TSet : .<TItem>
    {
        protected override .<TItem> CreateSetAdapter(TSet value) { }
    }
    public abstract class SetAssertionBase<TSet, TItem> : .<TSet, TItem>
        where TSet : .<TItem>
    {
        protected SetAssertionBase(.<TSet> context) { }
        public new .<TSet, TItem> And { get; }
        public new .<TSet, TItem> Or { get; }
        protected abstract .<TItem> CreateSetAdapter(TSet value);
        public .<TSet, TItem> DoesNotOverlap(.<TItem> other, [.("other")] string? expression = null) { }
        protected override string GetExpectation() { }
        public .<TSet, TItem> IsProperSubsetOf(.<TItem> other, [.("other")] string? expression = null) { }
        public .<TSet, TItem> IsProperSupersetOf(.<TItem> other, [.("other")] string? expression = null) { }
        public .<TSet, TItem> IsSubsetOf(.<TItem> other, [.("other")] string? expression = null) { }
        public .<TSet, TItem> IsSupersetOf(.<TItem> other, [.("other")] string? expression = null) { }
        public .<TSet, TItem> Overlaps(.<TItem> other, [.("other")] string? expression = null) { }
        public .<TSet, TItem> SetEquals(.<TItem> other, [.("other")] string? expression = null) { }
    }
    public class SetAssertion<TItem> : .<.<TItem>, TItem>, ., .<.<TItem>>
    {
        public SetAssertion(.<TItem> value, string expression) { }
        protected override .<TItem> CreateSetAdapter(.<TItem> value) { }
    }
    public class SetOrContinuation<TSet, TItem> : .<TSet, TItem>
        where TSet : .<TItem>
    {
        protected override .<TItem> CreateSetAdapter(TSet value) { }
    }
    public class TaskAssertion<TValue> : ., .<.<TValue?>>, .<TValue>, .<TValue>
    {
        public TaskAssertion(.<TValue?> task, string? expression) { }
        public .<TValue> Context { get; }
        public .<TTarget, TValue> IsAssignableTo<TTarget>() { }
        public .<.<TValue>> IsCanceled() { }
        public .<.<TValue>> IsCompleted() { }
        public .<.<TValue>> IsFaulted() { }
        public .<TTarget, TValue> IsNotAssignableTo<TTarget>() { }
        public .<.<TValue>> IsNotCanceled() { }
        public .<.<TValue>> IsNotCompleted() { }
        public .<.<TValue>> IsNotFaulted() { }
        public .<TValue, TExpected> IsNotTypeOf<TExpected>() { }
        public .<TValue, TExpected> IsTypeOf<TExpected>() { }
        public .<TException> Throws<TException>()
            where TException :  { }
        public .<TException> ThrowsExactly<TException>()
            where TException :  { }
    }
    public class ValueAssertion<TValue> : ., .<TValue>
    {
        protected ValueAssertion(.<TValue> context) { }
        public ValueAssertion(TValue? value, string? expression) { }
        public .<TValue> Context { get; }
        public .<TTarget, TValue> IsAssignableTo<TTarget>() { }
        public .<TTarget, TValue> IsNotAssignableTo<TTarget>() { }
        public .<TValue, TExpected> IsNotTypeOf<TExpected>() { }
        public .<TValue, TExpected> IsTypeOf<TExpected>() { }
    }
}