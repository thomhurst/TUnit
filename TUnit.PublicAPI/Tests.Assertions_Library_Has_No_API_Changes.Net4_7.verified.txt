[assembly: .(".NETStandard,Version=v2.0", FrameworkDisplayName=".NET Standard 2.0")]
namespace 
{
    public static class Assert
    {
        public static void Fail(string reason) { }
        public static  Multiple() { }
        public static . That( value, [.("value")] string? doNotPopulateThisValue = null) { }
        public static .<.<object>> That(.IEnumerable enumerable, [.("enumerable")] string? doNotPopulateThisValue = null) { }
        public static . That(<.> value, [.("value")] string? doNotPopulateThisValue = null) { }
        public static . That(. value, [.("value")] string? doNotPopulateThisValue = null) { }
        public static . That(. value, [.("value")] string? doNotPopulateThisValue = null) { }
        public static .<TActual> That<TActual>(<.<TActual>> value, [.("value")] string? doNotPopulateThisValue = null) { }
        public static .<TActual> That<TActual>(<TActual> value, [.("value")] string? doNotPopulateThisValue = null) { }
        public static .<TActual> That<TActual>(.<TActual> value, [.("value")] string? doNotPopulateThisValue = null) { }
        public static .<TActual> That<TActual>(.<TActual> value, [.("value")] string? doNotPopulateThisValue = null) { }
        public static .<TActual> That<TActual>(TActual value, [.("value")] string? doNotPopulateThisValue = null) { }
        public static  Throws( @delegate, [.("delegate")] string? doNotPopulateThisValue = null) { }
        public static  Throws( type,  @delegate, [.("delegate")] string? doNotPopulateThisValue = null) { }
        public static TException Throws<TException>( @delegate, [.("delegate")] string? doNotPopulateThisValue = null)
            where TException :  { }
        public static TException Throws<TException>(string parameterName,  @delegate, [.("delegate")] string? doNotPopulateThisValue = null)
            where TException :  { }
        public static ..ThrowsException<object?, > ThrowsAsync(<.> @delegate, [.("delegate")] string? doNotPopulateThisValue = null) { }
        public static ..ThrowsException<object?, > ThrowsAsync(. @delegate, [.("delegate")] string? doNotPopulateThisValue = null) { }
        public static ..ThrowsException<object?, > ThrowsAsync(. @delegate, [.("delegate")] string? doNotPopulateThisValue = null) { }
        public static ..ThrowsException<object?, > ThrowsAsync( type, <.> @delegate, [.("delegate")] string? doNotPopulateThisValue = null) { }
        public static ..ThrowsException<object?, > ThrowsAsync( type, . @delegate, [.("delegate")] string? doNotPopulateThisValue = null) { }
        public static ..ThrowsException<object?, > ThrowsAsync( type, . @delegate, [.("delegate")] string? doNotPopulateThisValue = null) { }
        public static ..ThrowsException<object?, TException> ThrowsAsync<TException>(<.> @delegate, [.("delegate")] string? doNotPopulateThisValue = null)
            where TException :  { }
        public static ..ThrowsException<object?, TException> ThrowsAsync<TException>(. @delegate, [.("delegate")] string? doNotPopulateThisValue = null)
            where TException :  { }
        public static ..ThrowsException<object?, TException> ThrowsAsync<TException>(. @delegate, [.("delegate")] string? doNotPopulateThisValue = null)
            where TException :  { }
        public static ..ThrowsException<object?, TException> ThrowsAsync<TException>(string parameterName, <.> @delegate, [.("delegate")] string? doNotPopulateThisValue = null, [.("parameterName")] string? doNotPopulateThisValue2 = null)
            where TException :  { }
        public static ..ThrowsException<object?, TException> ThrowsAsync<TException>(string parameterName, . @delegate, [.("delegate")] string? doNotPopulateThisValue = null, [.("parameterName")] string? doNotPopulateThisValue2 = null)
            where TException :  { }
        public static ..ThrowsException<object?, TException> ThrowsAsync<TException>(string parameterName, . @delegate, [.("delegate")] string? doNotPopulateThisValue = null, [.("parameterName")] string? doNotPopulateThisValue2 = null)
            where TException :  { }
    }
    public readonly struct AssertionData : <.AssertionData>
    {
        public AssertionData(object? Result, ? Exception, string? ActualExpression,  Start,  End) { }
        public string? ActualExpression { get; init; }
        public  End { get; init; }
        public ? Exception { get; init; }
        public object? Result { get; init; }
        public  Start { get; init; }
        public static .AssertionData op_Implicit(<object?, ?, string?, , > tuple) { }
    }
    public class AssertionDecision : <.AssertionDecision>
    {
        public static .AssertionDecision Continue { get; }
        public static .AssertionDecision Pass { get; }
        public static .AssertionDecision Fail(string message) { }
    }
    public class AssertionMetadata
    {
        public AssertionMetadata() { }
        public  Duration { get; }
        public required  EndTime { get; init; }
        public required  StartTime { get; init; }
    }
    public class CollectionWrapper<TInner>
    {
        public CollectionWrapper(..IValueSource<.<TInner>> valueSource) { }
        public .<.<TInner>> Satisfy(<..IValueSource<TInner?>, .> assert, [.("assert")] string assertionBuilderExpression = "") { }
        public .<.<TInner>> Satisfy<TExpected>(<TInner?, .<TExpected>?> asyncMapper, <..IValueSource<TExpected?>, .> assert, [.("asyncMapper")] string mapperExpression = "", [.("assert")] string assertionBuilderExpression = "") { }
        public .<.<TInner>> Satisfy<TExpected>(<TInner?, TExpected> mapper, <..IValueSource<TExpected?>, .> assert, [.("mapper")] string mapperExpression = "", [.("assert")] string assertionBuilderExpression = "") { }
    }
    public static class Compare
    {
        public static .<.ComparisonFailure> CheckEquivalent<TActual, TExpected>(TActual actual, TExpected expected, .CompareOptions options, int? index) { }
    }
    public class CompareOptions : <.CompareOptions>
    {
        public CompareOptions() { }
        public . EquivalencyKind { get; set; }
        public string[] MembersToIgnore { get; init; }
    }
    public class ComparisonFailure : <.ComparisonFailure>
    {
        public ComparisonFailure() { }
        public required object? Actual { get; init; }
        public required object? Expected { get; init; }
        public required string[] NestedMemberNames { get; init; }
        public required .MemberType Type { get; init; }
    }
    public static class Fail
    {
        [.]
        public static void Test(string reason) { }
        public static void Unless([.(false)] bool condition, string reason) { }
        public static void When([.(true)] bool condition, string reason) { }
    }
    public enum MemberType
    {
        Property = 0,
        Field = 1,
        Value = 2,
        EnumerableItem = 3,
        DictionaryItem = 4,
    }
}
namespace .AssertConditions
{
    public class AssertionResult
    {
        public bool IsPassed { get; }
        public string Message { get; }
        public static . Passed { get; }
        public . And(. other) { }
        public .<.> OrAsync(<.<.>> otherResult) { }
        public . OrFailIf(bool isFailed, ..InterpolatedStringHandler stringHandler) { }
        public . OrFailIf(bool isFailed, string message) { }
        public static . Fail(string message) { }
        public static . FailIf(bool isFailed, ..InterpolatedStringHandler stringHandler) { }
        public static . FailIf(bool isFailed, string message) { }
        public static .<.> op_Implicit(. result) { }
        public static .<.> op_Implicit(. result) { }
        public readonly struct InterpolatedStringHandler
        {
            public InterpolatedStringHandler(int literalLength, int formattedCount, bool isFailed, out bool enabled) { }
            public void AppendFormatted<T>(T? t) { }
            public void AppendFormatted<T>(T? t, string format)
                where T :  { }
            public void AppendLiteral(string s) { }
        }
    }
    public abstract class BaseAssertCondition
    {
        protected BaseAssertCondition() { }
        public string? OverriddenMessage { get; }
        public string? Subject { get; }
        public virtual ? WaitFor { get; protected set; }
        public . FailWithMessage(string message) { }
        protected abstract string GetExpectation();
    }
    public abstract class BaseAssertCondition<TActual> : .
    {
        protected BaseAssertCondition() { }
        public string? ActualExpression { get; }
        public .<.> GetAssertionResult(TActual? actualValue, ? exception, .AssertionMetadata assertionMetadata, string? actualExpression = null) { }
        protected abstract .<.> GetResult(TActual? actualValue, ? exception, .AssertionMetadata assertionMetadata);
    }
    public enum ChainType
    {
        None = 0,
        And = 1,
        Or = 2,
    }
    public abstract class ConvertToAssertCondition<TFromType, TToType> : .<TFromType>
    {
        protected ConvertToAssertCondition() { }
        public TToType ConvertedValue { get; }
        public abstract .<<., TToType?>> ConvertValue(TFromType? value);
        protected override sealed .<.> GetResult(TFromType? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public abstract class DelegateAssertCondition : .<object?, >
    {
        protected DelegateAssertCondition() { }
    }
    public abstract class DelegateAssertCondition<TActual> : .<TActual, >
    {
        protected DelegateAssertCondition() { }
    }
    public abstract class DelegateAssertCondition<TActual, TException> : .<TActual>
        where TException : 
    {
        protected DelegateAssertCondition() { }
        protected override string GetExpectation() { }
        protected virtual string GetFailureMessage(TException? exception) { }
        protected override .<.> GetResult(TActual? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
        public void WithComparer(<TException?, .AssertionDecision> comparer) { }
    }
    public class EnumerableSatisfiesAssertCondition<TActual, TInner, TExpected> : .<TActual>
        where TActual : .<TInner?>
    {
        public EnumerableSatisfiesAssertCondition(<TInner?, .<TExpected>?> mapper, <..IValueSource<TExpected?>, .> assertionBuilder, string mapperExpression, string assertionBuilderExpression) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(TActual? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public abstract class ExpectedExceptionDelegateAssertCondition<TException> : .<object?, >
    {
        protected ExpectedExceptionDelegateAssertCondition() { }
    }
    public abstract class ExpectedValueAssertCondition<TActual, TExpected> : .<TActual>
    {
        protected ExpectedValueAssertCondition(TExpected? expected) { }
        public TExpected ExpectedValue { get; }
        protected abstract .<.> GetResult(TActual? actualValue, TExpected? expectedValue);
        protected override .<.> GetResult(TActual? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
        public void WithComparer(<TActual?, TExpected?, .AssertionDecision> comparer) { }
        public void WithTransform(<TActual?, TActual?> actualTransformation, <TExpected?, TExpected?> expectedTransformation) { }
    }
    public class FailureLocation : <.>
    {
        public FailureLocation() { }
        public object? ActualValue { get; }
        public object? ExpectedValue { get; }
        public long Position { get; }
    }
    public class FuncValueAssertCondition<TActual, TExpected> : .<TActual, TExpected>
    {
        public FuncValueAssertCondition(TExpected? expected, <TActual?, TExpected?, .<TActual, TExpected>, bool> condition, <TActual?, ?, string?, string> defaultMessageFactory, string expectation) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(TActual? actualValue, TExpected? expectedValue) { }
    }
    public class NotNullExpectedValueAssertCondition<TActual> : .<TActual?, TActual>
        where TActual :  class?
    {
        public NotNullExpectedValueAssertCondition() { }
        public override .<<., TActual?>> ConvertValue(TActual? value) { }
        protected override string GetExpectation() { }
    }
    public class NotNullStructExpectedValueAssertCondition<TActual> : .<TActual?, TActual>
        where TActual :  struct
    {
        public NotNullStructExpectedValueAssertCondition() { }
        public override .<<., TActual>> ConvertValue(TActual? value) { }
        protected override string GetExpectation() { }
    }
    public class NullExpectedValueAssertCondition<TActual> : .<TActual>
    {
        public NullExpectedValueAssertCondition() { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(TActual? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class SatisfiesAssertCondition<TActual, TExpected> : .<TActual>
    {
        public SatisfiesAssertCondition(<TActual, .<TExpected>?> mapper, <..IValueSource<TExpected?>, .<TExpected?>> assertionBuilder, string mapperExpression, string assertionBuilderExpression) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(TActual? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public abstract class StringMatcher
    {
        protected StringMatcher() { }
        public static ..RegexMatch AsRegex(string pattern) { }
        public static ..WildcardMatch AsWildcard(string pattern) { }
        public static . op_Implicit(. pattern) { }
        public static . op_Implicit(string pattern) { }
        public sealed class RegexMatch : .
        {
            public ..RegexMatch IgnoringCase(bool ignoreCase = true) { }
            public override string ToString() { }
        }
        public sealed class WildcardMatch : .
        {
            public ..WildcardMatch IgnoringCase(bool ignoreCase = true) { }
            public override string ToString() { }
        }
    }
    public abstract class ValueAssertCondition<TActual> : .<TActual>
    {
        protected ValueAssertCondition() { }
        protected override string GetExpectation() { }
        protected abstract string GetFailureMessage(TActual? actualValue);
        protected override .<.> GetResult(TActual? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
        protected abstract . Passes(TActual? actualValue);
        public void WithComparer(<TActual?, .AssertionDecision> comparer) { }
        public void WithTransform(<TActual?, TActual?> actualTransformation) { }
    }
}
namespace .
{
    public class DateTimeEqualsExpectedValueAssertCondition : .<, >
    {
        public DateTimeEqualsExpectedValueAssertCondition( expected) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult( actualValue,  expectedValue) { }
        public void SetTolerance( tolerance) { }
    }
    public class DateTimeOffsetEqualsExpectedValueAssertCondition : .<, >
    {
        public DateTimeOffsetEqualsExpectedValueAssertCondition( expected) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult( actualValue,  expectedValue) { }
        public void SetTolerance( tolerance) { }
    }
    public class TimeSpanEqualsExpectedValueAssertCondition : .<, >
    {
        public TimeSpanEqualsExpectedValueAssertCondition( expected) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult( actualValue,  expectedValue) { }
        public void SetTolerance( tolerance) { }
    }
}
namespace .
{
    public class Member<TActualRootType, TPropertyType>
    {
        public Member(..IValueSource<TActualRootType> valueSource, .<<TActualRootType, TPropertyType>> selector) { }
        public .<TActualRootType> EqualTo(TPropertyType expected, [.("expected")] string? doNotPopulateThisValue = null) { }
        public .<TActualRootType> NotEqualTo(TPropertyType expected, [.("expected")] string? doNotPopulateThisValue = null) { }
    }
    public class PropertyEqualsExpectedValueAssertCondition<TRootObjectType, TPropertyType> : .<TRootObjectType, TPropertyType>
    {
        public PropertyEqualsExpectedValueAssertCondition(.<<TRootObjectType, TPropertyType>> propertySelector, TPropertyType expected, bool isEqual) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(TRootObjectType? actualValue, TPropertyType? expectedValue) { }
    }
}
namespace .
{
    public class EnumerableAllExpectedFuncAssertCondition<TActual, TInner> : .<TActual>
        where TActual : .<TInner>
    {
        public EnumerableAllExpectedFuncAssertCondition(<TInner, bool> matcher, string? matcherString) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(TActual? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class EnumerableContainsExpectedFuncAssertCondition<TActual, TInner> : .<TActual>
        where TActual : .<TInner>
    {
        public EnumerableContainsExpectedFuncAssertCondition(<TInner, bool> matcher, string? matcherString) { }
        public TInner FoundItem { get; }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(TActual? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class EnumerableContainsExpectedValueAssertCondition<TActual, TInner> : .<TActual, TInner>
        where TActual : .<TInner>
    {
        public EnumerableContainsExpectedValueAssertCondition(TInner expected, .<TInner?>? equalityComparer) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(TActual? actualValue, TInner? inner) { }
    }
    public class EnumerableCountEqualToExpectedValueAssertCondition<TActual, TInner> : .<TActual, int>
        where TActual : .<TInner>
    {
        public EnumerableCountEqualToExpectedValueAssertCondition(int expected) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(TActual? actualValue, int count) { }
    }
    public class EnumerableCountNotEqualToExpectedValueAssertCondition<TActual, TInner> : .<TActual, int>
        where TActual : .<TInner>
    {
        public EnumerableCountNotEqualToExpectedValueAssertCondition(int expected) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(TActual? actualValue, int count) { }
    }
    public class EnumerableDistinctItemsExpectedValueAssertCondition<TActual, TInner> : .<TActual>
        where TActual : .<TInner>
    {
        public EnumerableDistinctItemsExpectedValueAssertCondition(.<TInner?>? equalityComparer) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(TActual? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class EnumerableEquivalentToExpectedValueAssertCondition<TActual, TInner> : .<TActual, .<TInner>>
        where TActual : .<TInner>?
    {
        public EnumerableEquivalentToExpectedValueAssertCondition(.<TInner>? expected, .<TInner?> equalityComparer, . collectionOrdering) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(TActual? actualValue, .<TInner>? expectedValue) { }
    }
    public class EnumerableNotContainsExpectedFuncAssertCondition<TActual, TInner> : .<TActual>
        where TActual : .<TInner>
    {
        public EnumerableNotContainsExpectedFuncAssertCondition(<TInner, bool> matcher, string? matcherString) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(TActual? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class EnumerableNotContainsExpectedValueAssertCondition<TActual, TInner> : .<TActual, TInner>
        where TActual : .<TInner>
    {
        public EnumerableNotContainsExpectedValueAssertCondition(TInner expected, .<TInner?>? equalityComparer) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(TActual? actualValue, TInner? inner) { }
    }
    public class EnumerableNotEquivalentToExpectedValueAssertCondition<TActual, TInner> : .<TActual, .<TInner>>
        where TActual : .<TInner>?
    {
        public EnumerableNotEquivalentToExpectedValueAssertCondition(.<TInner>? expected, .<TInner?> equalityComparer, . collectionOrdering) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(TActual? actualValue, .<TInner>? expectedValue) { }
    }
    public class EnumerableOrderedByAssertCondition<TActual, TInner, TComparisonItem> : .<TActual>
        where TActual : .<TInner>
    {
        public EnumerableOrderedByAssertCondition(.<TComparisonItem?> comparer, <TInner, TComparisonItem> comparisonItemSelector, . order) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(TActual? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class PropertyOrMethodAccessor<TActual>
    {
        public PropertyOrMethodAccessor() { }
    }
}
namespace .
{
    public class BetweenAssertCondition<TActual> : .<TActual>
        where TActual : <TActual>
    {
        public BetweenAssertCondition(TActual minimum, TActual maximum) { }
        public void Exclusive() { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(TActual? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
        public void Inclusive() { }
    }
    public class NotBetweenAssertCondition<TActual> : .<TActual>
        where TActual : <TActual>
    {
        public NotBetweenAssertCondition(TActual minimum, TActual maximum) { }
        public void Exclusive() { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(TActual? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
        public void Inclusive() { }
    }
}
namespace .
{
    public class ExceptionMessageContainingExpectedValueAssertCondition<TException> : .<TException, string>
        where TException : 
    {
        public ExceptionMessageContainingExpectedValueAssertCondition(string expected,  stringComparison) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(TException? actualValue, string? expectedValue) { }
    }
    public class ExceptionMessageEndingWithExpectedValueAssertCondition<TException> : .<TException, string>
        where TException : 
    {
        public ExceptionMessageEndingWithExpectedValueAssertCondition(string expected,  stringComparison) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(TException? actualValue, string? expectedValue) { }
    }
    public class ExceptionMessageEqualsExpectedValueAssertCondition<TException> : .<TException, string>
        where TException : 
    {
        public ExceptionMessageEqualsExpectedValueAssertCondition(string expected,  stringComparison) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(TException? actualValue, string? expectedValue) { }
    }
    public class ExceptionMessageMatchingExpectedAssertCondition<TException> : .<TException, .>
        where TException : 
    {
        public ExceptionMessageMatchingExpectedAssertCondition(. match) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(TException? actualValue, .? expectedValue) { }
    }
    public class ExceptionMessageStartingWithExpectedValueAssertCondition<TException> : .<TException, string>
        where TException : 
    {
        public ExceptionMessageStartingWithExpectedValueAssertCondition(string expected,  stringComparison) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(TException? actualValue, string? expectedValue) { }
    }
}
namespace .
{
    public class ConvertedDelegateSource<TToType> : ..ISource, ..IValueSource<TToType?>
        where TToType : 
    {
        public ConvertedDelegateSource(..IDelegateSource source) { }
        public string? ActualExpression { get; }
        public .<.AssertionData> AssertionDataTask { get; }
        public .<.> Assertions { get; }
        public .StringBuilder ExpressionBuilder { get; }
        public ..ISource AppendExpression(string expression) { }
        public ..ISource WithAssertion(. assertCondition) { }
    }
    public class ConvertedValueSource<TFromType, TToType> : ..ISource, ..IValueSource<TToType?>
    {
        public ConvertedValueSource(..IValueSource<TFromType> source, .<TFromType, TToType> convertToAssertCondition) { }
        public string? ActualExpression { get; }
        public .<.AssertionData> AssertionDataTask { get; }
        public .<.> Assertions { get; }
        public .StringBuilder ExpressionBuilder { get; }
        public ..ISource AppendExpression(string expression) { }
        public ..ISource WithAssertion(. assertCondition) { }
    }
    public interface IDelegateSource : ..ISource { }
    public interface ISource
    {
        string? ActualExpression { get; }
        ..ISource AppendExpression(string expression);
        ..ISource WithAssertion(. assertCondition);
    }
    public interface IValueDelegateSource<out TActual> : ..IDelegateSource, ..ISource, ..IValueSource<TActual> { }
    public interface IValueSource<out TActual> : ..ISource { }
}
namespace .
{
    []
    public enum AssertionType
    {
        Value = 1,
        Delegate = 2,
    }
    public class DelegateAnd<TActual> : ..IDelegateSource, ..ISource
    {
        public DelegateAnd(. assertionBuilder) { }
        public static ..DelegateAnd<TActual> Create(. assertionBuilder) { }
    }
    public class DelegateOr<TActual> : ..IDelegateSource, ..ISource
    {
        public DelegateOr(. assertionBuilder) { }
        public static ..DelegateOr<TActual> Create(. assertionBuilder) { }
    }
    public class ValueAnd<TActual> : ..ISource, ..IValueSource<TActual>
    {
        public ValueAnd(. assertionBuilder) { }
        public static ..ValueAnd<TActual> Create(. assertionBuilder) { }
    }
    public class ValueDelegateAnd<TActual> : ..IDelegateSource, ..ISource, ..IValueDelegateSource<TActual>, ..IValueSource<TActual>
    {
        public ValueDelegateAnd(. assertionBuilder) { }
        public static ..ValueDelegateAnd<TActual> Create(. assertionBuilder) { }
    }
    public class ValueDelegateOr<TActual> : ..IDelegateSource, ..ISource, ..IValueDelegateSource<TActual>, ..IValueSource<TActual>
    {
        public ValueDelegateOr(. assertionBuilder) { }
        public static ..ValueDelegateOr<TActual> Create(. assertionBuilder) { }
    }
    public class ValueOr<TActual> : ..ISource, ..IValueSource<TActual>
    {
        public ValueOr(. assertionBuilder) { }
    }
}
namespace .
{
    public class StringEqualsExpectedValueAssertCondition : .<string, string>
    {
        public StringEqualsExpectedValueAssertCondition(string expected,  stringComparison) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(string? actualValue, string? expectedValue) { }
        public ..StringEqualsExpectedValueAssertCondition IgnoringWhitespace() { }
        public ..StringEqualsExpectedValueAssertCondition WithNullAndEmptyEquality() { }
        public ..StringEqualsExpectedValueAssertCondition WithTrimming() { }
    }
    public class StringNotContainsExpectedValueAssertCondition : .<string, string>
    {
        public StringNotContainsExpectedValueAssertCondition(string expected,  stringComparison) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(string? actualValue, string? expectedValue) { }
    }
    public class StringNotEqualsExpectedValueAssertCondition : .<string, string>
    {
        public StringNotEqualsExpectedValueAssertCondition(string expected,  stringComparison) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(string? actualValue, string? expectedValue) { }
    }
}
namespace .
{
    public class ThrowsAnyExceptionAssertCondition<TActual> : .<TActual, >
    {
        public ThrowsAnyExceptionAssertCondition() { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(TActual? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class ThrowsExactTypeOfDelegateAssertCondition<TActual, TExpectedException> : .<TActual, TExpectedException>
        where TExpectedException : 
    {
        public ThrowsExactTypeOfDelegateAssertCondition() { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(TActual? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class ThrowsException<TActual, TException>
        where TException : 
    {
        public ThrowsException(. delegateAssertionBuilder, ..IDelegateSource source, <?, ?> selector) { }
        public ..ValueAnd<TException> And { get; }
        public ..DelegateOr<object?> Or { get; }
        public .<TException?> GetAwaiter() { }
        public ..ThrowsException<TActual, > WithInnerException() { }
        public ..ThrowsException<TActual, TException> WithMessage(string expected, [.("expected")] string? doNotPopulateThisValue = null) { }
        public ..ThrowsException<TActual, TException> WithMessageContaining(string expected, [.("expected")] string? doNotPopulateThisValue = null) { }
        public ..ThrowsException<TActual, TException> WithMessageContaining(string expected,  stringComparison, [.("expected")] string? doNotPopulateThisValue = null, [.("stringComparison")] string? doNotPopulateThisValue2 = null) { }
        public ..ThrowsException<TActual, TException> WithMessageMatching(. match, [.("match")] string? doNotPopulateThisValue = null) { }
        public static .<TException?> op_Explicit(..ThrowsException<TActual, TException> throwsException) { }
    }
    public static class ThrowsExtensions
    {
        public static ..ThrowsException<object?, > Throws(this ..IDelegateSource delegateSource,  type, [.("type")] string? doNotPopulateThisValue = null) { }
        public static ..ThrowsException<object?, TException> Throws<TException>(this ..IDelegateSource delegateSource)
            where TException :  { }
        public static ..ThrowsException<object?, TException> ThrowsExactly<TException>(this ..IDelegateSource delegateSource)
            where TException :  { }
        public static ..ThrowsException<object?, > ThrowsException(this ..IDelegateSource delegateSource) { }
        public static .<object?, object?> ThrowsNothing(this ..IDelegateSource delegateSource) { }
        public static .<TActual, TActual> ThrowsNothing<TActual>(this ..IValueDelegateSource<TActual> delegateSource) { }
        public static ..ThrowsException<object?, > ThrowsWithin(this ..IDelegateSource delegateSource,  timeSpan, [.("timeSpan")] string? doNotPopulateThisValue = null) { }
        public static ..ThrowsException<object?, TException> ThrowsWithin<TException>(this ..IDelegateSource delegateSource,  timeSpan, [.("timeSpan")] string? doNotPopulateThisValue = null)
            where TException :  { }
        public static ..ThrowsException<TActual, TException> WithParameterName<TActual, TException>(this ..ThrowsException<TActual, TException> throwsException, string expected, [.("expected")] string? doNotPopulateThisValue = null)
            where TException :  { }
    }
    public class ThrowsNothingAssertCondition<TActual> : .<TActual, >
    {
        public ThrowsNothingAssertCondition() { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(TActual? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class ThrowsOfTypeAssertCondition : .<object?, >
    {
        public ThrowsOfTypeAssertCondition( type) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(object? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class ThrowsOfTypeAssertCondition<TActual, TExpectedException> : .<TActual, TExpectedException>
        where TExpectedException : 
    {
        public ThrowsOfTypeAssertCondition() { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(TActual? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class ThrowsWithMessageAssertCondition<TActual, TException> : .<TActual, >
        where TException : 
    {
        public ThrowsWithMessageAssertCondition(string expectedMessage,  stringComparison, <?, ?> exceptionSelector) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(TActual? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class ThrowsWithMessageContainingAssertCondition<TActual, TException> : .<TActual, >
        where TException : 
    {
        public ThrowsWithMessageContainingAssertCondition(string expected,  stringComparison, <?, ?> exceptionSelector) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(TActual? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class ThrowsWithMessageMatchingAssertCondition<TActual, TException> : .<TActual, >
        where TException : 
    {
        public ThrowsWithMessageMatchingAssertCondition(. match, <?, ?> exceptionSelector) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(TActual? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class ThrowsWithParamNameAssertCondition<TActual, TException> : .<TActual, >
        where TException : 
    {
        public ThrowsWithParamNameAssertCondition(string expectedParamName,  stringComparison, <?, ?> exceptionSelector) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(TActual? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
}
namespace .AssertionBuilders
{
    public class AndAssertionBuilder : ., . { }
    public abstract class AssertionBuilder : ..ISource
    {
        protected .AssertionData? AwaitedAssertionData;
        protected .? OtherTypeAssertionBuilder;
        protected readonly .<.> Results;
        public AssertionBuilder(..ISource source) { }
        public AssertionBuilder(.<.AssertionData> assertionDataTask, string? actualExpression) { }
        public AssertionBuilder(.<.AssertionData> assertionDataTask, string actualExpression, .StringBuilder expressionBuilder, .<.> assertions) { }
        protected void AppendCallerMethod(string?[] expressions, [.] string methodName = "") { }
        [.DebuggerHidden]
        [("This is a base `object` method that should not be called.", true)]
        public new void Equals(object? obj) { }
        [.DebuggerHidden]
        [("This is a base `object` method that should not be called.", true)]
        public void ReferenceEquals(object a, object b) { }
    }
    public class AsyncDelegateAssertionBuilder : ., ..IDelegateSource, ..ISource { }
    public class AsyncValueDelegateAssertionBuilder<TActual> : ., ..IDelegateSource, ..ISource, ..IValueDelegateSource<TActual>, ..IValueSource<TActual> { }
    public class CastableResultAssertionBuilder<TActual, TExpected> : .<TActual, TExpected> { }
    public class CastedAssertionBuilder<TActual, TExpected> : .<TExpected> { }
    public class ConvertedDelegateAssertionBuilder<TException> : .<TException>
        where TException : 
    {
        public ConvertedDelegateAssertionBuilder(..IDelegateSource source) { }
    }
    public class ConvertedValueAssertionBuilder<TFromType, TToType> : .<TToType>
    {
        public ConvertedValueAssertionBuilder(..IValueSource<TFromType> source, .<TFromType, TToType> convertToAssertCondition) { }
    }
    public class DelegateAssertionBuilder : ., ..IDelegateSource, ..ISource { }
    public interface IAndAssertionBuilder { }
    public interface IInvokableAssertionBuilder : ..ISource
    {
        . GetAwaiter();
        string? GetExpression();
    }
    public interface IOrAssertionBuilder { }
    public class InvokableAssertionBuilder<TActual> : ., ..ISource, .
    {
        protected readonly ..ISource Source;
        protected .<.> Assertions { get; }
        public .<.<.>> GetAssertionResults() { }
        public . GetAwaiter() { }
    }
    public class InvokableDelegateAssertionBuilder : .<object?>, ..IDelegateSource, ..ISource
    {
        public ..DelegateAnd<object?> And { get; }
        public . AssertionBuilder { get; }
        public ..DelegateOr<object?> Or { get; }
    }
    public class InvokableValueAssertionBuilder<TActual> : .<TActual>, ..ISource, ..IValueSource<TActual>
    {
        public InvokableValueAssertionBuilder(..ISource source) { }
        public ..ValueAnd<TActual> And { get; }
        public ..ValueOr<TActual> Or { get; }
        public .<TActual> Because(string reason) { }
        public new .<TActual?> GetAwaiter() { }
    }
    public class InvokableValueDelegateAssertionBuilder<TActual> : .<TActual>
    {
        public ..ValueDelegateAnd<TActual> And { get; }
        public . AssertionBuilder { get; }
        public ..ValueDelegateOr<TActual> Or { get; }
    }
    public class MappableResultAssertionBuilder<TActual, TExpected> : .<TActual>
    {
        public new .<TExpected?> GetAwaiter() { }
    }
    public class MappableResultAssertionBuilder<TActual, TAssertCondition, TExpected> : .<TActual>
        where TAssertCondition : .<TActual>
    {
        public new .<TExpected?> GetAwaiter() { }
    }
    public class OrAssertionBuilder : ., . { }
    public class ValueAssertionBuilder<TActual> : ., ..ISource, ..IValueSource<TActual>
    {
        public ValueAssertionBuilder(..ISource source) { }
    }
    public class ValueDelegateAssertionBuilder<TActual> : ., ..IDelegateSource, ..ISource, ..IValueDelegateSource<TActual>, ..IValueSource<TActual> { }
}
namespace .
{
    public class AndAssertionGroupInvoker<TActual, TAssertionBuilder>
        where TAssertionBuilder : .
    {
        public AndAssertionGroupInvoker(..AssertionGroup<TActual, TAssertionBuilder> group1, ..AssertionGroup<TActual, TAssertionBuilder> group2) { }
        public ..AndAssertionGroupInvoker<TActual, TAssertionBuilder> And(..AssertionGroup<TActual, TAssertionBuilder> group) { }
        public .<TActual?> GetAwaiter() { }
    }
    public class AndAssertionGroup<TActual, TAssertionBuilder> : ..AssertionGroup<TActual, TAssertionBuilder>
        where TAssertionBuilder : .
    {
        public ..AndAssertionGroup<TActual, TAssertionBuilder> And(<TAssertionBuilder, .<TActual>> assert) { }
        public override .<TActual?> GetAwaiter() { }
    }
    public static class AssertionGroup
    {
        public static ..AndAssertionGroupInvoker<TActual, TAssertionBuilder> And<TActual, TAssertionBuilder>(..AssertionGroup<TActual, TAssertionBuilder> group1, ..AssertionGroup<TActual, TAssertionBuilder> group2)
            where TAssertionBuilder : . { }
        public static ..UnknownAssertionGroupInvoker<TActual, TAssertionBuilder> Assert<TActual, TAssertionBuilder>(..AssertionGroup<TActual, TAssertionBuilder> group)
            where TAssertionBuilder : . { }
        public static ..AssertionGroupBuilder<object?, .> For( value) { }
        public static ..AssertionGroupBuilder<object?, .> For(<.> value) { }
        public static ..AssertionGroupBuilder<object?, .> For(. value) { }
        public static ..AssertionGroupBuilder<object?, .> For(. value) { }
        public static ..AssertionGroupBuilder<TActual, .<TActual>> For<TActual>(<.<TActual>> value) { }
        public static ..AssertionGroupBuilder<TActual, .<TActual>> For<TActual>(<TActual> value) { }
        public static ..AssertionGroupBuilder<TActual, .<TActual>> For<TActual>(.<TActual> value) { }
        public static ..AssertionGroupBuilder<TActual, .<TActual>> For<TActual>(.<TActual> value) { }
        public static ..AssertionGroupBuilder<TActual, .<TActual>> For<TActual>(TActual value) { }
        public static ..AssertionGroupBuilder<object?, .> ForSameValueAs(..AssertionGroup<object?, .> otherGroup) { }
        public static ..AssertionGroupBuilder<object?, .> ForSameValueAs(..AssertionGroup<object?, .> otherGroup) { }
        public static ..AssertionGroupBuilder<TActual, .<TActual>> ForSameValueAs<TActual>(..AssertionGroup<TActual, .<TActual>> otherGroup) { }
        public static ..AssertionGroupBuilder<TActual, .<TActual>> ForSameValueAs<TActual>(..AssertionGroup<TActual, .<TActual>> otherGroup) { }
        public static ..AssertionGroupBuilder<TActual, .<TActual>> ForSameValueAs<TActual>(..AssertionGroup<TActual, .<TActual>> otherGroup) { }
        public static ..OrAssertionGroupInvoker<TActual, TAssertionBuilder> Or<TActual, TAssertionBuilder>(..AssertionGroup<TActual, TAssertionBuilder> group1, ..AssertionGroup<TActual, TAssertionBuilder> group2)
            where TAssertionBuilder : . { }
    }
    public class AssertionGroupBuilder<TActual, TAssertionBuilder>
        where TAssertionBuilder : .
    {
        public ..UnknownAssertionGroup<TActual, TAssertionBuilder> WithAssertion(<TAssertionBuilder, .<TActual>> assert) { }
    }
    public abstract class AssertionGroup<TActual, TAssertionBuilder>
        where TAssertionBuilder : .
    {
        public abstract .<TActual?> GetAwaiter();
    }
    public class OrAssertionException : 
    {
        public OrAssertionException(.<> exceptions) { }
        public override string Message { get; }
    }
    public class OrAssertionGroupInvoker<TActual, TAssertionBuilder>
        where TAssertionBuilder : .
    {
        public OrAssertionGroupInvoker(..AssertionGroup<TActual, TAssertionBuilder> group1, ..AssertionGroup<TActual, TAssertionBuilder> group2) { }
        public .<TActual?> GetAwaiter() { }
        public ..OrAssertionGroupInvoker<TActual, TAssertionBuilder> Or(..AssertionGroup<TActual, TAssertionBuilder> group) { }
    }
    public class OrAssertionGroup<TActual, TAssertionBuilder> : ..AssertionGroup<TActual, TAssertionBuilder>
        where TAssertionBuilder : .
    {
        public override .<TActual?> GetAwaiter() { }
        public ..OrAssertionGroup<TActual, TAssertionBuilder> Or(<TAssertionBuilder, .<TActual>> assert) { }
    }
    public class UnknownAssertionGroupInvoker<TActual, TAssertionBuilder>
        where TAssertionBuilder : .
    {
        public UnknownAssertionGroupInvoker(..AssertionGroup<TActual, TAssertionBuilder> group) { }
        public ..AndAssertionGroupInvoker<TActual, TAssertionBuilder> And(..AssertionGroup<TActual, TAssertionBuilder> otherGroup) { }
        public ..OrAssertionGroupInvoker<TActual, TAssertionBuilder> Or(..AssertionGroup<TActual, TAssertionBuilder> otherGroup) { }
    }
    public class UnknownAssertionGroup<TActual, TAssertionBuilder>
        where TAssertionBuilder : .
    {
        public ..AndAssertionGroup<TActual, TAssertionBuilder> And(<TAssertionBuilder, .<TActual>> assert) { }
        public ..OrAssertionGroup<TActual, TAssertionBuilder> Or(<TAssertionBuilder, .<TActual>> assert) { }
    }
}
namespace .
{
    public class BetweenAssertionBuilderWrapper<TActual> : .<TActual>
        where TActual : <TActual>
    {
        public ..BetweenAssertionBuilderWrapper<TActual> WithExclusiveBounds() { }
        public ..BetweenAssertionBuilderWrapper<TActual> WithInclusiveBounds() { }
    }
    public class DateTimeEqualToAssertionBuilderWrapper : .<>
    {
        public ..DateTimeEqualToAssertionBuilderWrapper Within( tolerance, [.("tolerance")] string doNotPopulateThis = "") { }
    }
    public class DateTimeOffsetEqualToAssertionBuilderWrapper : .<>
    {
        public ..DateTimeOffsetEqualToAssertionBuilderWrapper Within( tolerance, [.("tolerance")] string doNotPopulateThis = "") { }
    }
    public class EquivalentToAssertionBuilderWrapper<TActual, TExpected> : .<TActual>
    {
        public ..EquivalentToAssertionBuilderWrapper<TActual, TExpected> IgnoringMember(string propertyName, [.("propertyName")] string doNotPopulateThis = "") { }
        public ..EquivalentToAssertionBuilderWrapper<TActual, TExpected> WithPartialEquivalency() { }
    }
    public class GenericEqualToAssertionBuilderWrapper<TActual> : .<TActual> { }
    public class GenericNotEqualToAssertionBuilderWrapper<TActual> : .<TActual> { }
    public class NotBetweenAssertionBuilderWrapper<TActual> : .<TActual>
        where TActual : <TActual>
    {
        public ..NotBetweenAssertionBuilderWrapper<TActual> WithExclusiveBounds() { }
        public ..NotBetweenAssertionBuilderWrapper<TActual> WithInclusiveBounds() { }
    }
    public class NotEquivalentToAssertionBuilderWrapper<TActual, TExpected> : .<TActual>
    {
        public ..NotEquivalentToAssertionBuilderWrapper<TActual, TExpected> IgnoringMember(string propertyName, [.("propertyName")] string doNotPopulateThis = "") { }
        public ..NotEquivalentToAssertionBuilderWrapper<TActual, TExpected> WithPartialEquivalency() { }
    }
    public class NotNullAssertionBuilderWrapper<TActual> : .<TActual>
        where TActual :  class
    {
        public new .<TActual> GetAwaiter() { }
    }
    public class NotNullStructAssertionBuilderWrapper<TActual> : .<TActual>
        where TActual :  struct
    {
        public new .<TActual> GetAwaiter() { }
    }
    public class SingleItemAssertionBuilderWrapper<TActual, TInner> : .<TActual>
        where TActual : .<TInner>
    {
        public new .<TInner> GetAwaiter() { }
    }
    public class StringContainsAssertionBuilderWrapper : .<string>
    {
        public ..StringContainsAssertionBuilderWrapper IgnoringWhitespace() { }
        public ..StringContainsAssertionBuilderWrapper WithTrimming() { }
    }
    public class StringEqualToAssertionBuilderWrapper : .<string>
    {
        public ..StringEqualToAssertionBuilderWrapper IgnoringWhitespace() { }
        public ..StringEqualToAssertionBuilderWrapper WithNullAndEmptyEquality() { }
        public ..StringEqualToAssertionBuilderWrapper WithTrimming() { }
    }
    public class TimeSpanEqualToAssertionBuilderWrapper : .<>
    {
        public ..TimeSpanEqualToAssertionBuilderWrapper Within( tolerance, [.("tolerance")] string doNotPopulateThis = "") { }
    }
}
namespace .
{
    public class CompleteWithinAssertCondition<TActual> : .<TActual>
    {
        public CompleteWithinAssertCondition( timeSpan) { }
        public override ? WaitFor { get; }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(TActual? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public static class DelegateExtensions
    {
        public static . CompletesWithin(this ..IDelegateSource delegateSource,  timeSpan, [.("timeSpan")] string? doNotPopulateThisValue = null) { }
        public static .<TActual> CompletesWithin<TActual>(this ..IValueDelegateSource<TActual> delegateSource,  timeSpan, [.("timeSpan")] string? doNotPopulateThisValue = null) { }
    }
}
namespace ..Conditions
{
    public class EnumDoesNotHaveFlagAssertCondition<TEnum> : .<TEnum>
        where TEnum : 
    {
        public EnumDoesNotHaveFlagAssertCondition(TEnum expected) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(TEnum? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class EnumDoesNotHaveSameNameAsCondition<TEnum, TExpected> : .<TEnum>
        where TEnum : 
        where TExpected : 
    {
        public EnumDoesNotHaveSameNameAsCondition(TExpected expected) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(TEnum? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class EnumDoesNotHaveSameValueAsCondition<TEnum, TExpected> : .<TEnum>
        where TEnum : 
        where TExpected : 
    {
        public EnumDoesNotHaveSameValueAsCondition(TExpected expected) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(TEnum? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class EnumHasFlagAssertCondition<TEnum> : .<TEnum>
        where TEnum : 
    {
        public EnumHasFlagAssertCondition(TEnum expected) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(TEnum? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class EnumHasSameNameAsCondition<TEnum, TExpected> : .<TEnum>
        where TEnum : 
        where TExpected : 
    {
        public EnumHasSameNameAsCondition(TExpected expected) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(TEnum? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class EnumHasSameValueAsCondition<TEnum, TExpected> : .<TEnum>
        where TEnum : 
        where TExpected : 
    {
        public EnumHasSameValueAsCondition(TExpected expected) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(TEnum? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class EnumIsDefinedAssertCondition<TEnum> : .<TEnum>
        where TEnum : 
    {
        public EnumIsDefinedAssertCondition() { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(TEnum? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class EnumIsNotDefinedAssertCondition<TEnum> : .<TEnum>
        where TEnum : 
    {
        public EnumIsNotDefinedAssertCondition() { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(TEnum? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
}
namespace .
{
    public static class EnumHasExtensions
    {
        public static .<TEnum> DoesNotHaveFlag<TEnum>(this ..IValueSource<TEnum> valueSource, TEnum expected, [.("expected")] string? doNotPopulateThisValue1 = null)
            where TEnum :  { }
        public static .<TEnum> DoesNotHaveSameNameAs<TEnum, TExpected>(this ..IValueSource<TEnum> valueSource, TExpected expected, [.("expected")] string? doNotPopulateThisValue1 = null)
            where TEnum : 
            where TExpected :  { }
        public static .<TEnum> DoesNotHaveSameValueAs<TEnum, TExpected>(this ..IValueSource<TEnum> valueSource, TExpected expected, [.("expected")] string? doNotPopulateThisValue1 = null)
            where TEnum : 
            where TExpected :  { }
        public static .<TEnum> HasFlag<TEnum>(this ..IValueSource<TEnum> valueSource, TEnum expected, [.("expected")] string? doNotPopulateThisValue1 = null)
            where TEnum :  { }
        public static .<TEnum> HasSameNameAs<TEnum, TExpected>(this ..IValueSource<TEnum> valueSource, TExpected expected, [.("expected")] string? doNotPopulateThisValue1 = null)
            where TEnum : 
            where TExpected :  { }
        public static .<TEnum> HasSameValueAs<TEnum, TExpected>(this ..IValueSource<TEnum> valueSource, TExpected expected, [.("expected")] string? doNotPopulateThisValue1 = null)
            where TEnum : 
            where TExpected :  { }
        public static .<TEnum> IsDefined<TEnum>(this ..IValueSource<TEnum> valueSource)
            where TEnum :  { }
        public static .<TEnum> IsNotDefined<TEnum>(this ..IValueSource<TEnum> valueSource)
            where TEnum :  { }
    }
}
namespace ..Conditions
{
    public class AssignableFromExpectedValueAssertCondition<TActual> : .<TActual>
    {
        public AssignableFromExpectedValueAssertCondition( expectedType) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(TActual? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class AssignableToExpectedValueAssertCondition<TActual> : .<TActual>
    {
        public AssignableToExpectedValueAssertCondition( expectedType) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(TActual? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class ConvertExceptionToValueAssertCondition<TException> : .<object?>
        where TException : 
    {
        public ConvertExceptionToValueAssertCondition() { }
        public TException ConvertedExceptionValue { get; }
        protected override string GetExpectation() { }
        protected override sealed .<.> GetResult(object? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class DefaultExpectedValueAssertCondition<TActual> : .<TActual>
    {
        public DefaultExpectedValueAssertCondition() { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(TActual? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class DelegateConversionAssertionCondition<TToType> : .<TToType>
        where TToType : 
    {
        public DelegateConversionAssertionCondition(..IDelegateSource source, .<object?> assertCondition) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(TToType? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class EqualsExpectedValueAssertCondition<TActual> : .<TActual, TActual>
    {
        public EqualsExpectedValueAssertCondition(TActual expected) { }
        public EqualsExpectedValueAssertCondition(TActual expected, .<TActual> equalityComparer) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(TActual? actualValue, TActual? expectedValue) { }
    }
    public class EquivalentToExpectedValueAssertCondition<TActual, TExpected> : .<TActual, TExpected>
    {
        public EquivalentToExpectedValueAssertCondition(TExpected expected, string? expectedExpression) { }
        public . EquivalencyKind { get; set; }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(TActual? actualValue, TExpected? expectedValue) { }
        public void IgnoringMember(string fieldName) { }
    }
    public class NotAssignableFromExpectedValueAssertCondition<TActual> : .<TActual>
    {
        public NotAssignableFromExpectedValueAssertCondition( expectedType) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(TActual? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class NotAssignableToExpectedValueAssertCondition<TActual> : .<TActual>
    {
        public NotAssignableToExpectedValueAssertCondition( expectedType) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(TActual? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class NotDefaultExpectedValueAssertCondition<TActual> : .<TActual, TActual>
    {
        public NotDefaultExpectedValueAssertCondition() { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(TActual? actualValue, TActual? expectedValue) { }
    }
    public class NotEqualsExpectedValueAssertCondition<TActual> : .<TActual, TActual>
    {
        public NotEqualsExpectedValueAssertCondition(TActual expected) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(TActual? actualValue, TActual? expectedValue) { }
    }
    public class NotEquivalentToExpectedValueAssertCondition<TActual, TExpected> : .<TActual, TExpected>
    {
        public NotEquivalentToExpectedValueAssertCondition(TExpected expected, string? expectedExpression) { }
        public . EquivalencyKind { get; set; }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(TActual? actualValue, TExpected? expectedValue) { }
        public void IgnoringMember(string fieldName) { }
    }
    public class NotSameReferenceExpectedValueAssertCondition<TActual, TExpected> : .<TActual, TExpected>
    {
        public NotSameReferenceExpectedValueAssertCondition(TExpected expected) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(TActual? actualValue, TExpected? expectedValue) { }
    }
    public class NotTypeOfExpectedValueAssertCondition<TActual> : .<TActual>
    {
        public NotTypeOfExpectedValueAssertCondition( expected) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(TActual? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class SameReferenceExpectedValueAssertCondition<TActual, TExpected> : .<TActual, TExpected>
    {
        public SameReferenceExpectedValueAssertCondition(TExpected expected) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(TActual? actualValue, TExpected? expectedValue) { }
    }
    public class TypeOfExpectedValueAssertCondition<TActual> : .<TActual>
    {
        public TypeOfExpectedValueAssertCondition( expectedType) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(TActual? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class ValueConversionAssertionCondition<TFromType, TToType> : .<TToType>
    {
        public ValueConversionAssertionCondition(..ISource source, .<TFromType, TToType> convertToAssertCondition) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(TToType? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
}
namespace ..Conditions
{
    public class StringContainsExpectedValueAssertCondition : .<string, string>
    {
        public StringContainsExpectedValueAssertCondition(string expected,  stringComparison) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(string? actualValue, string? expectedValue) { }
    }
}
namespace .
{
    public class ThrowsWithinAssertCondition<TActual, TExpectedException> : .<TActual, TExpectedException>
        where TExpectedException : 
    {
        public ThrowsWithinAssertCondition( timeSpan) { }
        public override ? WaitFor { get; }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(TActual? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
}
namespace .Enums
{
    public enum CollectionOrdering
    {
        Matching = 0,
        Any = 1,
    }
    public enum EquivalencyKind
    {
        Full = 0,
        Partial = 1,
    }
    public enum Order
    {
        Ascending = 0,
        Descending = 1,
    }
}
namespace .Equality
{
    public class CollectionEquivalentToEqualityComparer<T> : .<T>
    {
        public CollectionEquivalentToEqualityComparer() { }
        public CollectionEquivalentToEqualityComparer(.CompareOptions compareOptions) { }
        public override int? EnumerableIndex { get; protected set; }
        public override bool Equals(T? x, T? y) { }
    }
    public class EquivalentToEqualityComparer<T> : .<T>
    {
        public EquivalentToEqualityComparer() { }
        public EquivalentToEqualityComparer(.CompareOptions compareOptions) { }
        public .ComparisonFailure[]? ComparisonFailures { get; }
        public virtual int? EnumerableIndex { get; protected set; }
        public virtual bool Equals(T? x, T? y) { }
        public string GetFailureMessages() { }
        public int GetHashCode([.] T obj) { }
    }
}
namespace .Exceptions
{
    public class AssertionException : .
    {
        public AssertionException(string? message) { }
        public AssertionException(string? message,  innerException) { }
    }
    public class BaseAssertionException : 
    {
        public BaseAssertionException() { }
        public BaseAssertionException(string? message) { }
        public BaseAssertionException(string? message, ? innerException) { }
    }
    public class MaybeCaughtException : 
    {
        public MaybeCaughtException( exception) { }
    }
    public class MixedAndOrAssertionsException : .
    {
        public MixedAndOrAssertionsException() { }
    }
}
namespace .Extensions
{
    public static class BooleanIsExtensions
    {
        public static .<bool> IsEqualTo(this ..IValueSource<bool> valueSource, bool expected) { }
        public static .<bool?> IsEqualTo(this ..IValueSource<bool?> valueSource, bool expected) { }
        public static .<bool?> IsEqualTo(this ..IValueSource<bool?> valueSource, bool? expected) { }
        public static .<bool> IsFalse(this ..IValueSource<bool> valueSource) { }
        public static .<bool?> IsFalse(this ..IValueSource<bool?> valueSource) { }
        public static .<bool> IsTrue(this ..IValueSource<bool> valueSource) { }
        public static .<bool?> IsTrue(this ..IValueSource<bool?> valueSource) { }
    }
    public static class BooleanIsNotExtensions
    {
        public static .<bool> IsNotEqualTo(this ..IValueSource<bool> valueSource, bool expected) { }
        public static .<bool?> IsNotEqualTo(this ..IValueSource<bool?> valueSource, bool expected) { }
        public static .<bool?> IsNotEqualTo(this ..IValueSource<bool?> valueSource, bool? expected) { }
        public static .<bool> IsNotFalse(this ..IValueSource<bool> valueSource) { }
        public static .<bool?> IsNotFalse(this ..IValueSource<bool?> valueSource) { }
        public static .<bool> IsNotTrue(this ..IValueSource<bool> valueSource) { }
        public static .<bool?> IsNotTrue(this ..IValueSource<bool?> valueSource) { }
    }
    public static class CharIsExtensions
    {
        public static .<char> IsEqualTo(this ..IValueSource<char> valueSource, char expected) { }
        public static .<char?> IsEqualTo(this ..IValueSource<char?> valueSource, char expected) { }
        public static .<char?> IsEqualTo(this ..IValueSource<char?> valueSource, char? expected) { }
    }
    public static class CharIsNotExtensions
    {
        public static .<char> IsNotEqualTo(this ..IValueSource<char> valueSource, char expected) { }
        public static .<char?> IsNotEqualTo(this ..IValueSource<char?> valueSource, char expected) { }
        public static .<char?> IsNotEqualTo(this ..IValueSource<char?> valueSource, char? expected) { }
    }
    public static class CollectionsIsExtensions
    {
        public static .<.<TInner>> IsEmpty<TInner>(this ..IValueSource<.<TInner>> valueSource) { }
        public static .<TActual> IsEquivalentTo<TActual, TInner>(this ..IValueSource<TActual> valueSource, .<TInner> expected, [.("expected")] string doNotPopulateThisValue = null)
            where TActual : .<TInner> { }
        public static .<TActual> IsEquivalentTo<TActual, TInner>(this ..IValueSource<TActual> valueSource, .<TInner> expected, .<TInner> comparer, [.("expected")] string doNotPopulateThisValue = null, [.("comparer")] string doNotPopulateThisValue2 = null)
            where TActual : .<TInner> { }
        public static .<TActual> IsEquivalentTo<TActual, TInner>(this ..IValueSource<TActual> valueSource, .<TInner> expected, . collectionOrdering, [.("expected")] string doNotPopulateThisValue = null, [.("collectionOrdering")] string doNotPopulateThisValue2 = null)
            where TActual : .<TInner> { }
        public static .<TActual> IsEquivalentTo<TActual, TInner>(this ..IValueSource<TActual> valueSource, .<TInner> expected, .<TInner> comparer, . collectionOrdering, [.("expected")] string doNotPopulateThisValue = null, [.("collectionOrdering")] string doNotPopulateThisValue2 = null)
            where TActual : .<TInner> { }
        public static .<.<TInner>> IsInDescendingOrder<TInner>(this ..IValueSource<.<TInner>> valueSource) { }
        public static .<.<TInner>> IsInDescendingOrder<TInner>(this ..IValueSource<.<TInner>> valueSource, .<TInner> comparer) { }
        public static .<.<TInner>> IsInOrder<TInner>(this ..IValueSource<.<TInner>> valueSource) { }
        public static .<.<TInner>> IsInOrder<TInner>(this ..IValueSource<.<TInner>> valueSource, .<TInner> comparer) { }
        public static .<.<TInner>> IsOrderedBy<TInner, TComparisonItem>(this ..IValueSource<.<TInner>> valueSource, <TInner, TComparisonItem> comparisonItemSelector, [.("comparisonItemSelector")] string doNotPopulateThisValue = null) { }
        public static .<.<TInner>> IsOrderedBy<TInner, TComparisonItem>(this ..IValueSource<.<TInner>> valueSource, <TInner, TComparisonItem> comparisonItemSelector, .<TComparisonItem> comparer, [.("comparisonItemSelector")] string doNotPopulateThisValue = null, [.("comparer")] string doNotPopulateThisValue2 = null) { }
        public static .<.<TInner>> IsOrderedByDescending<TInner, TComparisonItem>(this ..IValueSource<.<TInner>> valueSource, <TInner, TComparisonItem> comparisonItemSelector, [.("comparisonItemSelector")] string doNotPopulateThisValue = null) { }
        public static .<.<TInner>> IsOrderedByDescending<TInner, TComparisonItem>(this ..IValueSource<.<TInner>> valueSource, <TInner, TComparisonItem> comparisonItemSelector, .<TComparisonItem> comparer, [.("comparisonItemSelector")] string doNotPopulateThisValue = null, [.("comparer")] string doNotPopulateThisValue2 = null) { }
    }
    public static class CollectionsIsNotExtensions
    {
        public static .<.<TInner>> IsNotEmpty<TInner>(this ..IValueSource<.<TInner>> valueSource) { }
        public static .<TActual> IsNotEquivalentTo<TActual, TInner>(this ..IValueSource<TActual> valueSource, .<TInner> expected, [.("expected")] string doNotPopulateThisValue = null)
            where TActual : .<TInner> { }
        public static .<TActual> IsNotEquivalentTo<TActual, TInner>(this ..IValueSource<TActual> valueSource, .<TInner> expected, .<TInner> comparer, [.("expected")] string doNotPopulateThisValue = null, [.("comparer")] string doNotPopulateThisValue2 = null)
            where TActual : .<TInner> { }
        public static .<TActual> IsNotEquivalentTo<TActual, TInner>(this ..IValueSource<TActual> valueSource, .<TInner> expected, . collectionOrdering, [.("expected")] string doNotPopulateThisValue = null, [.("collectionOrdering")] string doNotPopulateThisValue2 = null)
            where TActual : .<TInner> { }
        public static .<TActual> IsNotEquivalentTo<TActual, TInner>(this ..IValueSource<TActual> valueSource, .<TInner> expected, .<TInner> comparer, . collectionOrdering, [.("expected")] string doNotPopulateThisValue = null, [.("collectionOrdering")] string doNotPopulateThisValue2 = null)
            where TActual : .<TInner> { }
    }
    public static class ComparableIsExtensions
    {
        public static ..BetweenAssertionBuilderWrapper<TActual> IsBetween<TActual>(this ..IValueSource<TActual> valueSource, TActual lowerBound, TActual upperBound, [.("lowerBound")] string doNotPopulateThisValue1 = null, [.("upperBound")] string doNotPopulateThisValue2 = null)
            where TActual : <TActual> { }
        public static .<TActual> IsGreaterThan<TActual>(this ..IValueSource<TActual> valueSource, TActual expected, [.("expected")] string doNotPopulateThisValue = null)
            where TActual : <TActual> { }
        public static .<TActual> IsGreaterThanOrEqualTo<TActual>(this ..IValueSource<TActual> valueSource, TActual expected, [.("expected")] string doNotPopulateThisValue = null)
            where TActual : <TActual> { }
        public static .<TActual> IsLessThan<TActual>(this ..IValueSource<TActual> valueSource, TActual expected, [.("expected")] string doNotPopulateThisValue = null)
            where TActual : <TActual> { }
        public static .<TActual> IsLessThanOrEqualTo<TActual>(this ..IValueSource<TActual> valueSource, TActual expected, [.("expected")] string doNotPopulateThisValue = null)
            where TActual : <TActual> { }
    }
    public static class ComparableIsNotExtensions
    {
        public static ..NotBetweenAssertionBuilderWrapper<TActual> IsNotBetween<TActual>(this ..IValueSource<TActual> valueSource, TActual lowerBound, TActual upperBound, [.("lowerBound")] string doNotPopulateThisValue1 = null, [.("upperBound")] string doNotPopulateThisValue2 = null)
            where TActual : <TActual> { }
        public static .<TActual> IsNotGreaterThan<TActual>(this ..IValueSource<TActual> valueSource, TActual expected, [.("expected")] string doNotPopulateThisValue = null)
            where TActual : <TActual> { }
        public static .<TActual> IsNotGreaterThanOrEqualTo<TActual>(this ..IValueSource<TActual> valueSource, TActual expected, [.("expected")] string doNotPopulateThisValue = null)
            where TActual : <TActual> { }
        public static .<TActual> IsNotLessThan<TActual>(this ..IValueSource<TActual> valueSource, TActual expected, [.("expected")] string doNotPopulateThisValue = null)
            where TActual : <TActual> { }
        public static .<TActual> IsNotLessThanOrEqualTo<TActual>(this ..IValueSource<TActual> valueSource, TActual expected, [.("expected")] string doNotPopulateThisValue = null)
            where TActual : <TActual> { }
    }
    public static class DateTimeIsExtensions
    {
        public static .<> IsAfter(this ..IValueSource<> valueSource,  expected, [.("expected")] string doNotPopulateThisValue = null) { }
        public static .<> IsAfterOrEqualTo(this ..IValueSource<> valueSource,  expected, [.("expected")] string doNotPopulateThisValue = null) { }
        public static .<> IsBefore(this ..IValueSource<> valueSource,  expected, [.("expected")] string doNotPopulateThisValue = null) { }
        public static .<> IsBeforeOrEqualTo(this ..IValueSource<> valueSource,  expected, [.("expected")] string doNotPopulateThisValue = null) { }
        public static ..DateTimeEqualToAssertionBuilderWrapper IsEqualTo(this ..IValueSource<> valueSource,  expected, [.("expected")] string doNotPopulateThisValue1 = null) { }
    }
    public static class DateTimeOffsetIsExtensions
    {
        public static .<> IsAfter(this ..IValueSource<> valueSource,  expected, [.("expected")] string doNotPopulateThisValue = null) { }
        public static .<> IsAfterOrEqualTo(this ..IValueSource<> valueSource,  expected, [.("expected")] string doNotPopulateThisValue = null) { }
        public static .<> IsBefore(this ..IValueSource<> valueSource,  expected, [.("expected")] string doNotPopulateThisValue = null) { }
        public static .<> IsBeforeOrEqualTo(this ..IValueSource<> valueSource,  expected, [.("expected")] string doNotPopulateThisValue = null) { }
        public static ..DateTimeOffsetEqualToAssertionBuilderWrapper IsEqualTo(this ..IValueSource<> valueSource,  expected, [.("expected")] string doNotPopulateThisValue1 = null) { }
    }
    public static class DoesExtensions
    {
        public static ..StringContainsAssertionBuilderWrapper Contains(this ..IValueSource<string> valueSource, string expected, [.("expected")] string doNotPopulateThisValue = null) { }
        public static ..StringContainsAssertionBuilderWrapper Contains(this ..IValueSource<string> valueSource, string expected,  stringComparison, [.("expected")] string doNotPopulateThisValue1 = null, [.("stringComparison")] string doNotPopulateThisValue2 = null) { }
        public static .<.<TInner>, ..EnumerableContainsExpectedFuncAssertCondition<.<TInner>, TInner>, TInner> Contains<TInner>(this ..IValueSource<.<TInner>> valueSource, <TInner, bool> matcher, [.("matcher")] string doNotPopulateThisValue = null) { }
        public static .<TActual> Contains<TActual, TInner>(this ..IValueSource<TActual> valueSource, TInner expected, .<TInner> equalityComparer = null, [.("expected")] string doNotPopulateThisValue = null)
            where TActual : .<TInner> { }
        public static .<.<TKey, TValue>> ContainsKey<TKey, TValue>(this ..IValueSource<.<TKey, TValue>> valueSource, TKey expected, .<TKey> equalityComparer = null, [.("expected")] string doNotPopulateThisValue = null) { }
        public static .<TDictionary> ContainsKey<TDictionary, TKey>(this ..IValueSource<TDictionary> valueSource, TKey expected, .<TKey> equalityComparer = null, [.("expected")] string doNotPopulateThisValue = null)
            where TDictionary : .IDictionary { }
        public static .<.<TInner>> ContainsOnly<TInner>(this ..IValueSource<.<TInner>> valueSource, <TInner, bool> matcher, [.("matcher")] string doNotPopulateThisValue = null) { }
        public static .<TDictionary> ContainsValue<TDictionary, TValue>(this ..IValueSource<TDictionary> valueSource, TValue expected, .<TValue> equalityComparer = null, [.("expected")] string doNotPopulateThisValue = null)
            where TDictionary : .IDictionary { }
        public static .<string> EndsWith(this ..IValueSource<string> valueSource, string expected, [.("expected")] string doNotPopulateThisValue = null) { }
        public static .<string> EndsWith(this ..IValueSource<string> valueSource, string expected,  stringComparison, [.("expected")] string doNotPopulateThisValue1 = null, [.("stringComparison")] string doNotPopulateThisValue2 = null) { }
        public static .<string> Matches(this ..IValueSource<string> valueSource, . regex, [.("regex")] string expression = "") { }
        public static .<string> Matches(this ..IValueSource<string> valueSource, string regex, [.("regex")] string expression = "") { }
        public static .<string> StartsWith(this ..IValueSource<string> valueSource, string expected, [.("expected")] string doNotPopulateThisValue = null) { }
        public static .<string> StartsWith(this ..IValueSource<string> valueSource, string expected,  stringComparison, [.("expected")] string doNotPopulateThisValue1 = null, [.("stringComparison")] string doNotPopulateThisValue2 = null) { }
    }
    public static class DoesNotExtensions
    {
        public static .<string> DoesNotContain(this ..IValueSource<string> valueSource, string expected, [.("expected")] string doNotPopulateThisValue = null) { }
        public static .<string> DoesNotContain(this ..IValueSource<string> valueSource, string expected,  stringComparison, [.("expected")] string doNotPopulateThisValue1 = null, [.("stringComparison")] string doNotPopulateThisValue2 = null) { }
        public static .<.<TInner>> DoesNotContain<TInner>(this ..IValueSource<.<TInner>> valueSource, <TInner, bool> matcher, [.("matcher")] string? doNotPopulateThisValue = null) { }
        public static .<TActual> DoesNotContain<TActual, TInner>(this ..IValueSource<TActual> valueSource, TInner expected, .<TInner?>? equalityComparer = null, [.("expected")] string? doNotPopulateThisValue = null)
            where TActual : .<TInner> { }
        public static .<.<TKey, TValue>> DoesNotContainKey<TKey, TValue>(this ..IValueSource<.<TKey, TValue>> valueSource, TKey expected, .<TKey> equalityComparer = null, [.("expected")] string doNotPopulateThisValue = null) { }
        public static .<TDictionary> DoesNotContainKey<TDictionary, TKey>(this ..IValueSource<TDictionary> valueSource, TKey expected, .<TKey> equalityComparer = null, [.("expected")] string doNotPopulateThisValue = null)
            where TDictionary : .IDictionary { }
        public static .<.<TKey, TValue>> DoesNotContainValue<TKey, TValue>(this ..IValueSource<.<TKey, TValue>> valueSource, TValue expected, .<TValue> equalityComparer = null, [.("expected")] string doNotPopulateThisValue = null) { }
        public static .<TDictionary> DoesNotContainValue<TDictionary, TValue>(this ..IValueSource<TDictionary> valueSource, TValue expected, .<TValue> equalityComparer = null, [.("expected")] string doNotPopulateThisValue = null)
            where TDictionary : .IDictionary { }
        public static .<string> DoesNotEndWith(this ..IValueSource<string> valueSource, string expected, [.("expected")] string doNotPopulateThisValue = null) { }
        public static .<string> DoesNotEndWith(this ..IValueSource<string> valueSource, string expected,  stringComparison, [.("expected")] string doNotPopulateThisValue1 = null, [.("stringComparison")] string doNotPopulateThisValue2 = null) { }
        public static .<string> DoesNotMatch(this ..IValueSource<string> valueSource, . regex, [.("regex")] string expression = "") { }
        public static .<string> DoesNotMatch(this ..IValueSource<string> valueSource, string regex, [.("regex")] string expression = "") { }
        public static .<string> DoesNotStartWith(this ..IValueSource<string> valueSource, string expected, [.("expected")] string doNotPopulateThisValue = null) { }
        public static .<string> DoesNotStartWith(this ..IValueSource<string> valueSource, string expected,  stringComparison, [.("expected")] string doNotPopulateThisValue1 = null, [.("stringComparison")] string doNotPopulateThisValue2 = null) { }
    }
    public class EnumerableCount<TActual, TInner>
        where TActual : .<TInner>
    {
        public EnumerableCount(..IValueSource<TActual> valueSource) { }
        public .<TActual> Empty { get; }
        public .<TActual> EqualTo(int expected, [.("expected")] string? doNotPopulateThisValue = null) { }
        public .<TActual> EqualToOne() { }
        public .<TActual> EqualToZero() { }
        public .<TActual> GreaterThan(int expected, [.("expected")] string? doNotPopulateThisValue = null) { }
        public .<TActual> GreaterThanOrEqualTo(int expected, [.("expected")] string? doNotPopulateThisValue = null) { }
        public .<TActual> LessThan(int expected, [.("expected")] string? doNotPopulateThisValue = null) { }
        public .<TActual> LessThanOrEqualTo(int expected, [.("expected")] string? doNotPopulateThisValue = null) { }
        public .<TActual> Negative() { }
        public .<TActual> Positive() { }
    }
    public static class GenericIsExtensions
    {
        public static .<object> IsAssignableFrom(this ..IValueSource<object> valueSource,  type) { }
        public static .<object> IsAssignableFrom<TExpected>(this ..IValueSource<object> valueSource) { }
        public static .<object> IsAssignableTo(this ..IValueSource<object> valueSource,  type) { }
        public static .<object, TExpected> IsAssignableTo<TExpected>(this ..IValueSource<object> valueSource) { }
        public static ..GenericEqualToAssertionBuilderWrapper<TActual> IsEqualTo<TActual>(this ..IValueSource<TActual> valueSource, TActual expected, [.("expected")] string doNotPopulateThisValue1 = null) { }
        public static ..GenericEqualToAssertionBuilderWrapper<TActual> IsEqualTo<TActual>(this ..IValueSource<TActual> valueSource, TActual expected, .<TActual> equalityComparer, [.("expected")] string doNotPopulateThisValue1 = null) { }
        public static .<TActual> IsEquatableOrEqualTo<TActual>(this ..IValueSource<TActual> valueSource, TActual expected, [.("expected")] string doNotPopulateThisValue1 = null) { }
        public static ..EquivalentToAssertionBuilderWrapper<TActual, TExpected> IsEquivalentTo<TActual, TExpected>(this ..IValueSource<TActual> valueSource, TExpected expected, [.("expected")] string doNotPopulateThisValue1 = null) { }
        public static .<object> IsNotAssignableFrom(this ..IValueSource<object> valueSource,  type) { }
        public static .<object> IsNotAssignableFrom<TExpected>(this ..IValueSource<object> valueSource) { }
        public static .<object> IsNotAssignableTo(this ..IValueSource<object> valueSource,  type) { }
        public static .<object> IsNotAssignableTo<TExpected>(this ..IValueSource<object> valueSource) { }
        public static .<object> IsNotTypeOf(this ..IValueSource<object> valueSource,  type) { }
        public static .<object> IsNotTypeOf<TExpected>(this ..IValueSource<object> valueSource) { }
        public static .<TActual> IsNull<TActual>(this ..IValueSource<TActual> valueSource) { }
        public static .<TActual> IsSameReferenceAs<TActual, TExpected>(this ..IValueSource<TActual> valueSource, TExpected expected, [.("expected")] string doNotPopulateThisValue1 = null) { }
        public static .<object> IsTypeOf(this ..IValueSource<object> valueSource,  type) { }
        public static .<object, TExpected> IsTypeOf<TExpected>(this ..IValueSource<object> valueSource) { }
    }
    public static class GenericIsInExtensions
    {
        public static .<TActual> IsIn<TActual>(this ..IValueSource<TActual> valueSource, .<TActual> expected) { }
        public static .<TActual> IsIn<TActual>(this ..IValueSource<TActual> valueSource, params TActual[] expected) { }
        public static .<TActual> IsIn<TActual>(this ..IValueSource<TActual> valueSource, .<TActual> expected, .<TActual> equalityComparer) { }
    }
    public static class GenericIsNotExtensions
    {
        public static .<TActual> IsDefault<TActual>(this ..IValueSource<TActual> valueSource) { }
        public static .<TActual> IsNotDefault<TActual>(this ..IValueSource<TActual> valueSource) { }
        public static ..GenericNotEqualToAssertionBuilderWrapper<TActual> IsNotEqualTo<TActual>(this ..IValueSource<TActual> valueSource, TActual expected, [.("expected")] string? doNotPopulateThisValue = null) { }
        public static .<TActual> IsNotEquatableOrEqualTo<TActual>(this ..IValueSource<TActual> valueSource, TActual expected, [.("expected")] string? doNotPopulateThisValue = null) { }
        public static ..NotEquivalentToAssertionBuilderWrapper<TActual, TExpected> IsNotEquivalentTo<TActual, TExpected>(this ..IValueSource<TActual> valueSource, TExpected expected, [.("expected")] string? doNotPopulateThisValue1 = null) { }
        public static ..NotNullAssertionBuilderWrapper<TActual> IsNotNull<TActual>(this ..IValueSource<TActual?> valueSource)
            where TActual :  class { }
        public static ..NotNullStructAssertionBuilderWrapper<TActual> IsNotNull<TActual>(this ..IValueSource<TActual?> valueSource)
            where TActual :  struct { }
        public static .<TActual> IsNotSameReferenceAs<TActual, TExpected>(this ..IValueSource<TActual> valueSource, TExpected expected, [.("expected")] string? doNotPopulateThisValue1 = null) { }
    }
    public static class GenericSatisfiesExtensions
    {
        public static .CollectionWrapper<TInner> All<TInner>(this ..IValueSource<.<TInner>> valueSource) { }
        public static .<TActual> Satisfies<TActual, TExpected>(this ..IValueSource<TActual> valueSource, <TActual, .<TExpected>?> asyncMapper, <..IValueSource<TExpected?>, .<TExpected?>> assert, [.("asyncMapper")] string mapperExpression = "", [.("assert")] string assertionBuilderExpression = "") { }
        public static .<TActual> Satisfies<TActual, TExpected>(this ..IValueSource<TActual> valueSource, <TActual, TExpected> mapper, <..IValueSource<TExpected?>, .<TExpected?>> assert, [.("mapper")] string mapperExpression = "", [.("assert")] string assertionBuilderExpression = "") { }
    }
    public static class HasExtensions
    {
        public static .<.<TInner>, TInner> HasCount<TInner>(this ..IValueSource<.<TInner>> valueSource) { }
        public static .<.<TInner>, TInner> HasCount<TInner>(this ..IValueSource<.<TInner>> valueSource) { }
        public static .<.<TInner>> HasCount<TInner>(this ..IValueSource<.<TInner>> valueSource, int count) { }
        public static .<.<TInner>> HasDistinctItems<TInner>(this ..IValueSource<.<TInner>> valueSource) { }
        public static .<.<TInner>> HasDistinctItems<TInner>(this ..IValueSource<.<TInner>> valueSource) { }
        public static .<.<TInner>> HasDistinctItems<TInner>(this ..IValueSource<.<TInner>> valueSource, .<TInner> equalityComparer) { }
        public static .<.<TInner>> HasDistinctItems<TInner>(this ..IValueSource<.<TInner>> valueSource, .<TInner> equalityComparer) { }
        public static . HasLength(this ..IValueSource<string> valueSource) { }
        public static ..Member<TRootObject, TPropertyType> HasMember<TRootObject, TPropertyType>(this ..IValueSource<TRootObject> valueSource, .<<TRootObject, TPropertyType>> selector, [.("selector")] string expression = "") { }
        public static .<TActual> HasMessageContaining<TActual>(this ..IValueSource<TActual> valueSource, string expected, [.("expected")] string doNotPopulateThisValue = null)
            where TActual :  { }
        public static .<TActual> HasMessageContaining<TActual>(this ..IValueSource<TActual> valueSource, string expected,  stringComparison, [.("expected")] string doNotPopulateThisValue1 = null, [.("stringComparison")] string doNotPopulateThisValue2 = null)
            where TActual :  { }
        public static .<TActual> HasMessageEndingWith<TActual>(this ..IValueSource<TActual> valueSource, string expected, [.("expected")] string doNotPopulateThisValue = null)
            where TActual :  { }
        public static .<TActual> HasMessageEndingWith<TActual>(this ..IValueSource<TActual> valueSource, string expected,  stringComparison, [.("expected")] string doNotPopulateThisValue1 = null, [.("stringComparison")] string doNotPopulateThisValue2 = null)
            where TActual :  { }
        public static .<TActual> HasMessageEqualTo<TActual>(this ..IValueSource<TActual> valueSource, string expected, [.("expected")] string doNotPopulateThisValue = null)
            where TActual :  { }
        public static .<TActual> HasMessageEqualTo<TActual>(this ..IValueSource<TActual> valueSource, string expected,  stringComparison, [.("expected")] string doNotPopulateThisValue1 = null, [.("stringComparison")] string doNotPopulateThisValue2 = null)
            where TActual :  { }
        public static .<TActual> HasMessageMatching<TActual>(this ..IValueSource<TActual> valueSource, . expected,  stringComparison, [.("expected")] string doNotPopulateThisValue1 = null, [.("stringComparison")] string doNotPopulateThisValue2 = null)
            where TActual :  { }
        public static .<TActual> HasMessageStartingWith<TActual>(this ..IValueSource<TActual> valueSource, string expected, [.("expected")] string doNotPopulateThisValue = null)
            where TActual :  { }
        public static .<TActual> HasMessageStartingWith<TActual>(this ..IValueSource<TActual> valueSource, string expected,  stringComparison, [.("expected")] string doNotPopulateThisValue1 = null, [.("stringComparison")] string doNotPopulateThisValue2 = null)
            where TActual :  { }
        public static ..SingleItemAssertionBuilderWrapper<.<TInner>, TInner> HasSingleItem<TInner>(this ..IValueSource<.<TInner>> valueSource) { }
        public static ..SingleItemAssertionBuilderWrapper<.<TInner>, TInner> HasSingleItem<TInner>(this ..IValueSource<.<TInner>> valueSource) { }
    }
    public static class ImmutableArrayIsExtensions
    {
        public static .<.<TInner>> IsEmpty<TInner>(this ..IValueSource<.<TInner>> valueSource) { }
        public static .<.<TInner>> IsEquivalentTo<TInner>(this ..IValueSource<.<TInner>> valueSource, .<TInner> expected, [.("expected")] string doNotPopulateThisValue = null) { }
        public static .<.<TInner>> IsEquivalentTo<TInner>(this ..IValueSource<.<TInner>> valueSource, .<TInner> expected, .<TInner> comparer, [.("expected")] string doNotPopulateThisValue = null) { }
        public static .<.<TInner>> IsEquivalentTo<TInner>(this ..IValueSource<.<TInner>> valueSource, .<TInner> expected, . collectionOrdering, [.("expected")] string doNotPopulateThisValue = null) { }
        public static .<.<TInner>> IsEquivalentTo<TInner>(this ..IValueSource<.<TInner>> valueSource, .<TInner> expected, .<TInner> comparer, . collectionOrdering, [.("expected")] string doNotPopulateThisValue = null) { }
        public static .<.<TInner>> IsInDescendingOrder<TInner>(this ..IValueSource<.<TInner>> valueSource) { }
        public static .<.<TInner>> IsInDescendingOrder<TInner>(this ..IValueSource<.<TInner>> valueSource, .<TInner> comparer) { }
        public static .<.<TInner>> IsInOrder<TInner>(this ..IValueSource<.<TInner>> valueSource) { }
        public static .<.<TInner>> IsInOrder<TInner>(this ..IValueSource<.<TInner>> valueSource, .<TInner> comparer) { }
        public static .<.<TInner>> IsOrderedBy<TInner, TComparisonItem>(this ..IValueSource<.<TInner>> valueSource, <TInner, TComparisonItem> comparisonItemSelector, [.("comparisonItemSelector")] string doNotPopulateThisValue = null) { }
        public static .<.<TInner>> IsOrderedBy<TInner, TComparisonItem>(this ..IValueSource<.<TInner>> valueSource, <TInner, TComparisonItem> comparisonItemSelector, .<TComparisonItem> comparer, [.("comparisonItemSelector")] string doNotPopulateThisValue = null, [.("comparer")] string doNotPopulateThisValue2 = null) { }
        public static .<.<TInner>> IsOrderedByDescending<TInner, TComparisonItem>(this ..IValueSource<.<TInner>> valueSource, <TInner, TComparisonItem> comparisonItemSelector, [.("comparisonItemSelector")] string doNotPopulateThisValue = null) { }
        public static .<.<TInner>> IsOrderedByDescending<TInner, TComparisonItem>(this ..IValueSource<.<TInner>> valueSource, <TInner, TComparisonItem> comparisonItemSelector, .<TComparisonItem> comparer, [.("comparisonItemSelector")] string doNotPopulateThisValue = null, [.("comparer")] string doNotPopulateThisValue2 = null) { }
    }
    public static class ImmutableArrayIsNotExtensions
    {
        public static .<.<TInner>> IsNotEmpty<TInner>(this ..IValueSource<.<TInner>> valueSource) { }
        public static .<.<TInner>> IsNotEquivalentTo<TInner>(this ..IValueSource<.<TInner>> valueSource, .<TInner> expected, [.("expected")] string doNotPopulateThisValue = null) { }
        public static .<.<TInner>> IsNotEquivalentTo<TInner>(this ..IValueSource<.<TInner>> valueSource, .<TInner> expected, .<TInner> comparer, [.("expected")] string doNotPopulateThisValue = null, [.("comparer")] string doNotPopulateThisValue2 = null) { }
        public static .<.<TInner>> IsNotEquivalentTo<TInner>(this ..IValueSource<.<TInner>> valueSource, .<TInner> expected, . collectionOrdering, [.("expected")] string doNotPopulateThisValue = null, [.("collectionOrdering")] string doNotPopulateThisValue2 = null) { }
        public static .<.<TInner>> IsNotEquivalentTo<TInner>(this ..IValueSource<.<TInner>> valueSource, .<TInner> expected, .<TInner> comparer, . collectionOrdering, [.("expected")] string doNotPopulateThisValue = null, [.("collectionOrdering")] string doNotPopulateThisValue2 = null) { }
    }
    public static class SourceExtensions
    {
        public static . RegisterAssertion<TActual>(this ..IDelegateSource delegateSource, .<TActual> assertCondition, string?[] argumentExpressions, [.] string? caller = null) { }
        public static .<TActual> RegisterAssertion<TActual>(this ..IValueSource<TActual> source, .<TActual> assertCondition, string?[] argumentExpressions, [.] string? caller = null) { }
        public static .<TToType> RegisterConversionAssertion<TToType>(this ..IDelegateSource source)
            where TToType :  { }
        public static .<TToType> RegisterConversionAssertion<TFromType, TToType>(this ..IValueSource<TFromType> source, .<TFromType, TToType> assertCondition, string?[] argumentExpressions, [.] string? caller = null) { }
    }
    public static class StringExtensions
    {
        public static string GetStringOr(this string? value, string defaultValue) { }
        public static string GetStringOrEmpty(this string? value) { }
        public static string PrependAOrAn(this string value) { }
        public static string ReplaceNewLines(this string value) { }
        public static string ShowNewLines(this string value) { }
        public static string TruncateWithEllipsis(this string value, int maxLength) { }
    }
    public static class StringIsExtensions
    {
        public static .<string> IsEmpty(this ..IValueSource<string> valueSource) { }
        public static ..StringEqualToAssertionBuilderWrapper IsEqualTo(this ..IValueSource<string> valueSource, string expected, [.("expected")] string doNotPopulateThisValue1 = null) { }
        public static ..StringEqualToAssertionBuilderWrapper IsEqualTo(this ..IValueSource<string> valueSource, string expected,  stringComparison, [.("expected")] string doNotPopulateThisValue1 = null, [.("stringComparison")] string doNotPopulateThisValue2 = null) { }
        public static .<string> IsNullOrEmpty(this ..IValueSource<string> valueSource) { }
        public static .<string> IsNullOrWhitespace(this ..IValueSource<string> valueSource) { }
    }
    public static class StringIsNotExtensions
    {
        public static .<string> IsNotEmpty(this ..IValueSource<string> valueSource) { }
        public static .<string> IsNotEqualTo(this ..IValueSource<string> valueSource, string expected, [.("expected")] string doNotPopulateThisValue = null) { }
        public static .<string> IsNotEqualTo(this ..IValueSource<string> valueSource, string expected,  stringComparison, [.("expected")] string doNotPopulateThisValue1 = null, [.("stringComparison")] string doNotPopulateThisValue2 = null) { }
        public static .<string> IsNotNullOrEmpty(this ..IValueSource<string> valueSource) { }
        public static .<string> IsNotNullOrWhitespace(this ..IValueSource<string> valueSource) { }
    }
    public class StringLength
    {
        public StringLength(..IValueSource<string> valueSource) { }
        public .<string> Positive { get; }
        public .<string> Zero { get; }
        public .<string> EqualTo(int expected, [.("expected")] string? doNotPopulateThisValue = null) { }
        public .<string> GreaterThan(int expected, [.("expected")] string? doNotPopulateThisValue = null) { }
        public .<string> GreaterThanOrEqualTo(int expected, [.("expected")] string? doNotPopulateThisValue = null) { }
        public .<string> LessThan(int expected, [.("expected")] string? doNotPopulateThisValue = null) { }
        public .<string> LessThanOrEqualTo(int expected, [.("expected")] string? doNotPopulateThisValue = null) { }
    }
    public static class TimeSpanExtensions
    {
        public static  Days(this int days) { }
        public static  Hours(this int hours) { }
        public static  Milliseconds(this int milliseconds) { }
        public static  Minutes(this int minutes) { }
        public static  Seconds(this int seconds) { }
    }
    public static class TimeSpanIsExtensions
    {
        public static ..TimeSpanEqualToAssertionBuilderWrapper IsEqualTo(this ..IValueSource<> valueSource,  expected, [.("expected")] string doNotPopulateThisValue1 = null) { }
        public static .<> IsZero(this ..IValueSource<> valueSource) { }
    }
    public static class TimeSpanIsNotExtensions
    {
        public static .<> IsNotZero(this ..IValueSource<> valueSource) { }
    }
}
namespace .Helpers
{
    public static class ExpressionHelpers
    {
        public static string GetName<T1, T2>(.<<T1, T2>> exp) { }
    }
    public abstract class Formatter
    {
        protected Formatter() { }
        public abstract bool CanHandle(object? value);
        public abstract string FormatValue(object? value);
        public static string Format(object? value) { }
    }
    public class StringDifference
    {
        public StringDifference(string? actualValue, string? expectedValue, .<string>? comparer = null) { }
        public int IgnoreWhiteSpace { get; set; }
        public int? OverriddenIndex { get; set; }
        public int IndexOfFirstMismatch() { }
        public override string ToString() { }
        public string ToString(string prefix) { }
    }
    public static class TimeSpanFormatter
    {
        public static string PrettyPrint(this  timeSpan) { }
    }
}