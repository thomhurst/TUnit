[assembly: .(".NETStandard,Version=v2.0", FrameworkDisplayName=".NET Standard 2.0")]
namespace 
{
    public static class Assert
    {
        public static void Fail(string reason) { }
        public static  Multiple() { }
        public static . That( action, [.("action")] string? expression = null) { }
        public static .<object> That(.IEnumerable value, [.("value")] string? expression = null) { }
        public static . That(<.> action, [.("action")] string? expression = null) { }
        public static . That(. task, [.("task")] string? expression = null) { }
        public static .<TItem> That<TItem>(.<TItem> value, [.("value")] string? expression = null) { }
        public static .<TItem> That<TItem>(.<TItem> value, [.("value")] string? expression = null) { }
        public static .<TValue> That<TValue>(<.<TValue>> func, [.("func")] string? expression = null) { }
        public static .<TValue> That<TValue>(<TValue> func, [.("func")] string? expression = null) { }
        public static .<TValue> That<TValue>(.<TValue> task, [.("task")] string? expression = null) { }
        public static .<TItem> That<TItem>(TItem[] value, [.("value")] string? expression = null) { }
        public static .<TValue> That<TValue>(TValue? value, [.("value")] string? expression = null) { }
        public static .<TKey, TValue> That<TKey, TValue>(.<TKey, TValue> value, [.("value")] string? expression = null)
            where TKey :  notnull { }
        public static .<TKey, TValue> That<TKey, TValue>(.<TKey, TValue> value, [.("value")] string? expression = null) { }
        public static .<TKey, TValue> That<TKey, TValue>(.<TKey, TValue> value, [.("value")] string? expression = null)
            where TKey :  notnull { }
        public static .<TKey, TValue> That<TKey, TValue>(.<TKey, TValue> value, [.("value")] string? expression = null)
            where TKey :  notnull { }
        public static TException Throws<TException>( action)
            where TException :  { }
        public static .<> ThrowsAsync(<.> action) { }
        public static .<> ThrowsAsync(. task) { }
        public static .<> ThrowsAsync(. task) { }
        public static .<?> ThrowsAsync( exceptionType, <.> action) { }
        public static .<TException> ThrowsAsync<TException>(<.> action)
            where TException :  { }
        public static .<TException> ThrowsAsync<TException>(string parameterName, <.> action)
            where TException :  { }
        public static TException ThrowsExactly<TException>( action)
            where TException :  { }
        public static TException ThrowsExactly<TException>(string parameterName,  action)
            where TException :  { }
        public static .<TException> ThrowsExactlyAsync<TException>(<.> action)
            where TException :  { }
        public static .<TException> ThrowsExactlyAsync<TException>(string parameterName, <.> action)
            where TException :  { }
    }
    public static class Fail
    {
        public static void Test(string reason) { }
        public static void Unless([.(false)] bool condition, string reason) { }
        public static void When([.(true)] bool condition, string reason) { }
    }
    public class StringMatcher
    {
        public .StringMatcher IgnoringCase() { }
        public bool IsMatch(string? input) { }
        public override string ToString() { }
        public static .StringMatcher AsRegex(string pattern) { }
        public static .StringMatcher AsWildcard(string pattern) { }
    }
}
namespace .
{
    public class DoesNotHaveFlagAssertion<TEnum> : .<TEnum>
        where TEnum :  struct, 
    {
        public DoesNotHaveFlagAssertion(.<TEnum> context, TEnum unexpectedFlag) { }
        protected override .<.> CheckAsync(.<TEnum> metadata) { }
        protected override string GetExpectation() { }
    }
    public class DoesNotHaveSameNameAsAssertion<TEnum> : .<TEnum>
        where TEnum :  struct, 
    {
        public DoesNotHaveSameNameAsAssertion(.<TEnum> context,  otherEnumValue) { }
        protected override .<.> CheckAsync(.<TEnum> metadata) { }
        protected override string GetExpectation() { }
    }
    public class DoesNotHaveSameValueAsAssertion<TEnum> : .<TEnum>
        where TEnum :  struct, 
    {
        public DoesNotHaveSameValueAsAssertion(.<TEnum> context,  otherEnumValue) { }
        protected override .<.> CheckAsync(.<TEnum> metadata) { }
        protected override string GetExpectation() { }
    }
    public class HasFlagAssertion<TEnum> : .<TEnum>
        where TEnum :  struct, 
    {
        public HasFlagAssertion(.<TEnum> context, TEnum expectedFlag) { }
        protected override .<.> CheckAsync(.<TEnum> metadata) { }
        protected override string GetExpectation() { }
    }
    public class HasSameNameAsAssertion<TEnum> : .<TEnum>
        where TEnum :  struct, 
    {
        public HasSameNameAsAssertion(.<TEnum> context,  otherEnumValue) { }
        protected override .<.> CheckAsync(.<TEnum> metadata) { }
        protected override string GetExpectation() { }
    }
    public class HasSameValueAsAssertion<TEnum> : .<TEnum>
        where TEnum :  struct, 
    {
        public HasSameValueAsAssertion(.<TEnum> context,  otherEnumValue) { }
        protected override .<.> CheckAsync(.<TEnum> metadata) { }
        protected override string GetExpectation() { }
    }
    public class IsDefinedAssertion<TEnum> : .<TEnum>
        where TEnum :  struct, 
    {
        public IsDefinedAssertion(.<TEnum> context) { }
        protected override .<.> CheckAsync(.<TEnum> metadata) { }
        protected override string GetExpectation() { }
    }
    public class IsNotDefinedAssertion<TEnum> : .<TEnum>
        where TEnum :  struct, 
    {
        public IsNotDefinedAssertion(.<TEnum> context) { }
        protected override .<.> CheckAsync(.<TEnum> metadata) { }
        protected override string GetExpectation() { }
    }
}
namespace .
{
    public class IsNotParsableIntoAssertion<T> : .<string>
    {
        public IsNotParsableIntoAssertion(.<string> context) { }
        protected override .<.> CheckAsync(.<string> metadata) { }
        protected override string GetExpectation() { }
        public ..IsNotParsableIntoAssertion<T> WithFormatProvider( formatProvider) { }
    }
    public class IsParsableIntoAssertion<T> : .<string>
    {
        public IsParsableIntoAssertion(.<string> context) { }
        protected override .<.> CheckAsync(.<string> metadata) { }
        protected override string GetExpectation() { }
        public ..IsParsableIntoAssertion<T> WithFormatProvider( formatProvider) { }
    }
    public class WhenParsedIntoAssertion<T> : .<T>, .<T>
    {
        public WhenParsedIntoAssertion(.<string> stringContext, ? formatProvider = null) { }
        protected override .<.> CheckAsync(.<T> metadata) { }
        protected override string GetExpectation() { }
        public ..WhenParsedIntoAssertion<T> WithFormatProvider( formatProvider) { }
    }
}
namespace .Attributes
{
    [(.Class, AllowMultiple=true)]
    public class CreateAssertionAttribute : 
    {
        public CreateAssertionAttribute( targetType, string methodName) { }
        public CreateAssertionAttribute( targetType,  containingType, string methodName) { }
        public ? ContainingType { get; }
        public string? CustomName { get; set; }
        public string MethodName { get; }
        public bool NegateLogic { get; set; }
        public bool RequiresGenericTypeParameter { get; set; }
        public  TargetType { get; }
        public bool TreatAsInstance { get; set; }
    }
    [(.Class, AllowMultiple=true)]
    public class CreateAssertionAttribute<TTarget> : 
    {
        public CreateAssertionAttribute(string methodName) { }
        public CreateAssertionAttribute( containingType, string methodName) { }
        public ? ContainingType { get; }
        public string? CustomName { get; set; }
        public string MethodName { get; }
        public bool NegateLogic { get; set; }
        public bool RequiresGenericTypeParameter { get; set; }
        public  TargetType { get; }
        public bool TreatAsInstance { get; set; }
    }
}
namespace .Chaining
{
    public class AndAssertion<TValue> : .<TValue>
    {
        public AndAssertion(.<TValue> first, .<TValue> second) { }
        public new .<TValue> Or { get; }
        public override .<TValue?> AssertAsync() { }
        protected override string GetExpectation() { }
    }
    public class OrAssertion<TValue> : .<TValue>
    {
        public OrAssertion(.<TValue> first, .<TValue> second) { }
        public new .<TValue> And { get; }
        public override .<TValue?> AssertAsync() { }
        protected override string GetExpectation() { }
    }
}
namespace .Conditions
{
    public class AsyncMappedSatisfiesAssertion<TValue, TMapped> : .<TValue>
    {
        public AsyncMappedSatisfiesAssertion(.<TValue> context, <TValue?, .<TMapped>> selector, <.<TMapped>, .<TMapped>?> assertions, string selectorDescription) { }
        protected override .<.> CheckAsync(.<TValue> metadata) { }
        protected override string GetExpectation() { }
    }
    public abstract class BaseThrowsAssertion<TException, TSelf> : .<TException>
        where TException : 
        where TSelf : .<TException, TSelf>
    {
        protected BaseThrowsAssertion(.<object?> context) { }
        protected abstract bool IsExactTypeMatch { get; }
        protected override sealed .<.> CheckAsync(.<TException> metadata) { }
        protected abstract bool CheckExceptionType( actualException, out string? errorMessage);
        protected override string GetExpectation() { }
        public TSelf HasMessageContaining(string expectedSubstring) { }
        public TSelf HasMessageContaining(string expectedSubstring,  comparison) { }
        public TSelf WithMessage(string expectedMessage) { }
        public TSelf WithMessageContaining(string expectedSubstring) { }
        public TSelf WithMessageContaining(string expectedSubstring,  comparison) { }
        public TSelf WithMessageMatching(.StringMatcher matcher) { }
        public TSelf WithMessageMatching(string pattern) { }
        public TSelf WithMessageNotContaining(string notExpectedSubstring) { }
        public TSelf WithMessageNotContaining(string notExpectedSubstring,  comparison) { }
        public TSelf WithParameterName(string expectedParameterName) { }
    }
    public class BetweenAssertion<TValue> : .<TValue>
        where TValue : <TValue>
    {
        public BetweenAssertion(.<TValue> context, TValue minimum, TValue maximum) { }
        protected override .<.> CheckAsync(.<TValue> metadata) { }
        public .<TValue> Exclusive() { }
        protected override string GetExpectation() { }
        public .<TValue> Inclusive() { }
        public .<TValue> InclusiveMaximum() { }
        public .<TValue> InclusiveMinimum() { }
    }
    public class CanBeCanceledAssertion : .<.CancellationToken>
    {
        public CanBeCanceledAssertion(.<.CancellationToken> context) { }
        protected override .<.> CheckAsync(.<.CancellationToken> metadata) { }
        protected override string GetExpectation() { }
    }
    public class CannotBeCanceledAssertion : .<.CancellationToken>
    {
        public CannotBeCanceledAssertion(.<.CancellationToken> context) { }
        protected override .<.> CheckAsync(.<.CancellationToken> metadata) { }
        protected override string GetExpectation() { }
    }
    public class CollectionAllAssertion<TCollection, TItem> : .<TCollection>
        where TCollection : .<TItem>
    {
        public CollectionAllAssertion(.<TCollection> context, <TItem, bool> predicate, string predicateDescription) { }
        protected override .<.> CheckAsync(.<TCollection> metadata) { }
        protected override string GetExpectation() { }
    }
    public class CollectionAllSatisfyAssertion<TCollection, TItem> : .<TCollection>
        where TCollection : .<TItem>
    {
        public CollectionAllSatisfyAssertion(.<TCollection> context, <.<TItem>> assertion, string assertionDescription) { }
        protected override .<.> CheckAsync(.<TCollection> metadata) { }
        protected override string GetExpectation() { }
    }
    public class CollectionAllSatisfyHelper<TCollection, TItem>
        where TCollection : .<TItem>
    {
        public CollectionAllSatisfyHelper(.<TCollection> context) { }
        public .<TCollection, TItem> Satisfy(<.<TItem>> assertion, [.("assertion")] string? expression = null) { }
        public .<TCollection, TItem, TMapped> Satisfy<TMapped>(<TItem, TMapped> mapper, <.<TMapped>, .<TMapped>?> assertion, [.("mapper")] string? mapperExpression = null, [.("assertion")] string? assertionExpression = null) { }
    }
    public class CollectionAllSatisfyMappedAssertion<TCollection, TItem, TMapped> : .<TCollection>
        where TCollection : .<TItem>
    {
        public CollectionAllSatisfyMappedAssertion(.<TCollection> context, <TItem, TMapped> mapper, <.<TMapped>, .<TMapped>?> assertion, string mapperDescription, string assertionDescription) { }
        protected override .<.> CheckAsync(.<TCollection> metadata) { }
        protected override string GetExpectation() { }
    }
    public class CollectionAnyAssertion<TCollection, TItem> : .<TCollection>
        where TCollection : .<TItem>
    {
        public CollectionAnyAssertion(.<TCollection> context, <TItem, bool> predicate, string predicateDescription) { }
        protected override .<.> CheckAsync(.<TCollection> metadata) { }
        protected override string GetExpectation() { }
    }
    public class CollectionContainsAssertion<TCollection, TItem> : .<TCollection>
        where TCollection : .<TItem>
    {
        public CollectionContainsAssertion(.<TCollection> context, TItem expected, .<TItem>? comparer = null) { }
        protected override .<.> CheckAsync(.<TCollection> metadata) { }
        protected override string GetExpectation() { }
    }
    public class CollectionContainsPredicateAssertion<TCollection, TItem> : .<TItem>
        where TCollection : .<TItem>
    {
        public CollectionContainsPredicateAssertion(.<TCollection> context, <TItem, bool> predicate) { }
        protected override .<.> CheckAsync(.<TItem> metadata) { }
        protected override string GetExpectation() { }
    }
    public class CollectionCountAssertion<TValue> : .<TValue>
        where TValue : .IEnumerable
    {
        public CollectionCountAssertion(.<TValue> context, int expectedCount) { }
        protected override .<.> CheckAsync(.<TValue> metadata) { }
        protected override string GetExpectation() { }
    }
    public class CollectionDoesNotContainAssertion<TCollection, TItem> : .<TCollection>
        where TCollection : .<TItem>
    {
        public CollectionDoesNotContainAssertion(.<TCollection> context, TItem expected, .<TItem>? comparer = null) { }
        protected override .<.> CheckAsync(.<TCollection> metadata) { }
        protected override string GetExpectation() { }
    }
    public class CollectionDoesNotContainPredicateAssertion<TCollection, TItem> : .<TCollection>
        where TCollection : .<TItem>
    {
        public CollectionDoesNotContainPredicateAssertion(.<TCollection> context, <TItem, bool> predicate, string predicateDescription) { }
        protected override .<.> CheckAsync(.<TCollection> metadata) { }
        protected override string GetExpectation() { }
    }
    public class CollectionIsEmptyAssertion<TValue> : .<TValue>
        where TValue : .IEnumerable
    {
        public CollectionIsEmptyAssertion(.<TValue> context) { }
        protected override .<.> CheckAsync(.<TValue> metadata) { }
        protected override string GetExpectation() { }
    }
    public class CollectionIsInDescendingOrderAssertion<TCollection, TItem> : .<TCollection>
        where TCollection : .<TItem>
        where TItem : <TItem>
    {
        public CollectionIsInDescendingOrderAssertion(.<TCollection> context) { }
        protected override .<.> CheckAsync(.<TCollection> metadata) { }
        protected override string GetExpectation() { }
    }
    public class CollectionIsInOrderAssertion<TCollection, TItem> : .<TCollection>
        where TCollection : .<TItem>
        where TItem : <TItem>
    {
        public CollectionIsInOrderAssertion(.<TCollection> context) { }
        protected override .<.> CheckAsync(.<TCollection> metadata) { }
        protected override string GetExpectation() { }
    }
    public class CollectionIsNotEmptyAssertion<TValue> : .<TValue>
        where TValue : .IEnumerable
    {
        public CollectionIsNotEmptyAssertion(.<TValue> context) { }
        protected override .<.> CheckAsync(.<TValue> metadata) { }
        protected override string GetExpectation() { }
    }
    public class CompletesWithinActionAssertion : .<object?>
    {
        public CompletesWithinActionAssertion( action,  timeout, .<object?>? context = null) { }
        protected override .<.> CheckAsync(.<object?> metadata) { }
        protected override string GetExpectation() { }
    }
    public class CompletesWithinAsyncAssertion : .<object?>
    {
        public CompletesWithinAsyncAssertion(<.> asyncAction,  timeout, .<object?>? context = null) { }
        protected override .<.> CheckAsync(.<object?> metadata) { }
        protected override string GetExpectation() { }
    }
    public class DateTimeEqualsAssertion : .<>
    {
        public DateTimeEqualsAssertion(.<> context,  expected) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
        public . Within( tolerance) { }
    }
    public class DateTimeEqualsExactAssertion : .<>
    {
        public DateTimeEqualsExactAssertion(.<> context,  expected) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public class DateTimeOffsetEqualsAssertion : .<>
    {
        public DateTimeOffsetEqualsAssertion(.<> context,  expected) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
        public . Within( tolerance) { }
    }
    public class DictionaryContainsKeyAssertion<TKey, TValue> : .<.<TKey, TValue>>
    {
        public DictionaryContainsKeyAssertion(.<.<TKey, TValue>> context, TKey expectedKey, .<TKey>? comparer = null) { }
        protected override .<.> CheckAsync(.<.<TKey, TValue>> metadata) { }
        protected override string GetExpectation() { }
    }
    public class DictionaryDoesNotContainKeyAssertion<TKey, TValue> : .<.<TKey, TValue>>
    {
        public DictionaryDoesNotContainKeyAssertion(.<.<TKey, TValue>> context, TKey expectedKey) { }
        protected override .<.> CheckAsync(.<.<TKey, TValue>> metadata) { }
        protected override string GetExpectation() { }
    }
    public class DirectoryDoesNotExistAssertion : .<.DirectoryInfo>
    {
        public DirectoryDoesNotExistAssertion(.<.DirectoryInfo> context) { }
        protected override .<.> CheckAsync(.<.DirectoryInfo> metadata) { }
        protected override string GetExpectation() { }
    }
    public class DirectoryExistsAssertion : .<.DirectoryInfo>
    {
        public DirectoryExistsAssertion(.<.DirectoryInfo> context) { }
        protected override .<.> CheckAsync(.<.DirectoryInfo> metadata) { }
        protected override string GetExpectation() { }
    }
    public class DirectoryHasFilesAssertion : .<.DirectoryInfo>
    {
        public DirectoryHasFilesAssertion(.<.DirectoryInfo> context) { }
        protected override .<.> CheckAsync(.<.DirectoryInfo> metadata) { }
        protected override string GetExpectation() { }
    }
    public class DirectoryHasNoSubdirectoriesAssertion : .<.DirectoryInfo>
    {
        public DirectoryHasNoSubdirectoriesAssertion(.<.DirectoryInfo> context) { }
        protected override .<.> CheckAsync(.<.DirectoryInfo> metadata) { }
        protected override string GetExpectation() { }
    }
    public class DirectoryIsNotEmptyAssertion : .<.DirectoryInfo>
    {
        public DirectoryIsNotEmptyAssertion(.<.DirectoryInfo> context) { }
        protected override .<.> CheckAsync(.<.DirectoryInfo> metadata) { }
        protected override string GetExpectation() { }
    }
    public class DoubleEqualsAssertion : .<double>
    {
        public DoubleEqualsAssertion(.<double> context, double expected) { }
        protected override .<.> CheckAsync(.<double> metadata) { }
        protected override string GetExpectation() { }
        public . Within(double tolerance) { }
    }
    public class EqualsAssertion<TValue> : .<TValue>
    {
        public EqualsAssertion(.<TValue> context, TValue expected, .<TValue>? comparer = null) { }
        public TValue Expected { get; }
        protected override .<.> CheckAsync(.<TValue> metadata) { }
        protected override string GetExpectation() { }
        public .<TValue> IgnoringType( type) { }
        public .<TValue> IgnoringType<TIgnore>() { }
        public .<TValue> Within(object tolerance) { }
    }
    public class ExceptionMessageAssertion : .<object?>
    {
        public ExceptionMessageAssertion(.<object?> context, string expectedSubstring,  comparison = 4) { }
        protected override .<.> CheckAsync(.<object?> metadata) { }
        protected override string GetExpectation() { }
    }
    public class FalseAssertion : .<bool>
    {
        public FalseAssertion(.<bool> context) { }
        protected override .<.> CheckAsync(.<bool> metadata) { }
        protected override string GetExpectation() { }
    }
    public class FileDoesNotExistAssertion : .<.FileInfo>
    {
        public FileDoesNotExistAssertion(.<.FileInfo> context) { }
        protected override .<.> CheckAsync(.<.FileInfo> metadata) { }
        protected override string GetExpectation() { }
    }
    public class FileExistsAssertion : .<.FileInfo>
    {
        public FileExistsAssertion(.<.FileInfo> context) { }
        protected override .<.> CheckAsync(.<.FileInfo> metadata) { }
        protected override string GetExpectation() { }
    }
    public class FileIsNotEmptyAssertion : .<.FileInfo>
    {
        public FileIsNotEmptyAssertion(.<.FileInfo> context) { }
        protected override .<.> CheckAsync(.<.FileInfo> metadata) { }
        protected override string GetExpectation() { }
    }
    public class FileIsNotExecutableAssertion : .<.FileInfo>
    {
        public FileIsNotExecutableAssertion(.<.FileInfo> context) { }
        protected override .<.> CheckAsync(.<.FileInfo> metadata) { }
        protected override string GetExpectation() { }
    }
    public class FileIsNotHiddenAssertion : .<.FileInfo>
    {
        public FileIsNotHiddenAssertion(.<.FileInfo> context) { }
        protected override .<.> CheckAsync(.<.FileInfo> metadata) { }
        protected override string GetExpectation() { }
    }
    public class FileIsNotReadOnlyAssertion : .<.FileInfo>
    {
        public FileIsNotReadOnlyAssertion(.<.FileInfo> context) { }
        protected override .<.> CheckAsync(.<.FileInfo> metadata) { }
        protected override string GetExpectation() { }
    }
    public class FileIsNotSystemAssertion : .<.FileInfo>
    {
        public FileIsNotSystemAssertion(.<.FileInfo> context) { }
        protected override .<.> CheckAsync(.<.FileInfo> metadata) { }
        protected override string GetExpectation() { }
    }
    public class GreaterThanAssertion<TValue> : .<TValue>
        where TValue : <TValue>
    {
        public GreaterThanAssertion(.<TValue> context, TValue minimum) { }
        protected override .<.> CheckAsync(.<TValue> metadata) { }
        protected override string GetExpectation() { }
    }
    public class GreaterThanOrEqualAssertion<TValue> : .<TValue>
        where TValue : <TValue>
    {
        public GreaterThanOrEqualAssertion(.<TValue> context, TValue minimum) { }
        protected override .<.> CheckAsync(.<TValue> metadata) { }
        protected override string GetExpectation() { }
    }
    public class HasDistinctItemsAssertion<TValue> : .<TValue>
        where TValue : .IEnumerable
    {
        public HasDistinctItemsAssertion(.<TValue> context) { }
        protected override .<.> CheckAsync(.<TValue> metadata) { }
        protected override string GetExpectation() { }
    }
    public class HasInnerExceptionAssertion : .<>
    {
        public HasInnerExceptionAssertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public class HasMessageEqualToAssertion<TValue> : .<TValue>
    {
        public HasMessageEqualToAssertion(.<TValue> context, string expectedMessage,  comparison = 4) { }
        protected override .<.> CheckAsync(.<TValue> metadata) { }
        protected override string GetExpectation() { }
    }
    public class HasMessageStartingWithAssertion<TValue> : .<TValue>
    {
        public HasMessageStartingWithAssertion(.<TValue> context, string expectedPrefix,  comparison = 4) { }
        protected override .<.> CheckAsync(.<TValue> metadata) { }
        protected override string GetExpectation() { }
    }
    public class HasNoDataAssertion : .<>
    {
        public HasNoDataAssertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public class HasNoInnerExceptionAssertion : .<>
    {
        public HasNoInnerExceptionAssertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public class HasSingleItemAssertion<TValue> : .<TValue>
        where TValue : .IEnumerable
    {
        public HasSingleItemAssertion(.<TValue> context) { }
        protected override .<.> CheckAsync(.<TValue> metadata) { }
        protected override string GetExpectation() { }
    }
    public class HasStackTraceAssertion : .<>
    {
        public HasStackTraceAssertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public class IsASCIIEncodingAssertion : .<.Encoding>
    {
        public IsASCIIEncodingAssertion(.<.Encoding> context) { }
        protected override .<.> CheckAsync(.<.Encoding> metadata) { }
        protected override string GetExpectation() { }
    }
    public class IsAliveAssertion : .<>
    {
        public IsAliveAssertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public class IsAssignableToAssertion<TValue, TTarget> : .<TValue>
    {
        public IsAssignableToAssertion(.<TValue> context) { }
        protected override .<.> CheckAsync(.<TValue> metadata) { }
        protected override string GetExpectation() { }
    }
    public class IsBigEndianUnicodeEncodingAssertion : .<.Encoding>
    {
        public IsBigEndianUnicodeEncodingAssertion(.<.Encoding> context) { }
        protected override .<.> CheckAsync(.<.Encoding> metadata) { }
        protected override string GetExpectation() { }
    }
    public class IsCancellationRequestedAssertion : .<.CancellationToken>
    {
        public IsCancellationRequestedAssertion(.<.CancellationToken> context) { }
        protected override .<.> CheckAsync(.<.CancellationToken> metadata) { }
        protected override string GetExpectation() { }
    }
    public class IsClientErrorStatusCodeAssertion : .<.HttpStatusCode>
    {
        public IsClientErrorStatusCodeAssertion(.<.HttpStatusCode> context) { }
        protected override .<.> CheckAsync(.<.HttpStatusCode> metadata) { }
        protected override string GetExpectation() { }
    }
    public class IsCollectibleAssertion : .<.Assembly>
    {
        public IsCollectibleAssertion(.<.Assembly> context) { }
        protected override .<.> CheckAsync(.<.Assembly> metadata) { }
        protected override string GetExpectation() { }
    }
    public class IsControlAssertion : .<char>
    {
        public IsControlAssertion(.<char> context) { }
        protected override .<.> CheckAsync(.<char> metadata) { }
        protected override string GetExpectation() { }
    }
    public class IsDaylightSavingTimeAssertion : .<>
    {
        public IsDaylightSavingTimeAssertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public class IsDeadAssertion : .<>
    {
        public IsDeadAssertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public class IsDebugBuildAssertion : .<.Assembly>
    {
        public IsDebugBuildAssertion(.<.Assembly> context) { }
        protected override .<.> CheckAsync(.<.Assembly> metadata) { }
        protected override string GetExpectation() { }
    }
    public class IsDefaultAssertion<TValue> : .<TValue>
    {
        public IsDefaultAssertion(.<TValue> context) { }
        protected override .<.> CheckAsync(.<TValue> metadata) { }
        protected override string GetExpectation() { }
    }
    public class IsDigitAssertion : .<char>
    {
        public IsDigitAssertion(.<char> context) { }
        protected override .<.> CheckAsync(.<char> metadata) { }
        protected override string GetExpectation() { }
    }
    public class IsDynamicAssertion : .<.Assembly>
    {
        public IsDynamicAssertion(.<.Assembly> context) { }
        protected override .<.> CheckAsync(.<.Assembly> metadata) { }
        protected override string GetExpectation() { }
    }
    public class IsEnglishCultureAssertion : .<.CultureInfo>
    {
        public IsEnglishCultureAssertion(.<.CultureInfo> context) { }
        protected override .<.> CheckAsync(.<.CultureInfo> metadata) { }
        protected override string GetExpectation() { }
    }
    public class IsEquatableOrEqualToAssertion<TValue> : .<TValue>
    {
        public IsEquatableOrEqualToAssertion(.<TValue> context, TValue expected) { }
        protected override .<.> CheckAsync(.<TValue> metadata) { }
        protected override string GetExpectation() { }
        public .<TValue> Using(.<TValue> comparer) { }
    }
    public class IsEquivalentToAssertion<TCollection, TItem> : .<TCollection>
        where TCollection : .<TItem>
    {
        public IsEquivalentToAssertion(.<TCollection> context, .<TItem> expected, . ordering = 0) { }
        protected override .<.> CheckAsync(.<TCollection> metadata) { }
        protected override string GetExpectation() { }
        public .<TCollection, TItem> Using(.<TItem> comparer) { }
    }
    public class IsErrorStatusCodeAssertion : .<.HttpStatusCode>
    {
        public IsErrorStatusCodeAssertion(.<.HttpStatusCode> context) { }
        protected override .<.> CheckAsync(.<.HttpStatusCode> metadata) { }
        protected override string GetExpectation() { }
    }
    public class IsFridayAssertion : .<>
    {
        public IsFridayAssertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public class IsFullyTrustedAssertion : .<.Assembly>
    {
        public IsFullyTrustedAssertion(.<.Assembly> context) { }
        protected override .<.> CheckAsync(.<.Assembly> metadata) { }
        protected override string GetExpectation() { }
    }
    public class IsHighSurrogateAssertion : .<char>
    {
        public IsHighSurrogateAssertion(.<char> context) { }
        protected override .<.> CheckAsync(.<char> metadata) { }
        protected override string GetExpectation() { }
    }
    public class IsInAssertion<TValue> : .<TValue>
    {
        public IsInAssertion(.<TValue> context, .<TValue> collection) { }
        protected override .<.> CheckAsync(.<TValue> metadata) { }
        protected override string GetExpectation() { }
        public .<TValue> Using(.<TValue> comparer) { }
    }
    public class IsInformationalStatusCodeAssertion : .<.HttpStatusCode>
    {
        public IsInformationalStatusCodeAssertion(.<.HttpStatusCode> context) { }
        protected override .<.> CheckAsync(.<.HttpStatusCode> metadata) { }
        protected override string GetExpectation() { }
    }
    public class IsInvariantCultureAssertion : .<.CultureInfo>
    {
        public IsInvariantCultureAssertion(.<.CultureInfo> context) { }
        protected override .<.> CheckAsync(.<.CultureInfo> metadata) { }
        protected override string GetExpectation() { }
    }
    public class IsLeapYearAssertion : .<>
    {
        public IsLeapYearAssertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public class IsLeftToRightCultureAssertion : .<.CultureInfo>
    {
        public IsLeftToRightCultureAssertion(.<.CultureInfo> context) { }
        protected override .<.> CheckAsync(.<.CultureInfo> metadata) { }
        protected override string GetExpectation() { }
    }
    public class IsLetterAssertion : .<char>
    {
        public IsLetterAssertion(.<char> context) { }
        protected override .<.> CheckAsync(.<char> metadata) { }
        protected override string GetExpectation() { }
    }
    public class IsLetterOrDigitAssertion : .<char>
    {
        public IsLetterOrDigitAssertion(.<char> context) { }
        protected override .<.> CheckAsync(.<char> metadata) { }
        protected override string GetExpectation() { }
    }
    public class IsLowSurrogateAssertion : .<char>
    {
        public IsLowSurrogateAssertion(.<char> context) { }
        protected override .<.> CheckAsync(.<char> metadata) { }
        protected override string GetExpectation() { }
    }
    public class IsLowerAssertion : .<char>
    {
        public IsLowerAssertion(.<char> context) { }
        protected override .<.> CheckAsync(.<char> metadata) { }
        protected override string GetExpectation() { }
    }
    public class IsMondayAssertion : .<>
    {
        public IsMondayAssertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public class IsNeutralCultureAssertion : .<.CultureInfo>
    {
        public IsNeutralCultureAssertion(.<.CultureInfo> context) { }
        protected override .<.> CheckAsync(.<.CultureInfo> metadata) { }
        protected override string GetExpectation() { }
    }
    public class IsNoneAssertion : .<.CancellationToken>
    {
        public IsNoneAssertion(.<.CancellationToken> context) { }
        protected override .<.> CheckAsync(.<.CancellationToken> metadata) { }
        protected override string GetExpectation() { }
    }
    public class IsNotAssignableToAssertion<TValue, TTarget> : .<TValue>
    {
        public IsNotAssignableToAssertion(.<TValue> context) { }
        protected override .<.> CheckAsync(.<TValue> metadata) { }
        protected override string GetExpectation() { }
    }
    public class IsNotCancellationRequestedAssertion : .<.CancellationToken>
    {
        public IsNotCancellationRequestedAssertion(.<.CancellationToken> context) { }
        protected override .<.> CheckAsync(.<.CancellationToken> metadata) { }
        protected override string GetExpectation() { }
    }
    public class IsNotCollectibleAssertion : .<.Assembly>
    {
        public IsNotCollectibleAssertion(.<.Assembly> context) { }
        protected override .<.> CheckAsync(.<.Assembly> metadata) { }
        protected override string GetExpectation() { }
    }
    public class IsNotControlAssertion : .<char>
    {
        public IsNotControlAssertion(.<char> context) { }
        protected override .<.> CheckAsync(.<char> metadata) { }
        protected override string GetExpectation() { }
    }
    public class IsNotDaylightSavingTimeAssertion : .<>
    {
        public IsNotDaylightSavingTimeAssertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public class IsNotDefaultAssertion<TValue> : .<TValue>
    {
        public IsNotDefaultAssertion(.<TValue> context) { }
        protected override .<.> CheckAsync(.<TValue> metadata) { }
        protected override string GetExpectation() { }
    }
    public class IsNotDigitAssertion : .<char>
    {
        public IsNotDigitAssertion(.<char> context) { }
        protected override .<.> CheckAsync(.<char> metadata) { }
        protected override string GetExpectation() { }
    }
    public class IsNotDynamicAssertion : .<.Assembly>
    {
        public IsNotDynamicAssertion(.<.Assembly> context) { }
        protected override .<.> CheckAsync(.<.Assembly> metadata) { }
        protected override string GetExpectation() { }
    }
    public class IsNotEnglishCultureAssertion : .<.CultureInfo>
    {
        public IsNotEnglishCultureAssertion(.<.CultureInfo> context) { }
        protected override .<.> CheckAsync(.<.CultureInfo> metadata) { }
        protected override string GetExpectation() { }
    }
    public class IsNotFullyTrustedAssertion : .<.Assembly>
    {
        public IsNotFullyTrustedAssertion(.<.Assembly> context) { }
        protected override .<.> CheckAsync(.<.Assembly> metadata) { }
        protected override string GetExpectation() { }
    }
    public class IsNotHighSurrogateAssertion : .<char>
    {
        public IsNotHighSurrogateAssertion(.<char> context) { }
        protected override .<.> CheckAsync(.<char> metadata) { }
        protected override string GetExpectation() { }
    }
    public class IsNotInAssertion<TValue> : .<TValue>
    {
        public IsNotInAssertion(.<TValue> context, .<TValue> collection) { }
        protected override .<.> CheckAsync(.<TValue> metadata) { }
        protected override string GetExpectation() { }
        public .<TValue> Using(.<TValue> comparer) { }
    }
    public class IsNotInvariantCultureAssertion : .<.CultureInfo>
    {
        public IsNotInvariantCultureAssertion(.<.CultureInfo> context) { }
        protected override .<.> CheckAsync(.<.CultureInfo> metadata) { }
        protected override string GetExpectation() { }
    }
    public class IsNotLeapYearAssertion : .<>
    {
        public IsNotLeapYearAssertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public class IsNotLetterAssertion : .<char>
    {
        public IsNotLetterAssertion(.<char> context) { }
        protected override .<.> CheckAsync(.<char> metadata) { }
        protected override string GetExpectation() { }
    }
    public class IsNotLetterOrDigitAssertion : .<char>
    {
        public IsNotLetterOrDigitAssertion(.<char> context) { }
        protected override .<.> CheckAsync(.<char> metadata) { }
        protected override string GetExpectation() { }
    }
    public class IsNotLowSurrogateAssertion : .<char>
    {
        public IsNotLowSurrogateAssertion(.<char> context) { }
        protected override .<.> CheckAsync(.<char> metadata) { }
        protected override string GetExpectation() { }
    }
    public class IsNotLowerAssertion : .<char>
    {
        public IsNotLowerAssertion(.<char> context) { }
        protected override .<.> CheckAsync(.<char> metadata) { }
        protected override string GetExpectation() { }
    }
    public class IsNotNeutralCultureAssertion : .<.CultureInfo>
    {
        public IsNotNeutralCultureAssertion(.<.CultureInfo> context) { }
        protected override .<.> CheckAsync(.<.CultureInfo> metadata) { }
        protected override string GetExpectation() { }
    }
    public class IsNotNoneAssertion : .<.CancellationToken>
    {
        public IsNotNoneAssertion(.<.CancellationToken> context) { }
        protected override .<.> CheckAsync(.<.CancellationToken> metadata) { }
        protected override string GetExpectation() { }
    }
    public class IsNotNumberAssertion : .<char>
    {
        public IsNotNumberAssertion(.<char> context) { }
        protected override .<.> CheckAsync(.<char> metadata) { }
        protected override string GetExpectation() { }
    }
    public class IsNotPunctuationAssertion : .<char>
    {
        public IsNotPunctuationAssertion(.<char> context) { }
        protected override .<.> CheckAsync(.<char> metadata) { }
        protected override string GetExpectation() { }
    }
    public class IsNotSeparatorAssertion : .<char>
    {
        public IsNotSeparatorAssertion(.<char> context) { }
        protected override .<.> CheckAsync(.<char> metadata) { }
        protected override string GetExpectation() { }
    }
    public class IsNotSignedAssertion : .<.Assembly>
    {
        public IsNotSignedAssertion(.<.Assembly> context) { }
        protected override .<.> CheckAsync(.<.Assembly> metadata) { }
        protected override string GetExpectation() { }
    }
    public class IsNotSingleByteEncodingAssertion : .<.Encoding>
    {
        public IsNotSingleByteEncodingAssertion(.<.Encoding> context) { }
        protected override .<.> CheckAsync(.<.Encoding> metadata) { }
        protected override string GetExpectation() { }
    }
    public class IsNotSuccessStatusCodeAssertion : .<.HttpStatusCode>
    {
        public IsNotSuccessStatusCodeAssertion(.<.HttpStatusCode> context) { }
        protected override .<.> CheckAsync(.<.HttpStatusCode> metadata) { }
        protected override string GetExpectation() { }
    }
    public class IsNotSurrogateAssertion : .<char>
    {
        public IsNotSurrogateAssertion(.<char> context) { }
        protected override .<.> CheckAsync(.<char> metadata) { }
        protected override string GetExpectation() { }
    }
    public class IsNotSymbolAssertion : .<char>
    {
        public IsNotSymbolAssertion(.<char> context) { }
        protected override .<.> CheckAsync(.<char> metadata) { }
        protected override string GetExpectation() { }
    }
    public class IsNotTodayAssertion : .<>
    {
        public IsNotTodayAssertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public class IsNotUTF8EncodingAssertion : .<.Encoding>
    {
        public IsNotUTF8EncodingAssertion(.<.Encoding> context) { }
        protected override .<.> CheckAsync(.<.Encoding> metadata) { }
        protected override string GetExpectation() { }
    }
    public class IsNotUpperAssertion : .<char>
    {
        public IsNotUpperAssertion(.<char> context) { }
        protected override .<.> CheckAsync(.<char> metadata) { }
        protected override string GetExpectation() { }
    }
    public class IsNotUtcAssertion : .<>
    {
        public IsNotUtcAssertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public class IsNotWhiteSpaceAssertion : .<char>
    {
        public IsNotWhiteSpaceAssertion(.<char> context) { }
        protected override .<.> CheckAsync(.<char> metadata) { }
        protected override string GetExpectation() { }
    }
    public class IsNumberAssertion : .<char>
    {
        public IsNumberAssertion(.<char> context) { }
        protected override .<.> CheckAsync(.<char> metadata) { }
        protected override string GetExpectation() { }
    }
    public class IsPunctuationAssertion : .<char>
    {
        public IsPunctuationAssertion(.<char> context) { }
        protected override .<.> CheckAsync(.<char> metadata) { }
        protected override string GetExpectation() { }
    }
    public class IsReadOnlyCultureAssertion : .<.CultureInfo>
    {
        public IsReadOnlyCultureAssertion(.<.CultureInfo> context) { }
        protected override .<.> CheckAsync(.<.CultureInfo> metadata) { }
        protected override string GetExpectation() { }
    }
    public class IsRedirectionStatusCodeAssertion : .<.HttpStatusCode>
    {
        public IsRedirectionStatusCodeAssertion(.<.HttpStatusCode> context) { }
        protected override .<.> CheckAsync(.<.HttpStatusCode> metadata) { }
        protected override string GetExpectation() { }
    }
    public class IsReleaseBuildAssertion : .<.Assembly>
    {
        public IsReleaseBuildAssertion(.<.Assembly> context) { }
        protected override .<.> CheckAsync(.<.Assembly> metadata) { }
        protected override string GetExpectation() { }
    }
    public class IsRightToLeftCultureAssertion : .<.CultureInfo>
    {
        public IsRightToLeftCultureAssertion(.<.CultureInfo> context) { }
        protected override .<.> CheckAsync(.<.CultureInfo> metadata) { }
        protected override string GetExpectation() { }
    }
    public class IsSeparatorAssertion : .<char>
    {
        public IsSeparatorAssertion(.<char> context) { }
        protected override .<.> CheckAsync(.<char> metadata) { }
        protected override string GetExpectation() { }
    }
    public class IsServerErrorStatusCodeAssertion : .<.HttpStatusCode>
    {
        public IsServerErrorStatusCodeAssertion(.<.HttpStatusCode> context) { }
        protected override .<.> CheckAsync(.<.HttpStatusCode> metadata) { }
        protected override string GetExpectation() { }
    }
    public class IsSignedAssertion : .<.Assembly>
    {
        public IsSignedAssertion(.<.Assembly> context) { }
        protected override .<.> CheckAsync(.<.Assembly> metadata) { }
        protected override string GetExpectation() { }
    }
    public class IsSingleByteEncodingAssertion : .<.Encoding>
    {
        public IsSingleByteEncodingAssertion(.<.Encoding> context) { }
        protected override .<.> CheckAsync(.<.Encoding> metadata) { }
        protected override string GetExpectation() { }
    }
    public class IsSuccessStatusCodeAssertion : .<.HttpStatusCode>
    {
        public IsSuccessStatusCodeAssertion(.<.HttpStatusCode> context) { }
        protected override .<.> CheckAsync(.<.HttpStatusCode> metadata) { }
        protected override string GetExpectation() { }
    }
    public class IsSurrogateAssertion : .<char>
    {
        public IsSurrogateAssertion(.<char> context) { }
        protected override .<.> CheckAsync(.<char> metadata) { }
        protected override string GetExpectation() { }
    }
    public class IsSymbolAssertion : .<char>
    {
        public IsSymbolAssertion(.<char> context) { }
        protected override .<.> CheckAsync(.<char> metadata) { }
        protected override string GetExpectation() { }
    }
    public class IsTodayAssertion : .<>
    {
        public IsTodayAssertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public class IsTypeOfRuntimeAssertion<TValue> : .<TValue>
    {
        public IsTypeOfRuntimeAssertion(.<TValue> context,  expectedType) { }
        protected override .<.> CheckAsync(.<TValue> metadata) { }
        protected override string GetExpectation() { }
    }
    public class IsUTF32EncodingAssertion : .<.Encoding>
    {
        public IsUTF32EncodingAssertion(.<.Encoding> context) { }
        protected override .<.> CheckAsync(.<.Encoding> metadata) { }
        protected override string GetExpectation() { }
    }
    public class IsUTF8EncodingAssertion : .<.Encoding>
    {
        public IsUTF8EncodingAssertion(.<.Encoding> context) { }
        protected override .<.> CheckAsync(.<.Encoding> metadata) { }
        protected override string GetExpectation() { }
    }
    public class IsUnicodeEncodingAssertion : .<.Encoding>
    {
        public IsUnicodeEncodingAssertion(.<.Encoding> context) { }
        protected override .<.> CheckAsync(.<.Encoding> metadata) { }
        protected override string GetExpectation() { }
    }
    public class IsUpperAssertion : .<char>
    {
        public IsUpperAssertion(.<char> context) { }
        protected override .<.> CheckAsync(.<char> metadata) { }
        protected override string GetExpectation() { }
    }
    public class IsUtcAssertion : .<>
    {
        public IsUtcAssertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public class IsWeekdayAssertion : .<>
    {
        public IsWeekdayAssertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public class IsWeekendAssertion : .<>
    {
        public IsWeekendAssertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public class IsWhiteSpaceAssertion : .<char>
    {
        public IsWhiteSpaceAssertion(.<char> context) { }
        protected override .<.> CheckAsync(.<char> metadata) { }
        protected override string GetExpectation() { }
    }
    public class LessThanAssertion<TValue> : .<TValue>
        where TValue : <TValue>
    {
        public LessThanAssertion(.<TValue> context, TValue maximum) { }
        protected override .<.> CheckAsync(.<TValue> metadata) { }
        protected override string GetExpectation() { }
    }
    public class LessThanOrEqualAssertion<TValue> : .<TValue>
        where TValue : <TValue>
    {
        public LessThanOrEqualAssertion(.<TValue> context, TValue maximum) { }
        protected override .<.> CheckAsync(.<TValue> metadata) { }
        protected override string GetExpectation() { }
    }
    public class LongEqualsAssertion : .<long>
    {
        public LongEqualsAssertion(.<long> context, long expected) { }
        protected override .<.> CheckAsync(.<long> metadata) { }
        protected override string GetExpectation() { }
        public . Within(long tolerance) { }
    }
    public class MappedSatisfiesAssertion<TValue, TMapped> : .<TValue>
    {
        public MappedSatisfiesAssertion(.<TValue> context, <TValue?, TMapped> selector, <.<TMapped>, .<TMapped>?> assertions, string selectorDescription) { }
        protected override .<.> CheckAsync(.<TValue> metadata) { }
        protected override string GetExpectation() { }
    }
    public class MemberAssertion<TObject, TMember> : .<TMember>, .<TMember>
    {
        public MemberAssertion(.<TObject> parentContext, .<<TObject, TMember>> memberSelector) { }
        protected override .<.> CheckAsync(.<TMember> metadata) { }
        protected override string GetExpectation() { }
    }
    public class NotEqualsAssertion<TValue> : .<TValue>
    {
        public NotEqualsAssertion(.<TValue> context, TValue notExpected, .<TValue>? comparer = null) { }
        protected override .<.> CheckAsync(.<TValue> metadata) { }
        protected override string GetExpectation() { }
        public .<TValue> IgnoringType( type) { }
        public .<TValue> IgnoringType<TIgnore>() { }
    }
    public class NotEquivalentToAssertion<TCollection, TItem> : .<TCollection>
        where TCollection : .<TItem>
    {
        public NotEquivalentToAssertion(.<TCollection> context, .<TItem> notExpected, . ordering = 0) { }
        protected override .<.> CheckAsync(.<TCollection> metadata) { }
        protected override string GetExpectation() { }
        public .<TCollection, TItem> Using(.<TItem> comparer) { }
    }
    public class NotNullAssertion<TValue> : .<TValue>
    {
        public NotNullAssertion(.<TValue> context) { }
        protected override .<.> CheckAsync(.<TValue> metadata) { }
        protected override string GetExpectation() { }
    }
    public class NotSameReferenceAssertion<TValue> : .<TValue>
    {
        public NotSameReferenceAssertion(.<TValue> context, object? expected) { }
        protected override .<.> CheckAsync(.<TValue> metadata) { }
        protected override string GetExpectation() { }
    }
    public class NotStructuralEquivalencyAssertion<TValue> : .<TValue>
    {
        public NotStructuralEquivalencyAssertion(.<TValue> context, object? notExpected) { }
        protected override .<.> CheckAsync(.<TValue> metadata) { }
        protected override string GetExpectation() { }
        public .<TValue> IgnoringMember(string memberPath) { }
        public .<TValue> IgnoringType( type) { }
        public .<TValue> IgnoringType<T>() { }
        public .<TValue> WithPartialEquivalency() { }
    }
    public class NullAssertion<TValue> : .<TValue>
    {
        public NullAssertion(.<TValue> context) { }
        protected override .<.> CheckAsync(.<TValue> metadata) { }
        protected override string GetExpectation() { }
    }
    public class SameReferenceAssertion<TValue> : .<TValue>
    {
        public SameReferenceAssertion(.<TValue> context, object? expected) { }
        protected override .<.> CheckAsync(.<TValue> metadata) { }
        protected override string GetExpectation() { }
    }
    public class SatisfiesAssertion<TValue> : .<TValue>
    {
        public SatisfiesAssertion(.<TValue> context, <TValue?, bool> predicate, string predicateDescription) { }
        protected override .<.> CheckAsync(.<TValue> metadata) { }
        protected override string GetExpectation() { }
    }
    public class StringBuilderHasExcessCapacityAssertion : .<.StringBuilder>
    {
        public StringBuilderHasExcessCapacityAssertion(.<.StringBuilder> context) { }
        protected override .<.> CheckAsync(.<.StringBuilder> metadata) { }
        protected override string GetExpectation() { }
    }
    public class StringBuilderIsEmptyAssertion : .<.StringBuilder>
    {
        public StringBuilderIsEmptyAssertion(.<.StringBuilder> context) { }
        protected override .<.> CheckAsync(.<.StringBuilder> metadata) { }
        protected override string GetExpectation() { }
    }
    public class StringBuilderIsNotEmptyAssertion : .<.StringBuilder>
    {
        public StringBuilderIsNotEmptyAssertion(.<.StringBuilder> context) { }
        protected override .<.> CheckAsync(.<.StringBuilder> metadata) { }
        protected override string GetExpectation() { }
    }
    public class StringContainsAssertion : .<string>
    {
        public StringContainsAssertion(.<string> context, string expected) { }
        protected override .<.> CheckAsync(.<string> metadata) { }
        protected override string GetExpectation() { }
        public . IgnoringCase() { }
        public . IgnoringWhitespace() { }
        public . WithComparison( comparison) { }
        public . WithTrimming() { }
    }
    public class StringDoesNotContainAssertion : .<string>
    {
        public StringDoesNotContainAssertion(.<string> context, string expected) { }
        protected override .<.> CheckAsync(.<string> metadata) { }
        protected override string GetExpectation() { }
        public . IgnoringCase() { }
        public . WithComparison( comparison) { }
    }
    public class StringDoesNotMatchAssertion : .<string>
    {
        public StringDoesNotMatchAssertion(.<string> context, string pattern) { }
        protected override .<.> CheckAsync(.<string> metadata) { }
        protected override string GetExpectation() { }
        public . IgnoringCase() { }
        public . WithOptions(. options) { }
    }
    public class StringEndsWithAssertion : .<string>
    {
        public StringEndsWithAssertion(.<string> context, string expected) { }
        protected override .<.> CheckAsync(.<string> metadata) { }
        protected override string GetExpectation() { }
        public . IgnoringCase() { }
        public . WithComparison( comparison) { }
    }
    public class StringEqualsAssertion : .<string>
    {
        public StringEqualsAssertion(.<string> context, string expected) { }
        protected override .<.> CheckAsync(.<string> metadata) { }
        protected override string GetExpectation() { }
        public . IgnoringCase() { }
        public . IgnoringWhitespace() { }
        public . WithComparison( comparison) { }
        public . WithNullAndEmptyEquality() { }
        public . WithTrimming() { }
    }
    public class StringIsEmptyAssertion : .<string>
    {
        public StringIsEmptyAssertion(.<string> context) { }
        protected override .<.> CheckAsync(.<string> metadata) { }
        protected override string GetExpectation() { }
    }
    public class StringIsNotEmptyAssertion : .<string>
    {
        public StringIsNotEmptyAssertion(.<string> context) { }
        protected override .<.> CheckAsync(.<string> metadata) { }
        protected override string GetExpectation() { }
    }
    public class StringIsNotNullOrEmptyAssertion : .<string>
    {
        public StringIsNotNullOrEmptyAssertion(.<string> context) { }
        protected override .<.> CheckAsync(.<string> metadata) { }
        protected override string GetExpectation() { }
    }
    public class StringIsNullOrEmptyAssertion : .<string>
    {
        public StringIsNullOrEmptyAssertion(.<string> context) { }
        protected override .<.> CheckAsync(.<string> metadata) { }
        protected override string GetExpectation() { }
    }
    public class StringIsNullOrWhitespaceAssertion : .<string>
    {
        public StringIsNullOrWhitespaceAssertion(.<string> context) { }
        protected override .<.> CheckAsync(.<string> metadata) { }
        protected override string GetExpectation() { }
    }
    public class StringLengthAssertion : .<string>
    {
        public StringLengthAssertion(.<string> context, int expectedLength) { }
        protected override .<.> CheckAsync(.<string> metadata) { }
        protected override string GetExpectation() { }
    }
    public class StringMatchesAssertion : .<string>
    {
        public StringMatchesAssertion(.<string> context, string pattern) { }
        protected override .<.> CheckAsync(.<string> metadata) { }
        protected override string GetExpectation() { }
        public . IgnoringCase() { }
        public . WithOptions(. options) { }
    }
    public class StringStartsWithAssertion : .<string>
    {
        public StringStartsWithAssertion(.<string> context, string expected) { }
        protected override .<.> CheckAsync(.<string> metadata) { }
        protected override string GetExpectation() { }
        public . IgnoringCase() { }
        public . WithComparison( comparison) { }
    }
    public class StructuralEquivalencyAssertion<TValue> : .<TValue>
    {
        public StructuralEquivalencyAssertion(.<TValue> context, object? expected) { }
        protected override .<.> CheckAsync(.<TValue> metadata) { }
        protected override string GetExpectation() { }
        public .<TValue> IgnoringMember(string memberPath) { }
        public .<TValue> IgnoringType( type) { }
        public .<TValue> IgnoringType<T>() { }
        public .<TValue> WithPartialEquivalency() { }
    }
    public class ThrowsAssertion<TException> : .<TException, .<TException>>
        where TException : 
    {
        public ThrowsAssertion(.<object?> context) { }
        protected override bool IsExactTypeMatch { get; }
        protected override bool CheckExceptionType( actualException, out string? errorMessage) { }
        public .<> WithInnerException() { }
    }
    public class ThrowsExactlyAssertion<TException> : .<TException, .<TException>>
        where TException : 
    {
        public ThrowsExactlyAssertion(.<object?> context) { }
        protected override bool IsExactTypeMatch { get; }
        protected override bool CheckExceptionType( actualException, out string? errorMessage) { }
    }
    public class ThrowsNothingAssertion<TValue> : .<TValue>
    {
        public ThrowsNothingAssertion(.<TValue> context) { }
        protected override .<.> CheckAsync(.<TValue> metadata) { }
        protected override string GetExpectation() { }
    }
    public class TrueAssertion : .<bool>
    {
        public TrueAssertion(.<bool> context) { }
        protected override .<.> CheckAsync(.<bool> metadata) { }
        protected override string GetExpectation() { }
    }
    public class TypeOfAssertion<TFrom, TTo> : .<TTo>
    {
        public TypeOfAssertion(.<TFrom> parentContext) { }
        protected override .<.> CheckAsync(.<TTo> metadata) { }
        protected override string GetExpectation() { }
    }
}
namespace .
{
    public class CountWrapper<TValue> : .<TValue>
        where TValue : .IEnumerable
    {
        public CountWrapper(.<TValue> context) { }
        public .<TValue> EqualTo(int expectedCount, [.("expectedCount")] string? expression = null) { }
        public .<int> GreaterThanOrEqualTo(int expected, [.("expected")] string? expression = null) { }
        public .<int> Positive() { }
    }
    public class LengthWrapper : .<string>
    {
        public LengthWrapper(.<string> context) { }
        public . EqualTo(int expectedLength, [.("expectedLength")] string? expression = null) { }
    }
}
namespace .Core
{
    public class AndContinuation<TValue> : .<TValue>
    {
        public .<TValue> Context { get; }
    }
    public sealed class AssertionContext<TValue>
    {
        public AssertionContext(.<TValue> evaluation, .StringBuilder expressionBuilder) { }
        public AssertionContext(TValue? value, .StringBuilder expressionBuilder) { }
        public .<TValue> Evaluation { get; }
        public .StringBuilder ExpressionBuilder { get; }
        [return: .(new string[] {
                "Value",
                "Exception"})]
        public .<<TValue?, ?>> GetAsync() { }
        [return: .(new string[] {
                "Start",
                "End"})]
        public <, > GetTiming() { }
        public .<TNew> Map<TNew>(<TValue?, TNew?> mapper) { }
    }
    public readonly struct AssertionResult
    {
        public bool IsPassed { get; }
        public string Message { get; }
        public static . Passed { get; }
        public static . FailIf(bool condition, string message) { }
        public static . Failed(string message) { }
    }
    public abstract class Assertion<TValue>
    {
        protected readonly .<TValue> Context;
        protected Assertion(.<TValue> context) { }
        public .<TValue> And { get; }
        public .<TValue> Or { get; }
        protected void AppendExpression(string expression) { }
        public virtual .<TValue?> AssertAsync() { }
        public .<TValue> Because(string message) { }
        protected virtual .<.> CheckAsync(.<TValue> metadata) { }
        protected  CreateException(. result) { }
        public .<TValue?> GetAwaiter() { }
        protected abstract string GetExpectation();
    }
    public enum ChainType
    {
        None = 0,
        And = 1,
        Or = 2,
    }
    public sealed class EvaluationContext<TValue>
    {
        public EvaluationContext(<.<<TValue?, ?>>> evaluator) { }
        public EvaluationContext(TValue? value) { }
        [return: .(new string?[]?[] {
                "Value",
                "Exception"})]
        public .<<TValue?, ?>> GetAsync() { }
        [return: .(new string[] {
                "Start",
                "End"})]
        public <, > GetTiming() { }
        public .<TNew> Map<TNew>(<TValue?, TNew?> mapper) { }
    }
    public readonly struct EvaluationMetadata<TValue>
    {
        public EvaluationMetadata(TValue? value, ? exception,  startTime,  endTime) { }
        public  Duration { get; }
        public  EndTime { get; }
        public ? Exception { get; }
        public  StartTime { get; }
        public TValue Value { get; }
    }
    public interface IAssertionSource<TValue>
    {
        .<TValue> Context { get; }
    }
    public interface IDelegateAssertionSource<TValue> : .<TValue> { }
    public class OrContinuation<TValue> : .<TValue>
    {
        public .<TValue> Context { get; }
    }
}
namespace .Enums
{
    public enum CollectionOrdering
    {
        Any = 0,
        Matching = 1,
    }
}
namespace .Exceptions
{
    public class AssertionException : .
    {
        public AssertionException(string? message) { }
        public AssertionException(string? message,  innerException) { }
    }
    public class BaseAssertionException : 
    {
        public BaseAssertionException() { }
        public BaseAssertionException(string? message) { }
        public BaseAssertionException(string? message, ? innerException) { }
    }
    public class MaybeCaughtException : 
    {
        public MaybeCaughtException( exception) { }
    }
    public class MixedAndOrAssertionsException : .
    {
        public MixedAndOrAssertionsException() { }
    }
}
namespace .Extensions
{
    public static class AssemblyAssertionExtensions
    {
        public static . IsCollectible(this .<.Assembly> source) { }
        public static . IsDebugBuild(this .<.Assembly> source) { }
        public static . IsDynamic(this .<.Assembly> source) { }
        public static . IsFullyTrusted(this .<.Assembly> source) { }
        public static . IsNotCollectible(this .<.Assembly> source) { }
        public static . IsNotDynamic(this .<.Assembly> source) { }
        public static . IsNotFullyTrusted(this .<.Assembly> source) { }
        public static . IsNotSigned(this .<.Assembly> source) { }
        public static . IsReleaseBuild(this .<.Assembly> source) { }
        public static . IsSigned(this .<.Assembly> source) { }
    }
    public static class AssertionExtensions
    {
        public static .<.<TItem>, TItem> All<TItem>(this .<.<TItem>> source) { }
        public static .<.<TItem>, TItem> All<TItem>(this .<.<TItem>> source, <TItem, bool> predicate, [.("predicate")] string? expression = null) { }
        public static .<TCollection, TItem> All<TCollection, TItem>(this .<TCollection> source)
            where TCollection : .<TItem> { }
        public static .<TCollection, TItem> All<TCollection, TItem>(this .<TCollection> source, <TItem, bool> predicate, [.("predicate")] string? expression = null)
            where TCollection : .<TItem> { }
        public static .<TCollection, TItem> Any<TCollection, TItem>(this .<TCollection> source, <TItem, bool> predicate, [.("predicate")] string? expression = null)
            where TCollection : .<TItem> { }
        public static . CompletesWithin(this . source,  timeout, [.("timeout")] string? expression = null) { }
        public static . CompletesWithin(this . source,  timeout, [.("timeout")] string? expression = null) { }
        public static . Contains(this .<string> source, string expected, [.("expected")] string? expression = null) { }
        public static .<.<TItem>, TItem> Contains<TItem>(this .<.<TItem>> source, <TItem, bool> predicate, [.("predicate")] string? expression = null) { }
        public static .<.<TItem>, TItem> Contains<TItem>(this .<.<TItem>> source, TItem expected, [.("expected")] string? expression = null) { }
        public static .<TCollection, TItem> Contains<TCollection, TItem>(this .<TCollection> source, <TItem, bool> predicate, [.("predicate")] string? expression = null)
            where TCollection : .<TItem> { }
        public static .<TCollection, TItem> Contains<TCollection, TItem>(this .<TCollection> source, TItem expected, [.("expected")] string? expression = null)
            where TCollection : .<TItem> { }
        public static .<TKey, TValue> ContainsKey<TKey, TValue>(this .<.<TKey, TValue>> source, TKey key, [.("key")] string? expression = null) { }
        public static .<TKey, TValue> ContainsKey<TKey, TValue>(this .<.<TKey, TValue>> source, TKey key, .<TKey> comparer, [.("key")] string? expression = null) { }
        public static .<TKey, TValue> ContainsKey<TDictionary, TKey, TValue>(this .<TDictionary> source, TKey key, [.("key")] string? expression = null)
            where TDictionary : .<TKey, TValue> { }
        public static .<TKey, TValue> ContainsKey<TDictionary, TKey, TValue>(this .<TDictionary> source, TKey key, .<TKey> comparer, [.("key")] string? expression = null)
            where TDictionary : .<TKey, TValue> { }
        public static .<.<TItem>, TItem> ContainsOnly<TItem>(this .<.<TItem>> source, <TItem, bool> predicate, [.("predicate")] string? expression = null) { }
        public static .<TCollection, TItem> ContainsOnly<TCollection, TItem>(this .<TCollection> source, <TItem, bool> predicate, [.("predicate")] string? expression = null)
            where TCollection : .<TItem> { }
        public static . DoesNotContain(this .<string> source, string expected, [.("expected")] string? expression = null) { }
        public static .<.<TItem>, TItem> DoesNotContain<TItem>(this .<.<TItem>> source, <TItem, bool> predicate, [.("predicate")] string? expression = null) { }
        public static .<.<TItem>, TItem> DoesNotContain<TItem>(this .<.<TItem>> source, TItem expected, [.("expected")] string? expression = null) { }
        public static .<TCollection, TItem> DoesNotContain<TCollection, TItem>(this .<TCollection> source, <TItem, bool> predicate, [.("predicate")] string? expression = null)
            where TCollection : .<TItem> { }
        public static .<TCollection, TItem> DoesNotContain<TCollection, TItem>(this .<TCollection> source, TItem expected, [.("expected")] string? expression = null)
            where TCollection : .<TItem> { }
        public static .<TKey, TValue> DoesNotContainKey<TKey, TValue>(this .<.<TKey, TValue>> source, TKey key, [.("key")] string? expression = null) { }
        public static .<TKey, TValue> DoesNotContainKey<TDictionary, TKey, TValue>(this .<TDictionary> source, TKey key, [.("key")] string? expression = null)
            where TDictionary : .<TKey, TValue> { }
        public static ..DoesNotHaveFlagAssertion<TEnum> DoesNotHaveFlag<TEnum>(this .<TEnum> source, TEnum unexpectedFlag, [.("unexpectedFlag")] string? expression = null)
            where TEnum :  struct,  { }
        public static ..DoesNotHaveSameNameAsAssertion<TEnum> DoesNotHaveSameNameAs<TEnum>(this .<TEnum> source,  otherEnumValue, [.("otherEnumValue")] string? expression = null)
            where TEnum :  struct,  { }
        public static ..DoesNotHaveSameValueAsAssertion<TEnum> DoesNotHaveSameValueAs<TEnum>(this .<TEnum> source,  otherEnumValue, [.("otherEnumValue")] string? expression = null)
            where TEnum :  struct,  { }
        public static . DoesNotMatch(this .<string> source, . regex, [.("regex")] string? expression = null) { }
        public static . DoesNotMatch(this .<string> source, string pattern, [.("pattern")] string? expression = null) { }
        public static . EndsWith(this .<string> source, string expected, [.("expected")] string? expression = null) { }
        public static .<TValue> EqualTo<TValue>(this .<TValue> source, TValue expected, [.("expected")] string? expression = null) { }
        public static ..CountWrapper<TValue> HasCount<TValue>(this .<TValue> source)
            where TValue : .IEnumerable { }
        public static .<TValue> HasCount<TValue>(this .<TValue> source, int expectedCount, [.("expectedCount")] string? expression = null)
            where TValue : .IEnumerable { }
        public static .<TValue> HasDistinctItems<TValue>(this .<TValue> source)
            where TValue : .IEnumerable { }
        public static ..HasFlagAssertion<TEnum> HasFlag<TEnum>(this .<TEnum> source, TEnum expectedFlag, [.("expectedFlag")] string? expression = null)
            where TEnum :  struct,  { }
        public static ..LengthWrapper HasLength(this .<string> source) { }
        public static . HasLength(this .<string> source, int expectedLength, [.("expectedLength")] string? expression = null) { }
        public static .<TObject, TMember> HasMember<TObject, TMember>(this .<TObject> source, .<<TObject, TMember>> memberSelector) { }
        public static . HasMessageContaining<TValue>(this .<TValue> source, string expectedSubstring) { }
        public static . HasMessageContaining<TValue>(this .<TValue> source, string expectedSubstring,  comparison) { }
        public static .<TValue> HasMessageEqualTo<TValue>(this .<TValue> source, string expectedMessage) { }
        public static .<TValue> HasMessageEqualTo<TValue>(this .<TValue> source, string expectedMessage,  comparison) { }
        public static .<TValue> HasMessageStartingWith<TValue>(this .<TValue> source, string expectedPrefix) { }
        public static .<TValue> HasMessageStartingWith<TValue>(this .<TValue> source, string expectedPrefix,  comparison) { }
        public static ..HasSameNameAsAssertion<TEnum> HasSameNameAs<TEnum>(this .<TEnum> source,  otherEnumValue, [.("otherEnumValue")] string? expression = null)
            where TEnum :  struct,  { }
        public static ..HasSameValueAsAssertion<TEnum> HasSameValueAs<TEnum>(this .<TEnum> source,  otherEnumValue, [.("otherEnumValue")] string? expression = null)
            where TEnum :  struct,  { }
        public static .<TValue> HasSingleItem<TValue>(this .<TValue> source)
            where TValue : .IEnumerable { }
        public static .<> IsAfterOrEqualTo(this .<> source,  expected, [.("expected")] string? expression = null) { }
        public static .<object, TTarget> IsAssignableTo<TTarget>(this .<object> source) { }
        public static .<TValue, TTarget> IsAssignableTo<TTarget, TValue>(this .<TValue> source) { }
        public static .<TValue> IsBetween<TValue>(this .<TValue> source, TValue minimum, TValue maximum, [.("minimum")] string? minExpr = null, [.("maximum")] string? maxExpr = null)
            where TValue : <TValue> { }
        public static .<TValue> IsDefault<TValue>(this .<TValue> source) { }
        public static ..IsDefinedAssertion<TEnum> IsDefined<TEnum>(this .<TEnum> source)
            where TEnum :  struct,  { }
        public static . IsEmpty(this .<string> source) { }
        public static .<TValue> IsEmpty<TValue>(this .<TValue> source)
            where TValue : .IEnumerable { }
        public static . IsEqualTo(this .<> source,  expected, [.("expected")] string? expression = null) { }
        public static . IsEqualTo(this .<> source,  expected, [.("expected")] string? expression = null) { }
        public static . IsEqualTo(this .<double> source, double expected, [.("expected")] string? expression = null) { }
        public static . IsEqualTo(this .<long> source, long expected, [.("expected")] string? expression = null) { }
        public static . IsEqualTo(this .<string> source, string expected, [.("expected")] string? expression = null) { }
        public static . IsEqualTo(this .<string> source, string expected,  comparison, [.("expected")] string? expression = null) { }
        public static .<TValue> IsEqualTo<TValue>(this .<TValue> source, TValue expected, [.("expected")] string? expression = null) { }
        public static .<TValue> IsEqualTo<TValue>(this .<TValue> source, TValue expected, .<TValue> comparer, [.("expected")] string? expression = null) { }
        public static .<TValue> IsEquatableOrEqualTo<TValue>(this .<TValue> source, TValue expected, [.("expected")] string? expression = null) { }
        public static .<TValue> IsEquivalentTo<TValue>(this .<TValue> source, object? expected, [.("expected")] string? expression = null) { }
        public static .<TCollection, TItem> IsEquivalentTo<TCollection, TItem>(this .<TCollection> source, .<TItem> expected, [.("expected")] string? expression = null)
            where TCollection : .<TItem> { }
        public static .<TCollection, TItem> IsEquivalentTo<TCollection, TItem>(this .<TCollection> source, .<TItem> expected, .<TItem> comparer, [.("expected")] string? expression = null)
            where TCollection : .<TItem> { }
        public static .<TCollection, TItem> IsEquivalentTo<TCollection, TItem>(this .<TCollection> source, .<TItem> expected, . ordering, [.("expected")] string? expression = null)
            where TCollection : .<TItem> { }
        public static . IsFalse(this .<bool> source) { }
        public static .<TValue> IsGreaterThan<TValue>(this .<TValue> source, TValue minimum, [.("minimum")] string? expression = null)
            where TValue : <TValue> { }
        public static .<TValue> IsGreaterThanOrEqualTo<TValue>(this .<TValue> source, TValue minimum, [.("minimum")] string? expression = null)
            where TValue : <TValue> { }
        public static .<TValue> IsIn<TValue>(this .<TValue> source, params TValue[] collection) { }
        public static .<TValue> IsIn<TValue>(this .<TValue> source, .<TValue> collection, [.("collection")] string? expression = null) { }
        public static .<.<TItem>, TItem> IsInDescendingOrder<TItem>(this .<.<TItem>> source)
            where TItem : <TItem> { }
        public static .<TCollection, TItem> IsInDescendingOrder<TCollection, TItem>(this .<TCollection> source)
            where TCollection : .<TItem>
            where TItem : <TItem> { }
        public static .<.<TItem>, TItem> IsInOrder<TItem>(this .<.<TItem>> source)
            where TItem : <TItem> { }
        public static .<TCollection, TItem> IsInOrder<TCollection, TItem>(this .<TCollection> source)
            where TCollection : .<TItem>
            where TItem : <TItem> { }
        public static .<TValue> IsLessThan<TValue>(this .<TValue> source, TValue maximum, [.("maximum")] string? expression = null)
            where TValue : <TValue> { }
        public static .<TValue> IsLessThanOrEqualTo<TValue>(this .<TValue> source, TValue maximum, [.("maximum")] string? expression = null)
            where TValue : <TValue> { }
        public static .<TValue> IsNegative<TValue>(this .<TValue> source)
            where TValue : <TValue> { }
        public static .<TValue> IsNegative<TValue>(this .<TValue?> source)
            where TValue :  struct, <TValue> { }
        public static .<object, TTarget> IsNotAssignableTo<TTarget>(this .<object> source) { }
        public static .<TValue, TTarget> IsNotAssignableTo<TTarget, TValue>(this .<TValue> source) { }
        public static .<TValue> IsNotDefault<TValue>(this .<TValue> source) { }
        public static ..IsNotDefinedAssertion<TEnum> IsNotDefined<TEnum>(this .<TEnum> source)
            where TEnum :  struct,  { }
        public static . IsNotEmpty(this .<string> source) { }
        public static .<TValue> IsNotEmpty<TValue>(this .<TValue> source)
            where TValue : .IEnumerable { }
        public static .<TValue> IsNotEqualTo<TValue>(this .<TValue> source, TValue notExpected, [.("notExpected")] string? expression = null) { }
        public static .<TValue> IsNotEquivalentTo<TValue>(this .<TValue> source, object? expected, [.("expected")] string? expression = null) { }
        public static .<TCollection, TItem> IsNotEquivalentTo<TCollection, TItem>(this .<TCollection> source, .<TItem> expected, [.("expected")] string? expression = null)
            where TCollection : .<TItem> { }
        public static .<TCollection, TItem> IsNotEquivalentTo<TCollection, TItem>(this .<TCollection> source, .<TItem> expected, .<TItem> comparer, [.("expected")] string? expression = null)
            where TCollection : .<TItem> { }
        public static .<TCollection, TItem> IsNotEquivalentTo<TCollection, TItem>(this .<TCollection> source, .<TItem> expected, . ordering, [.("expected")] string? expression = null)
            where TCollection : .<TItem> { }
        public static .<TValue> IsNotIn<TValue>(this .<TValue> source, params TValue[] collection) { }
        public static .<TValue> IsNotIn<TValue>(this .<TValue> source, .<TValue> collection, [.("collection")] string? expression = null) { }
        public static .<TValue> IsNotNull<TValue>(this .<TValue> source) { }
        public static . IsNotNullOrEmpty(this .<string> source) { }
        public static ..IsNotParsableIntoAssertion<T> IsNotParsableInto<T>(this .<string> source) { }
        public static .<TValue> IsNotSameReferenceAs<TValue>(this .<TValue> source, object? expected, [.("expected")] string? expression = null) { }
        public static .<TValue> IsNull<TValue>(this .<TValue> source) { }
        public static . IsNullOrEmpty(this .<string> source) { }
        public static . IsNullOrWhitespace(this .<string> source) { }
        public static ..IsParsableIntoAssertion<T> IsParsableInto<T>(this .<string> source) { }
        public static .<TValue> IsPositive<TValue>(this .<TValue> source)
            where TValue : <TValue> { }
        public static .<TValue> IsPositive<TValue>(this .<TValue?> source)
            where TValue :  struct, <TValue> { }
        public static .<TValue> IsSameReferenceAs<TValue>(this .<TValue> source, object? expected, [.("expected")] string? expression = null) { }
        public static . IsTrue(this .<bool> source) { }
        public static .<object> IsTypeOf(this .<object> source,  expectedType) { }
        public static .<object, TExpected> IsTypeOf<TExpected>(this .<object> source) { }
        public static .<TValue> IsTypeOf<TValue>(this .<TValue> source,  expectedType) { }
        public static .<TValue, TExpected> IsTypeOf<TExpected, TValue>(this .<TValue> source) { }
        public static . Matches(this .<string> source, . regex, [.("regex")] string? expression = null) { }
        public static . Matches(this .<string> source, string pattern, [.("pattern")] string? expression = null) { }
        public static .<TValue> Satisfies<TValue>(this .<TValue> source, <TValue?, bool> predicate, [.("predicate")] string? expression = null) { }
        public static .<TValue, TMapped> Satisfies<TValue, TMapped>(this .<TValue> source, <TValue?, .<TMapped>> selector, <.<TMapped>, .<TMapped>?> assertions, [.("selector")] string? selectorExpression = null) { }
        public static .<TValue, TMapped> Satisfies<TValue, TMapped>(this .<TValue> source, <TValue?, TMapped> selector, <.<TMapped>, .<TMapped>?> assertions, [.("selector")] string? selectorExpression = null) { }
        public static . StartsWith(this .<string> source, string expected, [.("expected")] string? expression = null) { }
        public static .<TException> Throws<TException>(this . source)
            where TException :  { }
        public static .<TException> Throws<TException>(this . source)
            where TException :  { }
        public static .<TException> Throws<TException, TValue>(this .<TValue> source)
            where TException :  { }
        public static .<TException> ThrowsAsync<TValue, TException>(this .<TValue> source)
            where TException :  { }
        public static .<TException> ThrowsExactly<TException>(this . source)
            where TException :  { }
        public static .<TException> ThrowsExactly<TException>(this . source)
            where TException :  { }
        public static .<TException> ThrowsExactly<TException, TValue>(this .<TValue> source)
            where TException :  { }
        public static .<> ThrowsException<TValue>(this .<TValue> source) { }
        public static .<TException> ThrowsException<TException, TValue>(this .<TValue> source)
            where TException :  { }
        public static .<TValue> ThrowsNothing<TValue>(this .<TValue> source) { }
        public static ..WhenParsedIntoAssertion<T> WhenParsedInto<T>(this .<string> source) { }
        public static . WithMessageContaining(this .<object?> source, string expectedSubstring) { }
        public static . WithMessageContaining(this .<object?> source, string expectedSubstring,  comparison) { }
    }
    public static class CancellationTokenAssertionExtensions
    {
        public static . CanBeCanceled(this .<.CancellationToken> source) { }
        public static . CannotBeCanceled(this .<.CancellationToken> source) { }
        public static . IsCancellationRequested(this .<.CancellationToken> source) { }
        public static . IsNone(this .<.CancellationToken> source) { }
        public static . IsNotCancellationRequested(this .<.CancellationToken> source) { }
        public static . IsNotNone(this .<.CancellationToken> source) { }
    }
    public static class CharAssertionExtensions
    {
        public static . IsControl(this .<char> source) { }
        public static . IsDigit(this .<char> source) { }
        public static . IsHighSurrogate(this .<char> source) { }
        public static . IsLetter(this .<char> source) { }
        public static . IsLetterOrDigit(this .<char> source) { }
        public static . IsLowSurrogate(this .<char> source) { }
        public static . IsLower(this .<char> source) { }
        public static . IsNotControl(this .<char> source) { }
        public static . IsNotDigit(this .<char> source) { }
        public static . IsNotHighSurrogate(this .<char> source) { }
        public static . IsNotLetter(this .<char> source) { }
        public static . IsNotLetterOrDigit(this .<char> source) { }
        public static . IsNotLowSurrogate(this .<char> source) { }
        public static . IsNotLower(this .<char> source) { }
        public static . IsNotNumber(this .<char> source) { }
        public static . IsNotPunctuation(this .<char> source) { }
        public static . IsNotSeparator(this .<char> source) { }
        public static . IsNotSurrogate(this .<char> source) { }
        public static . IsNotSymbol(this .<char> source) { }
        public static . IsNotUpper(this .<char> source) { }
        public static . IsNotWhiteSpace(this .<char> source) { }
        public static . IsNumber(this .<char> source) { }
        public static . IsPunctuation(this .<char> source) { }
        public static . IsSeparator(this .<char> source) { }
        public static . IsSurrogate(this .<char> source) { }
        public static . IsSymbol(this .<char> source) { }
        public static . IsUpper(this .<char> source) { }
        public static . IsWhiteSpace(this .<char> source) { }
    }
    public static class CultureInfoAssertionExtensions
    {
        public static . IsEnglish(this .<.CultureInfo> source) { }
        public static . IsInvariant(this .<.CultureInfo> source) { }
        public static . IsLeftToRight(this .<.CultureInfo> source) { }
        public static . IsNeutralCulture(this .<.CultureInfo> source) { }
        public static . IsNotEnglish(this .<.CultureInfo> source) { }
        public static . IsNotInvariant(this .<.CultureInfo> source) { }
        public static . IsNotNeutralCulture(this .<.CultureInfo> source) { }
        public static . IsReadOnly(this .<.CultureInfo> source) { }
        public static . IsRightToLeft(this .<.CultureInfo> source) { }
    }
    public static class DateTimeAssertionExtensions
    {
        public static . EqualsExact(this .<> source,  expected, [.("expected")] string? expression = null) { }
        public static . IsDaylightSavingTime(this .<> source) { }
        public static . IsLeapYear(this .<> source) { }
        public static . IsNotDaylightSavingTime(this .<> source) { }
        public static . IsNotLeapYear(this .<> source) { }
        public static . IsNotToday(this .<> source) { }
        public static . IsNotUtc(this .<> source) { }
        public static . IsToday(this .<> source) { }
        public static . IsUtc(this .<> source) { }
    }
    public static class EncodingAssertionExtensions
    {
        public static . IsASCII(this .<.Encoding> source) { }
        public static . IsBigEndianUnicode(this .<.Encoding> source) { }
        public static . IsNotSingleByte(this .<.Encoding> source) { }
        public static .8EncodingAssertion IsNotUTF8(this .<.Encoding> source) { }
        public static . IsSingleByte(this .<.Encoding> source) { }
        public static .32EncodingAssertion IsUTF32(this .<.Encoding> source) { }
        public static .8EncodingAssertion IsUTF8(this .<.Encoding> source) { }
        public static . IsUnicode(this .<.Encoding> source) { }
    }
    public static class FileSystemAssertionExtensions
    {
        public static . DoesNotExist(this .<.DirectoryInfo> source) { }
        public static . DoesNotExist(this .<.FileInfo> source) { }
        public static . Exists(this .<.DirectoryInfo> source) { }
        public static . Exists(this .<.FileInfo> source) { }
        public static . HasFiles(this .<.DirectoryInfo> source) { }
        public static . HasNoSubdirectories(this .<.DirectoryInfo> source) { }
        public static . IsNotEmpty(this .<.DirectoryInfo> source) { }
        public static . IsNotEmpty(this .<.FileInfo> source) { }
        public static . IsNotExecutable(this .<.FileInfo> source) { }
        public static . IsNotHidden(this .<.FileInfo> source) { }
        public static . IsNotReadOnly(this .<.FileInfo> source) { }
        public static . IsNotSystem(this .<.FileInfo> source) { }
    }
    public static class HttpStatusCodeAssertionExtensions
    {
        public static . IsClientError(this .<.HttpStatusCode> source) { }
        public static . IsError(this .<.HttpStatusCode> source) { }
        public static . IsInformational(this .<.HttpStatusCode> source) { }
        public static . IsNotSuccess(this .<.HttpStatusCode> source) { }
        public static . IsRedirection(this .<.HttpStatusCode> source) { }
        public static . IsServerError(this .<.HttpStatusCode> source) { }
        public static . IsSuccess(this .<.HttpStatusCode> source) { }
    }
    public static class MiscellaneousAssertionExtensions
    {
        public static . HasExcessCapacity(this .<.StringBuilder> source) { }
        public static . HasInnerException(this .<> source) { }
        public static . HasNoData(this .<> source) { }
        public static . HasNoInnerException(this .<> source) { }
        public static . HasStackTrace(this .<> source) { }
        public static . IsAlive(this .<> source) { }
        public static . IsDead(this .<> source) { }
        public static . IsEmpty(this .<.StringBuilder> source) { }
        public static . IsFriday(this .<> source) { }
        public static . IsMonday(this .<> source) { }
        public static . IsNotEmpty(this .<.StringBuilder> source) { }
        public static . IsWeekday(this .<> source) { }
        public static . IsWeekend(this .<> source) { }
    }
}
namespace .Sources
{
    public class AsyncDelegateAssertion : .<object?>, .<object?>
    {
        public AsyncDelegateAssertion(<.> action, string? expression) { }
        public .<object?> Context { get; }
    }
    public class AsyncFuncAssertion<TValue> : .<TValue>, .<TValue>
    {
        public AsyncFuncAssertion(<.<TValue>> func, string? expression) { }
        public .<TValue> Context { get; }
        public .<TException> Throws<TException>()
            where TException :  { }
        public .<TException> ThrowsExactly<TException>()
            where TException :  { }
    }
    public class CollectionAssertion<TItem> : .<.<TItem>>
    {
        public CollectionAssertion(.<TItem> value, string? expression) { }
        public .<.<TItem>> Context { get; }
    }
    public class DelegateAssertion : .<object?>, .<object?>
    {
        public DelegateAssertion( action, string? expression) { }
        public .<object?> Context { get; }
    }
    public class DictionaryAssertion<TKey, TValue> : .<.<TKey, TValue>>
    {
        public DictionaryAssertion(.<TKey, TValue> value, string? expression) { }
        public .<.<TKey, TValue>> Context { get; }
    }
    public class FuncAssertion<TValue> : .<TValue>, .<TValue>
    {
        public FuncAssertion(<TValue> func, string? expression) { }
        public .<TValue> Context { get; }
        public .<TException> Throws<TException>()
            where TException :  { }
        public .<TException> ThrowsExactly<TException>()
            where TException :  { }
    }
    public class ValueAssertion<TValue> : .<TValue>
    {
        public ValueAssertion(TValue? value, string? expression) { }
        public .<TValue> Context { get; }
    }
}