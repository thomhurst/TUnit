[assembly: .(".NETStandard,Version=v2.0", FrameworkDisplayName=".NET Standard 2.0")]
namespace 
{
    public static class Assert
    {
        public static void Fail(string reason) { }
        public static  Multiple() { }
        public static .<> That( action, [.("action")] string? doNotPopulateThisValue = null) { }
        public static .<.<object>, object> That(.IEnumerable enumerable, [.("enumerable")] string? doNotPopulateThisValue = null) { }
        public static .<<.>> That(<.> asyncAction, [.("asyncAction")] string? doNotPopulateThisValue = null) { }
        public static .<<.>> That(. task, [.("task")] string? doNotPopulateThisValue = null) { }
        public static .<<.>> That(. valueTask, [.("valueTask")] string? doNotPopulateThisValue = null) { }
        public static .<.<T>, T> That<T>(.<T> enumerable, [.("enumerable")] string? doNotPopulateThisValue = null) { }
        public static .<.<T>, T> That<T>(.<T> list, [.("list")] string? doNotPopulateThisValue = null) { }
        public static .<.<T>, T> That<T>(<.<T>> func, [.("func")] string? doNotPopulateThisValue = null) { }
        public static .<.<T>, T> That<T>(<.<T>> func, [.("func")] string? doNotPopulateThisValue = null) { }
        public static .<.<T>, T> That<T>(<.<.<T>>> asyncFunc, [.("asyncFunc")] string? doNotPopulateThisValue = null) { }
        public static .<.<T>, T> That<T>(<.<.<T>>> asyncFunc, [.("asyncFunc")] string? doNotPopulateThisValue = null) { }
        public static .<T> That<T>(<.<T>> asyncFunc, [.("asyncFunc")] string? doNotPopulateThisValue = null) { }
        public static .<TElement[], TElement> That<TElement>(<.<TElement[]>> asyncFunc, [.("asyncFunc")] string? doNotPopulateThisValue = null) { }
        public static .<T> That<T>(<T> func, [.("func")] string? doNotPopulateThisValue = null) { }
        public static .<TElement[], TElement> That<TElement>(<TElement[]> func, [.("func")] string? doNotPopulateThisValue = null) { }
        public static .<T> That<T>(.<T> task, [.("task")] string? doNotPopulateThisValue = null) { }
        public static .<T> That<T>(.<T> valueTask, [.("valueTask")] string? doNotPopulateThisValue = null) { }
        public static .<TActual> That<TActual>(TActual value, [.("value")] string? doNotPopulateThisValue = null) { }
        public static .<TElement[], TElement> That<TElement>(TElement[] array, [.("array")] string? doNotPopulateThisValue = null) { }
        public static . Throws( @delegate, [.("delegate")] string? doNotPopulateThisValue = null) { }
        public static . Throws( exceptionType,  @delegate, [.("delegate")] string? doNotPopulateThisValue = null) { }
        public static .<TException> Throws<TException>( @delegate, [.("delegate")] string? doNotPopulateThisValue = null)
            where TException :  { }
        public static . ThrowsAsync(<.> @delegate, [.("delegate")] string? doNotPopulateThisValue = null) { }
        public static . ThrowsAsync(. task, [.("task")] string? doNotPopulateThisValue = null) { }
        public static . ThrowsAsync(. valueTask, [.("valueTask")] string? doNotPopulateThisValue = null) { }
        public static . ThrowsAsync( exceptionType, <.> @delegate, [.("delegate")] string? doNotPopulateThisValue = null) { }
        public static .<TException> ThrowsAsync<TException>(<.> @delegate, [.("delegate")] string? doNotPopulateThisValue = null)
            where TException :  { }
    }
    public readonly struct AssertionData : <.AssertionData>
    {
        public AssertionData(object? Result, ? Exception, string? ActualExpression,  Start,  End) { }
        public string? ActualExpression { get; init; }
        public  End { get; init; }
        public ? Exception { get; init; }
        public object? Result { get; init; }
        public  Start { get; init; }
        public static .AssertionData op_Implicit(<object?, ?, string?, , > tuple) { }
    }
    public class AssertionDecision : <.AssertionDecision>
    {
        public static .AssertionDecision Continue { get; }
        public static .AssertionDecision Pass { get; }
        public static .AssertionDecision Fail(string message) { }
    }
    public class AssertionMetadata
    {
        public AssertionMetadata() { }
        public  Duration { get; }
        public required  EndTime { get; init; }
        public required  StartTime { get; init; }
    }
    public static class Compare
    {
        public static .<.ComparisonFailure> CheckEquivalent<TActual, TExpected>(TActual actual, TExpected expected, .CompareOptions options, int? index) { }
    }
    public class CompareOptions : <.CompareOptions>
    {
        public CompareOptions() { }
        public . EquivalencyKind { get; set; }
        public string[] MembersToIgnore { get; init; }
        public [] TypesToIgnore { get; init; }
    }
    public class ComparisonFailure : <.ComparisonFailure>
    {
        public ComparisonFailure() { }
        public required object? Actual { get; init; }
        public required object? Expected { get; init; }
        public required string[] NestedMemberNames { get; init; }
        public required .MemberType Type { get; init; }
    }
    public static class Fail
    {
        [.]
        public static void Test(string reason) { }
        public static void Unless([.(false)] bool condition, string reason) { }
        public static void When([.(true)] bool condition, string reason) { }
    }
    public enum MemberType
    {
        Property = 0,
        Field = 1,
        Value = 2,
        EnumerableItem = 3,
        DictionaryItem = 4,
    }
}
namespace .AssertConditions
{
    public class AssertionResult
    {
        public bool IsPassed { get; }
        public string Message { get; }
        public static . Passed { get; }
        public . And(. other) { }
        public .<.> OrAsync(<.<.>> otherResult) { }
        public . OrFailIf(bool isFailed, ..InterpolatedStringHandler stringHandler) { }
        public . OrFailIf(bool isFailed, string message) { }
        public static . Fail(string message) { }
        public static . FailIf(bool isFailed, ..InterpolatedStringHandler stringHandler) { }
        public static . FailIf(bool isFailed, string message) { }
        public static .<.> op_Implicit(. result) { }
        public static .<.> op_Implicit(. result) { }
        public readonly struct InterpolatedStringHandler
        {
            public InterpolatedStringHandler(int literalLength, int formattedCount, bool isFailed, out bool enabled) { }
            public void AppendFormatted<T>(T? t) { }
            public void AppendFormatted<T>(T? t, string format)
                where T :  { }
            public void AppendLiteral(string s) { }
        }
    }
    public abstract class BaseAssertCondition
    {
        protected BaseAssertCondition() { }
        public string? OverriddenMessage { get; }
        public string? Subject { get; }
        public virtual ? WaitFor { get; protected set; }
        public . FailWithMessage(string message) { }
        protected abstract string GetExpectation();
    }
    public abstract class BaseAssertCondition<TActual> : .
    {
        protected BaseAssertCondition() { }
        public string? ActualExpression { get; }
        public .<.> GetAssertionResult(TActual? actualValue, ? exception, .AssertionMetadata assertionMetadata, string? actualExpression = null) { }
        protected abstract .<.> GetResult(TActual? actualValue, ? exception, .AssertionMetadata assertionMetadata);
    }
    public enum ChainType
    {
        None = 0,
        And = 1,
        Or = 2,
    }
    public abstract class ConvertToAssertCondition<TFromType, TToType> : .<TFromType>
    {
        protected ConvertToAssertCondition() { }
        public TToType ConvertedValue { get; }
        public abstract .<<., TToType?>> ConvertValue(TFromType? value);
        protected override sealed .<.> GetResult(TFromType? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public abstract class DelegateAssertCondition : .<object?, >
    {
        protected DelegateAssertCondition() { }
    }
    public abstract class DelegateAssertCondition<TActual> : .<TActual, >
    {
        protected DelegateAssertCondition() { }
    }
    public abstract class DelegateAssertCondition<TActual, TException> : .<TActual>
        where TException : 
    {
        protected DelegateAssertCondition() { }
        protected override string GetExpectation() { }
        protected virtual string GetFailureMessage(TException? exception) { }
        protected override .<.> GetResult(TActual? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
        public void WithComparer(<TException?, .AssertionDecision> comparer) { }
    }
    public abstract class ExpectedExceptionDelegateAssertCondition<TException> : .<object?, >
    {
        protected ExpectedExceptionDelegateAssertCondition() { }
    }
    public abstract class ExpectedValueAssertCondition<TActual, TExpected> : .<TActual>
    {
        protected ExpectedValueAssertCondition(TExpected? expected) { }
        public TExpected ExpectedValue { get; }
        protected abstract .<.> GetResult(TActual? actualValue, TExpected? expectedValue);
        protected override .<.> GetResult(TActual? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
        public void WithComparer(<TActual?, TExpected?, .AssertionDecision> comparer) { }
        public void WithTransform(<TActual?, TActual?> actualTransformation, <TExpected?, TExpected?> expectedTransformation) { }
    }
    public class FailureLocation : <.>
    {
        public FailureLocation() { }
        public object? ActualValue { get; }
        public object? ExpectedValue { get; }
        public long Position { get; }
    }
    public class FuncValueAssertCondition<TActual, TExpected> : .<TActual, TExpected>
    {
        public FuncValueAssertCondition(TExpected? expected, <TActual?, TExpected?, .<TActual, TExpected>, bool> condition, <TActual?, ?, string?, string> defaultMessageFactory, string expectation) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(TActual? actualValue, TExpected? expectedValue) { }
    }
    public class NotNullExpectedValueAssertCondition<TActual> : .<TActual?, TActual>
        where TActual :  class?
    {
        public NotNullExpectedValueAssertCondition() { }
        public override .<<., TActual?>> ConvertValue(TActual? value) { }
        protected override string GetExpectation() { }
    }
    public class NotNullStructExpectedValueAssertCondition<TActual> : .<TActual?, TActual>
        where TActual :  struct
    {
        public NotNullStructExpectedValueAssertCondition() { }
        public override .<<., TActual>> ConvertValue(TActual? value) { }
        protected override string GetExpectation() { }
    }
    public class NullExpectedValueAssertCondition<TActual> : .<TActual>
    {
        public NullExpectedValueAssertCondition() { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(TActual? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class StaticMethodAssertCondition<T> : .<T>
    {
        public StaticMethodAssertCondition(<T, bool> predicate, string methodName, bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(T? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public abstract class StringMatcher
    {
        protected StringMatcher() { }
        public static ..RegexMatch AsRegex(string pattern) { }
        public static ..WildcardMatch AsWildcard(string pattern) { }
        public static . op_Implicit(. pattern) { }
        public static . op_Implicit(string pattern) { }
        public sealed class RegexMatch : .
        {
            public ..RegexMatch IgnoringCase(bool ignoreCase = true) { }
            public override string ToString() { }
        }
        public sealed class WildcardMatch : .
        {
            public ..WildcardMatch IgnoringCase(bool ignoreCase = true) { }
            public override string ToString() { }
        }
    }
    public abstract class ValueAssertCondition<TActual> : .<TActual>
    {
        protected ValueAssertCondition() { }
        protected override string GetExpectation() { }
        protected abstract string GetFailureMessage(TActual? actualValue);
        protected override .<.> GetResult(TActual? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
        protected abstract . Passes(TActual? actualValue);
        public void WithComparer(<TActual?, .AssertionDecision> comparer) { }
        public void WithTransform(<TActual?, TActual?> actualTransformation) { }
    }
}
namespace .
{
    public class ExceptionMessageContainingExpectedValueAssertCondition<TException> : .<TException, string>
        where TException : 
    {
        public ExceptionMessageContainingExpectedValueAssertCondition(string expected,  stringComparison) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(TException? actualValue, string? expectedValue) { }
    }
    public class ExceptionMessageEndingWithExpectedValueAssertCondition<TException> : .<TException, string>
        where TException : 
    {
        public ExceptionMessageEndingWithExpectedValueAssertCondition(string expected,  stringComparison) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(TException? actualValue, string? expectedValue) { }
    }
    public class ExceptionMessageEqualsExpectedValueAssertCondition<TException> : .<TException, string>
        where TException : 
    {
        public ExceptionMessageEqualsExpectedValueAssertCondition(string expected,  stringComparison) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(TException? actualValue, string? expectedValue) { }
    }
    public class ExceptionMessageMatchingExpectedAssertCondition<TException> : .<TException, .>
        where TException : 
    {
        public ExceptionMessageMatchingExpectedAssertCondition(. match) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(TException? actualValue, .? expectedValue) { }
    }
    public class ExceptionMessageStartingWithExpectedValueAssertCondition<TException> : .<TException, string>
        where TException : 
    {
        public ExceptionMessageStartingWithExpectedValueAssertCondition(string expected,  stringComparison) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(TException? actualValue, string? expectedValue) { }
    }
    public class ExceptionTypeAssertCondition : .<, >
    {
        public ExceptionTypeAssertCondition( expectedType) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(? actualValue, ? expectedValue) { }
    }
}
namespace .
{
    public interface IDelegateSource : ..ISource { }
    public interface ISource
    {
        string? ActualExpression { get; }
        ..ISource AppendExpression(string expression);
        ..ISource WithAssertion(. assertCondition);
    }
    public interface IValueDelegateSource<out TActual> : ..IDelegateSource, ..ISource, ..IValueSource<TActual> { }
    public interface IValueSource<out TActual> : ..ISource { }
}
namespace .
{
    []
    public enum AssertionType
    {
        Value = 1,
        Delegate = 2,
    }
    public class DelegateAnd<TActual> : ..IDelegateSource, ..ISource
    {
        public DelegateAnd(. assertionBuilder) { }
        public static ..DelegateAnd<TActual> Create(. assertionBuilder) { }
    }
    public class DelegateOr<TActual> : ..IDelegateSource, ..ISource
    {
        public DelegateOr(. assertionBuilder) { }
        public static ..DelegateOr<TActual> Create(. assertionBuilder) { }
    }
    public class ValueAnd<TActual> : ..ISource, ..IValueSource<TActual>
    {
        public ValueAnd(. assertionBuilder) { }
        public static ..ValueAnd<TActual> Create(. assertionBuilder) { }
    }
    public class ValueDelegateAnd<TActual> : ..IDelegateSource, ..ISource, ..IValueDelegateSource<TActual>, ..IValueSource<TActual>
    {
        public ValueDelegateAnd(. assertionBuilder) { }
        public static ..ValueDelegateAnd<TActual> Create(. assertionBuilder) { }
    }
    public class ValueDelegateOr<TActual> : ..IDelegateSource, ..ISource, ..IValueDelegateSource<TActual>, ..IValueSource<TActual>
    {
        public ValueDelegateOr(. assertionBuilder) { }
        public static ..ValueDelegateOr<TActual> Create(. assertionBuilder) { }
    }
    public class ValueOr<TActual> : ..ISource, ..IValueSource<TActual>
    {
        public ValueOr(. assertionBuilder) { }
    }
}
namespace .AssertionBuilders
{
    public abstract class AssertionBase
    {
        protected AssertionBase() { }
        public abstract . ExecuteAsync();
        public abstract . GetAwaiter();
    }
    public abstract class AssertionBase<T> : .
    {
        protected AssertionBase(<.<T>> actualValueProvider) { }
        protected AssertionBase(<T> actualValueProvider) { }
        protected AssertionBase(.<T> actualValueTask) { }
        protected AssertionBase(T actualValue) { }
        public virtual .<T> And { get; }
        public virtual .<T> Or { get; }
        protected abstract .<.> AssertAsync();
        public virtual .<T> Because(string reason, [.("reason")] string? expression = null) { }
        public override . ExecuteAsync() { }
        protected .<T> GetActualValueAsync() { }
        public override . GetAwaiter() { }
    }
    public abstract class AssertionBuilder : .
    {
        protected AssertionBuilder() { }
        public virtual string? ActualExpression { get; protected set; }
        public virtual void AppendExpression(string expression) { }
        [.DebuggerHidden]
        [("This is a base `object` method that should not be called.", true)]
        public new void Equals(object? obj) { }
        public abstract .<.AssertionData> GetAssertionData();
        public virtual .<.> GetAssertions() { }
        public abstract . GetAwaiter();
        public virtual .? GetLastAssertion() { }
        public abstract . ProcessAssertionsAsync(.AssertionData data);
        [.DebuggerHidden]
        [("This is a base `object` method that should not be called.", true)]
        public void ReferenceEquals(object a, object b) { }
        public virtual void SetBecause(string reason, string? expression) { }
        public virtual void WithAssertion(. assertion) { }
    }
    public class AssertionBuilder<TActual>
    {
        public AssertionBuilder(<.<TActual>> asyncValueProvider, string? expression = null) { }
        public AssertionBuilder(<TActual> valueProvider, string? expression = null) { }
        public AssertionBuilder(.<TActual> task, string? expression = null) { }
        public AssertionBuilder(.<TActual> valueTask, string? expression = null) { }
        public AssertionBuilder(TActual value, string? expression = null) { }
        public .<TActual> And { get; }
        public .<TActual> AssertHasSingleItem() { }
        public .<TActual> Contains(<object?, bool> predicate) { }
        public .<TActual> Contains(object? item) { }
        public .<.<TItem>, TItem> Contains<TItem>(<TItem, bool> predicate) { }
        public .<TActual> DoesNotContain(object? item) { }
        public .<TActual> DoesNotContain<TElement>(<TElement, bool> predicate) { }
        public .<TActual> EqualTo(TActual expected) { }
        public .<TActual> GetAwaiter() { }
        public .<TActual> GreaterThanOrEqualTo(TActual value) { }
        public .<int> HasCount() { }
        public .<TActual> HasCount(int expectedCount) { }
        public .<TActual> HasDistinctItems() { }
        public .<TActual> IsAssignableTo( expectedType) { }
        public .<TActual> IsAssignableTo<TExpected>() { }
        public .<TActual> IsEmpty() { }
        public .<TActual> IsEqualTo(TActual expected) { }
        public .<TActual> IsEqualTo(object? expected) { }
        public .<TActual> IsEqualTo(TActual expected, .<TActual> comparer) { }
        public .<TActual> IsEqualTo(TActual expected, string because) { }
        public .<TActual> IsEquatableOrEqualTo(TActual expected) { }
        public .<TActual> IsEquivalentTo(.<object?> expected) { }
        public .<TActual> IsEquivalentTo(TActual expected) { }
        public .<TActual> IsEquivalentTo(object? expected) { }
        public .<TActual> IsEquivalentTo<TElement>(.<TElement> expected, .<TElement> comparer) { }
        public .<TActual> IsEquivalentTo<TElement>(.<TElement> expected, . ordering) { }
        public . IsFalse() { }
        public .<TActual> IsGreaterThan(TActual value) { }
        public .<TActual> IsGreaterThanOrEqualTo(TActual value) { }
        public .<TActual> IsIn(.<TActual> values) { }
        public .<TActual> IsIn(params TActual[] values) { }
        public .<TActual> IsLessThan(TActual value) { }
        public .<TActual> IsLessThanOrEqualTo(TActual value) { }
        public .<TActual> IsNegative() { }
        public .<TActual> IsNotAssignableTo( expectedType) { }
        public .<TActual> IsNotAssignableTo<TExpected>() { }
        public .<TActual> IsNotEmpty() { }
        public .<TActual> IsNotEqualTo(TActual expected) { }
        public .<TActual> IsNotEquivalentTo(TActual expected) { }
        public .<TActual> IsNotEquivalentTo(object? expected) { }
        public .<TActual> IsNotEquivalentTo<TElement>(.<TElement> expected, . ordering) { }
        public .<TActual> IsNotIn(params TActual[] values) { }
        public .<TActual> IsNotNull() { }
        public .<TActual> IsNull() { }
        public .<TActual> IsPositive() { }
        public . IsTrue() { }
        public .<TActual> IsTypeOf( expectedType) { }
        public .<TExpected> IsTypeOf<TExpected>()
            where TExpected :  class { }
        public .<TActual> Satisfies(<TActual, bool> predicate, string? failureMessage = null) { }
        public .<TActual, TProperty> Satisfies<TProperty>(<TActual, .<TProperty>> propertySelector, <.<TProperty>, .> assertionBuilder) { }
        public .<TActual> Satisfies<TConverted>(<TActual, TConverted> converter, <.<TConverted>, .<TConverted>> assertionBuilder) { }
        public .<TActual, TProperty> Satisfies<TProperty>(<TActual, TProperty> propertySelector, <.<TProperty>, .> assertionBuilder) { }
        public . Throws( exceptionType) { }
        public .<TException> Throws<TException>()
            where TException :  { }
        public .<TException> ThrowsExactly<TException>()
            where TException :  { }
        public . ThrowsException() { }
        public .<TException> ThrowsException<TException>()
            where TException :  { }
        public .<TActual> ThrowsNothing() { }
        public .<TResult> ThrowsNothing<TResult>() { }
    }
    public class AssertionChainBuilder<T> : .<T>
    {
        public new .<T> Contains(object? item) { }
        public new .<T> HasCount(int expectedCount) { }
        public new .<T> IsEmpty() { }
        public new .<T> IsEqualTo(T expected) { }
        public new .<T> IsFalse() { }
        public new .<T> IsNotEmpty() { }
        public new .<T> IsNotEqualTo(T expected) { }
        public new .<T> IsNotNull() { }
        public new .<T> IsNull() { }
        public new .<T> IsTrue() { }
        public new .<T> Satisfies(<T, bool> predicate, string? failureMessage = null) { }
    }
    public class AssertionEvaluator
    {
        public AssertionEvaluator() { }
        public . EvaluateAsync(..IAssertionChain chain) { }
        public .<.AssertionData> EvaluateAsync(.<.AssertionData> assertionDataTask, .<.> assertions, . expressionFormatter) { }
        public .<.> GetResults() { }
    }
    public static class BetweenAssertionExtensions
    {
        public static .<TActual> IsBetween<TActual>(this .<TActual> builder, TActual min, TActual max, bool inclusive = true)
            where TActual : <TActual> { }
        public static .<TActual> IsNotBetween<TActual>(this .<TActual> builder, TActual min, TActual max, bool inclusive = true)
            where TActual : <TActual> { }
    }
    public class BetweenAssertion<TActual> : .<TActual>
        where TActual : <TActual>
    {
        public BetweenAssertion(<.<TActual>> actualValueProvider, TActual min, TActual max, bool inclusive = true, bool shouldBeInRange = true) { }
        public BetweenAssertion(<TActual> actualValueProvider, TActual min, TActual max, bool inclusive = true, bool shouldBeInRange = true) { }
        public BetweenAssertion(TActual actualValue, TActual min, TActual max, bool inclusive = true, bool shouldBeInRange = true) { }
        protected override .<.> AssertAsync() { }
    }
    public class BooleanAssertion : .<bool>
    {
        public BooleanAssertion(<.<bool>> actualValueProvider, bool expectedValue) { }
        public BooleanAssertion(<bool> actualValueProvider, bool expectedValue) { }
        public BooleanAssertion(bool actualValue, bool expectedValue) { }
        protected override .<.> AssertAsync() { }
    }
    public class ChainedAssertion<T> : .<T>
    {
        public ChainedAssertion(.<T> baseAssertion) { }
        protected override .<.> AssertAsync() { }
    }
    public static class ChainingExtensions
    {
        public static . Chain<T>(this .<T> builder, . other) { }
        public static .<T> Chain<T>(this .<T> builder, .<T> other) { }
        public static .<T> CompletesWithin<T>(this .<T> builder,  timeout) { }
        public static .<T> HasMember<T>(this .<T> builder, string memberName) { }
        public static .<T, TProperty> HasMember<T, TProperty>(this .<T> builder, <T, TProperty> propertySelector) { }
        public static .<T> HasMessageContaining<T>(this .<T> builder, string substring)
            where T :  { }
        public static .<T> HasMessageEndingWith<T>(this .<T> builder, string suffix)
            where T :  { }
        public static .<T> HasMessageEqualTo<T>(this .<T> builder, string expectedMessage)
            where T :  { }
        public static .<T> HasMessageStartingWith<T>(this .<T> builder, string prefix)
            where T :  { }
        public static .<T> IgnoringMember<T>(this .<T> assertion, string memberName) { }
        public static .<string> IgnoringWhitespace(this .<string> assertion) { }
        public static . IgnoringWhitespace(this .<string> assertion) { }
        public static .<> IsAssignableTo(this . assertion,  targetType) { }
        public static .<TException> IsAssignableTo<TException>(this .<TException> assertion,  targetType)
            where TException :  { }
        public static .<T> IsAssignableTo<T, TTarget>(this .<T> builder) { }
        public static .<T> IsAssignableTo<T, TTarget>(this .<T> assertion) { }
        public static .<T> IsDefault<T>(this .<T> builder) { }
        public static .<T> IsNotDefault<T>(this .<T> builder) { }
        public static . WithNullAndEmptyEquality(this .<string> assertion) { }
        public static .<string> WithTrimming(this .<string> assertion) { }
        public static . WithTrimming(this .<string> assertion) { }
        public static .<> Within(this .<> assertion,  tolerance) { }
        public static .<> Within(this .<> assertion,  tolerance) { }
        public static .<> Within(this .<> assertion,  tolerance) { }
    }
    public class CollectionAllAssertion<T> : .<.<T>>
    {
        public CollectionAllAssertion(<.<T>> actualValueProvider) { }
        public CollectionAllAssertion(<.<.<T>>> actualValueProvider) { }
        protected override .<.> AssertAsync() { }
        public .<.<T>> Satisfy(<T, bool> predicate) { }
        public .<T, T> Satisfy(<.<T>, .> assertionBuilder) { }
        public .<T, TProperty> Satisfy<TProperty>(<T, .<TProperty>> asyncPropertySelector, <.<TProperty>, .> assertionBuilder) { }
        public .<T, TProperty> Satisfy<TProperty>(<T, TProperty> propertySelector, <.<TProperty>, .> assertionBuilder) { }
    }
    public static class CollectionAllExtensions
    {
        public static .<T> All<T>(this .<.<T>> builder) { }
        public static .<T> All<T>(this .<.<T>> builder) { }
        public static .<T> All<T>(this .<T[]> builder) { }
    }
    public enum CollectionAssertType
    {
        Empty = 0,
        NotEmpty = 1,
        Count = 2,
        Contains = 3,
        DoesNotContain = 4,
        HasSingleItem = 5,
        HasDistinctItems = 6,
    }
    public class CollectionAssertionBuilder<TCollection, TElement> : .<TCollection>
        where TCollection : .<TElement>
    {
        public CollectionAssertionBuilder(<.<TCollection>> asyncValueProvider, string? expression = null) { }
        public CollectionAssertionBuilder(<TCollection> valueProvider, string? expression = null) { }
        public CollectionAssertionBuilder(.<TCollection> task, string? expression = null) { }
        public CollectionAssertionBuilder(.<TCollection> valueTask, string? expression = null) { }
        public CollectionAssertionBuilder(TCollection value, string? expression = null) { }
        public .<TElement> All() { }
        public .<TCollection> All(<TElement, bool> predicate) { }
        public .<TCollection> Any(<TElement, bool> predicate) { }
        public .<TCollection, TElement> Contains(<TElement, bool> predicate) { }
        public .<TCollection> Contains(TElement item) { }
        public .<TCollection> ContainsOnly(<TElement, bool> predicate) { }
        public .<TCollection> DoesNotContain(<TElement, bool> predicate) { }
        public .<TCollection> DoesNotContain(TElement item) { }
        [("This is a base `object` method that should not be called.", true)]
        public new void Equals(object? obj) { }
        public new .<TCollection> GetAwaiter() { }
        public .<TElement> GetSingleItem() { }
        public .<int> HasCount() { }
        public .<TCollection> HasCount(int expectedCount) { }
        public .<TCollection> HasDistinctItems() { }
        public .<TCollection> HasSingleItem() { }
        public .<TCollection> IsEmpty() { }
        public .<TCollection> IsEquivalentTo(.<TElement> expected) { }
        public .<TCollection> IsInDescendingOrder() { }
        public .<TCollection> IsInOrder() { }
        public .<TCollection> IsNotEmpty() { }
        public .<TCollection> None(<TElement, bool> predicate) { }
        [("This is a base `object` method that should not be called.", true)]
        public new void ReferenceEquals(object a, object b) { }
    }
    public static class CollectionAssertionExtensions
    {
        public static .<T> Contains<T>(this .<T> assertion, <object, bool> predicate) { }
        public static .<int> HasCount<T>(this .<T> assertion) { }
        public static .<T> HasCount<T>(this .<T> assertion, int expectedCount) { }
    }
    public class CollectionAssertion<TActual> : .<TActual>
    {
        public CollectionAssertion(<.<TActual>> actualValueProvider, . assertType, int? expectedCount = default, object? expectedItem = null) { }
        public CollectionAssertion(<TActual> actualValueProvider, . assertType, int? expectedCount = default, object? expectedItem = null) { }
        public CollectionAssertion(TActual actualValue, . assertType, int? expectedCount = default, object? expectedItem = null) { }
        protected override .<.> AssertAsync() { }
    }
    public static class CollectionContainsOnlyExtensions
    {
        public static .<.<T>> ContainsOnly<T>(this .<.<T>> builder, <T, bool> predicate) { }
        public static .<.<T>> ContainsOnly<T>(this .<.<T>> builder, params T[] expected) { }
        public static .<.<T>> ContainsOnly<T>(this .<.<T>> builder, <T, bool> predicate) { }
        public static .<.<T>> ContainsOnly<T>(this .<.<T>> builder, params T[] expected) { }
        public static .<.<T>> ContainsOnly<T>(this .<.<T>> builder, <T, bool> predicate) { }
        public static .<.<T>> ContainsOnly<T>(this .<.<T>> builder, <T, bool> predicate) { }
        public static .<.<T>> ContainsOnly<T>(this .<.<T>> builder, params T[] expected) { }
        public static .<T[]> ContainsOnly<T>(this .<T[]> builder, <T, bool> predicate) { }
        public static .<T[]> ContainsOnly<T>(this .<T[]> builder, params T[] expected) { }
        public static .<.<int>> DoesNotContain(this .<.<int>> builder, <int, bool> predicate) { }
        public static .<.<int>> DoesNotContain(this .<.<int>> builder, <int, bool> predicate) { }
        public static .<int[]> DoesNotContain(this .<int[]> builder, <int, bool> predicate) { }
    }
    public static class CollectionExtensions
    {
        public static .<T> GetSingleItem<T>(this .<.<T>> builder) { }
        public static .<T> GetSingleItem<T>(this .<.<T>> builder) { }
        public static .<T> GetSingleItem<T>(this .<.<T>> builder) { }
        public static .<T> GetSingleItem<T>(this .<.<T>> builder) { }
        public static .<T> GetSingleItem<T>(this .<.<T>> builder) { }
        public static .<T> GetSingleItem<T>(this .<.<T>> builder) { }
        public static .<T> GetSingleItem<T>(this .<T[]> builder) { }
        public static .<T> HasSingleItem<T>(this .<T> builder)
            where T : .IEnumerable { }
    }
    public static class CollectionOrderingExtensions
    {
        public static .<.<T>> IsInDescendingOrder<T>(this .<.<T>> builder)
            where T : <T> { }
        public static .<T[]> IsInDescendingOrder<T>(this .<T[]> builder)
            where T : <T> { }
        public static .<.<object>> IsInOrder(this .<.<object>> builder) { }
        public static .<.<T>> IsInOrder<T>(this .<.<T>> builder)
            where T : <T> { }
        public static .<T[]> IsInOrder<T>(this .<T[]> builder)
            where T : <T> { }
    }
    public class ComparisonAndChain<TActual>
    {
        public ComparisonAndChain(.<TActual> previousAssertion, <.<TActual>> valueProvider) { }
        public . IsGreaterThan(TActual value) { }
        public . IsGreaterThanOrEqualTo(TActual value) { }
        public . IsLessThan(TActual value) { }
        public . IsLessThanOrEqualTo(TActual value) { }
    }
    public class ComparisonAssertion<TActual> : .<TActual>
    {
        public ComparisonAssertion(<.<TActual>> actualValueProvider, TActual comparisonValue, . comparisonType) { }
        public ComparisonAssertion(<TActual> actualValueProvider, TActual comparisonValue, . comparisonType) { }
        public ComparisonAssertion(TActual actualValue, TActual comparisonValue, . comparisonType) { }
        protected override .<.> AssertAsync() { }
    }
    public enum ComparisonType
    {
        GreaterThan = 0,
        GreaterThanOrEqual = 1,
        LessThan = 2,
        LessThanOrEqual = 3,
    }
    public class ContainsPredicateAssertion<TCollection, TItem> : .<TCollection>
        where TCollection : .<TItem>
    {
        public ContainsPredicateAssertion(<.<TCollection>> collectionProvider, <TItem, bool> predicate) { }
        protected override .<.> AssertAsync() { }
        public new .<TItem?> GetAwaiter() { }
    }
    public static class CultureInfoAssertionExtensions
    {
        public static .<.CultureInfo> IsEnglish(this .<.CultureInfo> builder) { }
        public static .<.CultureInfo> IsInvariant(this .<.CultureInfo> builder) { }
        public static .<.CultureInfo> IsLeftToRight(this .<.CultureInfo> builder) { }
        public static .<.CultureInfo> IsNeutralCulture(this .<.CultureInfo> builder) { }
        public static .<.CultureInfo> IsNotEnglish(this .<.CultureInfo> builder) { }
        public static .<.CultureInfo> IsNotInvariant(this .<.CultureInfo> builder) { }
        public static .<.CultureInfo> IsNotNeutralCulture(this .<.CultureInfo> builder) { }
        public static .<.CultureInfo> IsReadOnly(this .<.CultureInfo> builder) { }
        public static .<.CultureInfo> IsRightToLeft(this .<.CultureInfo> builder) { }
    }
    public class CustomAssertion<TActual> : .<TActual>
    {
        public CustomAssertion(<.<TActual>> actualValueProvider, <TActual, bool> predicate, string? failureMessage) { }
        public CustomAssertion(<TActual> actualValueProvider, <TActual, bool> predicate, string? failureMessage) { }
        public CustomAssertion(TActual actualValue, <TActual, bool> predicate, string? failureMessage) { }
        protected override .<.> AssertAsync() { }
        public .<TActual> IgnoringType<TIgnore>() { }
        public .<TActual> WithPartialEquivalency() { }
    }
    public class DateTimeAssertion : .<>
    {
        public DateTimeAssertion( actualValue,  expected) { }
        public DateTimeAssertion(<> actualValueProvider,  expected) { }
        public DateTimeAssertion(<.<>> actualValueProvider,  expected) { }
        protected override .<.> AssertAsync() { }
        public .<> IsAfterOrEqualTo( other) { }
        public .<> IsBeforeOrEqualTo( other) { }
        public . Within( tolerance) { }
    }
    public static class DateTimeAssertionBuilderExtensions
    {
        public static .<> IsAfterOrEqualTo(this .<> builder,  other) { }
        public static .<> IsBeforeOrEqualTo(this .<> builder,  other) { }
        public static . IsEqualTo(this .<> builder,  expected) { }
        public static . IsEqualTo(this .<> builder,  expected) { }
        public static . IsEqualTo(this .<> builder,  expected) { }
    }
    public class DateTimeOffsetAssertion : .<>
    {
        public DateTimeOffsetAssertion( actualValue,  expected) { }
        public DateTimeOffsetAssertion(<> actualValueProvider,  expected) { }
        public DateTimeOffsetAssertion(<.<>> actualValueProvider,  expected) { }
        protected override .<.> AssertAsync() { }
        public . Within( tolerance) { }
    }
    public static class DayOfWeekAssertionExtensions
    {
        public static .<> IsFriday(this .<> builder) { }
        public static .<> IsMonday(this .<> builder) { }
        public static .<> IsSaturday(this .<> builder) { }
        public static .<> IsSunday(this .<> builder) { }
        public static .<> IsThursday(this .<> builder) { }
        public static .<> IsTuesday(this .<> builder) { }
        public static .<> IsWednesday(this .<> builder) { }
        public static .<> IsWeekday(this .<> builder) { }
        public static .<> IsWeekend(this .<> builder) { }
    }
    public class DelegateAssertionBuilder<TDelegate> : .
        where TDelegate : 
    {
        protected readonly <.<TDelegate>> _delegateProvider;
        protected readonly string? _expression;
        public DelegateAssertionBuilder(<.<TDelegate>> asyncDelegateProvider, string? expression = null) { }
        public DelegateAssertionBuilder(<TDelegate> delegateProvider, string? expression = null) { }
        public DelegateAssertionBuilder(.<TDelegate> task, string? expression = null) { }
        public DelegateAssertionBuilder(.<TDelegate> valueTask, string? expression = null) { }
        public DelegateAssertionBuilder(TDelegate delegateValue, string? expression = null) { }
        public .<TDelegate> And { get; }
        [("This is a base `object` method that should not be called.", true)]
        public new void Equals(object? obj) { }
        public override .<.AssertionData> GetAssertionData() { }
        public override . GetAwaiter() { }
        public override . ProcessAssertionsAsync(.AssertionData data) { }
        [("This is a base `object` method that should not be called.", true)]
        public new void ReferenceEquals(object a, object b) { }
        public . Throws( exceptionType) { }
        public .<TException> Throws<TException>()
            where TException :  { }
        public .<TException> ThrowsExactly<TException>()
            where TException :  { }
        public . ThrowsException() { }
        public .<TException> ThrowsException<TException>()
            where TException :  { }
        public .<object?> ThrowsNothing() { }
    }
    public static class DictionaryAssertionExtensions
    {
        public static .<T> ContainsKey<T>(this .<T> builder, object key)
            where T : .IDictionary { }
        public static .<T> ContainsKey<T>(this .<T> builder, string key)
            where T : .<string, string> { }
        public static .<.<string, TValue>> ContainsKey<TValue>(this .<.<string, TValue>> builder, string key, .<string> comparer) { }
        public static .<TKey, TValue> ContainsKey<TKey, TValue>(this .<.<TKey, TValue>> builder, TKey key)
            where TKey :  notnull { }
        public static .<TKey, TValue> ContainsKey<TKey, TValue>(this .<.<TKey, TValue>> builder, TKey key) { }
        public static .<.<TKey, TValue>> ContainsKey<TKey, TValue>(this .<.<TKey, TValue>> builder, TKey key) { }
        public static .<TKey, TValue> DoesNotContainKey<TKey, TValue>(this .<.<TKey, TValue>> builder, TKey key)
            where TKey :  notnull { }
        public static .<TKey, TValue> DoesNotContainKey<TKey, TValue>(this .<.<TKey, TValue>> builder, TKey key) { }
        public static .<.<TKey, TValue>> DoesNotContainKey<TKey, TValue>(this .<.<TKey, TValue>> builder, TKey key) { }
    }
    public class DictionaryAssertion<TKey, TValue> : .<.<TKey, TValue>>
    {
        public DictionaryAssertion(.<TKey, TValue> actualValue, TKey? key, bool shouldContain) { }
        public DictionaryAssertion(<.<TKey, TValue>> actualValueProvider, TKey? key, bool shouldContain) { }
        public DictionaryAssertion(<.<.<TKey, TValue>>> actualValueProvider, TKey? key, bool shouldContain) { }
        protected override .<.> AssertAsync() { }
    }
    public static class DirectoryInfoAssertionExtensions
    {
        public static .<.DirectoryInfo> DoesNotExist(this .<.DirectoryInfo> builder) { }
        public static .<.DirectoryInfo> Exists(this .<.DirectoryInfo> builder) { }
        public static .<.DirectoryInfo> HasFiles(this .<.DirectoryInfo> builder) { }
        public static .<.DirectoryInfo> HasNoFiles(this .<.DirectoryInfo> builder) { }
        public static .<.DirectoryInfo> HasNoSubdirectories(this .<.DirectoryInfo> builder) { }
        public static .<.DirectoryInfo> HasSubdirectories(this .<.DirectoryInfo> builder) { }
        public static .<.DirectoryInfo> IsEmpty(this .<.DirectoryInfo> builder) { }
        public static .<.DirectoryInfo> IsNotEmpty(this .<.DirectoryInfo> builder) { }
    }
    public class DualAssertionBuilder<T> : .<T>
    {
        public DualAssertionBuilder(<.<T>> asyncFuncValue, string? expression = null) { }
        public DualAssertionBuilder(<T> funcValue, string? expression = null) { }
        public DualAssertionBuilder(.<T> task, string? expression = null) { }
        public DualAssertionBuilder(.<T> valueTask, string? expression = null) { }
        [("This is a base `object` method that should not be called.", true)]
        public new void Equals(object? obj) { }
        public new .<T> GetAwaiter() { }
        [("This is a base `object` method that should not be called.", true)]
        public new void ReferenceEquals(object a, object b) { }
        public . Throws( exceptionType) { }
        public .<TException> Throws<TException>()
            where TException :  { }
        public .<TException> ThrowsExactly<TException>()
            where TException :  { }
        public . ThrowsException() { }
        public .<TException> ThrowsException<TException>()
            where TException :  { }
        public .<T> ThrowsNothing() { }
    }
    public class DualCollectionAssertionBuilder<TCollection, TElement> : .<TCollection, TElement>
        where TCollection : .<TElement>
    {
        public DualCollectionAssertionBuilder(<.<TCollection>> asyncFuncValue, string? expression = null) { }
        public DualCollectionAssertionBuilder(<TCollection> funcValue, string? expression = null) { }
        public DualCollectionAssertionBuilder(.<TCollection> task, string? expression = null) { }
        public DualCollectionAssertionBuilder(.<TCollection> valueTask, string? expression = null) { }
        [("This is a base `object` method that should not be called.", true)]
        public new void Equals(object? obj) { }
        public new .<TCollection> GetAwaiter() { }
        [("This is a base `object` method that should not be called.", true)]
        public new void ReferenceEquals(object a, object b) { }
        public . Throws( exceptionType) { }
        public .<TException> Throws<TException>()
            where TException :  { }
        public .<TException> ThrowsExactly<TException>()
            where TException :  { }
        public . ThrowsException() { }
        public .<TException> ThrowsException<TException>()
            where TException :  { }
        public .<TCollection> ThrowsNothing() { }
    }
    public static class EncodingAssertionExtensions
    {
        public static .<.Encoding> IsASCII(this .<.Encoding> builder) { }
        public static .<.Encoding> IsBigEndianUnicode(this .<.Encoding> builder) { }
        public static .<.Encoding> IsNotSingleByte(this .<.Encoding> builder) { }
        public static .<.Encoding> IsNotUTF8(this .<.Encoding> builder) { }
        public static .<.Encoding> IsSingleByte(this .<.Encoding> builder) { }
        public static .<.Encoding> IsUTF32(this .<.Encoding> builder) { }
        public static .<.Encoding> IsUTF8(this .<.Encoding> builder) { }
        public static .<.Encoding> IsUnicode(this .<.Encoding> builder) { }
    }
    public class ExceptionAssertion : .<>
    {
        public ExceptionAssertion( syncDelegate) { }
        public ExceptionAssertion(<.> asyncDelegate) { }
        public ExceptionAssertion( syncDelegate,  expectedType) { }
        public ExceptionAssertion(<.> asyncDelegate,  expectedType) { }
        public new . WithInnerException() { }
    }
    public static class ExceptionAssertionExtensions
    {
        public static .<> HasInnerException(this .<> builder) { }
        public static .<> HasNoData(this .<> builder) { }
        public static .<> HasNoInnerException(this .<> builder) { }
        public static .<> HasStackTrace(this .<> builder) { }
    }
    public class ExceptionAssertion<TException> : .<TException>
        where TException : 
    {
        public ExceptionAssertion( syncDelegate) { }
        public ExceptionAssertion(<.> asyncDelegate) { }
        public ExceptionAssertion( syncDelegate,  expectedType) { }
        public ExceptionAssertion(<.> asyncDelegate,  expectedType) { }
        public new .<TException> And { get; }
        protected override .<.> AssertAsync() { }
        public new .<TException> GetAwaiter() { }
        public .<TException> GetExceptionAsync() { }
        public .<TException> HasInnerException() { }
        public .<TException> HasMessageContaining(string substring) { }
        public .<TException> HasMessageEqualTo(string expectedMessage) { }
        public .<TException> HasNoInnerException() { }
        public .<TException> HasStackTrace() { }
        public .<TException> IsAssignableTo( targetType) { }
        public .<TException> IsAssignableTo<TTarget>() { }
        public .<TException> Matching(<TException, bool> predicate) { }
        public .<TException> WithInnerException() { }
        public .<TException> WithInnerException<TInner>()
            where TInner :  { }
        public .<TException> WithMessage(string expectedMessage) { }
        public .<TException> WithMessageContaining(string substring) { }
        public .<TException> WithMessageContaining(string substring,  comparison) { }
        public .<TException> WithMessageMatching(. matcher) { }
        public .<TException> WithMessageMatching(string pattern) { }
        public .<TException> WithMessageNotContaining(string substring) { }
        public .<TException> WithMessageNotContaining(string substring,  comparison) { }
        public .<TException> WithParameterName(string parameterName) { }
        public static .<TException> op_Implicit(.<TException> assertion) { }
    }
    public class ExecutionTimeAssertion<T> : .<T>
    {
        public ExecutionTimeAssertion(<.<T>> actualValueProvider,  timeout) { }
        protected override .<.> AssertAsync() { }
    }
    public class ExpressionFormatter
    {
        public ExpressionFormatter(string? actualExpression) { }
        public string? ActualExpression { get; }
        public void AppendConnector(string connector) { }
        public void AppendMethod(string methodName, params string?[] arguments) { }
        public string GetExpression() { }
    }
    public static class FileInfoAssertionExtensions
    {
        public static .<.FileInfo> DoesNotExist(this .<.FileInfo> builder) { }
        public static .<.FileInfo> Exists(this .<.FileInfo> builder) { }
        public static .<.FileInfo> IsEmpty(this .<.FileInfo> builder) { }
        public static .<.FileInfo> IsExecutable(this .<.FileInfo> builder) { }
        public static .<.FileInfo> IsHidden(this .<.FileInfo> builder) { }
        public static .<.FileInfo> IsNotEmpty(this .<.FileInfo> builder) { }
        public static .<.FileInfo> IsNotExecutable(this .<.FileInfo> builder) { }
        public static .<.FileInfo> IsNotHidden(this .<.FileInfo> builder) { }
        public static .<.FileInfo> IsNotReadOnly(this .<.FileInfo> builder) { }
        public static .<.FileInfo> IsNotSystem(this .<.FileInfo> builder) { }
        public static .<.FileInfo> IsReadOnly(this .<.FileInfo> builder) { }
        public static .<.FileInfo> IsSystem(this .<.FileInfo> builder) { }
    }
    public enum FileSystemAssertType
    {
        FileExists = 0,
        FileDoesNotExist = 1,
        DirectoryExists = 2,
        DirectoryDoesNotExist = 3,
        HasFiles = 4,
        HasNoFiles = 5,
        HasSubdirectories = 6,
        HasNoSubdirectories = 7,
    }
    public class FileSystemAssertion : .<string>
    {
        public FileSystemAssertion(<.<string>> pathProvider, . assertType) { }
        public FileSystemAssertion(<string> pathProvider, . assertType) { }
        public FileSystemAssertion(string path, . assertType) { }
        protected override .<.> AssertAsync() { }
    }
    public static class FileSystemAssertionExtensions
    {
        public static . DirectoryDoesNotExist(this .<string> builder) { }
        public static . DirectoryExists(this .<string> builder) { }
        public static . DoesNotExist(this .<string> builder) { }
        public static . Exists(this .<string> builder) { }
        public static . HasFiles(this .<string> builder) { }
        public static . HasNoFiles(this .<string> builder) { }
        public static . HasNoSubdirectories(this .<string> builder) { }
        public static . HasSubdirectories(this .<string> builder) { }
    }
    public class GenericEqualToAssertion<TActual> : .<TActual>
    {
        public GenericEqualToAssertion(<.<TActual>> actualValueProvider, TActual expected) { }
        public GenericEqualToAssertion(<TActual> actualValueProvider, TActual expected) { }
        public GenericEqualToAssertion(TActual actualValue, TActual expected) { }
        protected override .<.> AssertAsync() { }
        public .<TActual> WithComparer(.<TActual> comparer) { }
        public .<TActual> WithComparison(<TActual?, TActual?, bool> comparison) { }
    }
    public class GenericNotEqualToAssertion<TActual> : .<TActual>
    {
        public GenericNotEqualToAssertion(<.<TActual>> actualValueProvider, TActual expected) { }
        public GenericNotEqualToAssertion(<TActual> actualValueProvider, TActual expected) { }
        public GenericNotEqualToAssertion(TActual actualValue, TActual expected) { }
        protected override .<.> AssertAsync() { }
        public .<TActual> WithComparer(.<TActual> comparer) { }
    }
    public static class HttpStatusCodeAssertionExtensions
    {
        public static .<.HttpStatusCode> IsClientError(this .<.HttpStatusCode> builder) { }
        public static .<.HttpStatusCode> IsError(this .<.HttpStatusCode> builder) { }
        public static .<.HttpStatusCode> IsInformational(this .<.HttpStatusCode> builder) { }
        public static .<.HttpStatusCode> IsNotSuccess(this .<.HttpStatusCode> builder) { }
        public static .<.HttpStatusCode> IsRedirection(this .<.HttpStatusCode> builder) { }
        public static .<.HttpStatusCode> IsServerError(this .<.HttpStatusCode> builder) { }
        public static .<.HttpStatusCode> IsSuccess(this .<.HttpStatusCode> builder) { }
    }
    public interface IInvokableAssertionBuilder
    {
        .<.AssertionData> GetAssertionData();
        .<.> GetAssertions();
        . GetAwaiter();
        .? GetLastAssertion();
        . ProcessAssertionsAsync(.AssertionData data);
    }
    public static class IgnoreType
    {
        public static .<T> For<T, TIgnore>(.<T> assertion) { }
    }
    public static class IgnoringTypeGenericExtensions
    {
        public static .<T> IgnoringType<T>(this .<T> assertion,  typeToIgnore) { }
    }
    public class MemberAssertion<TObject, TMember> : .<TMember>
    {
        public MemberAssertion(<.<TObject>> objectProvider, .<<TObject, TMember>> memberSelector) { }
        public .<TMember> EqualTo(TMember expected) { }
    }
    public class NullAssertion<TActual> : .<TActual>
    {
        public NullAssertion(<.<TActual>> actualValueProvider, bool shouldBeNull) { }
        public NullAssertion(<TActual> actualValueProvider, bool shouldBeNull) { }
        public NullAssertion(TActual actualValue, bool shouldBeNull) { }
        protected override .<.> AssertAsync() { }
        public new .<TActual> GetAwaiter() { }
    }
    public static class NullableStringAssertionBuilderExtensions
    {
        public static .<string?> DoesNotContain(this .<string?> builder, string substring) { }
        public static .<string?> HasLength(this .<string?> builder, int expectedLength) { }
        public static .<string?> IsEmpty(this .<string?> builder) { }
        public static .<string?> IsNotEmpty(this .<string?> builder) { }
    }
    public static class NumericAssertionExtensions
    {
        public static .<double> IsInfinity(this .<double> builder) { }
        public static .<double> IsNaN(this .<double> builder) { }
        public static .<decimal> IsNegative(this .<decimal> builder) { }
        public static .<double> IsNegative(this .<double> builder) { }
        public static .<float> IsNegative(this .<float> builder) { }
        public static .<int> IsNegative(this .<int> builder) { }
        public static .<long> IsNegative(this .<long> builder) { }
        public static .<short> IsNegative(this .<short> builder) { }
        public static .<byte> IsPositive(this .<byte> builder) { }
        public static .<decimal> IsPositive(this .<decimal> builder) { }
        public static .<double> IsPositive(this .<double> builder) { }
        public static .<float> IsPositive(this .<float> builder) { }
        public static .<int> IsPositive(this .<int> builder) { }
        public static .<long> IsPositive(this .<long> builder) { }
        public static .<short> IsPositive(this .<short> builder) { }
        public static .<int> IsZero(this .<int> builder) { }
        public static .<decimal> Negative(this .<decimal> builder) { }
        public static .<double> Negative(this .<double> builder) { }
        public static .<float> Negative(this .<float> builder) { }
        public static .<int> Negative(this .<int> builder) { }
        public static .<long> Negative(this .<long> builder) { }
        public static .<short> Negative(this .<short> builder) { }
        public static .<byte> Positive(this .<byte> builder) { }
        public static .<decimal> Positive(this .<decimal> builder) { }
        public static .<double> Positive(this .<double> builder) { }
        public static .<float> Positive(this .<float> builder) { }
        public static .<int> Positive(this .<int> builder) { }
        public static .<long> Positive(this .<long> builder) { }
        public static .<short> Positive(this .<short> builder) { }
        public static .<int> Zero(this .<int> builder) { }
    }
    public class NumericAssertion<T> : .<T>
        where T :  struct, <T>
    {
        public NumericAssertion(<.<T>> actualValueProvider) { }
        public NumericAssertion(<T> actualValueProvider) { }
        protected override .<.> AssertAsync() { }
        public .<T> GreaterThan(T other) { }
        public .<T> GreaterThanOrEqualTo(T other) { }
        public .<T> LessThan(T other) { }
        public .<T> LessThanOrEqualTo(T other) { }
        public .<T> Negative() { }
        public .<T> NotZero() { }
        public .<T> Positive() { }
        public .<T> Zero() { }
    }
    public static class NumericRangeAssertionExtensions
    {
        public static .<decimal> IsBetween(this .<decimal> builder, decimal min, decimal max) { }
        public static .<double> IsBetween(this .<double> builder, double min, double max) { }
        public static .<int> IsBetween(this .<int> builder, int min, int max) { }
        public static .<long> IsBetween(this .<long> builder, long min, long max) { }
        public static .<decimal> IsNotBetween(this .<decimal> builder, decimal min, decimal max) { }
        public static .<double> IsNotBetween(this .<double> builder, double min, double max) { }
        public static .<int> IsNotBetween(this .<int> builder, int min, int max) { }
        public static .<long> IsNotBetween(this .<long> builder, long min, long max) { }
    }
    public static class ObjectReferenceAssertionExtensions
    {
        public static .<TActual> IsNotSameReferenceAs<TActual>(this .<TActual> builder, object? expected) { }
        public static .<TActual> IsSameReferenceAs<TActual>(this .<TActual> builder, object? expected) { }
    }
    public class ParseAssertion<T> : .<string?>
    {
        public ParseAssertion(<.<string?>> actualValueProvider, bool shouldBeParsable) { }
        public ParseAssertion(<string?> actualValueProvider, bool shouldBeParsable) { }
        public ParseAssertion(string? actualValue, bool shouldBeParsable) { }
        protected override .<.> AssertAsync() { }
        public .<T> WithFormatProvider( formatProvider) { }
    }
    public class PropertyMemberAssertion<TObject, TProperty> : .<TObject>
    {
        public PropertyMemberAssertion(<.<TObject>> actualValueProvider, <TObject, TProperty> propertySelector) { }
        public PropertyMemberAssertion(<TObject> actualValueProvider, <TObject, TProperty> propertySelector) { }
        protected override .<.> AssertAsync() { }
        public .<TObject> EqualTo(TProperty expectedValue) { }
        public .<TObject> IsEqualTo(TProperty expectedValue) { }
    }
    public class PropertySatisfiesAllAssertion<T, TProperty> : .<.<T>>
    {
        public PropertySatisfiesAllAssertion(<.<.<T>>> actualValueProvider, <T, TProperty> propertySelector, <.<TProperty>, .> assertionBuilder) { }
        protected override .<.> AssertAsync() { }
    }
    public class PropertySatisfiesAllAsyncAssertion<T, TProperty> : .<.<T>>
    {
        public PropertySatisfiesAllAsyncAssertion(<.<.<T>>> actualValueProvider, <T, .<TProperty>> asyncPropertySelector, <.<TProperty>, .> assertionBuilder) { }
        protected override .<.> AssertAsync() { }
    }
    public class PropertySatisfiesAssertion<TActual, TProperty> : .<TActual>
    {
        public PropertySatisfiesAssertion(<.<TActual>> actualValueProvider, <TActual, TProperty> propertySelector, <.<TProperty>, .> assertionBuilder) { }
        public PropertySatisfiesAssertion(<TActual> actualValueProvider, <TActual, TProperty> propertySelector, <.<TProperty>, .> assertionBuilder) { }
        protected override .<.> AssertAsync() { }
    }
    public class PropertySatisfiesAsyncAssertion<TActual, TProperty> : .<TActual>
    {
        public PropertySatisfiesAsyncAssertion(<.<TActual>> actualValueProvider, <TActual, .<TProperty>> asyncPropertySelector, <.<TProperty>, .> assertionBuilder) { }
        public PropertySatisfiesAsyncAssertion(<TActual> actualValueProvider, <TActual, .<TProperty>> asyncPropertySelector, <.<TProperty>, .> assertionBuilder) { }
        protected override .<.> AssertAsync() { }
    }
    public static class RangeExtensions
    {
        public static .<TActual> WithExclusiveBounds<TActual>(this .<TActual> assertion)
            where TActual : <TActual> { }
        public static .<TActual> WithExclusiveBounds<TActual>(this .<TActual> assertion)
            where TActual : <TActual> { }
        public static .<TActual> WithInclusiveBounds<TActual>(this .<TActual> assertion)
            where TActual : <TActual> { }
        public static .<TActual> WithInclusiveBounds<TActual>(this .<TActual> assertion)
            where TActual : <TActual> { }
    }
    public static class ReferenceAssertionBuilderExtensions
    {
        public static .<TActual> IsNotSameReferenceAs<TActual>(this .<TActual> builder, TActual? expected)
            where TActual :  class { }
        public static .<TActual> IsSameReferenceAs<TActual>(this .<TActual> builder, TActual? expected)
            where TActual :  class { }
    }
    public class ReferenceAssertion<TActual> : .<TActual>
        where TActual :  class
    {
        public ReferenceAssertion(<.<TActual>> actualValueProvider, TActual? expected, bool shouldBeSame) { }
        public ReferenceAssertion(<TActual> actualValueProvider, TActual? expected, bool shouldBeSame) { }
        public ReferenceAssertion(TActual actualValue, TActual? expected, bool shouldBeSame) { }
        protected override .<.> AssertAsync() { }
    }
    public class SingleItemAssertion<TElement> : .<TElement>
    {
        public SingleItemAssertion(<.<.IEnumerable>> collectionProvider) { }
    }
    public static class StringAssertionBuilderExtensions
    {
        public static . Contains(this .<string> builder, string substring) { }
        public static .<string> DoesNotContain(this .<string> builder, string substring) { }
        public static .<string> DoesNotExist(this .<string> builder) { }
        public static .<string> DoesNotMatch(this .<string> builder, . regex) { }
        public static .<string> DoesNotMatch(this .<string> builder, string pattern) { }
        public static . EndsWith(this .<string> builder, string suffix) { }
        public static .<string> Exists(this .<string> builder) { }
        public static .<int> HasCount(this .<string> builder) { }
        public static .<string> HasFiles(this .<string> builder) { }
        public static .<int> HasLength(this .<string> builder) { }
        public static .<string> HasLength(this .<string> builder, int expectedLength) { }
        public static .<string> HasNoSubdirectories(this .<string> builder) { }
        public static .<string> IsDefault(this .<string> builder) { }
        public static .<string> IsEmpty(this .<string> builder) { }
        public static . IsEqualTo(this .<string> builder, string? expected) { }
        public static . IsEqualTo(this .<string> builder, string? expected,  comparison) { }
        public static .<string> IsNotDefault(this .<string> builder) { }
        public static .<string> IsNotEmpty(this .<string> builder) { }
        public static .<string> IsNotNullOrEmpty(this .<string> builder) { }
        public static .<T> IsNotParsableInto<T>(this .<string> builder) { }
        public static .<string> IsNullOrEmpty(this .<string> builder) { }
        public static .<string> IsNullOrWhitespace(this .<string> builder) { }
        public static .<T> IsParsableInto<T>(this .<string> builder) { }
        public static .<string> Matches(this .<string> builder, . regex) { }
        public static .<string> Matches(this .<string> builder, string pattern) { }
        public static . StartsWith(this .<string> builder, string prefix) { }
        public static .<T> WhenParsedInto<T>(this .<string> builder) { }
    }
    public static class StringAssertionExtensions
    {
        public static . IsEqualToSimplified(this <string?> actualProvider, string? expected) { }
        public static . IsEqualToSimplified(this .<string?> actualTask, string? expected) { }
        public static . IsEqualToSimplified(this string? actual, string? expected) { }
    }
    public static class StringBuilderAssertionExtensions
    {
        public static .<.StringBuilder> HasExcessCapacity(this .<.StringBuilder> builder) { }
        public static .<.StringBuilder> HasNoExcessCapacity(this .<.StringBuilder> builder) { }
        public static .<.StringBuilder> IsEmpty(this .<.StringBuilder> builder) { }
        public static .<.StringBuilder> IsNotEmpty(this .<.StringBuilder> builder) { }
    }
    public class StringContainsAssertion : .<string?>
    {
        public StringContainsAssertion(<.<string?>> actualValueProvider, string substring) { }
        public StringContainsAssertion(<string?> actualValueProvider, string substring) { }
        public StringContainsAssertion(string? actualValue, string substring) { }
        protected override .<.> AssertAsync() { }
        public . IgnoringCase() { }
        public . IgnoringWhitespace() { }
        public . WithComparison( comparison) { }
        public . WithTrimming() { }
    }
    public class StringEndsWithAssertion : .<string?>
    {
        public StringEndsWithAssertion(<.<string?>> actualValueProvider, string suffix) { }
        public StringEndsWithAssertion(<string?> actualValueProvider, string suffix) { }
        public StringEndsWithAssertion(string? actualValue, string suffix) { }
        protected override .<.> AssertAsync() { }
        public . IgnoringCase() { }
        public . WithComparison( comparison) { }
    }
    public class StringEqualToAssertion : .<string?>
    {
        public StringEqualToAssertion(<.<string?>> actualValueProvider, string? expected) { }
        public StringEqualToAssertion(<string?> actualValueProvider, string? expected) { }
        public StringEqualToAssertion(string? actualValue, string? expected) { }
        protected override .<.> AssertAsync() { }
        public . IgnoringCase() { }
        public . IgnoringWhitespace() { }
        public . WithNullAndEmptyEquality() { }
        public . WithStringComparison( comparison) { }
        public . WithTrimming() { }
    }
    public class StringStartsWithAssertion : .<string?>
    {
        public StringStartsWithAssertion(<.<string?>> actualValueProvider, string prefix) { }
        public StringStartsWithAssertion(<string?> actualValueProvider, string prefix) { }
        public StringStartsWithAssertion(string? actualValue, string prefix) { }
        protected override .<.> AssertAsync() { }
        public . IgnoringCase() { }
        public . WithComparison( comparison) { }
    }
    public class ThrowsNothingAssertion<TResult> : .<TResult>
    {
        public ThrowsNothingAssertion(<.<object?>> actualValueProvider) { }
        protected override .<.> AssertAsync() { }
        public new .<TResult> GetAwaiter() { }
        public .<TResult> GetValueAsync() { }
        public static .<TResult> op_Implicit(.<TResult> assertion) { }
    }
    public class TimeSpanAssertion : .<>
    {
        public TimeSpanAssertion(<.<>> actualValueProvider,  expected) { }
        public TimeSpanAssertion(<> actualValueProvider,  expected) { }
        public TimeSpanAssertion( actualValue,  expected) { }
        protected override .<.> AssertAsync() { }
        public . Within( tolerance) { }
    }
    public class TypeAssertion<TActual> : .<TActual>
    {
        public TypeAssertion(<.<TActual>> actualValueProvider,  expectedType, bool exact) { }
        public TypeAssertion(<TActual> actualValueProvider,  expectedType, bool exact) { }
        public TypeAssertion(TActual actualValue,  expectedType, bool exact) { }
        protected override .<.> AssertAsync() { }
    }
    public class TypeOfAssertion<TExpected> : .<TExpected>
        where TExpected :  class
    {
        public TypeOfAssertion(<.<object>> actualValueProvider) { }
        public TypeOfAssertion(<object> actualValueProvider) { }
        public new .<TExpected> And { get; }
        protected override .<.> AssertAsync() { }
        public new .<TExpected> GetAwaiter() { }
        public .<TExpected> GetValueAsync() { }
        public static .<TExpected> op_Implicit(.<TExpected> assertion) { }
    }
    public class ValueAssertionBuilder<TActual> : .
    {
        protected readonly <.<TActual>> _actualValueProvider;
        protected readonly string? _expression;
        public ValueAssertionBuilder(<.<TActual>> asyncValueProvider, string? expression = null) { }
        public ValueAssertionBuilder(<TActual> valueProvider, string? expression = null) { }
        public ValueAssertionBuilder(.<TActual> task, string? expression = null) { }
        public ValueAssertionBuilder(.<TActual> valueTask, string? expression = null) { }
        public ValueAssertionBuilder(TActual value, string? expression = null) { }
        public .<TActual> And { get; }
        public .<TActual> EqualTo(TActual expected) { }
        [("This is a base `object` method that should not be called.", true)]
        public new void Equals(object? obj) { }
        public override .<.AssertionData> GetAssertionData() { }
        public override . GetAwaiter() { }
        public .<TActual> GetTypedAwaiter() { }
        public .<TActual> IsAssignableTo( expectedType) { }
        public .<TActual> IsAssignableTo<TExpected>() { }
        public .<TActual> IsEqualTo(TActual expected) { }
        public .<TActual> IsEqualTo(object? expected) { }
        public .<TActual> IsEqualTo(TActual expected, .<TActual> comparer) { }
        public .<TActual> IsEqualTo(TActual expected, string because) { }
        public .<TActual> IsEquatableOrEqualTo(TActual expected) { }
        public .<TActual> IsEquivalentTo(.<object?> expected) { }
        public .<TActual> IsEquivalentTo(.<object?> expected, . ordering) { }
        public .<TActual> IsEquivalentTo(object? expected, <object, object, bool>? comparer = null) { }
        public .<TActual> IsEquivalentTo<TElement>(.<TElement> expected, .<TElement> comparer) { }
        public .<TActual> IsEquivalentTo<TExpected>(.<TExpected> expected, . ordering) { }
        public .<TActual> IsIn(.<TActual> values) { }
        public .<TActual> IsIn(params TActual[] values) { }
        public .<TActual> IsNotAssignableTo( expectedType) { }
        public .<TActual> IsNotAssignableTo<TExpected>() { }
        public .<TActual> IsNotEqualTo(TActual expected) { }
        public .<TActual> IsNotEqualTo(object? expected) { }
        public .<TActual> IsNotEquivalentTo(.<object?> expected) { }
        public .<TActual> IsNotEquivalentTo(.<object?> expected, . ordering) { }
        public .<TActual> IsNotEquivalentTo(object? expected, <object, object, bool>? comparer = null) { }
        public .<TActual> IsNotEquivalentTo<TExpected>(.<TExpected> expected, . ordering) { }
        public .<TActual> IsNotIn(.<TActual> values) { }
        public .<TActual> IsNotIn(params TActual[] values) { }
        public .<TActual> IsNotNull() { }
        public .<TActual> IsNotSameReferenceAs(TActual expected) { }
        public .<TActual> IsNotSameReferenceAs(object? expected) { }
        public .<TActual> IsNull() { }
        public .<TActual> IsSameReferenceAs(TActual expected) { }
        public .<TActual> IsSameReferenceAs(object? expected) { }
        public .<TActual> IsTypeOf( expectedType) { }
        public .<TExpected> IsTypeOf<TExpected>()
            where TExpected :  class { }
        public override . ProcessAssertionsAsync(.AssertionData data) { }
        [("This is a base `object` method that should not be called.", true)]
        public new void ReferenceEquals(object a, object b) { }
        public .<TActual> Satisfies(<TActual, bool> predicate, string? failureMessage = null) { }
        public .<TActual> Satisfies<TConverted>(<TActual, TConverted> converter, <.<TConverted>, .<TConverted>> assertionBuilder) { }
        public .<TActual, TProperty> Satisfies<TProperty>(.<<TActual, .<TProperty>>> asyncPropertySelector, <.<TProperty>, .> assertionBuilder) { }
        public .<TActual, TProperty> Satisfies<TProperty>(.<<TActual, TProperty>> propertySelector, <.<TProperty>, .> assertionBuilder) { }
    }
    public static class WeakReferenceAssertionExtensions
    {
        public static .<> IsAlive(this .<> builder) { }
        public static .<> IsDead(this .<> builder) { }
    }
    public class WhenParsedAssertion<T> : .<T>
    {
        public WhenParsedAssertion(<.<string?>> stringValueProvider, ? formatProvider = null) { }
    }
}
namespace .
{
    public class ChainedAssertion
    {
        public ChainedAssertion(. assertion, . chainType = 0) { }
        public . Assertion { get; }
        public . ChainType { get; }
    }
}
namespace .
{
    public interface IAssertionChain
    {
        void AddAndAssertion(. assertion);
        void AddAssertion(. assertion, . chainType = 0);
        void AddOrAssertion(. assertion);
        .<..ChainedAssertion> GetAssertions();
        .<.> GetBaseAssertions();
        .? GetLastAssertion();
    }
}
namespace .Attributes
{
    [(.Method)]
    public sealed class AssertionAttribute : 
    {
        public AssertionAttribute(string expectation, string? but = null) { }
        public string? But { get; }
        public string Expectation { get; }
    }
    [(.Class, AllowMultiple=true)]
    public class CreateAssertionAttribute : 
    {
        public CreateAssertionAttribute( targetType, string methodName) { }
        public CreateAssertionAttribute( targetType,  containingType, string methodName) { }
        public ? ContainingType { get; }
        public string? CustomName { get; set; }
        public string MethodName { get; }
        public bool NegateLogic { get; set; }
        public bool RequiresGenericTypeParameter { get; set; }
        public  TargetType { get; }
        public bool TreatAsInstance { get; set; }
    }
    [(.Class, AllowMultiple=true)]
    public class CreateAssertionAttribute<TTarget> : 
    {
        public CreateAssertionAttribute(string methodName) { }
        public CreateAssertionAttribute( containingType, string methodName) { }
        public ? ContainingType { get; }
        public string? CustomName { get; set; }
        public string MethodName { get; }
        public bool NegateLogic { get; set; }
        public bool RequiresGenericTypeParameter { get; set; }
        public  TargetType { get; }
        public bool TreatAsInstance { get; set; }
    }
}
namespace .Enums
{
    public enum CollectionOrdering
    {
        Matching = 0,
        Any = 1,
    }
    public enum EquivalencyKind
    {
        Full = 0,
        Partial = 1,
    }
    public enum Order
    {
        Ascending = 0,
        Descending = 1,
    }
}
namespace .Equality
{
    public class CollectionEquivalentToEqualityComparer<T> : .<T>
    {
        public CollectionEquivalentToEqualityComparer() { }
        public CollectionEquivalentToEqualityComparer(.CompareOptions compareOptions) { }
        public override int? EnumerableIndex { get; protected set; }
        public override bool Equals(T? x, T? y) { }
    }
    public class EquivalentToEqualityComparer<T> : .<T>
    {
        public EquivalentToEqualityComparer() { }
        public EquivalentToEqualityComparer(.CompareOptions compareOptions) { }
        public .ComparisonFailure[]? ComparisonFailures { get; }
        public virtual int? EnumerableIndex { get; protected set; }
        public virtual bool Equals(T? x, T? y) { }
        public string GetFailureMessages() { }
        public int GetHashCode([.] T obj) { }
    }
}
namespace .Exceptions
{
    public class AssertionException : .
    {
        public AssertionException(string? message) { }
        public AssertionException(string? message,  innerException) { }
    }
    public class BaseAssertionException : 
    {
        public BaseAssertionException() { }
        public BaseAssertionException(string? message) { }
        public BaseAssertionException(string? message, ? innerException) { }
    }
    public class MaybeCaughtException : 
    {
        public MaybeCaughtException( exception) { }
    }
    public class MixedAndOrAssertionsException : .
    {
        public MixedAndOrAssertionsException() { }
    }
}
namespace .Extensions
{
    public static class AssertionBuilderCollectionExtensions
    {
        public static .<TCollection> Contains<TCollection, TElement>(this .<TCollection> builder, TElement item)
            where TCollection : .<TElement> { }
        public static .<.<TElement>> ContainsOnly<TElement>(this .<.<TElement>> builder, <TElement, bool> predicate) { }
        public static .<TCollection> ContainsOnly<TCollection, TElement>(this .<TCollection> builder, <TElement, bool> predicate)
            where TCollection : .<TElement> { }
        public static .<.<TElement>> DoesNotContain<TElement>(this .<.<TElement>> builder, <TElement, bool> predicate) { }
        public static .<TCollection> DoesNotContain<TCollection, TElement>(this .<TCollection> builder, <TElement, bool> predicate)
            where TCollection : .<TElement> { }
        public static .<TCollection> DoesNotContain<TCollection, TElement>(this .<TCollection> builder, TElement item)
            where TCollection : .<TElement> { }
        public static .<int> HasCount<TElement>(this .<.<TElement>> builder) { }
        public static .<.<TElement>> HasCount<TElement>(this .<.<TElement>> builder, int expectedCount) { }
        public static .<TCollection> HasCount<TCollection, TElement>(this .<TCollection> builder, int expectedCount)
            where TCollection : .<TElement> { }
        public static .<.<TElement>> HasDistinctItems<TElement>(this .<.<TElement>> builder) { }
        public static .<TCollection> HasDistinctItems<TCollection, TElement>(this .<TCollection> builder)
            where TCollection : .<TElement> { }
        public static .<.<TElement>> HasSingleItem<TElement>(this .<.<TElement>> builder) { }
        public static .<TCollection> HasSingleItem<TCollection, TElement>(this .<TCollection> builder)
            where TCollection : .<TElement> { }
        public static .<.<TElement>> IsEmpty<TElement>(this .<.<TElement>> builder) { }
        public static .<TCollection> IsEmpty<TCollection, TElement>(this .<TCollection> builder)
            where TCollection : .<TElement> { }
        public static .<.<TElement>> IsNotEmpty<TElement>(this .<.<TElement>> builder) { }
        public static .<TCollection> IsNotEmpty<TCollection, TElement>(this .<TCollection> builder)
            where TCollection : .<TElement> { }
    }
    public static class BecauseExtensions
    {
        public static TAssertionBuilder Because<TAssertionBuilder>(this TAssertionBuilder assertionBuilder, string reason, [.("reason")] string? reasonExpression = null)
            where TAssertionBuilder : . { }
    }
    public static class BooleanAssertionExtensions
    {
        public static . IsFalse(this .<bool> builder) { }
        public static . IsFalse(this .<bool?> builder) { }
        public static . IsFalse(this .<bool> builder) { }
        public static . IsFalse(this .<bool?> builder) { }
        public static . IsTrue(this .<bool> builder) { }
        public static . IsTrue(this .<bool?> builder) { }
        public static . IsTrue(this .<bool> builder) { }
        public static . IsTrue(this .<bool?> builder) { }
    }
    public static class CollectionAssertionExtensions
    {
        public static .<TCollection> Contains<TCollection, TElement>(this .<TCollection> builder, TElement item)
            where TCollection : .<TElement> { }
        public static .<TCollection> Contains<TCollection, TElement>(this .<TCollection> builder, TElement item)
            where TCollection : .<TElement> { }
        public static .<.<T>> ContainsOnly<T>(this .<.<T>> builder, <T, bool> predicate) { }
        public static .<TCollection> DoesNotContain<TCollection, TElement>(this .<TCollection> builder, TElement item)
            where TCollection : .<TElement> { }
        public static .<TCollection> DoesNotContain<TCollection, TElement>(this .<TCollection> builder, TElement item)
            where TCollection : .<TElement> { }
        public static .<TCollection> HasCount<TCollection>(this .<TCollection> builder, int expectedCount)
            where TCollection : .IEnumerable { }
        public static .<.<T>> HasSingleItem<T>(this .<.<T>> builder) { }
        public static .<.<T>> HasSingleItem<T>(this .<.<T>> builder) { }
        public static .<TCollection> IsEmpty<TCollection>(this .<TCollection> builder)
            where TCollection : .IEnumerable { }
        public static .<TCollection> IsEmpty<TCollection>(this .<TCollection> builder)
            where TCollection : .IEnumerable { }
        public static .<TCollection> IsEquivalentTo<TCollection, TElement>(this .<TCollection> builder, .<TElement> expected)
            where TCollection : .<TElement>
            where TElement :  notnull { }
        public static .<TCollection> IsNotEmpty<TCollection>(this .<TCollection> builder)
            where TCollection : .IEnumerable { }
        public static .<TCollection> IsNotEmpty<TCollection>(this .<TCollection> builder)
            where TCollection : .IEnumerable { }
        public static .<TCollection> IsNotEquivalentTo<TCollection, TElement>(this .<TCollection> builder, .<TElement> expected)
            where TCollection : .<TElement>
            where TElement :  notnull { }
    }
    public static class ComparableAssertionExtensions
    {
        public static .<T> GreaterThanOrEqualTo<T>(this .<T> builder, T value)
            where T : <T> { }
        public static .<T> GreaterThanOrEqualTo<T>(this .<T> builder, T value)
            where T : <T> { }
        public static .<T> IsBetween<T>(this .<T> builder, T min, T max)
            where T : <T> { }
        public static .<T> IsBetween<T>(this .<T> builder, T min, T max)
            where T : <T> { }
        public static .<T> IsGreaterThan<T>(this .<T> builder, T value)
            where T : <T> { }
        public static .<T> IsGreaterThan<T>(this .<T> builder, T value)
            where T : <T> { }
        public static .<T> IsGreaterThanOrEqualTo<T>(this .<T> builder, T value)
            where T : <T> { }
        public static .<T> IsGreaterThanOrEqualTo<T>(this .<T> builder, T value)
            where T : <T> { }
        public static .<T> IsLessThan<T>(this .<T> builder, T value)
            where T : <T> { }
        public static .<T> IsLessThan<T>(this .<T> builder, T value)
            where T : <T> { }
        public static .<T> IsLessThanOrEqualTo<T>(this .<T> builder, T value)
            where T : <T> { }
        public static .<T> IsLessThanOrEqualTo<T>(this .<T> builder, T value)
            where T : <T> { }
    }
    public static class CustomAssertionExtensions
    {
        public static .<TActual> RegisterAssertion<TActual>(this ..IValueSource<TActual> valueSource, .<TActual> condition, string[]? expressions = null) { }
        public static .<TActual> RegisterAssertion<TActual>(this .<TActual> builder, .<TActual> condition, string[]? expressions = null) { }
        public static .<TToType> RegisterConversionAssertion<TActual, TToType>(this ..IValueSource<TActual> valueSource, .<TActual, TToType> condition, string[]? expressions = null) { }
        public static .<TToType> RegisterConversionAssertion<TActual, TToType>(this .<TActual> builder, .<TActual, TToType> condition, string[]? expressions = null) { }
        public static .<TToType> RegisterConversionAssertion<TActual, TToType>(this .<TActual> builder, .<TActual, TToType> condition, string[]? expressions = null) { }
    }
    public static class DelegateAssertionExtensions
    {
        public static .<> CompletesWithin(this .<> builder,  timeout) { }
        public static .<<.>> CompletesWithin(this .<<.>> builder,  timeout) { }
        public static .<T> CompletesWithin<T>(this .<T> builder,  timeout) { }
        public static .<> DoesNotCompleteWithin(this .<> builder,  timeout) { }
        public static .<<.>> DoesNotCompleteWithin(this .<<.>> builder,  timeout) { }
        public static .<T> DoesNotCompleteWithin<T>(this .<T> builder,  timeout) { }
    }
    public static class DictionaryAssertionExtensions
    {
        public static .<TDictionary> ContainsKey<TDictionary>(this .<TDictionary> builder, object key)
            where TDictionary :  class { }
        public static .<.<string, TValue>> ContainsKey<TValue>(this .<.<string, TValue>> builder, string key, .<string> comparer) { }
        public static .<.<TKey, TValue>> ContainsKey<TKey, TValue>(this .<.<TKey, TValue>> builder, TKey key)
            where TKey :  notnull { }
        public static .<.<TKey, TValue>> ContainsKey<TKey, TValue>(this .<.<TKey, TValue>> builder, TKey key)
            where TKey :  notnull { }
        public static .<.<TKey, TValue>> ContainsKey<TKey, TValue>(this .<.<TKey, TValue>> builder, TKey key)
            where TKey :  notnull { }
        public static .<.<TKey, TValue>> ContainsKey<TKey, TValue>(this .<.<TKey, TValue>> builder, TKey key)
            where TKey :  notnull { }
        public static .<.<TKey, TValue>> ContainsValue<TKey, TValue>(this .<.<TKey, TValue>> builder, TValue value)
            where TKey :  notnull { }
        public static .<TDictionary> DoesNotContainKey<TDictionary>(this .<TDictionary> builder, object key)
            where TDictionary :  class { }
        public static .<.<TKey, TValue>> DoesNotContainKey<TKey, TValue>(this .<.<TKey, TValue>> builder, TKey key)
            where TKey :  notnull { }
        public static .<.<TKey, TValue>> DoesNotContainKey<TKey, TValue>(this .<.<TKey, TValue>> builder, TKey key)
            where TKey :  notnull { }
        public static .<.<TKey, TValue>> DoesNotContainKey<TKey, TValue>(this .<.<TKey, TValue>> builder, TKey key)
            where TKey :  notnull { }
        public static .<.<TKey, TValue>> DoesNotContainKey<TKey, TValue>(this .<.<TKey, TValue>> builder, TKey key)
            where TKey :  notnull { }
        public static .<int> HasCount<TKey, TValue>(this .<.<TKey, TValue>> builder)
            where TKey :  notnull { }
        public static .<int> HasCount<TKey, TValue>(this .<.<TKey, TValue>> builder) { }
    }
    public static class EnumAssertionExtensions
    {
        public static .<TEnum> DoesNotHaveFlag<TEnum>(this .<TEnum> builder, TEnum flag)
            where TEnum :  { }
        public static .<TEnum> DoesNotHaveFlag<TEnum>(this .<TEnum> builder, TEnum flag)
            where TEnum :  { }
        public static .<TEnum> DoesNotHaveSameNameAs<TEnum>(this .<TEnum> builder,  other)
            where TEnum :  { }
        public static .<TEnum> DoesNotHaveSameNameAs<TEnum>(this .<TEnum> builder,  other)
            where TEnum :  { }
        public static .<TEnum> DoesNotHaveSameValueAs<TEnum>(this .<TEnum> builder,  other)
            where TEnum :  { }
        public static .<TEnum> HasFlag<TEnum>(this .<TEnum> builder, TEnum flag)
            where TEnum :  { }
        public static .<TEnum> HasFlag<TEnum>(this .<TEnum> builder, TEnum flag)
            where TEnum :  { }
        public static .<TEnum> HasSameNameAs<TEnum>(this .<TEnum> builder,  other)
            where TEnum :  { }
        public static .<TEnum> HasSameNameAs<TEnum>(this .<TEnum> builder,  other)
            where TEnum :  { }
        public static .<TEnum> HasSameValueAs<TEnum>(this .<TEnum> builder,  other)
            where TEnum :  { }
        public static .<TEnum> IsDefined<TEnum>(this .<TEnum> builder)
            where TEnum :  { }
        public static .<TEnum> IsDefined<TEnum>(this .<TEnum> builder)
            where TEnum :  { }
        public static .<TEnum> IsNotDefined<TEnum>(this .<TEnum> builder)
            where TEnum :  { }
        public static .<TEnum> IsNotDefined<TEnum>(this .<TEnum> builder)
            where TEnum :  { }
    }
    public static class ExceptionAssertionExtensions
    {
        public static .<TException> HasMessageContaining<TException>(this .<TException> builder, string substring)
            where TException :  { }
        public static .<TException> HasMessageContaining<TException>(this .<TException> builder, string substring)
            where TException :  { }
        public static .<TException> HasMessageEndingWith<TException>(this .<TException> builder, string suffix)
            where TException :  { }
        public static .<TException> HasMessageEndingWith<TException>(this .<TException> assertion, string suffix)
            where TException :  { }
        public static .<TException> HasMessageEndingWith<TException>(this .<TException> builder, string suffix)
            where TException :  { }
        public static .<TException> HasMessageEqualTo<TException>(this .<TException> builder, string expectedMessage)
            where TException :  { }
        public static .<TException> HasMessageMatching<TException>(this .<TException> assertion, string pattern)
            where TException :  { }
        public static .<TException> HasMessageStartingWith<TException>(this .<TException> builder, string prefix)
            where TException :  { }
        public static .<TException> HasMessageStartingWith<TException>(this .<TException> assertion, string prefix)
            where TException :  { }
        public static .<TException> HasMessageStartingWith<TException>(this .<TException> builder, string prefix)
            where TException :  { }
    }
    public static class GenericAssertionExtensions
    {
        public static .<T> DoesNotHaveMember<T>(this .<T> builder, string memberName) { }
        public static .<T> DoesNotHaveMember<T>(this .<T> builder, string memberName) { }
        public static .<T> HasMember<T>(this .<T> builder, string memberName) { }
        public static .<T> HasMember<T>(this .<T> builder, string memberName) { }
        public static .<T, TMember> HasMember<T, TMember>(this .<T> builder, .<<T, TMember>> memberSelector) { }
        public static .<T> IsDefault<T>(this .<T> builder) { }
        public static .<T> IsDefault<T>(this .<T> builder) { }
        public static .<T> IsNotDefault<T>(this .<T> builder) { }
        public static .<T> IsNotDefault<T>(this .<T> builder) { }
    }
    public static class NumericAssertionExtensions
    {
        public static .<int> IsGreaterThan(this .<int> builder, int value) { }
        public static .<byte> IsGreaterThan(this .<byte> builder, byte value) { }
        public static .<decimal> IsGreaterThan(this .<decimal> builder, decimal value) { }
        public static .<double> IsGreaterThan(this .<double> builder, double value) { }
        public static .<float> IsGreaterThan(this .<float> builder, float value) { }
        public static .<int> IsGreaterThan(this .<int> builder, int value) { }
        public static .<long> IsGreaterThan(this .<long> builder, long value) { }
        public static .<short> IsGreaterThan(this .<short> builder, short value) { }
        public static .<int> IsGreaterThanOrEqualTo(this .<int> builder, int value) { }
        public static .<byte> IsGreaterThanOrEqualTo(this .<byte> builder, byte value) { }
        public static .<decimal> IsGreaterThanOrEqualTo(this .<decimal> builder, decimal value) { }
        public static .<double> IsGreaterThanOrEqualTo(this .<double> builder, double value) { }
        public static .<float> IsGreaterThanOrEqualTo(this .<float> builder, float value) { }
        public static .<int> IsGreaterThanOrEqualTo(this .<int> builder, int value) { }
        public static .<long> IsGreaterThanOrEqualTo(this .<long> builder, long value) { }
        public static .<short> IsGreaterThanOrEqualTo(this .<short> builder, short value) { }
        public static .<int> IsLessThan(this .<int> builder, int value) { }
        public static .<byte> IsLessThan(this .<byte> builder, byte value) { }
        public static .<decimal> IsLessThan(this .<decimal> builder, decimal value) { }
        public static .<double> IsLessThan(this .<double> builder, double value) { }
        public static .<float> IsLessThan(this .<float> builder, float value) { }
        public static .<int> IsLessThan(this .<int> builder, int value) { }
        public static .<long> IsLessThan(this .<long> builder, long value) { }
        public static .<short> IsLessThan(this .<short> builder, short value) { }
        public static .<int> IsLessThanOrEqualTo(this .<int> builder, int value) { }
        public static .<byte> IsLessThanOrEqualTo(this .<byte> builder, byte value) { }
        public static .<decimal> IsLessThanOrEqualTo(this .<decimal> builder, decimal value) { }
        public static .<double> IsLessThanOrEqualTo(this .<double> builder, double value) { }
        public static .<float> IsLessThanOrEqualTo(this .<float> builder, float value) { }
        public static .<int> IsLessThanOrEqualTo(this .<int> builder, int value) { }
        public static .<long> IsLessThanOrEqualTo(this .<long> builder, long value) { }
        public static .<short> IsLessThanOrEqualTo(this .<short> builder, short value) { }
        public static .<int> IsNegative(this .<int> builder) { }
        public static .<decimal> IsNegative(this .<decimal> builder) { }
        public static .<double> IsNegative(this .<double> builder) { }
        public static .<float> IsNegative(this .<float> builder) { }
        public static .<int> IsNegative(this .<int> builder) { }
        public static .<long> IsNegative(this .<long> builder) { }
        public static .<short> IsNegative(this .<short> builder) { }
        public static .<int> IsPositive(this .<int> builder) { }
        public static .<byte> IsPositive(this .<byte> builder) { }
        public static .<decimal> IsPositive(this .<decimal> builder) { }
        public static .<double> IsPositive(this .<double> builder) { }
        public static .<float> IsPositive(this .<float> builder) { }
        public static .<int> IsPositive(this .<int> builder) { }
        public static .<long> IsPositive(this .<long> builder) { }
        public static .<short> IsPositive(this .<short> builder) { }
    }
    public static class StringAssertionExtensions
    {
        public static . Contains(this .<string> builder, string substring) { }
        public static . Contains(this .<string> builder, string substring) { }
        public static .<string> DoesNotContain(this .<string> builder, string substring) { }
        public static .<string> DoesNotContain(this .<string> builder, string substring) { }
        public static .<string> DoesNotMatch(this .<string> builder, . regex) { }
        public static .<string> DoesNotMatch(this .<string> builder, string pattern) { }
        public static .<string> DoesNotMatch(this .<string> builder, . regex) { }
        public static .<string> DoesNotMatch(this .<string> builder, string pattern) { }
        public static . EndsWith(this .<string> builder, string suffix) { }
        public static . EndsWith(this .<string> builder, string suffix) { }
        public static .<int> HasCount(this .<string> builder) { }
        public static .<int> HasLength(this .<string> builder) { }
        public static .<int> HasLength(this .<string> builder) { }
        public static .<string> HasLength(this .<string> builder, int expectedLength) { }
        public static .<string> HasLength(this .<string> builder, int expectedLength) { }
        public static .<string> IsEmpty(this .<string> builder) { }
        public static .<string> IsEmpty(this .<string> builder) { }
        public static .<string> IsEqualTo(this .<string> builder, string expected,  comparisonType) { }
        public static .<string> IsEqualTo(this .<string> builder, string expected,  comparisonType) { }
        public static .<string> IsNotEmpty(this .<string> builder) { }
        public static .<string> IsNotEmpty(this .<string> builder) { }
        public static .<string> IsNotEqualTo(this .<string> builder, string expected,  comparisonType) { }
        public static .<string> IsNotEqualTo(this .<string> builder, string expected,  comparisonType) { }
        public static .<string> IsNotNullOrEmpty(this .<string> builder) { }
        public static .<string> IsNotNullOrWhiteSpace(this .<string> builder) { }
        public static .<string> IsNotNullOrWhitespace(this .<string> builder) { }
        public static .<string> IsNotNullOrWhitespace(this .<string> builder) { }
        public static .<string> IsNullOrEmpty(this .<string> builder) { }
        public static .<string> IsNullOrWhiteSpace(this .<string> builder) { }
        public static .<string> IsNullOrWhitespace(this .<string> builder) { }
        public static .<string> IsNullOrWhitespace(this .<string> builder) { }
        public static .<string> Matches(this .<string> builder, . regex) { }
        public static .<string> Matches(this .<string> builder, string pattern) { }
        public static .<string> Matches(this .<string> builder, . regex) { }
        public static .<string> Matches(this .<string> builder, string pattern) { }
        public static . StartsWith(this .<string> builder, string prefix) { }
        public static . StartsWith(this .<string> builder, string prefix) { }
    }
    public static class StringExtensions
    {
        public static string GetStringOr(this string? value, string defaultValue) { }
        public static string GetStringOrEmpty(this string? value) { }
        public static string PrependAOrAn(this string value) { }
        public static string ReplaceNewLines(this string value) { }
        public static string ShowNewLines(this string value) { }
        public static string TruncateWithEllipsis(this string value, int maxLength) { }
    }
    public static class StringParseExtensions
    {
        public static .<T> IsNotParsableInto<T>(this .<string> builder) { }
        public static .<T> IsNotParsableInto<T>(this .<string> builder) { }
        public static .<T> IsParsableInto<T>(this .<string> builder) { }
        public static .<T> IsParsableInto<T>(this .<string> builder) { }
        public static .<string> IsParsableInto<T>(this .<string> builder, ? formatProvider) { }
        public static .<T> WhenParsedInto<T>(this .<string> builder) { }
        public static .<T> WhenParsedInto<T>(this .<string> builder) { }
    }
    public static class TimeSpanExtensions
    {
        public static  Days(this int days) { }
        public static  Hours(this int hours) { }
        public static  Milliseconds(this int milliseconds) { }
        public static  Minutes(this int minutes) { }
        public static  Seconds(this int seconds) { }
    }
}
namespace .Helpers
{
    public static class ExpressionHelpers
    {
        public static string GetName<T1, T2>(.<<T1, T2>> exp) { }
    }
    public abstract class Formatter
    {
        protected Formatter() { }
        public abstract bool CanHandle(object? value);
        public abstract string FormatValue(object? value);
        public static string Format(object? value) { }
    }
    public class StringDifference
    {
        public StringDifference(string? actualValue, string? expectedValue, .<string>? comparer = null) { }
        public int IgnoreWhiteSpace { get; set; }
        public int? OverriddenIndex { get; set; }
        public int IndexOfFirstMismatch() { }
        public override string ToString() { }
        public string ToString(string prefix) { }
    }
    public static class TimeSpanFormatter
    {
        public static string PrettyPrint(this  timeSpan) { }
    }
}