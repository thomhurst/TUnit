[assembly: .(".NETStandard,Version=v2.0", FrameworkDisplayName=".NET Standard 2.0")]
namespace 
{
    public static class Assert
    {
        public static void Fail(string reason) { }
        public static  Multiple() { }
        public static . That( value, [.("value")] string? doNotPopulateThisValue = null) { }
        public static .<.<object>> That(.IEnumerable enumerable, [.("enumerable")] string? doNotPopulateThisValue = null) { }
        public static . That(<.> value, [.("value")] string? doNotPopulateThisValue = null) { }
        public static . That(. value, [.("value")] string? doNotPopulateThisValue = null) { }
        public static . That(. value, [.("value")] string? doNotPopulateThisValue = null) { }
        public static .<TActual> That<TActual>(<.<TActual>> value, [.("value")] string? doNotPopulateThisValue = null) { }
        public static .<TActual> That<TActual>(<TActual> value, [.("value")] string? doNotPopulateThisValue = null) { }
        public static .<TActual> That<TActual>(.<TActual> value, [.("value")] string? doNotPopulateThisValue = null) { }
        public static .<TActual> That<TActual>(.<TActual> value, [.("value")] string? doNotPopulateThisValue = null) { }
        public static .<TActual> That<TActual>(TActual value, [.("value")] string? doNotPopulateThisValue = null) { }
        public static  Throws( @delegate, [.("delegate")] string? doNotPopulateThisValue = null) { }
        public static  Throws( type,  @delegate, [.("delegate")] string? doNotPopulateThisValue = null) { }
        public static TException Throws<TException>( @delegate, [.("delegate")] string? doNotPopulateThisValue = null)
            where TException :  { }
        public static TException Throws<TException>(string parameterName,  @delegate, [.("delegate")] string? doNotPopulateThisValue = null)
            where TException :  { }
        public static .<object?, > ThrowsAsync(<.> @delegate, [.("delegate")] string? doNotPopulateThisValue = null) { }
        public static .<object?, > ThrowsAsync(. @delegate, [.("delegate")] string? doNotPopulateThisValue = null) { }
        public static .<object?, > ThrowsAsync(. @delegate, [.("delegate")] string? doNotPopulateThisValue = null) { }
        public static .<object?, > ThrowsAsync( type, <.> @delegate, [.("delegate")] string? doNotPopulateThisValue = null) { }
        public static .<object?, > ThrowsAsync( type, . @delegate, [.("delegate")] string? doNotPopulateThisValue = null) { }
        public static .<object?, > ThrowsAsync( type, . @delegate, [.("delegate")] string? doNotPopulateThisValue = null) { }
        public static .<object?, TException> ThrowsAsync<TException>(<.> @delegate, [.("delegate")] string? doNotPopulateThisValue = null)
            where TException :  { }
        public static .<object?, TException> ThrowsAsync<TException>(. @delegate, [.("delegate")] string? doNotPopulateThisValue = null)
            where TException :  { }
        public static .<object?, TException> ThrowsAsync<TException>(. @delegate, [.("delegate")] string? doNotPopulateThisValue = null)
            where TException :  { }
        public static .<object?, TException> ThrowsAsync<TException>(string parameterName, <.> @delegate, [.("delegate")] string? doNotPopulateThisValue = null, [.("parameterName")] string? doNotPopulateThisValue2 = null)
            where TException :  { }
        public static .<object?, TException> ThrowsAsync<TException>(string parameterName, . @delegate, [.("delegate")] string? doNotPopulateThisValue = null, [.("parameterName")] string? doNotPopulateThisValue2 = null)
            where TException :  { }
        public static .<object?, TException> ThrowsAsync<TException>(string parameterName, . @delegate, [.("delegate")] string? doNotPopulateThisValue = null, [.("parameterName")] string? doNotPopulateThisValue2 = null)
            where TException :  { }
    }
    public readonly struct AssertionData : <.AssertionData>
    {
        public AssertionData(object? Result, ? Exception, string? ActualExpression,  Start,  End) { }
        public string? ActualExpression { get; init; }
        public  End { get; init; }
        public ? Exception { get; init; }
        public object? Result { get; init; }
        public  Start { get; init; }
        public static .AssertionData op_Implicit(<object?, ?, string?, , > tuple) { }
    }
    public class AssertionDecision : <.AssertionDecision>
    {
        public static .AssertionDecision Continue { get; }
        public static .AssertionDecision Pass { get; }
        public static .AssertionDecision Fail(string message) { }
    }
    public class AssertionMetadata
    {
        public AssertionMetadata() { }
        public  Duration { get; }
        public required  EndTime { get; init; }
        public required  StartTime { get; init; }
    }
    public class CollectionWrapper<TInner>
    {
        public CollectionWrapper(..IValueSource<.<TInner>> valueSource) { }
        public .<.<TInner>> Satisfy(<..IValueSource<TInner?>, .> assert, [.("assert")] string assertionBuilderExpression = "") { }
        public .<.<TInner>> Satisfy<TExpected>(<TInner?, .<TExpected>?> asyncMapper, <..IValueSource<TExpected?>, .> assert, [.("asyncMapper")] string mapperExpression = "", [.("assert")] string assertionBuilderExpression = "") { }
        public .<.<TInner>> Satisfy<TExpected>(<TInner?, TExpected> mapper, <..IValueSource<TExpected?>, .> assert, [.("mapper")] string mapperExpression = "", [.("assert")] string assertionBuilderExpression = "") { }
    }
    public static class Compare
    {
        public static .<.ComparisonFailure> CheckEquivalent<TActual, TExpected>(TActual actual, TExpected expected, .CompareOptions options, int? index) { }
    }
    public class CompareOptions : <.CompareOptions>
    {
        public CompareOptions() { }
        public . EquivalencyKind { get; set; }
        public string[] MembersToIgnore { get; init; }
    }
    public class ComparisonFailure : <.ComparisonFailure>
    {
        public ComparisonFailure() { }
        public required object? Actual { get; init; }
        public required object? Expected { get; init; }
        public required string[] NestedMemberNames { get; init; }
        public required .MemberType Type { get; init; }
    }
    public static class Fail
    {
        [.]
        public static void Test(string reason) { }
        public static void Unless([.(false)] bool condition, string reason) { }
        public static void When([.(true)] bool condition, string reason) { }
    }
    public enum MemberType
    {
        Property = 0,
        Field = 1,
        Value = 2,
        EnumerableItem = 3,
        DictionaryItem = 4,
    }
}
namespace .AssertConditions
{
    public class AssertionResult
    {
        public bool IsPassed { get; }
        public string Message { get; }
        public static . Passed { get; }
        public . And(. other) { }
        public .<.> OrAsync(<.<.>> otherResult) { }
        public . OrFailIf(bool isFailed, ..InterpolatedStringHandler stringHandler) { }
        public . OrFailIf(bool isFailed, string message) { }
        public static . Fail(string message) { }
        public static . FailIf(bool isFailed, ..InterpolatedStringHandler stringHandler) { }
        public static . FailIf(bool isFailed, string message) { }
        public static .<.> op_Implicit(. result) { }
        public static .<.> op_Implicit(. result) { }
        public readonly struct InterpolatedStringHandler
        {
            public InterpolatedStringHandler(int literalLength, int formattedCount, bool isFailed, out bool enabled) { }
            public void AppendFormatted<T>(T? t) { }
            public void AppendFormatted<T>(T? t, string format)
                where T :  { }
            public void AppendLiteral(string s) { }
        }
    }
    public abstract class BaseAssertCondition
    {
        protected BaseAssertCondition() { }
        public string? OverriddenMessage { get; }
        public string? Subject { get; }
        public virtual ? WaitFor { get; protected set; }
        public . FailWithMessage(string message) { }
        protected abstract string GetExpectation();
    }
    public abstract class BaseAssertCondition<TActual> : .
    {
        protected BaseAssertCondition() { }
        public string? ActualExpression { get; }
        public .<.> GetAssertionResult(TActual? actualValue, ? exception, .AssertionMetadata assertionMetadata, string? actualExpression = null) { }
        protected abstract .<.> GetResult(TActual? actualValue, ? exception, .AssertionMetadata assertionMetadata);
    }
    public enum ChainType
    {
        None = 0,
        And = 1,
        Or = 2,
    }
    public abstract class ConvertToAssertCondition<TFromType, TToType> : .<TFromType>
    {
        protected ConvertToAssertCondition() { }
        public TToType ConvertedValue { get; }
        public abstract .<<., TToType?>> ConvertValue(TFromType? value);
        protected override sealed .<.> GetResult(TFromType? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public abstract class DelegateAssertCondition : .<object?, >
    {
        protected DelegateAssertCondition() { }
    }
    public abstract class DelegateAssertCondition<TActual> : .<TActual, >
    {
        protected DelegateAssertCondition() { }
    }
    public abstract class DelegateAssertCondition<TActual, TException> : .<TActual>
        where TException : 
    {
        protected DelegateAssertCondition() { }
        protected override string GetExpectation() { }
        protected virtual string GetFailureMessage(TException? exception) { }
        protected override .<.> GetResult(TActual? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
        public void WithComparer(<TException?, .AssertionDecision> comparer) { }
    }
    public class EnumerableSatisfiesAssertCondition<TActual, TInner, TExpected> : .<TActual>
        where TActual : .<TInner?>
    {
        public EnumerableSatisfiesAssertCondition(<TInner?, .<TExpected>?> mapper, <..IValueSource<TExpected?>, .> assertionBuilder, string mapperExpression, string assertionBuilderExpression) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(TActual? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public abstract class ExpectedExceptionDelegateAssertCondition<TException> : .<object?, >
    {
        protected ExpectedExceptionDelegateAssertCondition() { }
    }
    public abstract class ExpectedValueAssertCondition<TActual, TExpected> : .<TActual>
    {
        protected ExpectedValueAssertCondition(TExpected? expected) { }
        public TExpected ExpectedValue { get; }
        protected abstract .<.> GetResult(TActual? actualValue, TExpected? expectedValue);
        protected override .<.> GetResult(TActual? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
        public void WithComparer(<TActual?, TExpected?, .AssertionDecision> comparer) { }
        public void WithTransform(<TActual?, TActual?> actualTransformation, <TExpected?, TExpected?> expectedTransformation) { }
    }
    public class FailureLocation : <.>
    {
        public FailureLocation() { }
        public object? ActualValue { get; }
        public object? ExpectedValue { get; }
        public long Position { get; }
    }
    public class FuncValueAssertCondition<TActual, TExpected> : .<TActual, TExpected>
    {
        public FuncValueAssertCondition(TExpected? expected, <TActual?, TExpected?, .<TActual, TExpected>, bool> condition, <TActual?, ?, string?, string> defaultMessageFactory, string expectation) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(TActual? actualValue, TExpected? expectedValue) { }
    }
    public class NotNullExpectedValueAssertCondition<TActual> : .<TActual?, TActual>
        where TActual :  class?
    {
        public NotNullExpectedValueAssertCondition() { }
        public override .<<., TActual?>> ConvertValue(TActual? value) { }
        protected override string GetExpectation() { }
    }
    public class NotNullStructExpectedValueAssertCondition<TActual> : .<TActual?, TActual>
        where TActual :  struct
    {
        public NotNullStructExpectedValueAssertCondition() { }
        public override .<<., TActual>> ConvertValue(TActual? value) { }
        protected override string GetExpectation() { }
    }
    public class NullExpectedValueAssertCondition<TActual> : .<TActual>
    {
        public NullExpectedValueAssertCondition() { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(TActual? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class SatisfiesAssertCondition<TActual, TExpected> : .<TActual>
    {
        public SatisfiesAssertCondition(<TActual, .<TExpected>?> mapper, <..IValueSource<TExpected?>, .<TExpected?>> assertionBuilder, string mapperExpression, string assertionBuilderExpression) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(TActual? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class StaticMethodAssertCondition<T> : .<T>
    {
        public StaticMethodAssertCondition(<T, bool> predicate, string methodName, bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(T? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public abstract class StringMatcher
    {
        protected StringMatcher() { }
        public static ..RegexMatch AsRegex(string pattern) { }
        public static ..WildcardMatch AsWildcard(string pattern) { }
        public static . op_Implicit(. pattern) { }
        public static . op_Implicit(string pattern) { }
        public sealed class RegexMatch : .
        {
            public ..RegexMatch IgnoringCase(bool ignoreCase = true) { }
            public override string ToString() { }
        }
        public sealed class WildcardMatch : .
        {
            public ..WildcardMatch IgnoringCase(bool ignoreCase = true) { }
            public override string ToString() { }
        }
    }
    public abstract class ValueAssertCondition<TActual> : .<TActual>
    {
        protected ValueAssertCondition() { }
        protected override string GetExpectation() { }
        protected abstract string GetFailureMessage(TActual? actualValue);
        protected override .<.> GetResult(TActual? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
        protected abstract . Passes(TActual? actualValue);
        public void WithComparer(<TActual?, .AssertionDecision> comparer) { }
        public void WithTransform(<TActual?, TActual?> actualTransformation) { }
    }
}
namespace .
{
    public class DateTimeEqualsExpectedValueAssertCondition : .<, >
    {
        public DateTimeEqualsExpectedValueAssertCondition( expected) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult( actualValue,  expectedValue) { }
        public void SetTolerance( tolerance) { }
    }
    public class DateTimeOffsetEqualsExpectedValueAssertCondition : .<, >
    {
        public DateTimeOffsetEqualsExpectedValueAssertCondition( expected) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult( actualValue,  expectedValue) { }
        public void SetTolerance( tolerance) { }
    }
    public class TimeSpanEqualsExpectedValueAssertCondition : .<, >
    {
        public TimeSpanEqualsExpectedValueAssertCondition( expected) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult( actualValue,  expectedValue) { }
        public void SetTolerance( tolerance) { }
    }
}
namespace .
{
    public class Member<TActualRootType, TPropertyType>
    {
        public Member(..IValueSource<TActualRootType> valueSource, .<<TActualRootType, TPropertyType>> selector) { }
        public .<TActualRootType> EqualTo(TPropertyType expected, [.("expected")] string? doNotPopulateThisValue = null) { }
        public .<TActualRootType> NotEqualTo(TPropertyType expected, [.("expected")] string? doNotPopulateThisValue = null) { }
    }
    public class PropertyEqualsExpectedValueAssertCondition<TRootObjectType, TPropertyType> : .<TRootObjectType, TPropertyType>
    {
        public PropertyEqualsExpectedValueAssertCondition(.<<TRootObjectType, TPropertyType>> propertySelector, TPropertyType expected, bool isEqual) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(TRootObjectType? actualValue, TPropertyType? expectedValue) { }
    }
}
namespace .
{
    public class EnumerableAllExpectedFuncAssertCondition<TActual, TInner> : .<TActual>
        where TActual : .<TInner>
    {
        public EnumerableAllExpectedFuncAssertCondition(<TInner, bool> matcher, string? matcherString) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(TActual? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class EnumerableContainsExpectedFuncAssertCondition<TActual, TInner> : .<TActual>
        where TActual : .<TInner>
    {
        public EnumerableContainsExpectedFuncAssertCondition(<TInner, bool> matcher, string? matcherString) { }
        public TInner FoundItem { get; }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(TActual? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class EnumerableContainsExpectedValueAssertCondition<TActual, TInner> : .<TActual, TInner>
        where TActual : .<TInner>
    {
        public EnumerableContainsExpectedValueAssertCondition(TInner expected, .<TInner?>? equalityComparer) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(TActual? actualValue, TInner? inner) { }
    }
    public class EnumerableCountEqualToExpectedValueAssertCondition<TActual, TInner> : .<TActual, int>
        where TActual : .<TInner>
    {
        public EnumerableCountEqualToExpectedValueAssertCondition(int expected) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(TActual? actualValue, int count) { }
    }
    public class EnumerableCountNotEqualToExpectedValueAssertCondition<TActual, TInner> : .<TActual, int>
        where TActual : .<TInner>
    {
        public EnumerableCountNotEqualToExpectedValueAssertCondition(int expected) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(TActual? actualValue, int count) { }
    }
    public class EnumerableDistinctItemsExpectedValueAssertCondition<TActual, TInner> : .<TActual>
        where TActual : .<TInner>
    {
        public EnumerableDistinctItemsExpectedValueAssertCondition(.<TInner?>? equalityComparer) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(TActual? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class EnumerableEquivalentToExpectedValueAssertCondition<TActual, TInner> : .<TActual, .<TInner>>
        where TActual : .<TInner>?
    {
        public EnumerableEquivalentToExpectedValueAssertCondition(.<TInner>? expected, .<TInner?> equalityComparer, . collectionOrdering) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(TActual? actualValue, .<TInner>? expectedValue) { }
    }
    public class EnumerableNotContainsExpectedFuncAssertCondition<TActual, TInner> : .<TActual>
        where TActual : .<TInner>
    {
        public EnumerableNotContainsExpectedFuncAssertCondition(<TInner, bool> matcher, string? matcherString) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(TActual? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class EnumerableNotContainsExpectedValueAssertCondition<TActual, TInner> : .<TActual, TInner>
        where TActual : .<TInner>
    {
        public EnumerableNotContainsExpectedValueAssertCondition(TInner expected, .<TInner?>? equalityComparer) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(TActual? actualValue, TInner? inner) { }
    }
    public class EnumerableNotEquivalentToExpectedValueAssertCondition<TActual, TInner> : .<TActual, .<TInner>>
        where TActual : .<TInner>?
    {
        public EnumerableNotEquivalentToExpectedValueAssertCondition(.<TInner>? expected, .<TInner?> equalityComparer, . collectionOrdering) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(TActual? actualValue, .<TInner>? expectedValue) { }
    }
    public class EnumerableOrderedByAssertCondition<TActual, TInner, TComparisonItem> : .<TActual>
        where TActual : .<TInner>
    {
        public EnumerableOrderedByAssertCondition(.<TComparisonItem?> comparer, <TInner, TComparisonItem> comparisonItemSelector, . order) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(TActual? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class PropertyOrMethodAccessor<TActual>
    {
        public PropertyOrMethodAccessor() { }
    }
}
namespace .
{
    public class BetweenAssertCondition<TActual> : .<TActual>
        where TActual : <TActual>
    {
        public BetweenAssertCondition(TActual minimum, TActual maximum) { }
        public void Exclusive() { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(TActual? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
        public void Inclusive() { }
    }
    public class NotBetweenAssertCondition<TActual> : .<TActual>
        where TActual : <TActual>
    {
        public NotBetweenAssertCondition(TActual minimum, TActual maximum) { }
        public void Exclusive() { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(TActual? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
        public void Inclusive() { }
    }
}
namespace .
{
    public class ExceptionMessageContainingExpectedValueAssertCondition<TException> : .<TException, string>
        where TException : 
    {
        public ExceptionMessageContainingExpectedValueAssertCondition(string expected,  stringComparison) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(TException? actualValue, string? expectedValue) { }
    }
    public class ExceptionMessageEndingWithExpectedValueAssertCondition<TException> : .<TException, string>
        where TException : 
    {
        public ExceptionMessageEndingWithExpectedValueAssertCondition(string expected,  stringComparison) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(TException? actualValue, string? expectedValue) { }
    }
    public class ExceptionMessageEqualsExpectedValueAssertCondition<TException> : .<TException, string>
        where TException : 
    {
        public ExceptionMessageEqualsExpectedValueAssertCondition(string expected,  stringComparison) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(TException? actualValue, string? expectedValue) { }
    }
    public class ExceptionMessageMatchingExpectedAssertCondition<TException> : .<TException, .>
        where TException : 
    {
        public ExceptionMessageMatchingExpectedAssertCondition(. match) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(TException? actualValue, .? expectedValue) { }
    }
    public class ExceptionMessageStartingWithExpectedValueAssertCondition<TException> : .<TException, string>
        where TException : 
    {
        public ExceptionMessageStartingWithExpectedValueAssertCondition(string expected,  stringComparison) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(TException? actualValue, string? expectedValue) { }
    }
}
namespace .
{
    public class ConvertedDelegateSource<TToType> : ..ISource, ..IValueSource<TToType?>
        where TToType : 
    {
        public ConvertedDelegateSource(..IDelegateSource source) { }
        public string? ActualExpression { get; }
        public .<.AssertionData> AssertionDataTask { get; }
        public .<.> Assertions { get; }
        public .StringBuilder ExpressionBuilder { get; }
        public ..ISource AppendExpression(string expression) { }
        public ..ISource WithAssertion(. assertCondition) { }
    }
    public class ConvertedValueSource<TFromType, TToType> : ..ISource, ..IValueSource<TToType?>
    {
        public ConvertedValueSource(..IValueSource<TFromType> source, .<TFromType, TToType> convertToAssertCondition) { }
        public string? ActualExpression { get; }
        public .<.AssertionData> AssertionDataTask { get; }
        public .<.> Assertions { get; }
        public .StringBuilder ExpressionBuilder { get; }
        public ..ISource AppendExpression(string expression) { }
        public ..ISource WithAssertion(. assertCondition) { }
    }
    public interface IDelegateSource : ..ISource { }
    public interface ISource
    {
        string? ActualExpression { get; }
        ..ISource AppendExpression(string expression);
        ..ISource WithAssertion(. assertCondition);
    }
    public interface IValueDelegateSource<out TActual> : ..IDelegateSource, ..ISource, ..IValueSource<TActual> { }
    public interface IValueSource<out TActual> : ..ISource { }
}
namespace .
{
    []
    public enum AssertionType
    {
        Value = 1,
        Delegate = 2,
    }
    public class DelegateAnd<TActual> : ..IDelegateSource, ..ISource
    {
        public DelegateAnd(. assertionBuilder) { }
        public static ..DelegateAnd<TActual> Create(. assertionBuilder) { }
    }
    public class DelegateOr<TActual> : ..IDelegateSource, ..ISource
    {
        public DelegateOr(. assertionBuilder) { }
        public static ..DelegateOr<TActual> Create(. assertionBuilder) { }
    }
    public class ValueAnd<TActual> : ..ISource, ..IValueSource<TActual>
    {
        public ValueAnd(. assertionBuilder) { }
        public static ..ValueAnd<TActual> Create(. assertionBuilder) { }
    }
    public class ValueDelegateAnd<TActual> : ..IDelegateSource, ..ISource, ..IValueDelegateSource<TActual>, ..IValueSource<TActual>
    {
        public ValueDelegateAnd(. assertionBuilder) { }
        public static ..ValueDelegateAnd<TActual> Create(. assertionBuilder) { }
    }
    public class ValueDelegateOr<TActual> : ..IDelegateSource, ..ISource, ..IValueDelegateSource<TActual>, ..IValueSource<TActual>
    {
        public ValueDelegateOr(. assertionBuilder) { }
        public static ..ValueDelegateOr<TActual> Create(. assertionBuilder) { }
    }
    public class ValueOr<TActual> : ..ISource, ..IValueSource<TActual>
    {
        public ValueOr(. assertionBuilder) { }
    }
}
namespace .
{
    public class StringEqualsExpectedValueAssertCondition : .<string, string>
    {
        public StringEqualsExpectedValueAssertCondition(string expected,  stringComparison) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(string? actualValue, string? expectedValue) { }
        public ..StringEqualsExpectedValueAssertCondition IgnoringWhitespace() { }
        public ..StringEqualsExpectedValueAssertCondition WithNullAndEmptyEquality() { }
        public ..StringEqualsExpectedValueAssertCondition WithTrimming() { }
    }
    public class StringNotContainsExpectedValueAssertCondition : .<string, string>
    {
        public StringNotContainsExpectedValueAssertCondition(string expected,  stringComparison) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(string? actualValue, string? expectedValue) { }
    }
    public class StringNotEqualsExpectedValueAssertCondition : .<string, string>
    {
        public StringNotEqualsExpectedValueAssertCondition(string expected,  stringComparison) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(string? actualValue, string? expectedValue) { }
    }
}
namespace .
{
    public class ThrowsAnyExceptionAssertCondition<TActual> : .<TActual, >
    {
        public ThrowsAnyExceptionAssertCondition() { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(TActual? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class ThrowsExactTypeOfDelegateAssertCondition<TActual, TExpectedException> : .<TActual, TExpectedException>
        where TExpectedException : 
    {
        public ThrowsExactTypeOfDelegateAssertCondition() { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(TActual? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class ThrowsNothingAssertCondition<TActual> : .<TActual, >
    {
        public ThrowsNothingAssertCondition() { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(TActual? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class ThrowsOfTypeAssertCondition : .<object?, >
    {
        public ThrowsOfTypeAssertCondition( type) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(object? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class ThrowsOfTypeAssertCondition<TActual, TExpectedException> : .<TActual, TExpectedException>
        where TExpectedException : 
    {
        public ThrowsOfTypeAssertCondition() { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(TActual? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class ThrowsWithMessageAssertCondition<TActual, TException> : .<TActual, >
        where TException : 
    {
        public ThrowsWithMessageAssertCondition(string expectedMessage,  stringComparison, <?, ?> exceptionSelector) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(TActual? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class ThrowsWithMessageContainingAssertCondition<TActual, TException> : .<TActual, >
        where TException : 
    {
        public ThrowsWithMessageContainingAssertCondition(string expected,  stringComparison, <?, ?> exceptionSelector) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(TActual? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class ThrowsWithMessageMatchingAssertCondition<TActual, TException> : .<TActual, >
        where TException : 
    {
        public ThrowsWithMessageMatchingAssertCondition(. match, <?, ?> exceptionSelector) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(TActual? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class ThrowsWithParamNameAssertCondition<TActual, TException> : .<TActual, >
        where TException : 
    {
        public ThrowsWithParamNameAssertCondition(string expectedParamName,  stringComparison, <?, ?> exceptionSelector) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(TActual? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class ThrowsWithinAssertCondition<TActual, TExpectedException> : .<TActual, TExpectedException>
        where TExpectedException : 
    {
        public ThrowsWithinAssertCondition( timeSpan) { }
        public override ? WaitFor { get; }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(TActual? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
}
namespace .AssertionBuilders
{
    public class AndAssertionBuilder : ., . { }
    public abstract class AssertionBuilder : ..ISource
    {
        protected .AssertionData? AwaitedAssertionData;
        protected .? OtherTypeAssertionBuilder;
        protected readonly .<.> Results;
        public AssertionBuilder(..ISource source) { }
        public AssertionBuilder(.<.AssertionData> assertionDataTask, string? actualExpression) { }
        public AssertionBuilder(.<.AssertionData> assertionDataTask, string actualExpression, .StringBuilder expressionBuilder, .<.> assertions) { }
        protected void AppendCallerMethod(string?[] expressions, [.] string methodName = "") { }
        [.DebuggerHidden]
        [("This is a base `object` method that should not be called.", true)]
        public new void Equals(object? obj) { }
        [.DebuggerHidden]
        [("This is a base `object` method that should not be called.", true)]
        public void ReferenceEquals(object a, object b) { }
    }
    public class AsyncDelegateAssertionBuilder : ., ..IDelegateSource, ..ISource { }
    public class AsyncValueDelegateAssertionBuilder<TActual> : ., ..IDelegateSource, ..ISource, ..IValueDelegateSource<TActual>, ..IValueSource<TActual> { }
    public class CastableResultAssertionBuilder<TActual, TExpected> : .<TActual, TExpected> { }
    public class CastedAssertionBuilder<TActual, TExpected> : .<TExpected> { }
    public class ConvertedDelegateAssertionBuilder<TException> : .<TException>
        where TException : 
    {
        public ConvertedDelegateAssertionBuilder(..IDelegateSource source) { }
    }
    public class ConvertedValueAssertionBuilder<TFromType, TToType> : .<TToType>
    {
        public ConvertedValueAssertionBuilder(..IValueSource<TFromType> source, .<TFromType, TToType> convertToAssertCondition) { }
    }
    public class DelegateAssertionBuilder : ., ..IDelegateSource, ..ISource { }
    public interface IAndAssertionBuilder { }
    public interface IInvokableAssertionBuilder : ..ISource
    {
        . GetAwaiter();
        string? GetExpression();
    }
    public interface IOrAssertionBuilder { }
    public class InvokableAssertionBuilder<TActual> : ., ..ISource, .
    {
        protected readonly ..ISource Source;
        protected .<.> Assertions { get; }
        public .<.<.>> GetAssertionResults() { }
        public . GetAwaiter() { }
    }
    public class InvokableDelegateAssertionBuilder : .<object?>, ..IDelegateSource, ..ISource
    {
        public ..DelegateAnd<object?> And { get; }
        public . AssertionBuilder { get; }
        public ..DelegateOr<object?> Or { get; }
    }
    public class InvokableValueAssertionBuilder<TActual> : .<TActual>, ..ISource, ..IValueSource<TActual>
    {
        public InvokableValueAssertionBuilder(..ISource source) { }
        public ..ValueAnd<TActual> And { get; }
        public ..ValueOr<TActual> Or { get; }
        public .<TActual> Because(string reason) { }
        public new .<TActual?> GetAwaiter() { }
    }
    public class InvokableValueDelegateAssertionBuilder<TActual> : .<TActual>
    {
        public ..ValueDelegateAnd<TActual> And { get; }
        public . AssertionBuilder { get; }
        public ..ValueDelegateOr<TActual> Or { get; }
    }
    public class MappableResultAssertionBuilder<TActual, TExpected> : .<TActual>
    {
        public MappableResultAssertionBuilder(.<TActual> assertionBuilder, <TActual?, TExpected?> mapper) { }
        public new .<TExpected?> GetAwaiter() { }
    }
    public class MappableResultAssertionBuilder<TActual, TAssertCondition, TExpected> : .<TActual>
        where TAssertCondition : .<TActual>
    {
        public MappableResultAssertionBuilder(.<TActual> assertionBuilder, TAssertCondition assertCondition, <TActual?, TAssertCondition, TExpected?> mapper) { }
        public new .<TExpected?> GetAwaiter() { }
    }
    public class OrAssertionBuilder : ., . { }
    public class ValueAssertionBuilder<TActual> : ., ..ISource, ..IValueSource<TActual>
    {
        public ValueAssertionBuilder(..ISource source) { }
    }
    public class ValueDelegateAssertionBuilder<TActual> : ., ..IDelegateSource, ..ISource, ..IValueDelegateSource<TActual>, ..IValueSource<TActual> { }
}
namespace .
{
    public class AndAssertionGroupInvoker<TActual, TAssertionBuilder>
        where TAssertionBuilder : .
    {
        public AndAssertionGroupInvoker(..AssertionGroup<TActual, TAssertionBuilder> group1, ..AssertionGroup<TActual, TAssertionBuilder> group2) { }
        public ..AndAssertionGroupInvoker<TActual, TAssertionBuilder> And(..AssertionGroup<TActual, TAssertionBuilder> group) { }
        public .<TActual?> GetAwaiter() { }
    }
    public class AndAssertionGroup<TActual, TAssertionBuilder> : ..AssertionGroup<TActual, TAssertionBuilder>
        where TAssertionBuilder : .
    {
        public ..AndAssertionGroup<TActual, TAssertionBuilder> And(<TAssertionBuilder, .<TActual>> assert) { }
        public override .<TActual?> GetAwaiter() { }
    }
    public static class AssertionGroup
    {
        public static ..AndAssertionGroupInvoker<TActual, TAssertionBuilder> And<TActual, TAssertionBuilder>(..AssertionGroup<TActual, TAssertionBuilder> group1, ..AssertionGroup<TActual, TAssertionBuilder> group2)
            where TAssertionBuilder : . { }
        public static ..UnknownAssertionGroupInvoker<TActual, TAssertionBuilder> Assert<TActual, TAssertionBuilder>(..AssertionGroup<TActual, TAssertionBuilder> group)
            where TAssertionBuilder : . { }
        public static ..AssertionGroupBuilder<object?, .> For( value) { }
        public static ..AssertionGroupBuilder<object?, .> For(<.> value) { }
        public static ..AssertionGroupBuilder<object?, .> For(. value) { }
        public static ..AssertionGroupBuilder<object?, .> For(. value) { }
        public static ..AssertionGroupBuilder<TActual, .<TActual>> For<TActual>(<.<TActual>> value) { }
        public static ..AssertionGroupBuilder<TActual, .<TActual>> For<TActual>(<TActual> value) { }
        public static ..AssertionGroupBuilder<TActual, .<TActual>> For<TActual>(.<TActual> value) { }
        public static ..AssertionGroupBuilder<TActual, .<TActual>> For<TActual>(.<TActual> value) { }
        public static ..AssertionGroupBuilder<TActual, .<TActual>> For<TActual>(TActual value) { }
        public static ..AssertionGroupBuilder<object?, .> ForSameValueAs(..AssertionGroup<object?, .> otherGroup) { }
        public static ..AssertionGroupBuilder<object?, .> ForSameValueAs(..AssertionGroup<object?, .> otherGroup) { }
        public static ..AssertionGroupBuilder<TActual, .<TActual>> ForSameValueAs<TActual>(..AssertionGroup<TActual, .<TActual>> otherGroup) { }
        public static ..AssertionGroupBuilder<TActual, .<TActual>> ForSameValueAs<TActual>(..AssertionGroup<TActual, .<TActual>> otherGroup) { }
        public static ..AssertionGroupBuilder<TActual, .<TActual>> ForSameValueAs<TActual>(..AssertionGroup<TActual, .<TActual>> otherGroup) { }
        public static ..OrAssertionGroupInvoker<TActual, TAssertionBuilder> Or<TActual, TAssertionBuilder>(..AssertionGroup<TActual, TAssertionBuilder> group1, ..AssertionGroup<TActual, TAssertionBuilder> group2)
            where TAssertionBuilder : . { }
    }
    public class AssertionGroupBuilder<TActual, TAssertionBuilder>
        where TAssertionBuilder : .
    {
        public ..UnknownAssertionGroup<TActual, TAssertionBuilder> WithAssertion(<TAssertionBuilder, .<TActual>> assert) { }
    }
    public abstract class AssertionGroup<TActual, TAssertionBuilder>
        where TAssertionBuilder : .
    {
        public abstract .<TActual?> GetAwaiter();
    }
    public class OrAssertionException : 
    {
        public OrAssertionException(.<> exceptions) { }
        public override string Message { get; }
    }
    public class OrAssertionGroupInvoker<TActual, TAssertionBuilder>
        where TAssertionBuilder : .
    {
        public OrAssertionGroupInvoker(..AssertionGroup<TActual, TAssertionBuilder> group1, ..AssertionGroup<TActual, TAssertionBuilder> group2) { }
        public .<TActual?> GetAwaiter() { }
        public ..OrAssertionGroupInvoker<TActual, TAssertionBuilder> Or(..AssertionGroup<TActual, TAssertionBuilder> group) { }
    }
    public class OrAssertionGroup<TActual, TAssertionBuilder> : ..AssertionGroup<TActual, TAssertionBuilder>
        where TAssertionBuilder : .
    {
        public override .<TActual?> GetAwaiter() { }
        public ..OrAssertionGroup<TActual, TAssertionBuilder> Or(<TAssertionBuilder, .<TActual>> assert) { }
    }
    public class UnknownAssertionGroupInvoker<TActual, TAssertionBuilder>
        where TAssertionBuilder : .
    {
        public UnknownAssertionGroupInvoker(..AssertionGroup<TActual, TAssertionBuilder> group) { }
        public ..AndAssertionGroupInvoker<TActual, TAssertionBuilder> And(..AssertionGroup<TActual, TAssertionBuilder> otherGroup) { }
        public ..OrAssertionGroupInvoker<TActual, TAssertionBuilder> Or(..AssertionGroup<TActual, TAssertionBuilder> otherGroup) { }
    }
    public class UnknownAssertionGroup<TActual, TAssertionBuilder>
        where TAssertionBuilder : .
    {
        public ..AndAssertionGroup<TActual, TAssertionBuilder> And(<TAssertionBuilder, .<TActual>> assert) { }
        public ..OrAssertionGroup<TActual, TAssertionBuilder> Or(<TAssertionBuilder, .<TActual>> assert) { }
    }
}
namespace .
{
    public class BetweenAssertionBuilderWrapper<TActual> : .<TActual>
        where TActual : <TActual>
    {
        public ..BetweenAssertionBuilderWrapper<TActual> WithExclusiveBounds() { }
        public ..BetweenAssertionBuilderWrapper<TActual> WithInclusiveBounds() { }
    }
    public class DateTimeEqualToAssertionBuilderWrapper : .<>
    {
        public ..DateTimeEqualToAssertionBuilderWrapper Within( tolerance, [.("tolerance")] string doNotPopulateThis = "") { }
    }
    public class DateTimeOffsetEqualToAssertionBuilderWrapper : .<>
    {
        public ..DateTimeOffsetEqualToAssertionBuilderWrapper Within( tolerance, [.("tolerance")] string doNotPopulateThis = "") { }
    }
    public class EquivalentToAssertionBuilderWrapper<TActual, TExpected> : .<TActual>
    {
        public ..EquivalentToAssertionBuilderWrapper<TActual, TExpected> IgnoringMember(string propertyName, [.("propertyName")] string doNotPopulateThis = "") { }
        public ..EquivalentToAssertionBuilderWrapper<TActual, TExpected> WithPartialEquivalency() { }
    }
    public class GenericEqualToAssertionBuilderWrapper<TActual> : .<TActual> { }
    public class GenericNotEqualToAssertionBuilderWrapper<TActual> : .<TActual> { }
    public class NotBetweenAssertionBuilderWrapper<TActual> : .<TActual>
        where TActual : <TActual>
    {
        public ..NotBetweenAssertionBuilderWrapper<TActual> WithExclusiveBounds() { }
        public ..NotBetweenAssertionBuilderWrapper<TActual> WithInclusiveBounds() { }
    }
    public class NotEquivalentToAssertionBuilderWrapper<TActual, TExpected> : .<TActual>
    {
        public ..NotEquivalentToAssertionBuilderWrapper<TActual, TExpected> IgnoringMember(string propertyName, [.("propertyName")] string doNotPopulateThis = "") { }
        public ..NotEquivalentToAssertionBuilderWrapper<TActual, TExpected> WithPartialEquivalency() { }
    }
    public class NotNullAssertionBuilderWrapper<TActual> : .<TActual>
        where TActual :  class
    {
        public new .<TActual> GetAwaiter() { }
    }
    public class NotNullStructAssertionBuilderWrapper<TActual> : .<TActual>
        where TActual :  struct
    {
        public new .<TActual> GetAwaiter() { }
    }
    public class SingleItemAssertionBuilderWrapper<TActual, TInner> : .<TActual>
        where TActual : .<TInner>
    {
        public new .<TInner> GetAwaiter() { }
    }
    public class StringContainsAssertionBuilderWrapper : .<string>
    {
        public ..StringContainsAssertionBuilderWrapper IgnoringWhitespace() { }
        public ..StringContainsAssertionBuilderWrapper WithTrimming() { }
    }
    public class StringEqualToAssertionBuilderWrapper : .<string>
    {
        public ..StringEqualToAssertionBuilderWrapper IgnoringWhitespace() { }
        public ..StringEqualToAssertionBuilderWrapper WithNullAndEmptyEquality() { }
        public ..StringEqualToAssertionBuilderWrapper WithTrimming() { }
    }
    public class TimeSpanEqualToAssertionBuilderWrapper : .<>
    {
        public ..TimeSpanEqualToAssertionBuilderWrapper Within( tolerance, [.("tolerance")] string doNotPopulateThis = "") { }
    }
}
namespace .
{
    public class CompleteWithinAssertCondition<TActual> : .<TActual>
    {
        public CompleteWithinAssertCondition( timeSpan) { }
        public override ? WaitFor { get; }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(TActual? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public static class DelegateExtensions
    {
        public static . CompletesWithin(this ..IDelegateSource delegateSource,  timeSpan, [.("timeSpan")] string? doNotPopulateThisValue = null) { }
        public static .<TActual> CompletesWithin<TActual>(this ..IValueDelegateSource<TActual> delegateSource,  timeSpan, [.("timeSpan")] string? doNotPopulateThisValue = null) { }
    }
}
namespace ..Conditions
{
    public class EnumDoesNotHaveFlagAssertCondition<TEnum> : .<TEnum>
        where TEnum : 
    {
        public EnumDoesNotHaveFlagAssertCondition(TEnum expected) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(TEnum? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class EnumDoesNotHaveSameNameAsCondition<TEnum, TExpected> : .<TEnum>
        where TEnum : 
        where TExpected : 
    {
        public EnumDoesNotHaveSameNameAsCondition(TExpected expected) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(TEnum? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class EnumDoesNotHaveSameValueAsCondition<TEnum, TExpected> : .<TEnum>
        where TEnum : 
        where TExpected : 
    {
        public EnumDoesNotHaveSameValueAsCondition(TExpected expected) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(TEnum? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class EnumHasFlagAssertCondition<TEnum> : .<TEnum>
        where TEnum : 
    {
        public EnumHasFlagAssertCondition(TEnum expected) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(TEnum? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class EnumHasSameNameAsCondition<TEnum, TExpected> : .<TEnum>
        where TEnum : 
        where TExpected : 
    {
        public EnumHasSameNameAsCondition(TExpected expected) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(TEnum? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class EnumHasSameValueAsCondition<TEnum, TExpected> : .<TEnum>
        where TEnum : 
        where TExpected : 
    {
        public EnumHasSameValueAsCondition(TExpected expected) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(TEnum? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
}
namespace .
{
    public static class EnumHasExtensions
    {
        public static .<TEnum> DoesNotHaveFlag<TEnum>(this ..IValueSource<TEnum> valueSource, TEnum expected, [.("expected")] string? doNotPopulateThisValue1 = null)
            where TEnum :  { }
        public static .<TEnum> DoesNotHaveSameNameAs<TEnum, TExpected>(this ..IValueSource<TEnum> valueSource, TExpected expected, [.("expected")] string? doNotPopulateThisValue1 = null)
            where TEnum : 
            where TExpected :  { }
        public static .<TEnum> DoesNotHaveSameValueAs<TEnum, TExpected>(this ..IValueSource<TEnum> valueSource, TExpected expected, [.("expected")] string? doNotPopulateThisValue1 = null)
            where TEnum : 
            where TExpected :  { }
        public static .<TEnum> HasFlag<TEnum>(this ..IValueSource<TEnum> valueSource, TEnum expected, [.("expected")] string? doNotPopulateThisValue1 = null)
            where TEnum :  { }
        public static .<TEnum> HasSameNameAs<TEnum, TExpected>(this ..IValueSource<TEnum> valueSource, TExpected expected, [.("expected")] string? doNotPopulateThisValue1 = null)
            where TEnum : 
            where TExpected :  { }
        public static .<TEnum> HasSameValueAs<TEnum, TExpected>(this ..IValueSource<TEnum> valueSource, TExpected expected, [.("expected")] string? doNotPopulateThisValue1 = null)
            where TEnum : 
            where TExpected :  { }
    }
}
namespace ..Conditions
{
    public class AssignableFromExpectedValueAssertCondition<TActual> : .<TActual>
    {
        public AssignableFromExpectedValueAssertCondition( expectedType) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(TActual? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class AssignableToExpectedValueAssertCondition<TActual> : .<TActual>
    {
        public AssignableToExpectedValueAssertCondition( expectedType) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(TActual? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class ConvertExceptionToValueAssertCondition<TException> : .<object?>
        where TException : 
    {
        public ConvertExceptionToValueAssertCondition() { }
        public TException ConvertedExceptionValue { get; }
        protected override string GetExpectation() { }
        protected override sealed .<.> GetResult(object? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class DefaultExpectedValueAssertCondition<TActual> : .<TActual>
    {
        public DefaultExpectedValueAssertCondition() { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(TActual? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class DelegateConversionAssertionCondition<TToType> : .<TToType>
        where TToType : 
    {
        public DelegateConversionAssertionCondition(..IDelegateSource source, .<object?> assertCondition) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(TToType? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class EqualsExpectedValueAssertCondition<TActual> : .<TActual, TActual>
    {
        public EqualsExpectedValueAssertCondition(TActual expected) { }
        public EqualsExpectedValueAssertCondition(TActual expected, .<TActual> equalityComparer) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(TActual? actualValue, TActual? expectedValue) { }
    }
    public class EquivalentToExpectedValueAssertCondition<TActual, TExpected> : .<TActual, TExpected>
    {
        public EquivalentToExpectedValueAssertCondition(TExpected expected, string? expectedExpression) { }
        public . EquivalencyKind { get; set; }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(TActual? actualValue, TExpected? expectedValue) { }
        public void IgnoringMember(string fieldName) { }
    }
    public class NotAssignableFromExpectedValueAssertCondition<TActual> : .<TActual>
    {
        public NotAssignableFromExpectedValueAssertCondition( expectedType) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(TActual? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class NotAssignableToExpectedValueAssertCondition<TActual> : .<TActual>
    {
        public NotAssignableToExpectedValueAssertCondition( expectedType) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(TActual? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class NotDefaultExpectedValueAssertCondition<TActual> : .<TActual, TActual>
    {
        public NotDefaultExpectedValueAssertCondition() { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(TActual? actualValue, TActual? expectedValue) { }
    }
    public class NotEqualsExpectedValueAssertCondition<TActual> : .<TActual, TActual>
    {
        public NotEqualsExpectedValueAssertCondition(TActual expected) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(TActual? actualValue, TActual? expectedValue) { }
    }
    public class NotEquivalentToExpectedValueAssertCondition<TActual, TExpected> : .<TActual, TExpected>
    {
        public NotEquivalentToExpectedValueAssertCondition(TExpected expected, string? expectedExpression) { }
        public . EquivalencyKind { get; set; }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(TActual? actualValue, TExpected? expectedValue) { }
        public void IgnoringMember(string fieldName) { }
    }
    public class NotSameReferenceExpectedValueAssertCondition<TActual, TExpected> : .<TActual, TExpected>
    {
        public NotSameReferenceExpectedValueAssertCondition(TExpected expected) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(TActual? actualValue, TExpected? expectedValue) { }
    }
    public class NotTypeOfExpectedValueAssertCondition<TActual> : .<TActual>
    {
        public NotTypeOfExpectedValueAssertCondition( expected) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(TActual? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class SameReferenceExpectedValueAssertCondition<TActual, TExpected> : .<TActual, TExpected>
    {
        public SameReferenceExpectedValueAssertCondition(TExpected expected) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(TActual? actualValue, TExpected? expectedValue) { }
    }
    public class TypeOfExpectedValueAssertCondition<TActual> : .<TActual>
    {
        public TypeOfExpectedValueAssertCondition( expectedType) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(TActual? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class ValueConversionAssertionCondition<TFromType, TToType> : .<TToType>
    {
        public ValueConversionAssertionCondition(..ISource source, .<TFromType, TToType> convertToAssertCondition) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(TToType? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
}
namespace ..Conditions
{
    public class StringContainsExpectedValueAssertCondition : .<string, string>
    {
        public StringContainsExpectedValueAssertCondition(string expected,  stringComparison) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(string? actualValue, string? expectedValue) { }
    }
}
namespace .Attributes
{
    [(.Class, AllowMultiple=true)]
    public class CreateAssertionAttribute : 
    {
        public CreateAssertionAttribute( targetType, string methodName) { }
        public CreateAssertionAttribute( targetType,  containingType, string methodName) { }
        public ? ContainingType { get; }
        public string? CustomName { get; set; }
        public string MethodName { get; }
        public bool NegateLogic { get; set; }
        public bool RequiresGenericTypeParameter { get; set; }
        public  TargetType { get; }
        public bool TreatAsInstance { get; set; }
    }
}
namespace .Enums
{
    public enum CollectionOrdering
    {
        Matching = 0,
        Any = 1,
    }
    public enum EquivalencyKind
    {
        Full = 0,
        Partial = 1,
    }
    public enum Order
    {
        Ascending = 0,
        Descending = 1,
    }
}
namespace .Equality
{
    public class CollectionEquivalentToEqualityComparer<T> : .<T>
    {
        public CollectionEquivalentToEqualityComparer() { }
        public CollectionEquivalentToEqualityComparer(.CompareOptions compareOptions) { }
        public override int? EnumerableIndex { get; protected set; }
        public override bool Equals(T? x, T? y) { }
    }
    public class EquivalentToEqualityComparer<T> : .<T>
    {
        public EquivalentToEqualityComparer() { }
        public EquivalentToEqualityComparer(.CompareOptions compareOptions) { }
        public .ComparisonFailure[]? ComparisonFailures { get; }
        public virtual int? EnumerableIndex { get; protected set; }
        public virtual bool Equals(T? x, T? y) { }
        public string GetFailureMessages() { }
        public int GetHashCode([.] T obj) { }
    }
}
namespace .Exceptions
{
    public class AssertionException : .
    {
        public AssertionException(string? message) { }
        public AssertionException(string? message,  innerException) { }
    }
    public class BaseAssertionException : 
    {
        public BaseAssertionException() { }
        public BaseAssertionException(string? message) { }
        public BaseAssertionException(string? message, ? innerException) { }
    }
    public class MaybeCaughtException : 
    {
        public MaybeCaughtException( exception) { }
    }
    public class MixedAndOrAssertionsException : .
    {
        public MixedAndOrAssertionsException() { }
    }
}
namespace .Extensions
{
    public class AggregateExceptionExceptionAssertionExtensionsHasMultipleInnerExceptionsWithAggregateExceptionAssertCondition : .<>
    {
        public AggregateExceptionExceptionAssertionExtensionsHasMultipleInnerExceptionsWithAggregateExceptionAssertCondition(bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class AssemblyAssemblyAssertionExtensionsIsDebugBuildWithAssemblyAssertCondition : .<.Assembly>
    {
        public AssemblyAssemblyAssertionExtensionsIsDebugBuildWithAssemblyAssertCondition(bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(.Assembly? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class AssemblyAssemblyAssertionExtensionsIsSignedWithAssemblyAssertCondition : .<.Assembly>
    {
        public AssemblyAssemblyAssertionExtensionsIsSignedWithAssemblyAssertCondition(bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(.Assembly? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    [.(typeof(.Assembly), "GlobalAssemblyCache")]
    [.(typeof(.Assembly), "GlobalAssemblyCache", CustomName="IsNotInGAC", NegateLogic=true)]
    [.(typeof(.Assembly), "IsDynamic")]
    [.(typeof(.Assembly), "IsDynamic", CustomName="IsNotDynamic", NegateLogic=true)]
    [.(typeof(.Assembly), "IsFullyTrusted")]
    [.(typeof(.Assembly), "IsFullyTrusted", CustomName="IsNotFullyTrusted", NegateLogic=true)]
    [.(typeof(.Assembly), typeof(.), "IsDebugBuild")]
    [.(typeof(.Assembly), typeof(.), "IsDebugBuild", CustomName="IsReleaseBuild", NegateLogic=true)]
    [.(typeof(.Assembly), typeof(.), "IsSigned")]
    [.(typeof(.Assembly), typeof(.), "IsSigned", CustomName="IsNotSigned", NegateLogic=true)]
    public static class AssemblyAssertionExtensions
    {
        public static .<.Assembly> GlobalAssemblyCache(this ..IValueSource<.Assembly> valueSource) { }
        public static .<.Assembly> IsDebugBuild(this ..IValueSource<.Assembly> valueSource) { }
        public static .<.Assembly> IsDynamic(this ..IValueSource<.Assembly> valueSource) { }
        public static .<.Assembly> IsFullyTrusted(this ..IValueSource<.Assembly> valueSource) { }
        public static .<.Assembly> IsNotDynamic(this ..IValueSource<.Assembly> valueSource) { }
        public static .<.Assembly> IsNotFullyTrusted(this ..IValueSource<.Assembly> valueSource) { }
        public static .<.Assembly> IsNotInGAC(this ..IValueSource<.Assembly> valueSource) { }
        public static .<.Assembly> IsNotSigned(this ..IValueSource<.Assembly> valueSource) { }
        public static .<.Assembly> IsReleaseBuild(this ..IValueSource<.Assembly> valueSource) { }
        public static .<.Assembly> IsSigned(this ..IValueSource<.Assembly> valueSource) { }
    }
    public class AssemblyGlobalAssemblyCacheAssertCondition : .<.Assembly>
    {
        public AssemblyGlobalAssemblyCacheAssertCondition(bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(.Assembly? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class AssemblyIsDynamicAssertCondition : .<.Assembly>
    {
        public AssemblyIsDynamicAssertCondition(bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(.Assembly? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class AssemblyIsFullyTrustedAssertCondition : .<.Assembly>
    {
        public AssemblyIsFullyTrustedAssertCondition(bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(.Assembly? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public static class BooleanIsExtensions
    {
        public static .<bool> IsEqualTo(this ..IValueSource<bool> valueSource, bool expected) { }
        public static .<bool?> IsEqualTo(this ..IValueSource<bool?> valueSource, bool expected) { }
        public static .<bool?> IsEqualTo(this ..IValueSource<bool?> valueSource, bool? expected) { }
        public static .<bool> IsFalse(this ..IValueSource<bool> valueSource) { }
        public static .<bool?> IsFalse(this ..IValueSource<bool?> valueSource) { }
        public static .<bool> IsTrue(this ..IValueSource<bool> valueSource) { }
        public static .<bool?> IsTrue(this ..IValueSource<bool?> valueSource) { }
    }
    public static class BooleanIsNotExtensions
    {
        public static .<bool> IsNotEqualTo(this ..IValueSource<bool> valueSource, bool expected) { }
        public static .<bool?> IsNotEqualTo(this ..IValueSource<bool?> valueSource, bool expected) { }
        public static .<bool?> IsNotEqualTo(this ..IValueSource<bool?> valueSource, bool? expected) { }
        public static .<bool> IsNotFalse(this ..IValueSource<bool> valueSource) { }
        public static .<bool?> IsNotFalse(this ..IValueSource<bool?> valueSource) { }
        public static .<bool> IsNotTrue(this ..IValueSource<bool> valueSource) { }
        public static .<bool?> IsNotTrue(this ..IValueSource<bool?> valueSource) { }
    }
    [.(typeof(.CancellationToken), "CanBeCanceled")]
    [.(typeof(.CancellationToken), "CanBeCanceled", CustomName="CannotBeCanceled", NegateLogic=true)]
    [.(typeof(.CancellationToken), "IsCancellationRequested")]
    [.(typeof(.CancellationToken), "IsCancellationRequested", CustomName="IsNotCancellationRequested", NegateLogic=true)]
    [.(typeof(.CancellationToken), typeof(.), "IsNone")]
    [.(typeof(.CancellationToken), typeof(.), "IsNone", CustomName="IsNotNone", NegateLogic=true)]
    public static class CancellationTokenAssertionExtensions
    {
        public static .<.CancellationToken> CanBeCanceled(this ..IValueSource<.CancellationToken> valueSource) { }
        public static .<.CancellationToken> CannotBeCanceled(this ..IValueSource<.CancellationToken> valueSource) { }
        public static .<.CancellationToken> IsCancellationRequested(this ..IValueSource<.CancellationToken> valueSource) { }
        public static .<.CancellationToken> IsNone(this ..IValueSource<.CancellationToken> valueSource) { }
        public static .<.CancellationToken> IsNotCancellationRequested(this ..IValueSource<.CancellationToken> valueSource) { }
        public static .<.CancellationToken> IsNotNone(this ..IValueSource<.CancellationToken> valueSource) { }
    }
    public class CancellationTokenCanBeCanceledAssertCondition : .<.CancellationToken>
    {
        public CancellationTokenCanBeCanceledAssertCondition(bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(.CancellationToken actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class CancellationTokenCancellationTokenAssertionExtensionsIsNoneWithCancellationTokenAssertCondition : .<.CancellationToken>
    {
        public CancellationTokenCancellationTokenAssertionExtensionsIsNoneWithCancellationTokenAssertCondition(bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(.CancellationToken actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class CancellationTokenIsCancellationRequestedAssertCondition : .<.CancellationToken>
    {
        public CancellationTokenIsCancellationRequestedAssertCondition(bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(.CancellationToken actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    [.(typeof(char), "IsControl")]
    [.(typeof(char), "IsControl", CustomName="IsNotControl", NegateLogic=true)]
    [.(typeof(char), "IsDigit")]
    [.(typeof(char), "IsDigit", CustomName="IsNotDigit", NegateLogic=true)]
    [.(typeof(char), "IsHighSurrogate")]
    [.(typeof(char), "IsHighSurrogate", CustomName="IsNotHighSurrogate", NegateLogic=true)]
    [.(typeof(char), "IsLetter")]
    [.(typeof(char), "IsLetter", CustomName="IsNotLetter", NegateLogic=true)]
    [.(typeof(char), "IsLetterOrDigit")]
    [.(typeof(char), "IsLetterOrDigit", CustomName="IsNotLetterOrDigit", NegateLogic=true)]
    [.(typeof(char), "IsLowSurrogate")]
    [.(typeof(char), "IsLowSurrogate", CustomName="IsNotLowSurrogate", NegateLogic=true)]
    [.(typeof(char), "IsLower")]
    [.(typeof(char), "IsLower", CustomName="IsNotLower", NegateLogic=true)]
    [.(typeof(char), "IsNumber")]
    [.(typeof(char), "IsNumber", CustomName="IsNotNumber", NegateLogic=true)]
    [.(typeof(char), "IsPunctuation")]
    [.(typeof(char), "IsPunctuation", CustomName="IsNotPunctuation", NegateLogic=true)]
    [.(typeof(char), "IsSeparator")]
    [.(typeof(char), "IsSeparator", CustomName="IsNotSeparator", NegateLogic=true)]
    [.(typeof(char), "IsSurrogate")]
    [.(typeof(char), "IsSurrogate", CustomName="IsNotSurrogate", NegateLogic=true)]
    [.(typeof(char), "IsSymbol")]
    [.(typeof(char), "IsSymbol", CustomName="IsNotSymbol", NegateLogic=true)]
    [.(typeof(char), "IsUpper")]
    [.(typeof(char), "IsUpper", CustomName="IsNotUpper", NegateLogic=true)]
    [.(typeof(char), "IsWhiteSpace")]
    [.(typeof(char), "IsWhiteSpace", CustomName="IsNotWhiteSpace", NegateLogic=true)]
    public static class CharAssertionExtensions
    {
        public static .<char> IsControl(this ..IValueSource<char> valueSource) { }
        public static .<char> IsDigit(this ..IValueSource<char> valueSource) { }
        public static .<char> IsHighSurrogate(this ..IValueSource<char> valueSource) { }
        public static .<char> IsLetter(this ..IValueSource<char> valueSource) { }
        public static .<char> IsLetterOrDigit(this ..IValueSource<char> valueSource) { }
        public static .<char> IsLowSurrogate(this ..IValueSource<char> valueSource) { }
        public static .<char> IsLower(this ..IValueSource<char> valueSource) { }
        public static .<char> IsNotControl(this ..IValueSource<char> valueSource) { }
        public static .<char> IsNotDigit(this ..IValueSource<char> valueSource) { }
        public static .<char> IsNotHighSurrogate(this ..IValueSource<char> valueSource) { }
        public static .<char> IsNotLetter(this ..IValueSource<char> valueSource) { }
        public static .<char> IsNotLetterOrDigit(this ..IValueSource<char> valueSource) { }
        public static .<char> IsNotLowSurrogate(this ..IValueSource<char> valueSource) { }
        public static .<char> IsNotLower(this ..IValueSource<char> valueSource) { }
        public static .<char> IsNotNumber(this ..IValueSource<char> valueSource) { }
        public static .<char> IsNotPunctuation(this ..IValueSource<char> valueSource) { }
        public static .<char> IsNotSeparator(this ..IValueSource<char> valueSource) { }
        public static .<char> IsNotSurrogate(this ..IValueSource<char> valueSource) { }
        public static .<char> IsNotSymbol(this ..IValueSource<char> valueSource) { }
        public static .<char> IsNotUpper(this ..IValueSource<char> valueSource) { }
        public static .<char> IsNotWhiteSpace(this ..IValueSource<char> valueSource) { }
        public static .<char> IsNumber(this ..IValueSource<char> valueSource) { }
        public static .<char> IsPunctuation(this ..IValueSource<char> valueSource) { }
        public static .<char> IsSeparator(this ..IValueSource<char> valueSource) { }
        public static .<char> IsSurrogate(this ..IValueSource<char> valueSource) { }
        public static .<char> IsSymbol(this ..IValueSource<char> valueSource) { }
        public static .<char> IsUpper(this ..IValueSource<char> valueSource) { }
        public static .<char> IsWhiteSpace(this ..IValueSource<char> valueSource) { }
    }
    public class CharIsControlWithCharAssertCondition : .<char>
    {
        public CharIsControlWithCharAssertCondition(bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(char actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class CharIsDigitWithCharAssertCondition : .<char>
    {
        public CharIsDigitWithCharAssertCondition(bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(char actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public static class CharIsExtensions
    {
        public static .<char> IsEqualTo(this ..IValueSource<char> valueSource, char expected) { }
        public static .<char?> IsEqualTo(this ..IValueSource<char?> valueSource, char expected) { }
        public static .<char?> IsEqualTo(this ..IValueSource<char?> valueSource, char? expected) { }
    }
    public class CharIsHighSurrogateWithCharAssertCondition : .<char>
    {
        public CharIsHighSurrogateWithCharAssertCondition(bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(char actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class CharIsLetterOrDigitWithCharAssertCondition : .<char>
    {
        public CharIsLetterOrDigitWithCharAssertCondition(bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(char actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class CharIsLetterWithCharAssertCondition : .<char>
    {
        public CharIsLetterWithCharAssertCondition(bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(char actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class CharIsLowSurrogateWithCharAssertCondition : .<char>
    {
        public CharIsLowSurrogateWithCharAssertCondition(bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(char actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class CharIsLowerWithCharAssertCondition : .<char>
    {
        public CharIsLowerWithCharAssertCondition(bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(char actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public static class CharIsNotExtensions
    {
        public static .<char> IsNotEqualTo(this ..IValueSource<char> valueSource, char expected) { }
        public static .<char?> IsNotEqualTo(this ..IValueSource<char?> valueSource, char expected) { }
        public static .<char?> IsNotEqualTo(this ..IValueSource<char?> valueSource, char? expected) { }
    }
    public class CharIsNumberWithCharAssertCondition : .<char>
    {
        public CharIsNumberWithCharAssertCondition(bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(char actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class CharIsPunctuationWithCharAssertCondition : .<char>
    {
        public CharIsPunctuationWithCharAssertCondition(bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(char actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class CharIsSeparatorWithCharAssertCondition : .<char>
    {
        public CharIsSeparatorWithCharAssertCondition(bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(char actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class CharIsSurrogateWithCharAssertCondition : .<char>
    {
        public CharIsSurrogateWithCharAssertCondition(bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(char actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class CharIsSymbolWithCharAssertCondition : .<char>
    {
        public CharIsSymbolWithCharAssertCondition(bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(char actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class CharIsUpperWithCharAssertCondition : .<char>
    {
        public CharIsUpperWithCharAssertCondition(bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(char actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class CharIsWhiteSpaceWithCharAssertCondition : .<char>
    {
        public CharIsWhiteSpaceWithCharAssertCondition(bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(char actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class CharUriIsHexDigitWithCharAssertCondition : .<char>
    {
        public CharUriIsHexDigitWithCharAssertCondition(bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(char actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public static class CollectionsIsExtensions
    {
        public static .<.<TInner>> IsEmpty<TInner>(this ..IValueSource<.<TInner>> valueSource) { }
        public static .<TActual> IsEquivalentTo<TActual, TInner>(this ..IValueSource<TActual> valueSource, .<TInner> expected, [.("expected")] string doNotPopulateThisValue = null)
            where TActual : .<TInner> { }
        public static .<TActual> IsEquivalentTo<TActual, TInner>(this ..IValueSource<TActual> valueSource, .<TInner> expected, .<TInner> comparer, [.("expected")] string doNotPopulateThisValue = null, [.("comparer")] string doNotPopulateThisValue2 = null)
            where TActual : .<TInner> { }
        public static .<TActual> IsEquivalentTo<TActual, TInner>(this ..IValueSource<TActual> valueSource, .<TInner> expected, . collectionOrdering, [.("expected")] string doNotPopulateThisValue = null, [.("collectionOrdering")] string doNotPopulateThisValue2 = null)
            where TActual : .<TInner> { }
        public static .<TActual> IsEquivalentTo<TActual, TInner>(this ..IValueSource<TActual> valueSource, .<TInner> expected, .<TInner> comparer, . collectionOrdering, [.("expected")] string doNotPopulateThisValue = null, [.("collectionOrdering")] string doNotPopulateThisValue2 = null)
            where TActual : .<TInner> { }
        public static .<.<TInner>> IsInDescendingOrder<TInner>(this ..IValueSource<.<TInner>> valueSource) { }
        public static .<.<TInner>> IsInDescendingOrder<TInner>(this ..IValueSource<.<TInner>> valueSource, .<TInner> comparer) { }
        public static .<.<TInner>> IsInOrder<TInner>(this ..IValueSource<.<TInner>> valueSource) { }
        public static .<.<TInner>> IsInOrder<TInner>(this ..IValueSource<.<TInner>> valueSource, .<TInner> comparer) { }
        public static .<.<TInner>> IsOrderedBy<TInner, TComparisonItem>(this ..IValueSource<.<TInner>> valueSource, <TInner, TComparisonItem> comparisonItemSelector, [.("comparisonItemSelector")] string doNotPopulateThisValue = null) { }
        public static .<.<TInner>> IsOrderedBy<TInner, TComparisonItem>(this ..IValueSource<.<TInner>> valueSource, <TInner, TComparisonItem> comparisonItemSelector, .<TComparisonItem> comparer, [.("comparisonItemSelector")] string doNotPopulateThisValue = null, [.("comparer")] string doNotPopulateThisValue2 = null) { }
        public static .<.<TInner>> IsOrderedByDescending<TInner, TComparisonItem>(this ..IValueSource<.<TInner>> valueSource, <TInner, TComparisonItem> comparisonItemSelector, [.("comparisonItemSelector")] string doNotPopulateThisValue = null) { }
        public static .<.<TInner>> IsOrderedByDescending<TInner, TComparisonItem>(this ..IValueSource<.<TInner>> valueSource, <TInner, TComparisonItem> comparisonItemSelector, .<TComparisonItem> comparer, [.("comparisonItemSelector")] string doNotPopulateThisValue = null, [.("comparer")] string doNotPopulateThisValue2 = null) { }
    }
    public static class CollectionsIsNotExtensions
    {
        public static .<.<TInner>> IsNotEmpty<TInner>(this ..IValueSource<.<TInner>> valueSource) { }
        public static .<TActual> IsNotEquivalentTo<TActual, TInner>(this ..IValueSource<TActual> valueSource, .<TInner> expected, [.("expected")] string doNotPopulateThisValue = null)
            where TActual : .<TInner> { }
        public static .<TActual> IsNotEquivalentTo<TActual, TInner>(this ..IValueSource<TActual> valueSource, .<TInner> expected, .<TInner> comparer, [.("expected")] string doNotPopulateThisValue = null, [.("comparer")] string doNotPopulateThisValue2 = null)
            where TActual : .<TInner> { }
        public static .<TActual> IsNotEquivalentTo<TActual, TInner>(this ..IValueSource<TActual> valueSource, .<TInner> expected, . collectionOrdering, [.("expected")] string doNotPopulateThisValue = null, [.("collectionOrdering")] string doNotPopulateThisValue2 = null)
            where TActual : .<TInner> { }
        public static .<TActual> IsNotEquivalentTo<TActual, TInner>(this ..IValueSource<TActual> valueSource, .<TInner> expected, .<TInner> comparer, . collectionOrdering, [.("expected")] string doNotPopulateThisValue = null, [.("collectionOrdering")] string doNotPopulateThisValue2 = null)
            where TActual : .<TInner> { }
    }
    public static class ComparableIsExtensions
    {
        public static ..BetweenAssertionBuilderWrapper<TActual> IsBetween<TActual>(this ..IValueSource<TActual> valueSource, TActual lowerBound, TActual upperBound, [.("lowerBound")] string doNotPopulateThisValue1 = null, [.("upperBound")] string doNotPopulateThisValue2 = null)
            where TActual : <TActual> { }
        public static .<TActual> IsGreaterThan<TActual>(this ..IValueSource<TActual> valueSource, TActual expected, [.("expected")] string doNotPopulateThisValue = null)
            where TActual : <TActual> { }
        public static .<TActual> IsGreaterThanOrEqualTo<TActual>(this ..IValueSource<TActual> valueSource, TActual expected, [.("expected")] string doNotPopulateThisValue = null)
            where TActual : <TActual> { }
        public static .<TActual> IsLessThan<TActual>(this ..IValueSource<TActual> valueSource, TActual expected, [.("expected")] string doNotPopulateThisValue = null)
            where TActual : <TActual> { }
        public static .<TActual> IsLessThanOrEqualTo<TActual>(this ..IValueSource<TActual> valueSource, TActual expected, [.("expected")] string doNotPopulateThisValue = null)
            where TActual : <TActual> { }
    }
    public static class ComparableIsNotExtensions
    {
        public static ..NotBetweenAssertionBuilderWrapper<TActual> IsNotBetween<TActual>(this ..IValueSource<TActual> valueSource, TActual lowerBound, TActual upperBound, [.("lowerBound")] string doNotPopulateThisValue1 = null, [.("upperBound")] string doNotPopulateThisValue2 = null)
            where TActual : <TActual> { }
        public static .<TActual> IsNotGreaterThan<TActual>(this ..IValueSource<TActual> valueSource, TActual expected, [.("expected")] string doNotPopulateThisValue = null)
            where TActual : <TActual> { }
        public static .<TActual> IsNotGreaterThanOrEqualTo<TActual>(this ..IValueSource<TActual> valueSource, TActual expected, [.("expected")] string doNotPopulateThisValue = null)
            where TActual : <TActual> { }
        public static .<TActual> IsNotLessThan<TActual>(this ..IValueSource<TActual> valueSource, TActual expected, [.("expected")] string doNotPopulateThisValue = null)
            where TActual : <TActual> { }
        public static .<TActual> IsNotLessThanOrEqualTo<TActual>(this ..IValueSource<TActual> valueSource, TActual expected, [.("expected")] string doNotPopulateThisValue = null)
            where TActual : <TActual> { }
    }
    [.(typeof(.CultureInfo), "IsNeutralCulture")]
    [.(typeof(.CultureInfo), "IsNeutralCulture", CustomName="IsNotNeutralCulture", NegateLogic=true)]
    [.(typeof(.CultureInfo), "IsReadOnly")]
    [.(typeof(.CultureInfo), "IsReadOnly", CustomName="IsNotReadOnly", NegateLogic=true)]
    [.(typeof(.CultureInfo), typeof(.), "IsEnglish")]
    [.(typeof(.CultureInfo), typeof(.), "IsEnglish", CustomName="IsNotEnglish", NegateLogic=true)]
    [.(typeof(.CultureInfo), typeof(.), "IsInvariant")]
    [.(typeof(.CultureInfo), typeof(.), "IsInvariant", CustomName="IsNotInvariant", NegateLogic=true)]
    [.(typeof(.CultureInfo), typeof(.), "IsRightToLeft")]
    [.(typeof(.CultureInfo), typeof(.), "IsRightToLeft", CustomName="IsLeftToRight", NegateLogic=true)]
    public static class CultureInfoAssertionExtensions
    {
        public static .<.CultureInfo> IsEnglish(this ..IValueSource<.CultureInfo> valueSource) { }
        public static .<.CultureInfo> IsInvariant(this ..IValueSource<.CultureInfo> valueSource) { }
        public static .<.CultureInfo> IsLeftToRight(this ..IValueSource<.CultureInfo> valueSource) { }
        public static .<.CultureInfo> IsNeutralCulture(this ..IValueSource<.CultureInfo> valueSource) { }
        public static .<.CultureInfo> IsNotEnglish(this ..IValueSource<.CultureInfo> valueSource) { }
        public static .<.CultureInfo> IsNotInvariant(this ..IValueSource<.CultureInfo> valueSource) { }
        public static .<.CultureInfo> IsNotNeutralCulture(this ..IValueSource<.CultureInfo> valueSource) { }
        public static .<.CultureInfo> IsNotReadOnly(this ..IValueSource<.CultureInfo> valueSource) { }
        public static .<.CultureInfo> IsReadOnly(this ..IValueSource<.CultureInfo> valueSource) { }
        public static .<.CultureInfo> IsRightToLeft(this ..IValueSource<.CultureInfo> valueSource) { }
    }
    public class CultureInfoCultureInfoAssertionExtensionsIsEnglishWithCultureInfoAssertCondition : .<.CultureInfo>
    {
        public CultureInfoCultureInfoAssertionExtensionsIsEnglishWithCultureInfoAssertCondition(bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(.CultureInfo? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class CultureInfoCultureInfoAssertionExtensionsIsInvariantWithCultureInfoAssertCondition : .<.CultureInfo>
    {
        public CultureInfoCultureInfoAssertionExtensionsIsInvariantWithCultureInfoAssertCondition(bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(.CultureInfo? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class CultureInfoCultureInfoAssertionExtensionsIsRightToLeftWithCultureInfoAssertCondition : .<.CultureInfo>
    {
        public CultureInfoCultureInfoAssertionExtensionsIsRightToLeftWithCultureInfoAssertCondition(bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(.CultureInfo? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class CultureInfoIsNeutralCultureAssertCondition : .<.CultureInfo>
    {
        public CultureInfoIsNeutralCultureAssertCondition(bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(.CultureInfo? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class CultureInfoIsReadOnlyAssertCondition : .<.CultureInfo>
    {
        public CultureInfoIsReadOnlyAssertCondition(bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(.CultureInfo? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    [.(typeof(), typeof(), "IsDaylightSavingTime")]
    [.(typeof(), typeof(), "IsDaylightSavingTime", CustomName="IsNotDaylightSavingTime", NegateLogic=true)]
    [.(typeof(), typeof(.), "IsLeapYear")]
    [.(typeof(), typeof(.), "IsLeapYear", CustomName="IsNotLeapYear", NegateLogic=true)]
    [.(typeof(), typeof(.), "IsToday")]
    [.(typeof(), typeof(.), "IsToday", CustomName="IsNotToday", NegateLogic=true)]
    [.(typeof(), typeof(.), "IsUtc")]
    [.(typeof(), typeof(.), "IsUtc", CustomName="IsNotUtc", NegateLogic=true)]
    [.(typeof(), typeof(.), "IsWeekend")]
    [.(typeof(), typeof(.), "IsWeekend", CustomName="IsWeekday", NegateLogic=true)]
    [.(typeof(), typeof(), "EqualsExact")]
    public static class DateTimeAssertionExtensions
    {
        public static .<> EqualsExact(this ..IValueSource<> valueSource,  other, [.("other")] string? doNotPopulateThisValue1 = null) { }
        public static .<> IsDaylightSavingTime(this ..IValueSource<> valueSource) { }
        public static .<> IsLeapYear(this ..IValueSource<> valueSource) { }
        public static .<> IsNotDaylightSavingTime(this ..IValueSource<> valueSource) { }
        public static .<> IsNotLeapYear(this ..IValueSource<> valueSource) { }
        public static .<> IsNotToday(this ..IValueSource<> valueSource) { }
        public static .<> IsNotUtc(this ..IValueSource<> valueSource) { }
        public static .<> IsToday(this ..IValueSource<> valueSource) { }
        public static .<> IsUtc(this ..IValueSource<> valueSource) { }
        public static .<> IsWeekday(this ..IValueSource<> valueSource) { }
        public static .<> IsWeekend(this ..IValueSource<> valueSource) { }
    }
    public class DateTimeDateTimeAssertionExtensionsIsLeapYearWithDateTimeAssertCondition : .<>
    {
        public DateTimeDateTimeAssertionExtensionsIsLeapYearWithDateTimeAssertCondition(bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult( actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class DateTimeDateTimeAssertionExtensionsIsTodayWithDateTimeAssertCondition : .<>
    {
        public DateTimeDateTimeAssertionExtensionsIsTodayWithDateTimeAssertCondition(bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult( actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class DateTimeDateTimeAssertionExtensionsIsUtcWithDateTimeAssertCondition : .<>
    {
        public DateTimeDateTimeAssertionExtensionsIsUtcWithDateTimeAssertCondition(bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult( actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class DateTimeDateTimeAssertionExtensionsIsWeekendWithDateTimeAssertCondition : .<>
    {
        public DateTimeDateTimeAssertionExtensionsIsWeekendWithDateTimeAssertCondition(bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult( actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class DateTimeIsDaylightSavingTimeAssertCondition : .<>
    {
        public DateTimeIsDaylightSavingTimeAssertCondition(bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult( actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public static class DateTimeIsExtensions
    {
        public static .<> IsAfter(this ..IValueSource<> valueSource,  expected, [.("expected")] string doNotPopulateThisValue = null) { }
        public static .<> IsAfterOrEqualTo(this ..IValueSource<> valueSource,  expected, [.("expected")] string doNotPopulateThisValue = null) { }
        public static .<> IsBefore(this ..IValueSource<> valueSource,  expected, [.("expected")] string doNotPopulateThisValue = null) { }
        public static .<> IsBeforeOrEqualTo(this ..IValueSource<> valueSource,  expected, [.("expected")] string doNotPopulateThisValue = null) { }
        public static ..DateTimeEqualToAssertionBuilderWrapper IsEqualTo(this ..IValueSource<> valueSource,  expected, [.("expected")] string doNotPopulateThisValue1 = null) { }
    }
    public class DateTimeOffsetEqualsExactWithDateTimeOffsetAssertCondition : .<>
    {
        public DateTimeOffsetEqualsExactWithDateTimeOffsetAssertCondition( other, bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult( actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public static class DateTimeOffsetIsExtensions
    {
        public static .<> IsAfter(this ..IValueSource<> valueSource,  expected, [.("expected")] string doNotPopulateThisValue = null) { }
        public static .<> IsAfterOrEqualTo(this ..IValueSource<> valueSource,  expected, [.("expected")] string doNotPopulateThisValue = null) { }
        public static .<> IsBefore(this ..IValueSource<> valueSource,  expected, [.("expected")] string doNotPopulateThisValue = null) { }
        public static .<> IsBeforeOrEqualTo(this ..IValueSource<> valueSource,  expected, [.("expected")] string doNotPopulateThisValue = null) { }
        public static ..DateTimeOffsetEqualToAssertionBuilderWrapper IsEqualTo(this ..IValueSource<> valueSource,  expected, [.("expected")] string doNotPopulateThisValue1 = null) { }
    }
    [.(typeof(), typeof(.), "IsFriday")]
    [.(typeof(), typeof(.), "IsFriday", CustomName="IsNotFriday", NegateLogic=true)]
    [.(typeof(), typeof(.), "IsMonday")]
    [.(typeof(), typeof(.), "IsMonday", CustomName="IsNotMonday", NegateLogic=true)]
    [.(typeof(), typeof(.), "IsWeekend")]
    [.(typeof(), typeof(.), "IsWeekend", CustomName="IsWeekday", NegateLogic=true)]
    public static class DayOfWeekAssertionExtensions
    {
        public static .<> IsFriday(this ..IValueSource<> valueSource) { }
        public static .<> IsMonday(this ..IValueSource<> valueSource) { }
        public static .<> IsNotFriday(this ..IValueSource<> valueSource) { }
        public static .<> IsNotMonday(this ..IValueSource<> valueSource) { }
        public static .<> IsWeekday(this ..IValueSource<> valueSource) { }
        public static .<> IsWeekend(this ..IValueSource<> valueSource) { }
    }
    public class DayOfWeekDayOfWeekAssertionExtensionsIsFridayWithDayOfWeekAssertCondition : .<>
    {
        public DayOfWeekDayOfWeekAssertionExtensionsIsFridayWithDayOfWeekAssertCondition(bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult( actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class DayOfWeekDayOfWeekAssertionExtensionsIsMondayWithDayOfWeekAssertCondition : .<>
    {
        public DayOfWeekDayOfWeekAssertionExtensionsIsMondayWithDayOfWeekAssertCondition(bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult( actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class DayOfWeekDayOfWeekAssertionExtensionsIsWeekendWithDayOfWeekAssertCondition : .<>
    {
        public DayOfWeekDayOfWeekAssertionExtensionsIsWeekendWithDayOfWeekAssertCondition(bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult( actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    [.(typeof(.DirectoryInfo), "Exists")]
    [.(typeof(.DirectoryInfo), "Exists", CustomName="DoesNotExist", NegateLogic=true)]
    [.(typeof(.DirectoryInfo), typeof(.), "HasFiles")]
    [.(typeof(.DirectoryInfo), typeof(.), "HasFiles", CustomName="HasNoFiles", NegateLogic=true)]
    [.(typeof(.DirectoryInfo), typeof(.), "HasSubdirectories")]
    [.(typeof(.DirectoryInfo), typeof(.), "HasSubdirectories", CustomName="HasNoSubdirectories", NegateLogic=true)]
    [.(typeof(.DirectoryInfo), typeof(.), "IsEmpty")]
    [.(typeof(.DirectoryInfo), typeof(.), "IsEmpty", CustomName="IsNotEmpty", NegateLogic=true)]
    [.(typeof(.DirectoryInfo), typeof(.), "IsHidden")]
    [.(typeof(.DirectoryInfo), typeof(.), "IsHidden", CustomName="IsNotHidden", NegateLogic=true)]
    [.(typeof(.DirectoryInfo), typeof(.), "IsReadOnly")]
    [.(typeof(.DirectoryInfo), typeof(.), "IsReadOnly", CustomName="IsNotReadOnly", NegateLogic=true)]
    [.(typeof(.DirectoryInfo), typeof(.), "IsSystem")]
    [.(typeof(.DirectoryInfo), typeof(.), "IsSystem", CustomName="IsNotSystem", NegateLogic=true)]
    public static class DirectoryInfoAssertionExtensions
    {
        public static .<.DirectoryInfo> DoesNotExist(this ..IValueSource<.DirectoryInfo> valueSource) { }
        public static .<.DirectoryInfo> Exists(this ..IValueSource<.DirectoryInfo> valueSource) { }
        public static .<.DirectoryInfo> HasFiles(this ..IValueSource<.DirectoryInfo> valueSource) { }
        public static .<.DirectoryInfo> HasNoFiles(this ..IValueSource<.DirectoryInfo> valueSource) { }
        public static .<.DirectoryInfo> HasNoSubdirectories(this ..IValueSource<.DirectoryInfo> valueSource) { }
        public static .<.DirectoryInfo> HasSubdirectories(this ..IValueSource<.DirectoryInfo> valueSource) { }
        public static .<.DirectoryInfo> IsEmpty(this ..IValueSource<.DirectoryInfo> valueSource) { }
        public static .<.DirectoryInfo> IsHidden(this ..IValueSource<.DirectoryInfo> valueSource) { }
        public static .<.DirectoryInfo> IsNotEmpty(this ..IValueSource<.DirectoryInfo> valueSource) { }
        public static .<.DirectoryInfo> IsNotHidden(this ..IValueSource<.DirectoryInfo> valueSource) { }
        public static .<.DirectoryInfo> IsNotReadOnly(this ..IValueSource<.DirectoryInfo> valueSource) { }
        public static .<.DirectoryInfo> IsNotSystem(this ..IValueSource<.DirectoryInfo> valueSource) { }
        public static .<.DirectoryInfo> IsReadOnly(this ..IValueSource<.DirectoryInfo> valueSource) { }
        public static .<.DirectoryInfo> IsSystem(this ..IValueSource<.DirectoryInfo> valueSource) { }
    }
    public class DirectoryInfoDirectoryInfoAssertionExtensionsHasFilesWithDirectoryInfoAssertCondition : .<.DirectoryInfo>
    {
        public DirectoryInfoDirectoryInfoAssertionExtensionsHasFilesWithDirectoryInfoAssertCondition(bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(.DirectoryInfo? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class DirectoryInfoDirectoryInfoAssertionExtensionsHasSubdirectoriesWithDirectoryInfoAssertCondition : .<.DirectoryInfo>
    {
        public DirectoryInfoDirectoryInfoAssertionExtensionsHasSubdirectoriesWithDirectoryInfoAssertCondition(bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(.DirectoryInfo? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class DirectoryInfoDirectoryInfoAssertionExtensionsIsEmptyWithDirectoryInfoAssertCondition : .<.DirectoryInfo>
    {
        public DirectoryInfoDirectoryInfoAssertionExtensionsIsEmptyWithDirectoryInfoAssertCondition(bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(.DirectoryInfo? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class DirectoryInfoDirectoryInfoAssertionExtensionsIsHiddenWithDirectoryInfoAssertCondition : .<.DirectoryInfo>
    {
        public DirectoryInfoDirectoryInfoAssertionExtensionsIsHiddenWithDirectoryInfoAssertCondition(bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(.DirectoryInfo? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class DirectoryInfoDirectoryInfoAssertionExtensionsIsReadOnlyWithDirectoryInfoAssertCondition : .<.DirectoryInfo>
    {
        public DirectoryInfoDirectoryInfoAssertionExtensionsIsReadOnlyWithDirectoryInfoAssertCondition(bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(.DirectoryInfo? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class DirectoryInfoDirectoryInfoAssertionExtensionsIsSystemWithDirectoryInfoAssertCondition : .<.DirectoryInfo>
    {
        public DirectoryInfoDirectoryInfoAssertionExtensionsIsSystemWithDirectoryInfoAssertCondition(bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(.DirectoryInfo? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class DirectoryInfoExistsAssertCondition : .<.DirectoryInfo>
    {
        public DirectoryInfoExistsAssertCondition(bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(.DirectoryInfo? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public static class DoesExtensions
    {
        public static ..StringContainsAssertionBuilderWrapper Contains(this ..IValueSource<string> valueSource, string expected, [.("expected")] string doNotPopulateThisValue = null) { }
        public static ..StringContainsAssertionBuilderWrapper Contains(this ..IValueSource<string> valueSource, string expected,  stringComparison, [.("expected")] string doNotPopulateThisValue1 = null, [.("stringComparison")] string doNotPopulateThisValue2 = null) { }
        public static .<.<TInner>, ..EnumerableContainsExpectedFuncAssertCondition<.<TInner>, TInner>, TInner> Contains<TInner>(this ..IValueSource<.<TInner>> valueSource, <TInner, bool> matcher, [.("matcher")] string doNotPopulateThisValue = null) { }
        public static .<TActual> Contains<TActual, TInner>(this ..IValueSource<TActual> valueSource, TInner expected, .<TInner> equalityComparer = null, [.("expected")] string doNotPopulateThisValue = null)
            where TActual : .<TInner> { }
        public static .<.<TKey, TValue>> ContainsKey<TKey, TValue>(this ..IValueSource<.<TKey, TValue>> valueSource, TKey expected, .<TKey> equalityComparer = null, [.("expected")] string doNotPopulateThisValue = null) { }
        public static .<TDictionary> ContainsKey<TDictionary, TKey>(this ..IValueSource<TDictionary> valueSource, TKey expected, .<TKey> equalityComparer = null, [.("expected")] string doNotPopulateThisValue = null)
            where TDictionary : .IDictionary { }
        public static .<.<TInner>> ContainsOnly<TInner>(this ..IValueSource<.<TInner>> valueSource, <TInner, bool> matcher, [.("matcher")] string doNotPopulateThisValue = null) { }
        public static .<TDictionary> ContainsValue<TDictionary, TValue>(this ..IValueSource<TDictionary> valueSource, TValue expected, .<TValue> equalityComparer = null, [.("expected")] string doNotPopulateThisValue = null)
            where TDictionary : .IDictionary { }
        public static .<string> Matches(this ..IValueSource<string> valueSource, . regex, [.("regex")] string expression = "") { }
        public static .<string> Matches(this ..IValueSource<string> valueSource, string regex, [.("regex")] string expression = "") { }
    }
    public static class DoesNotExtensions
    {
        public static .<.<TInner>> DoesNotContain<TInner>(this ..IValueSource<.<TInner>> valueSource, <TInner, bool> matcher, [.("matcher")] string? doNotPopulateThisValue = null) { }
        public static .<TActual> DoesNotContain<TActual, TInner>(this ..IValueSource<TActual> valueSource, TInner expected, .<TInner?>? equalityComparer = null, [.("expected")] string? doNotPopulateThisValue = null)
            where TActual : .<TInner> { }
        public static .<.<TKey, TValue>> DoesNotContainKey<TKey, TValue>(this ..IValueSource<.<TKey, TValue>> valueSource, TKey expected, .<TKey> equalityComparer = null, [.("expected")] string doNotPopulateThisValue = null) { }
        public static .<TDictionary> DoesNotContainKey<TDictionary, TKey>(this ..IValueSource<TDictionary> valueSource, TKey expected, .<TKey> equalityComparer = null, [.("expected")] string doNotPopulateThisValue = null)
            where TDictionary : .IDictionary { }
        public static .<.<TKey, TValue>> DoesNotContainValue<TKey, TValue>(this ..IValueSource<.<TKey, TValue>> valueSource, TValue expected, .<TValue> equalityComparer = null, [.("expected")] string doNotPopulateThisValue = null) { }
        public static .<TDictionary> DoesNotContainValue<TDictionary, TValue>(this ..IValueSource<TDictionary> valueSource, TValue expected, .<TValue> equalityComparer = null, [.("expected")] string doNotPopulateThisValue = null)
            where TDictionary : .IDictionary { }
        public static .<string> DoesNotMatch(this ..IValueSource<string> valueSource, . regex, [.("regex")] string expression = "") { }
        public static .<string> DoesNotMatch(this ..IValueSource<string> valueSource, string regex, [.("regex")] string expression = "") { }
    }
    [.(typeof(.Encoding), "IsSingleByte")]
    [.(typeof(.Encoding), "IsSingleByte", CustomName="IsNotSingleByte", NegateLogic=true)]
    [.(typeof(.Encoding), typeof(.), "IsASCII")]
    [.(typeof(.Encoding), typeof(.), "IsASCII", CustomName="IsNotASCII", NegateLogic=true)]
    [.(typeof(.Encoding), typeof(.), "IsBigEndianUnicode")]
    [.(typeof(.Encoding), typeof(.), "IsBigEndianUnicode", CustomName="IsNotBigEndianUnicode", NegateLogic=true)]
    [.(typeof(.Encoding), typeof(.), "IsUTF32")]
    [.(typeof(.Encoding), typeof(.), "IsUTF32", CustomName="IsNotUTF32", NegateLogic=true)]
    [.(typeof(.Encoding), typeof(.), "IsUTF8")]
    [.(typeof(.Encoding), typeof(.), "IsUTF8", CustomName="IsNotUTF8", NegateLogic=true)]
    [.(typeof(.Encoding), typeof(.), "IsUnicode")]
    [.(typeof(.Encoding), typeof(.), "IsUnicode", CustomName="IsNotUnicode", NegateLogic=true)]
    public static class EncodingAssertionExtensions
    {
        public static .<.Encoding> IsASCII(this ..IValueSource<.Encoding> valueSource) { }
        public static .<.Encoding> IsBigEndianUnicode(this ..IValueSource<.Encoding> valueSource) { }
        public static .<.Encoding> IsNotASCII(this ..IValueSource<.Encoding> valueSource) { }
        public static .<.Encoding> IsNotBigEndianUnicode(this ..IValueSource<.Encoding> valueSource) { }
        public static .<.Encoding> IsNotSingleByte(this ..IValueSource<.Encoding> valueSource) { }
        public static .<.Encoding> IsNotUTF32(this ..IValueSource<.Encoding> valueSource) { }
        public static .<.Encoding> IsNotUTF8(this ..IValueSource<.Encoding> valueSource) { }
        public static .<.Encoding> IsNotUnicode(this ..IValueSource<.Encoding> valueSource) { }
        public static .<.Encoding> IsSingleByte(this ..IValueSource<.Encoding> valueSource) { }
        public static .<.Encoding> IsUTF32(this ..IValueSource<.Encoding> valueSource) { }
        public static .<.Encoding> IsUTF8(this ..IValueSource<.Encoding> valueSource) { }
        public static .<.Encoding> IsUnicode(this ..IValueSource<.Encoding> valueSource) { }
    }
    public class EncodingEncodingAssertionExtensionsIsASCIIWithEncodingAssertCondition : .<.Encoding>
    {
        public EncodingEncodingAssertionExtensionsIsASCIIWithEncodingAssertCondition(bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(.Encoding? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class EncodingEncodingAssertionExtensionsIsBigEndianUnicodeWithEncodingAssertCondition : .<.Encoding>
    {
        public EncodingEncodingAssertionExtensionsIsBigEndianUnicodeWithEncodingAssertCondition(bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(.Encoding? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class EncodingEncodingAssertionExtensionsIsUTF32WithEncodingAssertCondition : .<.Encoding>
    {
        public EncodingEncodingAssertionExtensionsIsUTF32WithEncodingAssertCondition(bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(.Encoding? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class EncodingEncodingAssertionExtensionsIsUTF8WithEncodingAssertCondition : .<.Encoding>
    {
        public EncodingEncodingAssertionExtensionsIsUTF8WithEncodingAssertCondition(bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(.Encoding? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class EncodingEncodingAssertionExtensionsIsUnicodeWithEncodingAssertCondition : .<.Encoding>
    {
        public EncodingEncodingAssertionExtensionsIsUnicodeWithEncodingAssertCondition(bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(.Encoding? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class EncodingIsSingleByteAssertCondition : .<.Encoding>
    {
        public EncodingIsSingleByteAssertCondition(bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(.Encoding? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    [.(typeof(), "HasFlag")]
    [.(typeof(), "HasFlag", CustomName="DoesNotHaveFlag", NegateLogic=true)]
    public static class EnumAssertionExtensions
    {
        public static .<> DoesNotHaveFlag(this ..IValueSource<> valueSource,  flag, [.("flag")] string? doNotPopulateThisValue1 = null) { }
        public static .<> HasFlag(this ..IValueSource<> valueSource,  flag, [.("flag")] string? doNotPopulateThisValue1 = null) { }
    }
    public class EnumHasFlagWithEnumAssertCondition : .<>
    {
        public EnumHasFlagWithEnumAssertCondition( flag, bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class EnumerableCount<TActual, TInner>
        where TActual : .<TInner>
    {
        public EnumerableCount(..IValueSource<TActual> valueSource) { }
        public .<TActual> Empty { get; }
        public .<TActual> EqualTo(int expected, [.("expected")] string? doNotPopulateThisValue = null) { }
        public .<TActual> EqualToOne() { }
        public .<TActual> EqualToZero() { }
        public .<TActual> GreaterThan(int expected, [.("expected")] string? doNotPopulateThisValue = null) { }
        public .<TActual> GreaterThanOrEqualTo(int expected, [.("expected")] string? doNotPopulateThisValue = null) { }
        public .<TActual> LessThan(int expected, [.("expected")] string? doNotPopulateThisValue = null) { }
        public .<TActual> LessThanOrEqualTo(int expected, [.("expected")] string? doNotPopulateThisValue = null) { }
        public .<TActual> Negative() { }
        public .<TActual> Positive() { }
    }
    [.(typeof(), typeof(.), "HasMultipleInnerExceptions")]
    [.(typeof(), typeof(.), "HasMultipleInnerExceptions", CustomName="HasSingleInnerException", NegateLogic=true)]
    [.(typeof(), typeof(.), "HasData")]
    [.(typeof(), typeof(.), "HasData", CustomName="HasNoData", NegateLogic=true)]
    [.(typeof(), typeof(.), "HasHelpLink")]
    [.(typeof(), typeof(.), "HasHelpLink", CustomName="HasNoHelpLink", NegateLogic=true)]
    [.(typeof(), typeof(.), "HasInnerException")]
    [.(typeof(), typeof(.), "HasInnerException", CustomName="HasNoInnerException", NegateLogic=true)]
    [.(typeof(), typeof(.), "HasStackTrace")]
    [.(typeof(), typeof(.), "HasStackTrace", CustomName="HasNoStackTrace", NegateLogic=true)]
    public static class ExceptionAssertionExtensions
    {
        public static .<> HasData(this ..IValueSource<> valueSource) { }
        public static .<> HasHelpLink(this ..IValueSource<> valueSource) { }
        public static .<> HasInnerException(this ..IValueSource<> valueSource) { }
        public static .<> HasMultipleInnerExceptions(this ..IValueSource<> valueSource) { }
        public static .<> HasNoData(this ..IValueSource<> valueSource) { }
        public static .<> HasNoHelpLink(this ..IValueSource<> valueSource) { }
        public static .<> HasNoInnerException(this ..IValueSource<> valueSource) { }
        public static .<> HasNoStackTrace(this ..IValueSource<> valueSource) { }
        public static .<> HasSingleInnerException(this ..IValueSource<> valueSource) { }
        public static .<> HasStackTrace(this ..IValueSource<> valueSource) { }
    }
    public class ExceptionExceptionAssertionExtensionsHasDataWithExceptionAssertCondition : .<>
    {
        public ExceptionExceptionAssertionExtensionsHasDataWithExceptionAssertCondition(bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class ExceptionExceptionAssertionExtensionsHasHelpLinkWithExceptionAssertCondition : .<>
    {
        public ExceptionExceptionAssertionExtensionsHasHelpLinkWithExceptionAssertCondition(bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class ExceptionExceptionAssertionExtensionsHasInnerExceptionWithExceptionAssertCondition : .<>
    {
        public ExceptionExceptionAssertionExtensionsHasInnerExceptionWithExceptionAssertCondition(bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class ExceptionExceptionAssertionExtensionsHasStackTraceWithExceptionAssertCondition : .<>
    {
        public ExceptionExceptionAssertionExtensionsHasStackTraceWithExceptionAssertCondition(bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    [.(typeof(.FileInfo), "Exists")]
    [.(typeof(.FileInfo), "Exists", CustomName="DoesNotExist", NegateLogic=true)]
    [.(typeof(.FileInfo), "IsReadOnly")]
    [.(typeof(.FileInfo), "IsReadOnly", CustomName="IsNotReadOnly", NegateLogic=true)]
    [.(typeof(.FileInfo), typeof(.), "IsCompressed")]
    [.(typeof(.FileInfo), typeof(.), "IsCompressed", CustomName="IsNotCompressed", NegateLogic=true)]
    [.(typeof(.FileInfo), typeof(.), "IsEmpty")]
    [.(typeof(.FileInfo), typeof(.), "IsEmpty", CustomName="IsNotEmpty", NegateLogic=true)]
    [.(typeof(.FileInfo), typeof(.), "IsEncrypted")]
    [.(typeof(.FileInfo), typeof(.), "IsEncrypted", CustomName="IsNotEncrypted", NegateLogic=true)]
    [.(typeof(.FileInfo), typeof(.), "IsExecutable")]
    [.(typeof(.FileInfo), typeof(.), "IsExecutable", CustomName="IsNotExecutable", NegateLogic=true)]
    [.(typeof(.FileInfo), typeof(.), "IsHidden")]
    [.(typeof(.FileInfo), typeof(.), "IsHidden", CustomName="IsNotHidden", NegateLogic=true)]
    [.(typeof(.FileInfo), typeof(.), "IsSystem")]
    [.(typeof(.FileInfo), typeof(.), "IsSystem", CustomName="IsNotSystem", NegateLogic=true)]
    public static class FileInfoAssertionExtensions
    {
        public static .<.FileInfo> DoesNotExist(this ..IValueSource<.FileInfo> valueSource) { }
        public static .<.FileInfo> Exists(this ..IValueSource<.FileInfo> valueSource) { }
        public static .<.FileInfo> IsCompressed(this ..IValueSource<.FileInfo> valueSource) { }
        public static .<.FileInfo> IsEmpty(this ..IValueSource<.FileInfo> valueSource) { }
        public static .<.FileInfo> IsEncrypted(this ..IValueSource<.FileInfo> valueSource) { }
        public static .<.FileInfo> IsExecutable(this ..IValueSource<.FileInfo> valueSource) { }
        public static .<.FileInfo> IsHidden(this ..IValueSource<.FileInfo> valueSource) { }
        public static .<.FileInfo> IsNotCompressed(this ..IValueSource<.FileInfo> valueSource) { }
        public static .<.FileInfo> IsNotEmpty(this ..IValueSource<.FileInfo> valueSource) { }
        public static .<.FileInfo> IsNotEncrypted(this ..IValueSource<.FileInfo> valueSource) { }
        public static .<.FileInfo> IsNotExecutable(this ..IValueSource<.FileInfo> valueSource) { }
        public static .<.FileInfo> IsNotHidden(this ..IValueSource<.FileInfo> valueSource) { }
        public static .<.FileInfo> IsNotReadOnly(this ..IValueSource<.FileInfo> valueSource) { }
        public static .<.FileInfo> IsNotSystem(this ..IValueSource<.FileInfo> valueSource) { }
        public static .<.FileInfo> IsReadOnly(this ..IValueSource<.FileInfo> valueSource) { }
        public static .<.FileInfo> IsSystem(this ..IValueSource<.FileInfo> valueSource) { }
    }
    public class FileInfoExistsAssertCondition : .<.FileInfo>
    {
        public FileInfoExistsAssertCondition(bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(.FileInfo? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class FileInfoFileInfoAssertionExtensionsIsCompressedWithFileInfoAssertCondition : .<.FileInfo>
    {
        public FileInfoFileInfoAssertionExtensionsIsCompressedWithFileInfoAssertCondition(bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(.FileInfo? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class FileInfoFileInfoAssertionExtensionsIsEmptyWithFileInfoAssertCondition : .<.FileInfo>
    {
        public FileInfoFileInfoAssertionExtensionsIsEmptyWithFileInfoAssertCondition(bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(.FileInfo? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class FileInfoFileInfoAssertionExtensionsIsEncryptedWithFileInfoAssertCondition : .<.FileInfo>
    {
        public FileInfoFileInfoAssertionExtensionsIsEncryptedWithFileInfoAssertCondition(bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(.FileInfo? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class FileInfoFileInfoAssertionExtensionsIsExecutableWithFileInfoAssertCondition : .<.FileInfo>
    {
        public FileInfoFileInfoAssertionExtensionsIsExecutableWithFileInfoAssertCondition(bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(.FileInfo? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class FileInfoFileInfoAssertionExtensionsIsHiddenWithFileInfoAssertCondition : .<.FileInfo>
    {
        public FileInfoFileInfoAssertionExtensionsIsHiddenWithFileInfoAssertCondition(bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(.FileInfo? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class FileInfoFileInfoAssertionExtensionsIsSystemWithFileInfoAssertCondition : .<.FileInfo>
    {
        public FileInfoFileInfoAssertionExtensionsIsSystemWithFileInfoAssertCondition(bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(.FileInfo? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class FileInfoIsReadOnlyAssertCondition : .<.FileInfo>
    {
        public FileInfoIsReadOnlyAssertCondition(bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(.FileInfo? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    [.(typeof(.DirectoryInfo), "Exists")]
    [.(typeof(.DirectoryInfo), "Exists", CustomName="DoesNotExist", NegateLogic=true)]
    [.(typeof(.FileInfo), "Exists")]
    [.(typeof(.FileInfo), "Exists", CustomName="DoesNotExist", NegateLogic=true)]
    [.(typeof(.FileInfo), "IsReadOnly")]
    [.(typeof(.FileInfo), "IsReadOnly", CustomName="IsNotReadOnly", NegateLogic=true)]
    [.(typeof(.FileSystemInfo), "Exists")]
    [.(typeof(.FileSystemInfo), "Exists", CustomName="DoesNotExist", NegateLogic=true)]
    public static class FileSystemAssertionExtensions
    {
        public static .<.DirectoryInfo> DoesNotExist(this ..IValueSource<.DirectoryInfo> valueSource) { }
        public static .<.FileInfo> DoesNotExist(this ..IValueSource<.FileInfo> valueSource) { }
        public static .<.FileSystemInfo> DoesNotExist(this ..IValueSource<.FileSystemInfo> valueSource) { }
        public static .<.DirectoryInfo> Exists(this ..IValueSource<.DirectoryInfo> valueSource) { }
        public static .<.FileInfo> Exists(this ..IValueSource<.FileInfo> valueSource) { }
        public static .<.FileSystemInfo> Exists(this ..IValueSource<.FileSystemInfo> valueSource) { }
        public static .<.FileInfo> IsNotReadOnly(this ..IValueSource<.FileInfo> valueSource) { }
        public static .<.FileInfo> IsReadOnly(this ..IValueSource<.FileInfo> valueSource) { }
    }
    public class FileSystemInfoExistsAssertCondition : .<.FileSystemInfo>
    {
        public FileSystemInfoExistsAssertCondition(bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(.FileSystemInfo? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public static class GenericIsExtensions
    {
        public static .<object> IsAssignableFrom(this ..IValueSource<object> valueSource,  type) { }
        public static .<object> IsAssignableFrom<TExpected>(this ..IValueSource<object> valueSource) { }
        public static .<object> IsAssignableTo(this ..IValueSource<object> valueSource,  type) { }
        public static .<object, TExpected> IsAssignableTo<TExpected>(this ..IValueSource<object> valueSource) { }
        public static ..GenericEqualToAssertionBuilderWrapper<TActual> IsEqualTo<TActual>(this ..IValueSource<TActual> valueSource, TActual expected, [.("expected")] string doNotPopulateThisValue1 = null) { }
        public static ..GenericEqualToAssertionBuilderWrapper<TActual> IsEqualTo<TActual>(this ..IValueSource<TActual> valueSource, TActual expected, .<TActual> equalityComparer, [.("expected")] string doNotPopulateThisValue1 = null) { }
        public static .<TActual> IsEquatableOrEqualTo<TActual>(this ..IValueSource<TActual> valueSource, TActual expected, [.("expected")] string doNotPopulateThisValue1 = null) { }
        public static ..EquivalentToAssertionBuilderWrapper<TActual, TExpected> IsEquivalentTo<TActual, TExpected>(this ..IValueSource<TActual> valueSource, TExpected expected, [.("expected")] string doNotPopulateThisValue1 = null) { }
        public static .<object> IsNotAssignableFrom(this ..IValueSource<object> valueSource,  type) { }
        public static .<object> IsNotAssignableFrom<TExpected>(this ..IValueSource<object> valueSource) { }
        public static .<object> IsNotAssignableTo(this ..IValueSource<object> valueSource,  type) { }
        public static .<object> IsNotAssignableTo<TExpected>(this ..IValueSource<object> valueSource) { }
        public static .<object> IsNotTypeOf(this ..IValueSource<object> valueSource,  type) { }
        public static .<object> IsNotTypeOf<TExpected>(this ..IValueSource<object> valueSource) { }
        public static .<TActual> IsNull<TActual>(this ..IValueSource<TActual> valueSource) { }
        public static .<TActual> IsSameReferenceAs<TActual, TExpected>(this ..IValueSource<TActual> valueSource, TExpected expected, [.("expected")] string doNotPopulateThisValue1 = null) { }
        public static .<object> IsTypeOf(this ..IValueSource<object> valueSource,  type) { }
        public static .<object, TExpected> IsTypeOf<TExpected>(this ..IValueSource<object> valueSource) { }
    }
    public static class GenericIsInExtensions
    {
        public static .<TActual> IsIn<TActual>(this ..IValueSource<TActual> valueSource, .<TActual> expected) { }
        public static .<TActual> IsIn<TActual>(this ..IValueSource<TActual> valueSource, params TActual[] expected) { }
        public static .<TActual> IsIn<TActual>(this ..IValueSource<TActual> valueSource, .<TActual> expected, .<TActual> equalityComparer) { }
    }
    public static class GenericIsNotExtensions
    {
        public static .<TActual> IsDefault<TActual>(this ..IValueSource<TActual> valueSource) { }
        public static .<TActual> IsNotDefault<TActual>(this ..IValueSource<TActual> valueSource) { }
        public static ..GenericNotEqualToAssertionBuilderWrapper<TActual> IsNotEqualTo<TActual>(this ..IValueSource<TActual> valueSource, TActual expected, [.("expected")] string? doNotPopulateThisValue = null) { }
        public static .<TActual> IsNotEquatableOrEqualTo<TActual>(this ..IValueSource<TActual> valueSource, TActual expected, [.("expected")] string? doNotPopulateThisValue = null) { }
        public static ..NotEquivalentToAssertionBuilderWrapper<TActual, TExpected> IsNotEquivalentTo<TActual, TExpected>(this ..IValueSource<TActual> valueSource, TExpected expected, [.("expected")] string? doNotPopulateThisValue1 = null) { }
        public static ..NotNullAssertionBuilderWrapper<TActual> IsNotNull<TActual>(this ..IValueSource<TActual?> valueSource)
            where TActual :  class { }
        public static ..NotNullStructAssertionBuilderWrapper<TActual> IsNotNull<TActual>(this ..IValueSource<TActual?> valueSource)
            where TActual :  struct { }
        public static .<TActual> IsNotSameReferenceAs<TActual, TExpected>(this ..IValueSource<TActual> valueSource, TExpected expected, [.("expected")] string? doNotPopulateThisValue1 = null) { }
    }
    public static class GenericSatisfiesExtensions
    {
        public static .CollectionWrapper<TInner> All<TInner>(this ..IValueSource<.<TInner>> valueSource) { }
        public static .<TActual> Satisfies<TActual, TExpected>(this ..IValueSource<TActual> valueSource, <TActual, .<TExpected>?> asyncMapper, <..IValueSource<TExpected?>, .<TExpected?>> assert, [.("asyncMapper")] string mapperExpression = "", [.("assert")] string assertionBuilderExpression = "") { }
        public static .<TActual> Satisfies<TActual, TExpected>(this ..IValueSource<TActual> valueSource, <TActual, TExpected> mapper, <..IValueSource<TExpected?>, .<TExpected?>> assert, [.("mapper")] string mapperExpression = "", [.("assert")] string assertionBuilderExpression = "") { }
    }
    [.(typeof(), typeof(.), "IsEmpty")]
    [.(typeof(), typeof(.), "IsEmpty", CustomName="IsNotEmpty", NegateLogic=true)]
    [.(typeof(?), typeof(.), "IsNullOrEmpty")]
    [.(typeof(?), typeof(.), "IsNullOrEmpty", CustomName="IsNotNullOrEmpty", NegateLogic=true)]
    public static class GuidAssertionExtensions
    {
        public static .<> IsEmpty(this ..IValueSource<> valueSource) { }
        public static .<> IsNotEmpty(this ..IValueSource<> valueSource) { }
        public static .<?> IsNotNullOrEmpty(this ..IValueSource<?> valueSource) { }
        public static .<?> IsNullOrEmpty(this ..IValueSource<?> valueSource) { }
    }
    public class GuidGuidAssertionExtensionsIsEmptyWithGuidAssertCondition : .<>
    {
        public GuidGuidAssertionExtensionsIsEmptyWithGuidAssertCondition(bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult( actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public static class HasExtensions
    {
        public static .<.<TInner>, TInner> HasCount<TInner>(this ..IValueSource<.<TInner>> valueSource) { }
        public static .<.<TInner>, TInner> HasCount<TInner>(this ..IValueSource<.<TInner>> valueSource) { }
        public static .<.<TInner>> HasCount<TInner>(this ..IValueSource<.<TInner>> valueSource, int count) { }
        public static .<.<TInner>> HasDistinctItems<TInner>(this ..IValueSource<.<TInner>> valueSource) { }
        public static .<.<TInner>> HasDistinctItems<TInner>(this ..IValueSource<.<TInner>> valueSource) { }
        public static .<.<TInner>> HasDistinctItems<TInner>(this ..IValueSource<.<TInner>> valueSource, .<TInner> equalityComparer) { }
        public static .<.<TInner>> HasDistinctItems<TInner>(this ..IValueSource<.<TInner>> valueSource, .<TInner> equalityComparer) { }
        public static . HasLength(this ..IValueSource<string> valueSource) { }
        public static ..Member<TRootObject, TPropertyType> HasMember<TRootObject, TPropertyType>(this ..IValueSource<TRootObject> valueSource, .<<TRootObject, TPropertyType>> selector, [.("selector")] string expression = "") { }
        public static .<TActual> HasMessageContaining<TActual>(this ..IValueSource<TActual> valueSource, string expected, [.("expected")] string doNotPopulateThisValue = null)
            where TActual :  { }
        public static .<TActual> HasMessageContaining<TActual>(this ..IValueSource<TActual> valueSource, string expected,  stringComparison, [.("expected")] string doNotPopulateThisValue1 = null, [.("stringComparison")] string doNotPopulateThisValue2 = null)
            where TActual :  { }
        public static .<TActual> HasMessageEndingWith<TActual>(this ..IValueSource<TActual> valueSource, string expected, [.("expected")] string doNotPopulateThisValue = null)
            where TActual :  { }
        public static .<TActual> HasMessageEndingWith<TActual>(this ..IValueSource<TActual> valueSource, string expected,  stringComparison, [.("expected")] string doNotPopulateThisValue1 = null, [.("stringComparison")] string doNotPopulateThisValue2 = null)
            where TActual :  { }
        public static .<TActual> HasMessageEqualTo<TActual>(this ..IValueSource<TActual> valueSource, string expected, [.("expected")] string doNotPopulateThisValue = null)
            where TActual :  { }
        public static .<TActual> HasMessageEqualTo<TActual>(this ..IValueSource<TActual> valueSource, string expected,  stringComparison, [.("expected")] string doNotPopulateThisValue1 = null, [.("stringComparison")] string doNotPopulateThisValue2 = null)
            where TActual :  { }
        public static .<TActual> HasMessageMatching<TActual>(this ..IValueSource<TActual> valueSource, . expected,  stringComparison, [.("expected")] string doNotPopulateThisValue1 = null, [.("stringComparison")] string doNotPopulateThisValue2 = null)
            where TActual :  { }
        public static .<TActual> HasMessageStartingWith<TActual>(this ..IValueSource<TActual> valueSource, string expected, [.("expected")] string doNotPopulateThisValue = null)
            where TActual :  { }
        public static .<TActual> HasMessageStartingWith<TActual>(this ..IValueSource<TActual> valueSource, string expected,  stringComparison, [.("expected")] string doNotPopulateThisValue1 = null, [.("stringComparison")] string doNotPopulateThisValue2 = null)
            where TActual :  { }
        public static ..SingleItemAssertionBuilderWrapper<.<TInner>, TInner> HasSingleItem<TInner>(this ..IValueSource<.<TInner>> valueSource) { }
        public static ..SingleItemAssertionBuilderWrapper<.<TInner>, TInner> HasSingleItem<TInner>(this ..IValueSource<.<TInner>> valueSource) { }
    }
    [.(typeof(.HttpStatusCode), typeof(.), "IsClientError")]
    [.(typeof(.HttpStatusCode), typeof(.), "IsClientError", CustomName="IsNotClientError", NegateLogic=true)]
    [.(typeof(.HttpStatusCode), typeof(.), "IsError")]
    [.(typeof(.HttpStatusCode), typeof(.), "IsError", CustomName="IsNotError", NegateLogic=true)]
    [.(typeof(.HttpStatusCode), typeof(.), "IsInformational")]
    [.(typeof(.HttpStatusCode), typeof(.), "IsInformational", CustomName="IsNotInformational", NegateLogic=true)]
    [.(typeof(.HttpStatusCode), typeof(.), "IsRedirection")]
    [.(typeof(.HttpStatusCode), typeof(.), "IsRedirection", CustomName="IsNotRedirection", NegateLogic=true)]
    [.(typeof(.HttpStatusCode), typeof(.), "IsServerError")]
    [.(typeof(.HttpStatusCode), typeof(.), "IsServerError", CustomName="IsNotServerError", NegateLogic=true)]
    [.(typeof(.HttpStatusCode), typeof(.), "IsSuccess")]
    [.(typeof(.HttpStatusCode), typeof(.), "IsSuccess", CustomName="IsNotSuccess", NegateLogic=true)]
    public static class HttpStatusCodeAssertionExtensions
    {
        public static .<.HttpStatusCode> IsClientError(this ..IValueSource<.HttpStatusCode> valueSource) { }
        public static .<.HttpStatusCode> IsError(this ..IValueSource<.HttpStatusCode> valueSource) { }
        public static .<.HttpStatusCode> IsInformational(this ..IValueSource<.HttpStatusCode> valueSource) { }
        public static .<.HttpStatusCode> IsNotClientError(this ..IValueSource<.HttpStatusCode> valueSource) { }
        public static .<.HttpStatusCode> IsNotError(this ..IValueSource<.HttpStatusCode> valueSource) { }
        public static .<.HttpStatusCode> IsNotInformational(this ..IValueSource<.HttpStatusCode> valueSource) { }
        public static .<.HttpStatusCode> IsNotRedirection(this ..IValueSource<.HttpStatusCode> valueSource) { }
        public static .<.HttpStatusCode> IsNotServerError(this ..IValueSource<.HttpStatusCode> valueSource) { }
        public static .<.HttpStatusCode> IsNotSuccess(this ..IValueSource<.HttpStatusCode> valueSource) { }
        public static .<.HttpStatusCode> IsRedirection(this ..IValueSource<.HttpStatusCode> valueSource) { }
        public static .<.HttpStatusCode> IsServerError(this ..IValueSource<.HttpStatusCode> valueSource) { }
        public static .<.HttpStatusCode> IsSuccess(this ..IValueSource<.HttpStatusCode> valueSource) { }
    }
    public class HttpStatusCodeHttpStatusCodeAssertionExtensionsIsClientErrorWithHttpStatusCodeAssertCondition : .<.HttpStatusCode>
    {
        public HttpStatusCodeHttpStatusCodeAssertionExtensionsIsClientErrorWithHttpStatusCodeAssertCondition(bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(.HttpStatusCode actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class HttpStatusCodeHttpStatusCodeAssertionExtensionsIsErrorWithHttpStatusCodeAssertCondition : .<.HttpStatusCode>
    {
        public HttpStatusCodeHttpStatusCodeAssertionExtensionsIsErrorWithHttpStatusCodeAssertCondition(bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(.HttpStatusCode actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class HttpStatusCodeHttpStatusCodeAssertionExtensionsIsInformationalWithHttpStatusCodeAssertCondition : .<.HttpStatusCode>
    {
        public HttpStatusCodeHttpStatusCodeAssertionExtensionsIsInformationalWithHttpStatusCodeAssertCondition(bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(.HttpStatusCode actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class HttpStatusCodeHttpStatusCodeAssertionExtensionsIsRedirectionWithHttpStatusCodeAssertCondition : .<.HttpStatusCode>
    {
        public HttpStatusCodeHttpStatusCodeAssertionExtensionsIsRedirectionWithHttpStatusCodeAssertCondition(bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(.HttpStatusCode actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class HttpStatusCodeHttpStatusCodeAssertionExtensionsIsServerErrorWithHttpStatusCodeAssertCondition : .<.HttpStatusCode>
    {
        public HttpStatusCodeHttpStatusCodeAssertionExtensionsIsServerErrorWithHttpStatusCodeAssertCondition(bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(.HttpStatusCode actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class HttpStatusCodeHttpStatusCodeAssertionExtensionsIsSuccessWithHttpStatusCodeAssertCondition : .<.HttpStatusCode>
    {
        public HttpStatusCodeHttpStatusCodeAssertionExtensionsIsSuccessWithHttpStatusCodeAssertCondition(bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(.HttpStatusCode actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    [.(typeof(.IPAddress), "IsIPv4MappedToIPv6")]
    [.(typeof(.IPAddress), "IsIPv4MappedToIPv6", CustomName="IsNotIPv4MappedToIPv6", NegateLogic=true)]
    [.(typeof(.IPAddress), "IsIPv6LinkLocal")]
    [.(typeof(.IPAddress), "IsIPv6LinkLocal", CustomName="IsNotIPv6LinkLocal", NegateLogic=true)]
    [.(typeof(.IPAddress), "IsIPv6Multicast")]
    [.(typeof(.IPAddress), "IsIPv6Multicast", CustomName="IsNotIPv6Multicast", NegateLogic=true)]
    [.(typeof(.IPAddress), "IsIPv6SiteLocal")]
    [.(typeof(.IPAddress), "IsIPv6SiteLocal", CustomName="IsNotIPv6SiteLocal", NegateLogic=true)]
    [.(typeof(.IPAddress), typeof(.), "IsIPv4")]
    [.(typeof(.IPAddress), typeof(.), "IsIPv4", CustomName="IsNotIPv4", NegateLogic=true)]
    [.(typeof(.IPAddress), typeof(.), "IsIPv6")]
    [.(typeof(.IPAddress), typeof(.), "IsIPv6", CustomName="IsNotIPv6", NegateLogic=true)]
    [.(typeof(.IPAddress), typeof(.), "IsLoopback")]
    [.(typeof(.IPAddress), typeof(.), "IsLoopback", CustomName="IsNotLoopback", NegateLogic=true)]
    [.(typeof(.IPAddress), typeof(.), "IsPrivate")]
    [.(typeof(.IPAddress), typeof(.), "IsPrivate", CustomName="IsPublic", NegateLogic=true)]
    public static class IPAddressAssertionExtensions
    {
        public static .<.IPAddress> IsIPv4(this ..IValueSource<.IPAddress> valueSource) { }
        public static .<.IPAddress> IsIPv4MappedToIPv6(this ..IValueSource<.IPAddress> valueSource) { }
        public static .<.IPAddress> IsIPv6(this ..IValueSource<.IPAddress> valueSource) { }
        public static .<.IPAddress> IsIPv6LinkLocal(this ..IValueSource<.IPAddress> valueSource) { }
        public static .<.IPAddress> IsIPv6Multicast(this ..IValueSource<.IPAddress> valueSource) { }
        public static .<.IPAddress> IsIPv6SiteLocal(this ..IValueSource<.IPAddress> valueSource) { }
        public static .<.IPAddress> IsLoopback(this ..IValueSource<.IPAddress> valueSource) { }
        public static .<.IPAddress> IsNotIPv4(this ..IValueSource<.IPAddress> valueSource) { }
        public static .<.IPAddress> IsNotIPv4MappedToIPv6(this ..IValueSource<.IPAddress> valueSource) { }
        public static .<.IPAddress> IsNotIPv6(this ..IValueSource<.IPAddress> valueSource) { }
        public static .<.IPAddress> IsNotIPv6LinkLocal(this ..IValueSource<.IPAddress> valueSource) { }
        public static .<.IPAddress> IsNotIPv6Multicast(this ..IValueSource<.IPAddress> valueSource) { }
        public static .<.IPAddress> IsNotIPv6SiteLocal(this ..IValueSource<.IPAddress> valueSource) { }
        public static .<.IPAddress> IsNotLoopback(this ..IValueSource<.IPAddress> valueSource) { }
        public static .<.IPAddress> IsPrivate(this ..IValueSource<.IPAddress> valueSource) { }
        public static .<.IPAddress> IsPublic(this ..IValueSource<.IPAddress> valueSource) { }
    }
    public class IPAddressIPAddressAssertionExtensionsIsIPv4WithIPAddressAssertCondition : .<.IPAddress>
    {
        public IPAddressIPAddressAssertionExtensionsIsIPv4WithIPAddressAssertCondition(bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(.IPAddress? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class IPAddressIPAddressAssertionExtensionsIsIPv6WithIPAddressAssertCondition : .<.IPAddress>
    {
        public IPAddressIPAddressAssertionExtensionsIsIPv6WithIPAddressAssertCondition(bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(.IPAddress? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class IPAddressIPAddressAssertionExtensionsIsLoopbackWithIPAddressAssertCondition : .<.IPAddress>
    {
        public IPAddressIPAddressAssertionExtensionsIsLoopbackWithIPAddressAssertCondition(bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(.IPAddress? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class IPAddressIPAddressAssertionExtensionsIsPrivateWithIPAddressAssertCondition : .<.IPAddress>
    {
        public IPAddressIPAddressAssertionExtensionsIsPrivateWithIPAddressAssertCondition(bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(.IPAddress? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class IPAddressIsIPv4MappedToIPv6AssertCondition : .<.IPAddress>
    {
        public IPAddressIsIPv4MappedToIPv6AssertCondition(bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(.IPAddress? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class IPAddressIsIPv6LinkLocalAssertCondition : .<.IPAddress>
    {
        public IPAddressIsIPv6LinkLocalAssertCondition(bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(.IPAddress? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class IPAddressIsIPv6MulticastAssertCondition : .<.IPAddress>
    {
        public IPAddressIsIPv6MulticastAssertCondition(bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(.IPAddress? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class IPAddressIsIPv6SiteLocalAssertCondition : .<.IPAddress>
    {
        public IPAddressIsIPv6SiteLocalAssertCondition(bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(.IPAddress? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public static class ImmutableArrayIsExtensions
    {
        public static .<.<TInner>> IsEmpty<TInner>(this ..IValueSource<.<TInner>> valueSource) { }
        public static .<.<TInner>> IsEquivalentTo<TInner>(this ..IValueSource<.<TInner>> valueSource, .<TInner> expected, [.("expected")] string doNotPopulateThisValue = null) { }
        public static .<.<TInner>> IsEquivalentTo<TInner>(this ..IValueSource<.<TInner>> valueSource, .<TInner> expected, .<TInner> comparer, [.("expected")] string doNotPopulateThisValue = null) { }
        public static .<.<TInner>> IsEquivalentTo<TInner>(this ..IValueSource<.<TInner>> valueSource, .<TInner> expected, . collectionOrdering, [.("expected")] string doNotPopulateThisValue = null) { }
        public static .<.<TInner>> IsEquivalentTo<TInner>(this ..IValueSource<.<TInner>> valueSource, .<TInner> expected, .<TInner> comparer, . collectionOrdering, [.("expected")] string doNotPopulateThisValue = null) { }
        public static .<.<TInner>> IsInDescendingOrder<TInner>(this ..IValueSource<.<TInner>> valueSource) { }
        public static .<.<TInner>> IsInDescendingOrder<TInner>(this ..IValueSource<.<TInner>> valueSource, .<TInner> comparer) { }
        public static .<.<TInner>> IsInOrder<TInner>(this ..IValueSource<.<TInner>> valueSource) { }
        public static .<.<TInner>> IsInOrder<TInner>(this ..IValueSource<.<TInner>> valueSource, .<TInner> comparer) { }
        public static .<.<TInner>> IsOrderedBy<TInner, TComparisonItem>(this ..IValueSource<.<TInner>> valueSource, <TInner, TComparisonItem> comparisonItemSelector, [.("comparisonItemSelector")] string doNotPopulateThisValue = null) { }
        public static .<.<TInner>> IsOrderedBy<TInner, TComparisonItem>(this ..IValueSource<.<TInner>> valueSource, <TInner, TComparisonItem> comparisonItemSelector, .<TComparisonItem> comparer, [.("comparisonItemSelector")] string doNotPopulateThisValue = null, [.("comparer")] string doNotPopulateThisValue2 = null) { }
        public static .<.<TInner>> IsOrderedByDescending<TInner, TComparisonItem>(this ..IValueSource<.<TInner>> valueSource, <TInner, TComparisonItem> comparisonItemSelector, [.("comparisonItemSelector")] string doNotPopulateThisValue = null) { }
        public static .<.<TInner>> IsOrderedByDescending<TInner, TComparisonItem>(this ..IValueSource<.<TInner>> valueSource, <TInner, TComparisonItem> comparisonItemSelector, .<TComparisonItem> comparer, [.("comparisonItemSelector")] string doNotPopulateThisValue = null, [.("comparer")] string doNotPopulateThisValue2 = null) { }
    }
    public static class ImmutableArrayIsNotExtensions
    {
        public static .<.<TInner>> IsNotEmpty<TInner>(this ..IValueSource<.<TInner>> valueSource) { }
        public static .<.<TInner>> IsNotEquivalentTo<TInner>(this ..IValueSource<.<TInner>> valueSource, .<TInner> expected, [.("expected")] string doNotPopulateThisValue = null) { }
        public static .<.<TInner>> IsNotEquivalentTo<TInner>(this ..IValueSource<.<TInner>> valueSource, .<TInner> expected, .<TInner> comparer, [.("expected")] string doNotPopulateThisValue = null, [.("comparer")] string doNotPopulateThisValue2 = null) { }
        public static .<.<TInner>> IsNotEquivalentTo<TInner>(this ..IValueSource<.<TInner>> valueSource, .<TInner> expected, . collectionOrdering, [.("expected")] string doNotPopulateThisValue = null, [.("collectionOrdering")] string doNotPopulateThisValue2 = null) { }
        public static .<.<TInner>> IsNotEquivalentTo<TInner>(this ..IValueSource<.<TInner>> valueSource, .<TInner> expected, .<TInner> comparer, . collectionOrdering, [.("expected")] string doNotPopulateThisValue = null, [.("collectionOrdering")] string doNotPopulateThisValue2 = null) { }
    }
    public class NullableGuidAssertionExtensionsIsNullOrEmptyWithNullableAssertCondition : .<?>
    {
        public NullableGuidAssertionExtensionsIsNullOrEmptyWithNullableAssertCondition(bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    [.(typeof(string), typeof(.Path), "IsPathRooted", CustomName="IsNotRootedPath", NegateLogic=true)]
    [.(typeof(string), typeof(.Path), "IsPathRooted", CustomName="IsRootedPath")]
    public static class PathAssertionExtensions
    {
        public static .<string> IsNotRootedPath(this ..IValueSource<string> valueSource) { }
        public static .<string> IsRootedPath(this ..IValueSource<string> valueSource) { }
    }
    [.(typeof(.), typeof(.), "HasTimeout")]
    [.(typeof(.), typeof(.), "HasTimeout", CustomName="HasNoTimeout", NegateLogic=true)]
    [.(typeof(.), typeof(.), "IsCaseInsensitive")]
    [.(typeof(.), typeof(.), "IsCaseInsensitive", CustomName="IsCaseSensitive", NegateLogic=true)]
    [.(typeof(.), typeof(.), "IsCompiled")]
    [.(typeof(.), typeof(.), "IsCompiled", CustomName="IsNotCompiled", NegateLogic=true)]
    [.(typeof(.), typeof(.), "IsMultiline")]
    [.(typeof(.), typeof(.), "IsMultiline", CustomName="IsSingleline", NegateLogic=true)]
    public static class RegexAssertionExtensions
    {
        public static .<.> HasNoTimeout(this ..IValueSource<.> valueSource) { }
        public static .<.> HasTimeout(this ..IValueSource<.> valueSource) { }
        public static .<.> IsCaseInsensitive(this ..IValueSource<.> valueSource) { }
        public static .<.> IsCaseSensitive(this ..IValueSource<.> valueSource) { }
        public static .<.> IsCompiled(this ..IValueSource<.> valueSource) { }
        public static .<.> IsMultiline(this ..IValueSource<.> valueSource) { }
        public static .<.> IsNotCompiled(this ..IValueSource<.> valueSource) { }
        public static .<.> IsSingleline(this ..IValueSource<.> valueSource) { }
    }
    public class RegexRegexAssertionExtensionsHasTimeoutWithRegexAssertCondition : .<.>
    {
        public RegexRegexAssertionExtensionsHasTimeoutWithRegexAssertCondition(bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(.? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class RegexRegexAssertionExtensionsIsCaseInsensitiveWithRegexAssertCondition : .<.>
    {
        public RegexRegexAssertionExtensionsIsCaseInsensitiveWithRegexAssertCondition(bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(.? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class RegexRegexAssertionExtensionsIsCompiledWithRegexAssertCondition : .<.>
    {
        public RegexRegexAssertionExtensionsIsCompiledWithRegexAssertCondition(bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(.? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class RegexRegexAssertionExtensionsIsMultilineWithRegexAssertCondition : .<.>
    {
        public RegexRegexAssertionExtensionsIsMultilineWithRegexAssertCondition(bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(.? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public static class SourceExtensions
    {
        public static . RegisterAssertion<TActual>(this ..IDelegateSource delegateSource, .<TActual> assertCondition, string?[] argumentExpressions, [.] string? caller = null) { }
        public static .<TActual> RegisterAssertion<TActual>(this ..IValueSource<TActual> source, .<TActual> assertCondition, string?[] argumentExpressions, [.] string? caller = null) { }
        public static .<TToType> RegisterConversionAssertion<TToType>(this ..IDelegateSource source)
            where TToType :  { }
        public static .<TToType> RegisterConversionAssertion<TFromType, TToType>(this ..IValueSource<TFromType> source, .<TFromType, TToType> assertCondition, string?[] argumentExpressions, [.] string? caller = null) { }
    }
    [.(typeof(.Stream), "CanRead")]
    [.(typeof(.Stream), "CanRead", CustomName="CannotRead", NegateLogic=true)]
    [.(typeof(.Stream), "CanSeek")]
    [.(typeof(.Stream), "CanSeek", CustomName="CannotSeek", NegateLogic=true)]
    [.(typeof(.Stream), "CanWrite")]
    [.(typeof(.Stream), "CanWrite", CustomName="CannotWrite", NegateLogic=true)]
    [.(typeof(.Stream), typeof(.), "IsAtEnd")]
    [.(typeof(.Stream), typeof(.), "IsAtEnd", CustomName="IsNotAtEnd", NegateLogic=true)]
    [.(typeof(.Stream), typeof(.), "IsAtStart")]
    [.(typeof(.Stream), typeof(.), "IsAtStart", CustomName="IsNotAtStart", NegateLogic=true)]
    [.(typeof(.Stream), typeof(.), "IsEmpty")]
    [.(typeof(.Stream), typeof(.), "IsEmpty", CustomName="IsNotEmpty", NegateLogic=true)]
    public static class StreamAssertionExtensions
    {
        public static .<.Stream> CanRead(this ..IValueSource<.Stream> valueSource) { }
        public static .<.Stream> CanSeek(this ..IValueSource<.Stream> valueSource) { }
        public static .<.Stream> CanWrite(this ..IValueSource<.Stream> valueSource) { }
        public static .<.Stream> CannotRead(this ..IValueSource<.Stream> valueSource) { }
        public static .<.Stream> CannotSeek(this ..IValueSource<.Stream> valueSource) { }
        public static .<.Stream> CannotWrite(this ..IValueSource<.Stream> valueSource) { }
        public static .<.Stream> IsAtEnd(this ..IValueSource<.Stream> valueSource) { }
        public static .<.Stream> IsAtStart(this ..IValueSource<.Stream> valueSource) { }
        public static .<.Stream> IsEmpty(this ..IValueSource<.Stream> valueSource) { }
        public static .<.Stream> IsNotAtEnd(this ..IValueSource<.Stream> valueSource) { }
        public static .<.Stream> IsNotAtStart(this ..IValueSource<.Stream> valueSource) { }
        public static .<.Stream> IsNotEmpty(this ..IValueSource<.Stream> valueSource) { }
    }
    public class StreamCanReadAssertCondition : .<.Stream>
    {
        public StreamCanReadAssertCondition(bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(.Stream? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class StreamCanSeekAssertCondition : .<.Stream>
    {
        public StreamCanSeekAssertCondition(bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(.Stream? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class StreamCanWriteAssertCondition : .<.Stream>
    {
        public StreamCanWriteAssertCondition(bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(.Stream? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class StreamStreamAssertionExtensionsIsAtEndWithStreamAssertCondition : .<.Stream>
    {
        public StreamStreamAssertionExtensionsIsAtEndWithStreamAssertCondition(bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(.Stream? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class StreamStreamAssertionExtensionsIsAtStartWithStreamAssertCondition : .<.Stream>
    {
        public StreamStreamAssertionExtensionsIsAtStartWithStreamAssertCondition(bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(.Stream? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class StreamStreamAssertionExtensionsIsEmptyWithStreamAssertCondition : .<.Stream>
    {
        public StreamStreamAssertionExtensionsIsEmptyWithStreamAssertCondition(bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(.Stream? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    [.(typeof(string), "Contains", CustomName="DoesNotContain", NegateLogic=true)]
    [.(typeof(string), "EndsWith", CustomName="DoesNotEndWith", NegateLogic=true)]
    [.(typeof(string), "EndsWith", CustomName="EndsWith")]
    [.(typeof(string), "StartsWith", CustomName="DoesNotStartWith", NegateLogic=true)]
    [.(typeof(string), "StartsWith", CustomName="StartsWith")]
    public static class StringAssertionExtensions
    {
        public static .<string> DoesNotContain(this ..IValueSource<string> valueSource, string value, [.("value")] string? doNotPopulateThisValue1 = null) { }
        public static .<string> DoesNotEndWith(this ..IValueSource<string> valueSource, string value, [.("value")] string? doNotPopulateThisValue1 = null) { }
        public static .<string> DoesNotEndWith(this ..IValueSource<string> valueSource, string value,  comparisonType, [.("value")] string? doNotPopulateThisValue1 = null, [.("comparisonType")] string? doNotPopulateThisValue2 = null) { }
        public static .<string> DoesNotEndWith(this ..IValueSource<string> valueSource, string value, bool ignoreCase, .CultureInfo culture, [.("value")] string? doNotPopulateThisValue1 = null, [.("ignoreCase")] string? doNotPopulateThisValue2 = null, [.("culture")] string? doNotPopulateThisValue3 = null) { }
        public static .<string> DoesNotStartWith(this ..IValueSource<string> valueSource, string value, [.("value")] string? doNotPopulateThisValue1 = null) { }
        public static .<string> DoesNotStartWith(this ..IValueSource<string> valueSource, string value,  comparisonType, [.("value")] string? doNotPopulateThisValue1 = null, [.("comparisonType")] string? doNotPopulateThisValue2 = null) { }
        public static .<string> DoesNotStartWith(this ..IValueSource<string> valueSource, string value, bool ignoreCase, .CultureInfo culture, [.("value")] string? doNotPopulateThisValue1 = null, [.("ignoreCase")] string? doNotPopulateThisValue2 = null, [.("culture")] string? doNotPopulateThisValue3 = null) { }
        public static .<string> EndsWith(this ..IValueSource<string> valueSource, string value, [.("value")] string? doNotPopulateThisValue1 = null) { }
        public static .<string> EndsWith(this ..IValueSource<string> valueSource, string value,  comparisonType, [.("value")] string? doNotPopulateThisValue1 = null, [.("comparisonType")] string? doNotPopulateThisValue2 = null) { }
        public static .<string> EndsWith(this ..IValueSource<string> valueSource, string value, bool ignoreCase, .CultureInfo culture, [.("value")] string? doNotPopulateThisValue1 = null, [.("ignoreCase")] string? doNotPopulateThisValue2 = null, [.("culture")] string? doNotPopulateThisValue3 = null) { }
        public static .<string> StartsWith(this ..IValueSource<string> valueSource, string value, [.("value")] string? doNotPopulateThisValue1 = null) { }
        public static .<string> StartsWith(this ..IValueSource<string> valueSource, string value,  comparisonType, [.("value")] string? doNotPopulateThisValue1 = null, [.("comparisonType")] string? doNotPopulateThisValue2 = null) { }
        public static .<string> StartsWith(this ..IValueSource<string> valueSource, string value, bool ignoreCase, .CultureInfo culture, [.("value")] string? doNotPopulateThisValue1 = null, [.("ignoreCase")] string? doNotPopulateThisValue2 = null, [.("culture")] string? doNotPopulateThisValue3 = null) { }
    }
    [.(typeof(.StringBuilder), typeof(.), "HasExcessCapacity")]
    [.(typeof(.StringBuilder), typeof(.), "HasExcessCapacity", CustomName="HasNoExcessCapacity", NegateLogic=true)]
    [.(typeof(.StringBuilder), typeof(.), "IsAtCapacity")]
    [.(typeof(.StringBuilder), typeof(.), "IsAtCapacity", CustomName="IsNotAtCapacity", NegateLogic=true)]
    [.(typeof(.StringBuilder), typeof(.), "IsEmpty")]
    [.(typeof(.StringBuilder), typeof(.), "IsEmpty", CustomName="IsNotEmpty", NegateLogic=true)]
    public static class StringBuilderAssertionExtensions
    {
        public static .<.StringBuilder> HasExcessCapacity(this ..IValueSource<.StringBuilder> valueSource) { }
        public static .<.StringBuilder> HasNoExcessCapacity(this ..IValueSource<.StringBuilder> valueSource) { }
        public static .<.StringBuilder> IsAtCapacity(this ..IValueSource<.StringBuilder> valueSource) { }
        public static .<.StringBuilder> IsEmpty(this ..IValueSource<.StringBuilder> valueSource) { }
        public static .<.StringBuilder> IsNotAtCapacity(this ..IValueSource<.StringBuilder> valueSource) { }
        public static .<.StringBuilder> IsNotEmpty(this ..IValueSource<.StringBuilder> valueSource) { }
    }
    public class StringBuilderStringBuilderAssertionExtensionsHasExcessCapacityWithStringBuilderAssertCondition : .<.StringBuilder>
    {
        public StringBuilderStringBuilderAssertionExtensionsHasExcessCapacityWithStringBuilderAssertCondition(bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(.StringBuilder? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class StringBuilderStringBuilderAssertionExtensionsIsAtCapacityWithStringBuilderAssertCondition : .<.StringBuilder>
    {
        public StringBuilderStringBuilderAssertionExtensionsIsAtCapacityWithStringBuilderAssertCondition(bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(.StringBuilder? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class StringBuilderStringBuilderAssertionExtensionsIsEmptyWithStringBuilderAssertCondition : .<.StringBuilder>
    {
        public StringBuilderStringBuilderAssertionExtensionsIsEmptyWithStringBuilderAssertCondition(bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(.StringBuilder? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class StringContainsWithStringAssertCondition : .<string>
    {
        public StringContainsWithStringAssertCondition(string value, bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(string? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class StringEndsWithWithStringAnd1MoreAssertCondition : .<string>
    {
        public StringEndsWithWithStringAnd1MoreAssertCondition(string value,  comparisonType, bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(string? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class StringEndsWithWithStringAnd2MoreAssertCondition : .<string>
    {
        public StringEndsWithWithStringAnd2MoreAssertCondition(string value, bool ignoreCase, .CultureInfo culture, bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(string? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class StringEndsWithWithStringAssertCondition : .<string>
    {
        public StringEndsWithWithStringAssertCondition(string value, bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(string? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public static class StringExtensions
    {
        public static string GetStringOr(this string? value, string defaultValue) { }
        public static string GetStringOrEmpty(this string? value) { }
        public static string PrependAOrAn(this string value) { }
        public static string ReplaceNewLines(this string value) { }
        public static string ShowNewLines(this string value) { }
        public static string TruncateWithEllipsis(this string value, int maxLength) { }
    }
    public static class StringIsExtensions
    {
        public static .<string> IsEmpty(this ..IValueSource<string> valueSource) { }
        public static ..StringEqualToAssertionBuilderWrapper IsEqualTo(this ..IValueSource<string> valueSource, string expected, [.("expected")] string doNotPopulateThisValue1 = null) { }
        public static ..StringEqualToAssertionBuilderWrapper IsEqualTo(this ..IValueSource<string> valueSource, string expected,  stringComparison, [.("expected")] string doNotPopulateThisValue1 = null, [.("stringComparison")] string doNotPopulateThisValue2 = null) { }
        public static .<string> IsNullOrEmpty(this ..IValueSource<string> valueSource) { }
        public static .<string> IsNullOrWhitespace(this ..IValueSource<string> valueSource) { }
    }
    public static class StringIsNotExtensions
    {
        public static .<string> IsNotEmpty(this ..IValueSource<string> valueSource) { }
        public static .<string> IsNotEqualTo(this ..IValueSource<string> valueSource, string expected, [.("expected")] string doNotPopulateThisValue = null) { }
        public static .<string> IsNotEqualTo(this ..IValueSource<string> valueSource, string expected,  stringComparison, [.("expected")] string doNotPopulateThisValue1 = null, [.("stringComparison")] string doNotPopulateThisValue2 = null) { }
        public static .<string> IsNotNullOrEmpty(this ..IValueSource<string> valueSource) { }
        public static .<string> IsNotNullOrWhitespace(this ..IValueSource<string> valueSource) { }
    }
    public class StringLength
    {
        public StringLength(..IValueSource<string> valueSource) { }
        public .<string> Positive { get; }
        public .<string> Zero { get; }
        public .<string> EqualTo(int expected, [.("expected")] string? doNotPopulateThisValue = null) { }
        public .<string> GreaterThan(int expected, [.("expected")] string? doNotPopulateThisValue = null) { }
        public .<string> GreaterThanOrEqualTo(int expected, [.("expected")] string? doNotPopulateThisValue = null) { }
        public .<string> LessThan(int expected, [.("expected")] string? doNotPopulateThisValue = null) { }
        public .<string> LessThanOrEqualTo(int expected, [.("expected")] string? doNotPopulateThisValue = null) { }
    }
    public class StringPathIsPathRootedWithStringAssertCondition : .<string>
    {
        public StringPathIsPathRootedWithStringAssertCondition(bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(string? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class StringStartsWithWithStringAnd1MoreAssertCondition : .<string>
    {
        public StringStartsWithWithStringAnd1MoreAssertCondition(string value,  comparisonType, bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(string? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class StringStartsWithWithStringAnd2MoreAssertCondition : .<string>
    {
        public StringStartsWithWithStringAnd2MoreAssertCondition(string value, bool ignoreCase, .CultureInfo culture, bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(string? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class StringStartsWithWithStringAssertCondition : .<string>
    {
        public StringStartsWithWithStringAssertCondition(string value, bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(string? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class StringUriIsHexEncodingWithStringAnd1MoreAssertCondition : .<string>
    {
        public StringUriIsHexEncodingWithStringAnd1MoreAssertCondition(int index, bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(string? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class StringUriIsWellFormedUriStringWithStringAnd1MoreAssertCondition : .<string>
    {
        public StringUriIsWellFormedUriStringWithStringAnd1MoreAssertCondition( uriKind, bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(string? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    [.(typeof(.), "IsCanceled")]
    [.(typeof(.), "IsCanceled", CustomName="IsNotCanceled", NegateLogic=true)]
    [.(typeof(.), "IsCompleted")]
    [.(typeof(.), "IsCompleted", CustomName="IsNotCompleted", NegateLogic=true)]
    [.(typeof(.), "IsFaulted")]
    [.(typeof(.), "IsFaulted", CustomName="IsNotFaulted", NegateLogic=true)]
    public static class TaskAssertionExtensions
    {
        public static .<.> IsCanceled(this ..IValueSource<.> valueSource) { }
        public static .<.> IsCompleted(this ..IValueSource<.> valueSource) { }
        public static .<.> IsFaulted(this ..IValueSource<.> valueSource) { }
        public static .<.> IsNotCanceled(this ..IValueSource<.> valueSource) { }
        public static .<.> IsNotCompleted(this ..IValueSource<.> valueSource) { }
        public static .<.> IsNotFaulted(this ..IValueSource<.> valueSource) { }
    }
    public class TaskIsCanceledAssertCondition : .<.>
    {
        public TaskIsCanceledAssertCondition(bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(.? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class TaskIsCompletedAssertCondition : .<.>
    {
        public TaskIsCompletedAssertCondition(bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(.? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class TaskIsFaultedAssertCondition : .<.>
    {
        public TaskIsFaultedAssertCondition(bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(.? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class ThrowsException<TActual, TException>
        where TException : 
    {
        public ThrowsException(. delegateAssertionBuilder, ..IDelegateSource source, <?, ?> selector) { }
        public ..ValueAnd<TException> And { get; }
        public ..DelegateOr<object?> Or { get; }
        public .<TException?> GetAwaiter() { }
        public .<TActual, > WithInnerException() { }
        public .<TActual, TException> WithMessage(string expected, [.("expected")] string? doNotPopulateThisValue = null) { }
        public .<TActual, TException> WithMessageContaining(string expected, [.("expected")] string? doNotPopulateThisValue = null) { }
        public .<TActual, TException> WithMessageContaining(string expected,  stringComparison, [.("expected")] string? doNotPopulateThisValue = null, [.("stringComparison")] string? doNotPopulateThisValue2 = null) { }
        public .<TActual, TException> WithMessageMatching(. match, [.("match")] string? doNotPopulateThisValue = null) { }
        public static .<TException?> op_Explicit(.<TActual, TException> throwsException) { }
    }
    public static class ThrowsExtensions
    {
        public static .<object?, > Throws(this ..IDelegateSource delegateSource,  type, [.("type")] string? doNotPopulateThisValue = null) { }
        public static .<object?, TException> Throws<TException>(this ..IDelegateSource delegateSource)
            where TException :  { }
        public static .<object?, TException> ThrowsExactly<TException>(this ..IDelegateSource delegateSource)
            where TException :  { }
        public static .<object?, > ThrowsException(this ..IDelegateSource delegateSource) { }
        public static .<object?, object?> ThrowsNothing(this ..IDelegateSource delegateSource) { }
        public static .<TActual, TActual> ThrowsNothing<TActual>(this ..IValueDelegateSource<TActual> delegateSource) { }
        public static .<object?, > ThrowsWithin(this ..IDelegateSource delegateSource,  timeSpan, [.("timeSpan")] string? doNotPopulateThisValue = null) { }
        public static .<object?, TException> ThrowsWithin<TException>(this ..IDelegateSource delegateSource,  timeSpan, [.("timeSpan")] string? doNotPopulateThisValue = null)
            where TException :  { }
        public static .<TActual, TException> WithParameterName<TActual, TException>(this .<TActual, TException> throwsException, string expected, [.("expected")] string? doNotPopulateThisValue = null)
            where TException :  { }
    }
    [.(typeof(), typeof(.), "IsNegative")]
    [.(typeof(), typeof(.), "IsNegative", CustomName="IsPositiveOrZero", NegateLogic=true)]
    [.(typeof(), typeof(.), "IsPositive")]
    [.(typeof(), typeof(.), "IsPositive", CustomName="IsNegativeOrZero", NegateLogic=true)]
    [.(typeof(), typeof(.), "IsZero")]
    [.(typeof(), typeof(.), "IsZero", CustomName="IsNotZero", NegateLogic=true)]
    public static class TimeSpanAssertionExtensions
    {
        public static .<> IsNegative(this ..IValueSource<> valueSource) { }
        public static .<> IsNegativeOrZero(this ..IValueSource<> valueSource) { }
        public static .<> IsNotZero(this ..IValueSource<> valueSource) { }
        public static .<> IsPositive(this ..IValueSource<> valueSource) { }
        public static .<> IsPositiveOrZero(this ..IValueSource<> valueSource) { }
        public static .<> IsZero(this ..IValueSource<> valueSource) { }
    }
    public static class TimeSpanExtensions
    {
        public static  Days(this int days) { }
        public static  Hours(this int hours) { }
        public static  Milliseconds(this int milliseconds) { }
        public static  Minutes(this int minutes) { }
        public static  Seconds(this int seconds) { }
    }
    public static class TimeSpanIsExtensions
    {
        public static ..TimeSpanEqualToAssertionBuilderWrapper IsEqualTo(this ..IValueSource<> valueSource,  expected, [.("expected")] string doNotPopulateThisValue1 = null) { }
        public static .<> IsZero(this ..IValueSource<> valueSource) { }
    }
    public static class TimeSpanIsNotExtensions
    {
        public static .<> IsNotZero(this ..IValueSource<> valueSource) { }
    }
    public class TimeSpanTimeSpanAssertionExtensionsIsNegativeWithTimeSpanAssertCondition : .<>
    {
        public TimeSpanTimeSpanAssertionExtensionsIsNegativeWithTimeSpanAssertCondition(bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult( actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class TimeSpanTimeSpanAssertionExtensionsIsPositiveWithTimeSpanAssertCondition : .<>
    {
        public TimeSpanTimeSpanAssertionExtensionsIsPositiveWithTimeSpanAssertCondition(bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult( actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class TimeSpanTimeSpanAssertionExtensionsIsZeroWithTimeSpanAssertCondition : .<>
    {
        public TimeSpanTimeSpanAssertionExtensionsIsZeroWithTimeSpanAssertCondition(bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult( actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    [.(typeof(), "IsAbstract")]
    [.(typeof(), "IsAbstract", CustomName="IsNotAbstract", NegateLogic=true)]
    [.(typeof(), "IsArray")]
    [.(typeof(), "IsArray", CustomName="IsNotArray", NegateLogic=true)]
    [.(typeof(), "IsAssignableFrom")]
    [.(typeof(), "IsAssignableFrom", CustomName="IsNotAssignableFrom", NegateLogic=true)]
    [.(typeof(), "IsClass")]
    [.(typeof(), "IsClass", CustomName="IsNotClass", NegateLogic=true)]
    [.(typeof(), "IsEnum")]
    [.(typeof(), "IsEnum", CustomName="IsNotEnum", NegateLogic=true)]
    [.(typeof(), "IsGenericType")]
    [.(typeof(), "IsGenericType", CustomName="IsNotGenericType", NegateLogic=true)]
    [.(typeof(), "IsGenericTypeDefinition")]
    [.(typeof(), "IsGenericTypeDefinition", CustomName="IsNotGenericTypeDefinition", NegateLogic=true)]
    [.(typeof(), "IsInterface")]
    [.(typeof(), "IsInterface", CustomName="IsNotInterface", NegateLogic=true)]
    [.(typeof(), "IsNested")]
    [.(typeof(), "IsNested", CustomName="IsNotNested", NegateLogic=true)]
    [.(typeof(), "IsPrimitive")]
    [.(typeof(), "IsPrimitive", CustomName="IsNotPrimitive", NegateLogic=true)]
    [.(typeof(), "IsPublic")]
    [.(typeof(), "IsPublic", CustomName="IsNotPublic", NegateLogic=true)]
    [.(typeof(), "IsSealed")]
    [.(typeof(), "IsSealed", CustomName="IsNotSealed", NegateLogic=true)]
    [.(typeof(), "IsSerializable")]
    [.(typeof(), "IsSerializable", CustomName="IsNotSerializable", NegateLogic=true)]
    [.(typeof(), "IsValueType")]
    [.(typeof(), "IsValueType", CustomName="IsReferenceType", NegateLogic=true)]
    public static class TypeAssertionExtensions
    {
        public static .<> IsAbstract(this ..IValueSource<> valueSource) { }
        public static .<> IsArray(this ..IValueSource<> valueSource) { }
        public static .<> IsAssignableFrom(this ..IValueSource<> valueSource,  c, [.("c")] string? doNotPopulateThisValue1 = null) { }
        public static .<> IsClass(this ..IValueSource<> valueSource) { }
        public static .<> IsEnum(this ..IValueSource<> valueSource) { }
        public static .<> IsGenericType(this ..IValueSource<> valueSource) { }
        public static .<> IsGenericTypeDefinition(this ..IValueSource<> valueSource) { }
        public static .<> IsInterface(this ..IValueSource<> valueSource) { }
        public static .<> IsNested(this ..IValueSource<> valueSource) { }
        public static .<> IsNotAbstract(this ..IValueSource<> valueSource) { }
        public static .<> IsNotArray(this ..IValueSource<> valueSource) { }
        public static .<> IsNotAssignableFrom(this ..IValueSource<> valueSource,  c, [.("c")] string? doNotPopulateThisValue1 = null) { }
        public static .<> IsNotClass(this ..IValueSource<> valueSource) { }
        public static .<> IsNotEnum(this ..IValueSource<> valueSource) { }
        public static .<> IsNotGenericType(this ..IValueSource<> valueSource) { }
        public static .<> IsNotGenericTypeDefinition(this ..IValueSource<> valueSource) { }
        public static .<> IsNotInterface(this ..IValueSource<> valueSource) { }
        public static .<> IsNotNested(this ..IValueSource<> valueSource) { }
        public static .<> IsNotPrimitive(this ..IValueSource<> valueSource) { }
        public static .<> IsNotPublic(this ..IValueSource<> valueSource) { }
        public static .<> IsNotSealed(this ..IValueSource<> valueSource) { }
        public static .<> IsNotSerializable(this ..IValueSource<> valueSource) { }
        public static .<> IsPrimitive(this ..IValueSource<> valueSource) { }
        public static .<> IsPublic(this ..IValueSource<> valueSource) { }
        public static .<> IsReferenceType(this ..IValueSource<> valueSource) { }
        public static .<> IsSealed(this ..IValueSource<> valueSource) { }
        public static .<> IsSerializable(this ..IValueSource<> valueSource) { }
        public static .<> IsValueType(this ..IValueSource<> valueSource) { }
    }
    public class TypeIsAbstractAssertCondition : .<>
    {
        public TypeIsAbstractAssertCondition(bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class TypeIsArrayAssertCondition : .<>
    {
        public TypeIsArrayAssertCondition(bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class TypeIsAssignableFromWithTypeAssertCondition : .<>
    {
        public TypeIsAssignableFromWithTypeAssertCondition( c, bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class TypeIsClassAssertCondition : .<>
    {
        public TypeIsClassAssertCondition(bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class TypeIsEnumAssertCondition : .<>
    {
        public TypeIsEnumAssertCondition(bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class TypeIsGenericTypeAssertCondition : .<>
    {
        public TypeIsGenericTypeAssertCondition(bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class TypeIsGenericTypeDefinitionAssertCondition : .<>
    {
        public TypeIsGenericTypeDefinitionAssertCondition(bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class TypeIsInterfaceAssertCondition : .<>
    {
        public TypeIsInterfaceAssertCondition(bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class TypeIsNestedAssertCondition : .<>
    {
        public TypeIsNestedAssertCondition(bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class TypeIsPrimitiveAssertCondition : .<>
    {
        public TypeIsPrimitiveAssertCondition(bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class TypeIsPublicAssertCondition : .<>
    {
        public TypeIsPublicAssertCondition(bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class TypeIsSealedAssertCondition : .<>
    {
        public TypeIsSealedAssertCondition(bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class TypeIsSerializableAssertCondition : .<>
    {
        public TypeIsSerializableAssertCondition(bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class TypeIsValueTypeAssertCondition : .<>
    {
        public TypeIsValueTypeAssertCondition(bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    [.(typeof(), "IsAbsoluteUri")]
    [.(typeof(), "IsAbsoluteUri", CustomName="IsNotAbsoluteUri", NegateLogic=true)]
    [.(typeof(), "IsBaseOf")]
    [.(typeof(), "IsBaseOf", CustomName="IsNotBaseOf", NegateLogic=true)]
    [.(typeof(), "IsDefaultPort")]
    [.(typeof(), "IsDefaultPort", CustomName="IsNotDefaultPort", NegateLogic=true)]
    [.(typeof(), "IsFile")]
    [.(typeof(), "IsFile", CustomName="IsNotFile", NegateLogic=true)]
    [.(typeof(), "IsLoopback")]
    [.(typeof(), "IsLoopback", CustomName="IsNotLoopback", NegateLogic=true)]
    [.(typeof(), "IsUnc")]
    [.(typeof(), "IsUnc", CustomName="IsNotUnc", NegateLogic=true)]
    [.(typeof(), "IsWellFormedOriginalString")]
    [.(typeof(), "IsWellFormedOriginalString", CustomName="IsNotWellFormedOriginalString", NegateLogic=true)]
    [.(typeof(), typeof(.), "IsHttp")]
    [.(typeof(), typeof(.), "IsHttp", CustomName="IsNotHttp", NegateLogic=true)]
    [.(typeof(), typeof(.), "IsHttpOrHttps")]
    [.(typeof(), typeof(.), "IsHttpOrHttps", CustomName="IsNotHttpOrHttps", NegateLogic=true)]
    [.(typeof(), typeof(.), "IsHttps")]
    [.(typeof(), typeof(.), "IsHttps", CustomName="IsNotHttps", NegateLogic=true)]
    [.(typeof(char), typeof(), "IsHexDigit")]
    [.(typeof(char), typeof(), "IsHexDigit", CustomName="IsNotHexDigit", NegateLogic=true)]
    [.(typeof(string), typeof(), "IsHexEncoding")]
    [.(typeof(string), typeof(), "IsHexEncoding", CustomName="IsNotHexEncoding", NegateLogic=true)]
    [.(typeof(string), typeof(), "IsWellFormedUriString")]
    [.(typeof(string), typeof(), "IsWellFormedUriString", CustomName="IsNotWellFormedUriString", NegateLogic=true)]
    public static class UriAssertionExtensions
    {
        public static .<> IsAbsoluteUri(this ..IValueSource<> valueSource) { }
        public static .<> IsBaseOf(this ..IValueSource<> valueSource,  uri, [.("uri")] string? doNotPopulateThisValue1 = null) { }
        public static .<> IsDefaultPort(this ..IValueSource<> valueSource) { }
        public static .<> IsFile(this ..IValueSource<> valueSource) { }
        public static .<char> IsHexDigit(this ..IValueSource<char> valueSource) { }
        public static .<string> IsHexEncoding(this ..IValueSource<string> valueSource, int index, [.("index")] string? doNotPopulateThisValue1 = null) { }
        public static .<> IsHttp(this ..IValueSource<> valueSource) { }
        public static .<> IsHttpOrHttps(this ..IValueSource<> valueSource) { }
        public static .<> IsHttps(this ..IValueSource<> valueSource) { }
        public static .<> IsLoopback(this ..IValueSource<> valueSource) { }
        public static .<> IsNotAbsoluteUri(this ..IValueSource<> valueSource) { }
        public static .<> IsNotBaseOf(this ..IValueSource<> valueSource,  uri, [.("uri")] string? doNotPopulateThisValue1 = null) { }
        public static .<> IsNotDefaultPort(this ..IValueSource<> valueSource) { }
        public static .<> IsNotFile(this ..IValueSource<> valueSource) { }
        public static .<char> IsNotHexDigit(this ..IValueSource<char> valueSource) { }
        public static .<string> IsNotHexEncoding(this ..IValueSource<string> valueSource, int index, [.("index")] string? doNotPopulateThisValue1 = null) { }
        public static .<> IsNotHttp(this ..IValueSource<> valueSource) { }
        public static .<> IsNotHttpOrHttps(this ..IValueSource<> valueSource) { }
        public static .<> IsNotHttps(this ..IValueSource<> valueSource) { }
        public static .<> IsNotLoopback(this ..IValueSource<> valueSource) { }
        public static .<> IsNotUnc(this ..IValueSource<> valueSource) { }
        public static .<> IsNotWellFormedOriginalString(this ..IValueSource<> valueSource) { }
        public static .<string> IsNotWellFormedUriString(this ..IValueSource<string> valueSource,  uriKind, [.("uriKind")] string? doNotPopulateThisValue1 = null) { }
        public static .<> IsUnc(this ..IValueSource<> valueSource) { }
        public static .<> IsWellFormedOriginalString(this ..IValueSource<> valueSource) { }
        public static .<string> IsWellFormedUriString(this ..IValueSource<string> valueSource,  uriKind, [.("uriKind")] string? doNotPopulateThisValue1 = null) { }
    }
    public class UriIsAbsoluteUriAssertCondition : .<>
    {
        public UriIsAbsoluteUriAssertCondition(bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class UriIsBaseOfWithUriAssertCondition : .<>
    {
        public UriIsBaseOfWithUriAssertCondition( uri, bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class UriIsDefaultPortAssertCondition : .<>
    {
        public UriIsDefaultPortAssertCondition(bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class UriIsFileAssertCondition : .<>
    {
        public UriIsFileAssertCondition(bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class UriIsLoopbackAssertCondition : .<>
    {
        public UriIsLoopbackAssertCondition(bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class UriIsUncAssertCondition : .<>
    {
        public UriIsUncAssertCondition(bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class UriIsWellFormedOriginalStringAssertCondition : .<>
    {
        public UriIsWellFormedOriginalStringAssertCondition(bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class UriUriAssertionExtensionsIsHttpOrHttpsWithUriAssertCondition : .<>
    {
        public UriUriAssertionExtensionsIsHttpOrHttpsWithUriAssertCondition(bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class UriUriAssertionExtensionsIsHttpWithUriAssertCondition : .<>
    {
        public UriUriAssertionExtensionsIsHttpWithUriAssertCondition(bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class UriUriAssertionExtensionsIsHttpsWithUriAssertCondition : .<>
    {
        public UriUriAssertionExtensionsIsHttpsWithUriAssertCondition(bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    [.(typeof(), typeof(.), "IsMajorVersion")]
    [.(typeof(), typeof(.), "IsMajorVersion", CustomName="IsNotMajorVersion", NegateLogic=true)]
    public static class VersionAssertionExtensions
    {
        public static .<> IsMajorVersion(this ..IValueSource<> valueSource) { }
        public static .<> IsNotMajorVersion(this ..IValueSource<> valueSource) { }
    }
    public class VersionVersionAssertionExtensionsIsMajorVersionWithVersionAssertCondition : .<>
    {
        public VersionVersionAssertionExtensionsIsMajorVersionWithVersionAssertCondition(bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    [.(typeof(), "IsAlive")]
    [.(typeof(), "IsAlive", CustomName="IsDead", NegateLogic=true)]
    [.(typeof(), "TrackResurrection")]
    [.(typeof(), "TrackResurrection", CustomName="DoesNotTrackResurrection", NegateLogic=true)]
    public static class WeakReferenceAssertionExtensions
    {
        public static .<> DoesNotTrackResurrection(this ..IValueSource<> valueSource) { }
        public static .<> IsAlive(this ..IValueSource<> valueSource) { }
        public static .<> IsDead(this ..IValueSource<> valueSource) { }
        public static .<> TrackResurrection(this ..IValueSource<> valueSource) { }
    }
    public class WeakReferenceIsAliveAssertCondition : .<>
    {
        public WeakReferenceIsAliveAssertCondition(bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class WeakReferenceTrackResurrectionAssertCondition : .<>
    {
        public WeakReferenceTrackResurrectionAssertCondition(bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
}
namespace .Helpers
{
    public static class ExpressionHelpers
    {
        public static string GetName<T1, T2>(.<<T1, T2>> exp) { }
    }
    public abstract class Formatter
    {
        protected Formatter() { }
        public abstract bool CanHandle(object? value);
        public abstract string FormatValue(object? value);
        public static string Format(object? value) { }
    }
    public class StringDifference
    {
        public StringDifference(string? actualValue, string? expectedValue, .<string>? comparer = null) { }
        public int IgnoreWhiteSpace { get; set; }
        public int? OverriddenIndex { get; set; }
        public int IndexOfFirstMismatch() { }
        public override string ToString() { }
        public string ToString(string prefix) { }
    }
    public static class TimeSpanFormatter
    {
        public static string PrettyPrint(this  timeSpan) { }
    }
}