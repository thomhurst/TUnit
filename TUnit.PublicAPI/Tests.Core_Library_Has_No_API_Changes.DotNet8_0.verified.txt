[assembly: .(@", PublicKey=0024000004800000940000000602000000240000525341310004000001000100698a70398fa0b2230c5a72e3bd9d56b48f809f6173e49a19fbb942d621be93ad48c5566b47b28faabc359b9ad3ff4e00bbdea88f5bdfa250f391fedd28182b2e37b55d429c0151a42a98ea7a5821818cd15a79fef9903e8607a88304cf3e0317bf86ec96e32e1381535a6582251e5a6eed40b5a3ed82bc444598b1269cce57a7")]
[assembly: .(@", PublicKey=0024000004800000940000000602000000240000525341310004000001000100698a70398fa0b2230c5a72e3bd9d56b48f809f6173e49a19fbb942d621be93ad48c5566b47b28faabc359b9ad3ff4e00bbdea88f5bdfa250f391fedd28182b2e37b55d429c0151a42a98ea7a5821818cd15a79fef9903e8607a88304cf3e0317bf86ec96e32e1381535a6582251e5a6eed40b5a3ed82bc444598b1269cce57a7")]
[assembly: .(@", PublicKey=0024000004800000940000000602000000240000525341310004000001000100698a70398fa0b2230c5a72e3bd9d56b48f809f6173e49a19fbb942d621be93ad48c5566b47b28faabc359b9ad3ff4e00bbdea88f5bdfa250f391fedd28182b2e37b55d429c0151a42a98ea7a5821818cd15a79fef9903e8607a88304cf3e0317bf86ec96e32e1381535a6582251e5a6eed40b5a3ed82bc444598b1269cce57a7")]
[assembly: .(@".Microsoft, PublicKey=0024000004800000940000000602000000240000525341310004000001000100698a70398fa0b2230c5a72e3bd9d56b48f809f6173e49a19fbb942d621be93ad48c5566b47b28faabc359b9ad3ff4e00bbdea88f5bdfa250f391fedd28182b2e37b55d429c0151a42a98ea7a5821818cd15a79fef9903e8607a88304cf3e0317bf86ec96e32e1381535a6582251e5a6eed40b5a3ed82bc444598b1269cce57a7")]
[assembly: .(@", PublicKey=0024000004800000940000000602000000240000525341310004000001000100698a70398fa0b2230c5a72e3bd9d56b48f809f6173e49a19fbb942d621be93ad48c5566b47b28faabc359b9ad3ff4e00bbdea88f5bdfa250f391fedd28182b2e37b55d429c0151a42a98ea7a5821818cd15a79fef9903e8607a88304cf3e0317bf86ec96e32e1381535a6582251e5a6eed40b5a3ed82bc444598b1269cce57a7")]
[assembly: .(".NETCoreApp,Version=v8.0", FrameworkDisplayName=".NET 8.0")]
namespace 
{
    public abstract class AbstractDynamicTest
    {
        protected AbstractDynamicTest() { }
        public int DynamicTestIndex { get; set; }
        public abstract .<.DiscoveryResult> GetTests();
    }
    public abstract class AbstractDynamicTest<[.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..NonPublicConstructors | ..PublicMethods | ..NonPublicMethods | ..PublicFields | ..NonPublicFields | ..PublicProperties)]  T> : .AbstractDynamicTest
        where T :  class
    {
        protected AbstractDynamicTest() { }
    }
    [.DebuggerDisplay("{.Name}.{}")]
    public abstract class AbstractExecutableTest
    {
        protected AbstractExecutableTest() { }
        public required object?[] Arguments { get; init; }
        public object?[] ClassArguments { get; init; }
        public . CompletionTask { get; }
        public required .TestContext Context { get; init; }
        public .ResolvedDependency[] Dependencies { get; set; }
        public ? Duration { get; }
        public ? EndTime { get; set; }
        public .? ExecutionContext { get; set; }
        public .? ExecutionTask { get; }
        public .TestMetadata Metadata { get; init; }
        public .TestResult? Result { get; set; }
        public ? StartTime { get; set; }
        public .TestState State { get; set; }
        public required string TestId { get; init; }
        public abstract .<object> CreateInstanceAsync();
        public abstract . InvokeTestAsync(object instance, .CancellationToken cancellationToken);
        public void SetResult(.TestState state, ? exception = null) { }
    }
    [(.Method)]
    public sealed class AfterAttribute : .HookAttribute
    {
        public AfterAttribute(.HookType hookType, [.] string file = "", [.] int line = 0) { }
    }
    [(.Method)]
    public sealed class AfterEveryAttribute : .HookAttribute
    {
        public AfterEveryAttribute(.HookType hookType, [.] string file = "", [.] int line = 0) { }
    }
    public abstract class ArgumentDisplayFormatter
    {
        protected ArgumentDisplayFormatter() { }
        public abstract bool CanHandle(object? value);
        public abstract string FormatValue(object? value);
    }
    public abstract class ArgumentDisplayFormatterAttribute : .TUnitAttribute, ., .
    {
        protected ArgumentDisplayFormatterAttribute() { }
        public abstract .ArgumentDisplayFormatter Formatter { get; }
        public virtual int Order { get; }
        public . OnTestDiscovered(.DiscoveredTestContext context) { }
    }
    [(.Assembly | .Class | .Method, AllowMultiple=true)]
    public class ArgumentDisplayFormatterAttribute<T> : .ArgumentDisplayFormatterAttribute
        where T : .ArgumentDisplayFormatter, new ()
    {
        public ArgumentDisplayFormatterAttribute() { }
        public override .ArgumentDisplayFormatter Formatter { get; }
    }
    [(.Class | .Method | .Property | .Parameter, AllowMultiple=true)]
    public sealed class ArgumentsAttribute : , .IDataSourceAttribute, ., .
    {
        public ArgumentsAttribute(params object?[]? values) { }
        public string[]? Categories { get; set; }
        public string? DisplayName { get; set; }
        public int Order { get; }
        public string? Skip { get; set; }
        public bool SkipIfEmpty { get; set; }
        public object?[] Values { get; }
        [.(typeof(.ArgumentsAttribute.<GetDataRowsAsync>d__20))]
        public .<<.<object?[]?>>> GetDataRowsAsync(.DataGeneratorMetadata dataGeneratorMetadata) { }
        public . OnTestRegistered(.TestRegisteredContext context) { }
    }
    [(.Class | .Method | .Property | .Parameter, AllowMultiple=true)]
    public sealed class ArgumentsAttribute<T> : .TypedDataSourceAttribute<T>, ., .
    {
        public ArgumentsAttribute(T value) { }
        public string[]? Categories { get; set; }
        public string? DisplayName { get; set; }
        public int Order { get; }
        public string? Skip { get; set; }
        public override bool SkipIfEmpty { get; set; }
        [.(typeof(.ArgumentsAttribute<T>.<GetTypedDataRowsAsync>d__18))]
        public override .<<.<T>>> GetTypedDataRowsAsync(.DataGeneratorMetadata dataGeneratorMetadata) { }
        public . OnTestRegistered(.TestRegisteredContext context) { }
    }
    public class Artifact
    {
        public Artifact() { }
        public string? Description { get; init; }
        public required string DisplayName { get; init; }
        public required .FileInfo File { get; init; }
    }
    [.DebuggerDisplay("{().Name}")]
    public class AssemblyHookContext : .Context
    {
        public .<.TestContext> AllTests { get; }
        public required .Assembly Assembly { get; init; }
        public .<.ClassHookContext> TestClasses { get; }
        public int TestCount { get; }
        public .TestSessionContext TestSessionContext { get; }
        public new static .AssemblyHookContext? Current { get; }
        public void AddClass(.ClassHookContext classHookContext) { }
    }
    [.DebuggerDisplay("{Name})")]
    public class AssemblyMetadata : <.AssemblyMetadata>
    {
        public AssemblyMetadata() { }
        public required string Name { get; init; }
        public virtual bool Equals(.AssemblyMetadata? other) { }
        public override int GetHashCode() { }
        public static .AssemblyMetadata GetOrAdd(string name, <.AssemblyMetadata> factory) { }
    }
    public static class AsyncConvert
    {
        public static . Convert( action) { }
        public static . Convert(<.> action) { }
        public static . Convert(<.> action) { }
        public static . ConvertObject(object? invoke) { }
        [.("Trimming", "IL2075:\'this\' argument does not satisfy \'DynamicallyAccessedMembersAttribute\' in " +
            "call to target method. The return value of the source method does not have match" +
            "ing annotations.")]
        public static bool TryGetAwaitableTask(object awaitable, [.(true)] out .? task) { }
    }
    [(.Class | .Method | .Property, AllowMultiple=true)]
    public abstract class AsyncDataSourceGeneratorAttribute<[.(..PublicConstructors)]  T> : .TypedDataSourceAttribute<T>
    {
        protected AsyncDataSourceGeneratorAttribute() { }
        protected abstract .<<.<T>>> GenerateDataSourcesAsync(.DataGeneratorMetadata dataGeneratorMetadata);
        [.(typeof(.AsyncDataSourceGeneratorAttribute<T>.<GetTypedDataRowsAsync>d__1))]
        public override sealed .<<.<T>>> GetTypedDataRowsAsync(.DataGeneratorMetadata dataGeneratorMetadata) { }
    }
    [(.Class | .Method, AllowMultiple=true)]
    public abstract class AsyncDataSourceGeneratorAttribute<[.(..PublicConstructors)]  T1, [.(..PublicConstructors)]  T2> : .TypedDataSourceAttribute<<T1, T2>>
    {
        protected AsyncDataSourceGeneratorAttribute() { }
        protected abstract .<<.<<T1, T2>>>> GenerateDataSourcesAsync(.DataGeneratorMetadata dataGeneratorMetadata);
        [.(typeof(.AsyncDataSourceGeneratorAttribute<T1, T2>.<GetTypedDataRowsAsync>d__1))]
        public override sealed .<<.<<T1, T2>>>> GetTypedDataRowsAsync(.DataGeneratorMetadata dataGeneratorMetadata) { }
    }
    [(.Class | .Method, AllowMultiple=true)]
    public abstract class AsyncDataSourceGeneratorAttribute<[.(..PublicConstructors)]  T1, [.(..PublicConstructors)]  T2, [.(..PublicConstructors)]  T3> : .TypedDataSourceAttribute<<T1, T2, T3>>
    {
        protected AsyncDataSourceGeneratorAttribute() { }
        protected abstract .<<.<<T1, T2, T3>>>> GenerateDataSourcesAsync(.DataGeneratorMetadata dataGeneratorMetadata);
        [.(typeof(.AsyncDataSourceGeneratorAttribute<T1, T2, T3>.<GetTypedDataRowsAsync>d__1))]
        public override sealed .<<.<<T1, T2, T3>>>> GetTypedDataRowsAsync(.DataGeneratorMetadata dataGeneratorMetadata) { }
    }
    [(.Class | .Method, AllowMultiple=true)]
    public abstract class AsyncDataSourceGeneratorAttribute<[.(..PublicConstructors)]  T1, [.(..PublicConstructors)]  T2, [.(..PublicConstructors)]  T3, [.(..PublicConstructors)]  T4> : .TypedDataSourceAttribute<<T1, T2, T3, T4>>
    {
        protected AsyncDataSourceGeneratorAttribute() { }
        protected abstract .<<.<<T1, T2, T3, T4>>>> GenerateDataSourcesAsync(.DataGeneratorMetadata dataGeneratorMetadata);
        [.(typeof(.AsyncDataSourceGeneratorAttribute<T1, T2, T3, T4>.<GetTypedDataRowsAsync>d__1))]
        public override .<<.<<T1, T2, T3, T4>>>> GetTypedDataRowsAsync(.DataGeneratorMetadata dataGeneratorMetadata) { }
    }
    [(.Class | .Method, AllowMultiple=true)]
    public abstract class AsyncDataSourceGeneratorAttribute<[.(..PublicConstructors)]  T1, [.(..PublicConstructors)]  T2, [.(..PublicConstructors)]  T3, [.(..PublicConstructors)]  T4, [.(..PublicConstructors)]  T5> : .TypedDataSourceAttribute<<T1, T2, T3, T4, T5>>
    {
        protected AsyncDataSourceGeneratorAttribute() { }
        protected abstract .<<.<<T1, T2, T3, T4, T5>>>> GenerateDataSourcesAsync(.DataGeneratorMetadata dataGeneratorMetadata);
        [.(typeof(.AsyncDataSourceGeneratorAttribute<T1, T2, T3, T4, T5>.<GetTypedDataRowsAsync>d__1))]
        public override .<<.<<T1, T2, T3, T4, T5>>>> GetTypedDataRowsAsync(.DataGeneratorMetadata dataGeneratorMetadata) { }
    }
    public class AsyncEvent<TEventArgs>
    {
        public AsyncEvent() { }
        public .<.AsyncEvent<TEventArgs>.Invocation> InvocationList { get; }
        public void Add(<object, TEventArgs, .> callback, int order = 1073741823) { }
        public void AddAt(<object, TEventArgs, .> callback, int index, int order = 1073741823) { }
        public .AsyncEvent<TEventArgs> InsertAtFront(<object, TEventArgs, .> callback) { }
        public static .AsyncEvent<TEventArgs> operator +(.AsyncEvent<TEventArgs>? e, <object, TEventArgs, .> callback) { }
        public class Invocation : .
        {
            public Invocation(<object, TEventArgs, .> factory, int order) { }
            public int Order { get; }
            public . InvokeAsync(object sender, TEventArgs eventArgs) { }
        }
    }
    [(.Class | .Method | .Property, AllowMultiple=true)]
    public abstract class AsyncUntypedDataSourceGeneratorAttribute : , .IDataSourceAttribute
    {
        protected AsyncUntypedDataSourceGeneratorAttribute() { }
        public virtual bool SkipIfEmpty { get; set; }
        [.(typeof(.AsyncUntypedDataSourceGeneratorAttribute.<GenerateAsync>d__5))]
        public .<<.<object?[]?>>> GenerateAsync(.DataGeneratorMetadata dataGeneratorMetadata) { }
        protected abstract .<<.<object?[]?>>> GenerateDataSourcesAsync(.DataGeneratorMetadata dataGeneratorMetadata);
        public .<<.<object?[]?>>> GetDataRowsAsync(.DataGeneratorMetadata dataGeneratorMetadata) { }
    }
    [(.Method)]
    public abstract class BaseTestAttribute : .TUnitAttribute
    {
        public readonly string File;
        public readonly int Line;
    }
    [(.Method)]
    public sealed class BeforeAttribute : .HookAttribute
    {
        public BeforeAttribute(.HookType hookType, [.] string file = "", [.] int line = 0) { }
    }
    [(.Method)]
    public sealed class BeforeEveryAttribute : .HookAttribute
    {
        public BeforeEveryAttribute(.HookType hookType, [.] string file = "", [.] int line = 0) { }
    }
    public class BeforeTestDiscoveryContext : .Context
    {
        public .GlobalContext GlobalContext { get; }
        public required string? TestFilter { get; init; }
        public new static .BeforeTestDiscoveryContext? Current { get; }
    }
    [(.Assembly | .Class | .Method, AllowMultiple=true)]
    public class CategoryAttribute : .TUnitAttribute, ., .
    {
        public CategoryAttribute(string category) { }
        public string Category { get; }
        public int Order { get; }
        public . OnTestDiscovered(.DiscoveredTestContext context) { }
    }
    [(.Assembly | .Class)]
    public class ClassConstructorAttribute : .TUnitAttribute
    {
        public ClassConstructorAttribute([.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods | ..PublicProperties)]  classConstructorType) { }
        [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods | ..PublicProperties)]
        public  ClassConstructorType { get; init; }
    }
    [(.Assembly | .Class)]
    public sealed class ClassConstructorAttribute<[.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods | ..PublicProperties)]  T> : .ClassConstructorAttribute
        where T : ., new ()
    {
        public ClassConstructorAttribute() { }
    }
    public class ClassConstructorMetadata : <.ClassConstructorMetadata>
    {
        public ClassConstructorMetadata() { }
        public required .TestBuilderContext TestBuilderContext { get; init; }
        public required string TestSessionId { get; init; }
    }
    [(.Class | .Method | .Property | .Parameter, AllowMultiple=true)]
    public sealed class ClassDataSourceAttribute : .UntypedDataSourceGeneratorAttribute
    {
        public ClassDataSourceAttribute() { }
        [.("Trimming", "IL2026:Members annotated with \'RequiresUnreferencedCodeAttribute\' require dynamic" +
            " access otherwise can break functionality when trimming application code", Justification="Non-params constructor calls params one with proper annotations.")]
        public ClassDataSourceAttribute([.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..NonPublicConstructors | ..PublicProperties | ..NonPublicProperties)]  type) { }
        [.("Uses dynamically accessed types.")]
        public ClassDataSourceAttribute(params [] types) { }
        [.("Trimming", "IL2026:Members annotated with \'RequiresUnreferencedCodeAttribute\' require dynamic" +
            " access otherwise can break functionality when trimming application code", Justification="Non-params constructor calls params one with proper annotations.")]
        public ClassDataSourceAttribute([.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..NonPublicConstructors | ..PublicProperties | ..NonPublicProperties)]  type, [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..NonPublicConstructors | ..PublicProperties | ..NonPublicProperties)]  type2) { }
        [.("Trimming", "IL2026:Members annotated with \'RequiresUnreferencedCodeAttribute\' require dynamic" +
            " access otherwise can break functionality when trimming application code", Justification="Non-params constructor calls params one with proper annotations.")]
        public ClassDataSourceAttribute([.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..NonPublicConstructors | ..PublicProperties | ..NonPublicProperties)]  type, [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..NonPublicConstructors | ..PublicProperties | ..NonPublicProperties)]  type2, [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..NonPublicConstructors | ..PublicProperties | ..NonPublicProperties)]  type3) { }
        [.("Trimming", "IL2026:Members annotated with \'RequiresUnreferencedCodeAttribute\' require dynamic" +
            " access otherwise can break functionality when trimming application code", Justification="Non-params constructor calls params one with proper annotations.")]
        public ClassDataSourceAttribute([.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..NonPublicConstructors | ..PublicProperties | ..NonPublicProperties)]  type, [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..NonPublicConstructors | ..PublicProperties | ..NonPublicProperties)]  type2, [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..NonPublicConstructors | ..PublicProperties | ..NonPublicProperties)]  type3, [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..NonPublicConstructors | ..PublicProperties | ..NonPublicProperties)]  type4) { }
        [.("Trimming", "IL2026:Members annotated with \'RequiresUnreferencedCodeAttribute\' require dynamic" +
            " access otherwise can break functionality when trimming application code", Justification="Non-params constructor calls params one with proper annotations.")]
        public ClassDataSourceAttribute([.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..NonPublicConstructors | ..PublicProperties | ..NonPublicProperties)]  type, [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..NonPublicConstructors | ..PublicProperties | ..NonPublicProperties)]  type2, [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..NonPublicConstructors | ..PublicProperties | ..NonPublicProperties)]  type3, [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..NonPublicConstructors | ..PublicProperties | ..NonPublicProperties)]  type4, [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..NonPublicConstructors | ..PublicProperties | ..NonPublicProperties)]  type5) { }
        public string[] Keys { get; set; }
        public .SharedType[] Shared { get; set; }
        [.("Trimming", "IL2062:The parameter of method has a DynamicallyAccessedMembersAttribute, but the" +
            " value passed to it can not be statically analyzed.", Justification="Constructor parameter is annotated with DynamicallyAccessedMembers, so _types ele" +
            "ments have the required annotations.")]
        protected override .<<object?[]?>> GenerateDataSources(.DataGeneratorMetadata dataGeneratorMetadata) { }
        public .<string> GetKeys() { }
        public .<.SharedType> GetSharedTypes() { }
    }
    [(.Class | .Method | .Property | .Parameter, AllowMultiple=true)]
    public sealed class ClassDataSourceAttribute<[.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..NonPublicConstructors | ..PublicProperties | ..NonPublicProperties)]  T> : .DataSourceGeneratorAttribute<T>
    {
        public ClassDataSourceAttribute() { }
        public  ClassType { get; }
        public string Key { get; set; }
        public .SharedType Shared { get; set; }
        protected override .<<T>> GenerateDataSources(.DataGeneratorMetadata dataGeneratorMetadata) { }
        public .<string> GetKeys() { }
        public .<.SharedType> GetSharedTypes() { }
    }
    [(.Class | .Method, AllowMultiple=true)]
    public sealed class ClassDataSourceAttribute<[.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..NonPublicConstructors | ..PublicProperties | ..NonPublicProperties)]  T1, [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..NonPublicConstructors | ..PublicProperties | ..NonPublicProperties)]  T2> : .DataSourceGeneratorAttribute<T1, T2>
        where T1 : new()
        where T2 : new()
    {
        public ClassDataSourceAttribute() { }
        public string[] Keys { get; set; }
        public .SharedType[] Shared { get; set; }
        protected override .<<<T1, T2>>> GenerateDataSources(.DataGeneratorMetadata dataGeneratorMetadata) { }
        public .<string> GetKeys() { }
        public .<.SharedType> GetSharedTypes() { }
    }
    [(.Class | .Method, AllowMultiple=true)]
    public sealed class ClassDataSourceAttribute<[.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..NonPublicConstructors | ..PublicProperties | ..NonPublicProperties)]  T1, [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..NonPublicConstructors | ..PublicProperties | ..NonPublicProperties)]  T2, [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..NonPublicConstructors | ..PublicProperties | ..NonPublicProperties)]  T3> : .DataSourceGeneratorAttribute<T1, T2, T3>
        where T1 : new()
        where T2 : new()
        where T3 : new()
    {
        public ClassDataSourceAttribute() { }
        public string[] Keys { get; set; }
        public .SharedType[] Shared { get; set; }
        protected override .<<<T1, T2, T3>>> GenerateDataSources(.DataGeneratorMetadata dataGeneratorMetadata) { }
        public .<string> GetKeys() { }
        public .<.SharedType> GetSharedTypes() { }
    }
    [(.Class | .Method, AllowMultiple=true)]
    public sealed class ClassDataSourceAttribute<[.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..NonPublicConstructors | ..PublicProperties | ..NonPublicProperties)]  T1, [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..NonPublicConstructors | ..PublicProperties | ..NonPublicProperties)]  T2, [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..NonPublicConstructors | ..PublicProperties | ..NonPublicProperties)]  T3, [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..NonPublicConstructors | ..PublicProperties | ..NonPublicProperties)]  T4> : .DataSourceGeneratorAttribute<T1, T2, T3, T4>
        where T1 : new()
        where T2 : new()
        where T3 : new()
        where T4 : new()
    {
        public ClassDataSourceAttribute() { }
        public string[] Keys { get; set; }
        public .SharedType[] Shared { get; set; }
        protected override .<<<T1, T2, T3, T4>>> GenerateDataSources(.DataGeneratorMetadata dataGeneratorMetadata) { }
        public .<string> GetKeys() { }
        public .<.SharedType> GetSharedTypes() { }
    }
    [(.Class | .Method, AllowMultiple=true)]
    public sealed class ClassDataSourceAttribute<[.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..NonPublicConstructors | ..PublicProperties | ..NonPublicProperties)]  T1, [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..NonPublicConstructors | ..PublicProperties | ..NonPublicProperties)]  T2, [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..NonPublicConstructors | ..PublicProperties | ..NonPublicProperties)]  T3, [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..NonPublicConstructors | ..PublicProperties | ..NonPublicProperties)]  T4, [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..NonPublicConstructors | ..PublicProperties | ..NonPublicProperties)]  T5> : .DataSourceGeneratorAttribute<T1, T2, T3, T4, T5>
        where T1 : new()
        where T2 : new()
        where T3 : new()
        where T4 : new()
        where T5 : new()
    {
        public ClassDataSourceAttribute() { }
        public string[] Keys { get; set; }
        public .SharedType[] Shared { get; set; }
        protected override .<<<T1, T2, T3, T4, T5>>> GenerateDataSources(.DataGeneratorMetadata dataGeneratorMetadata) { }
        public .<string> GetKeys() { }
        public .<.SharedType> GetSharedTypes() { }
    }
    [.DebuggerDisplay("{}")]
    public class ClassHookContext : .Context
    {
        public .AssemblyHookContext AssemblyContext { get; }
        [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods | ..PublicProperties)]
        public required  ClassType { get; init; }
        public int TestCount { get; }
        public .<.TestContext> Tests { get; }
        public new static .ClassHookContext? Current { get; }
        public void AddTest(.TestContext testContext) { }
        public override bool Equals(object? obj) { }
        public override int GetHashCode() { }
    }
    [.DebuggerDisplay("{Type}")]
    public class ClassMetadata : <.ClassMetadata>, .IMemberMetadata
    {
        public ClassMetadata() { }
        public required .AssemblyMetadata Assembly { get; init; }
        public <object?[], object>? ConstructorFactory { get; init; }
        public bool HasRequiredProperties { get; init; }
        public []? ImplementedInterfaces { get; init; }
        public <object>? InitializeRequiredProperties { get; init; }
        public required string Name { get; init; }
        public required string? Namespace { get; init; }
        public <object>? ParameterlessFactory { get; init; }
        public required .ParameterMetadata[] Parameters { get; init; }
        public required .ClassMetadata? Parent { get; init; }
        public required .PropertyMetadata[] Properties { get; init; }
        public int TestConstructorIndex { get; init; }
        [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..NonPublicConstructors | ..PublicMethods | ..PublicProperties)]
        public required  Type { get; init; }
        public required .TypeInfo TypeInfo { get; init; }
        public virtual bool Equals(.ClassMetadata? other) { }
        public override int GetHashCode() { }
        public static .ClassMetadata GetOrAdd(string name, <.ClassMetadata> factory) { }
    }
    [(.Class | .Method)]
    public sealed class CombinedDataSourcesAttribute : .AsyncUntypedDataSourceGeneratorAttribute
    {
        public CombinedDataSourcesAttribute() { }
        [.(typeof(.CombinedDataSourcesAttribute.<GenerateDataSourcesAsync>d__0))]
        protected override .<<.<object?[]?>>> GenerateDataSourcesAsync(.DataGeneratorMetadata dataGeneratorMetadata) { }
    }
    public sealed class ConcreteType : .TypeInfo, <.ConcreteType>
    {
        public ConcreteType( Type) { }
        public  Type { get; init; }
        public override string ToString() { }
    }
    public sealed class ConstructedGeneric : .TypeInfo, <.ConstructedGeneric>
    {
        public ConstructedGeneric( GenericDefinition, .TypeInfo[] TypeArguments) { }
        public  GenericDefinition { get; init; }
        public .TypeInfo[] TypeArguments { get; init; }
        public override string ToString() { }
    }
    public abstract class Context : , .
    {
        public .TextWriter ErrorOutputWriter { get; }
        public .TextWriter OutputWriter { get; }
        protected .Context? Parent { get; }
        public static .Context Current { get; }
        public void AddAsyncLocalValues() { }
        public void Dispose() { }
        public . GetDefaultLogger() { }
        public virtual string GetErrorOutput() { }
        public virtual string GetStandardOutput() { }
        public void RestoreExecutionContext() { }
    }
    public class ContextProvider : .
    {
        public ContextProvider( serviceProvider, string testSessionId, string? testFilter) { }
        public .BeforeTestDiscoveryContext BeforeTestDiscoveryContext { get; }
        public .GlobalContext GlobalContext { get; }
        public .TestDiscoveryContext TestDiscoveryContext { get; }
        public .TestSessionContext TestSessionContext { get; }
        public .TestContext CreateTestContext(string testName, [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods | ..PublicProperties)]  classType, .TestBuilderContext testBuilderContext, .CancellationToken cancellationToken) { }
        public .AssemblyHookContext GetOrCreateAssemblyContext(.Assembly assembly) { }
        [.("Trimming", "IL2111", Justification="Type parameter is annotated at the method boundary.")]
        public .ClassHookContext GetOrCreateClassContext([.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods | ..PublicProperties)]  classType) { }
    }
    public class CultureExecutor : .DedicatedThreadExecutor
    {
        public CultureExecutor(.CultureInfo cultureInfo) { }
        protected override void ConfigureThread(.Thread thread) { }
    }
    public class DataGenerationException : 
    {
        public DataGenerationException(string message) { }
        public DataGenerationException(string message,  innerException) { }
        public DataGenerationException(string message, object? dataSource) { }
        public DataGenerationException(string message, object? dataSource,  innerException) { }
        public object? DataSource { get; }
        public string? DataSourceTypeName { get; }
        public string? TestClassName { get; }
        public string? TestMethodName { get; }
        public override string ToString() { }
        public .DataGenerationException WithTestContext(string? className, string? methodName) { }
    }
    public class DataGeneratorMetadata : <.DataGeneratorMetadata>
    {
        public DataGeneratorMetadata() { }
        public required object?[]? ClassInstanceArguments { get; init; }
        public <, .<object?>>? InstanceFactory { get; init; }
        public required .IMemberMetadata[] MembersToGenerate { get; init; }
        public required .TestBuilderContextAccessor TestBuilderContext { get; init; }
        public required object? TestClassInstance { get; init; }
        public required .MethodMetadata? TestInformation { get; init; }
        public required string TestSessionId { get; init; }
        public required . Type { get; init; }
    }
    public sealed class DataSourceContext
    {
        public DataSourceContext( testClassType, .DataSourceLevel level, .MemberInfo? targetMember = null, .ParameterInfo? targetParameter = null, .<>? attributes = null, ? serviceProvider = null) { }
        public .<> Attributes { get; }
        public .DataSourceLevel Level { get; }
        public ? ServiceProvider { get; }
        public .MemberInfo? TargetMember { get; }
        public .ParameterInfo? TargetParameter { get; }
        public  TestClassType { get; }
    }
    public class DataSourceException : .TestBuilderException
    {
        public DataSourceException(string dataSourceName,  innerException) { }
        public DataSourceException(string dataSourceName, string message) { }
        public string DataSourceName { get; }
        public static .DataSourceException FromNestedFailure(string message,  innerException) { }
    }
    [(.Class | .Method | .Property | .Parameter, AllowMultiple=true)]
    public abstract class DataSourceGeneratorAttribute<[.(..PublicConstructors)]  T> : .AsyncDataSourceGeneratorAttribute<T>
    {
        protected DataSourceGeneratorAttribute() { }
        protected abstract .<<T>> GenerateDataSources(.DataGeneratorMetadata dataGeneratorMetadata);
        [.(typeof(.DataSourceGeneratorAttribute<T>.<GenerateDataSourcesAsync>d__1))]
        protected override .<<.<T>>> GenerateDataSourcesAsync(.DataGeneratorMetadata dataGeneratorMetadata) { }
    }
    [(.Class | .Method | .Parameter, AllowMultiple=true)]
    public abstract class DataSourceGeneratorAttribute<[.(..PublicConstructors)]  T1, [.(..PublicConstructors)]  T2> : .AsyncDataSourceGeneratorAttribute<T1, T2>
    {
        protected DataSourceGeneratorAttribute() { }
        protected abstract .<<<T1, T2>>> GenerateDataSources(.DataGeneratorMetadata dataGeneratorMetadata);
        [.(typeof(.DataSourceGeneratorAttribute<T1, T2>.<GenerateDataSourcesAsync>d__1))]
        protected override .<<.<<T1, T2>>>> GenerateDataSourcesAsync(.DataGeneratorMetadata dataGeneratorMetadata) { }
    }
    [(.Class | .Method | .Parameter, AllowMultiple=true)]
    public abstract class DataSourceGeneratorAttribute<[.(..PublicConstructors)]  T1, [.(..PublicConstructors)]  T2, [.(..PublicConstructors)]  T3> : .AsyncDataSourceGeneratorAttribute<T1, T2, T3>
    {
        protected DataSourceGeneratorAttribute() { }
        protected abstract .<<<T1, T2, T3>>> GenerateDataSources(.DataGeneratorMetadata dataGeneratorMetadata);
        [.(typeof(.DataSourceGeneratorAttribute<T1, T2, T3>.<GenerateDataSourcesAsync>d__1))]
        protected override sealed .<<.<<T1, T2, T3>>>> GenerateDataSourcesAsync(.DataGeneratorMetadata dataGeneratorMetadata) { }
    }
    [(.Class | .Method | .Parameter, AllowMultiple=true)]
    public abstract class DataSourceGeneratorAttribute<[.(..PublicConstructors)]  T1, [.(..PublicConstructors)]  T2, [.(..PublicConstructors)]  T3, [.(..PublicConstructors)]  T4> : .AsyncDataSourceGeneratorAttribute<T1, T2, T3, T4>
    {
        protected DataSourceGeneratorAttribute() { }
        protected abstract .<<<T1, T2, T3, T4>>> GenerateDataSources(.DataGeneratorMetadata dataGeneratorMetadata);
        [.(typeof(.DataSourceGeneratorAttribute<T1, T2, T3, T4>.<GenerateDataSourcesAsync>d__1))]
        protected override .<<.<<T1, T2, T3, T4>>>> GenerateDataSourcesAsync(.DataGeneratorMetadata dataGeneratorMetadata) { }
    }
    [(.Class | .Method | .Parameter, AllowMultiple=true)]
    public abstract class DataSourceGeneratorAttribute<[.(..PublicConstructors)]  T1, [.(..PublicConstructors)]  T2, [.(..PublicConstructors)]  T3, [.(..PublicConstructors)]  T4, [.(..PublicConstructors)]  T5> : .AsyncDataSourceGeneratorAttribute<T1, T2, T3, T4, T5>
    {
        protected DataSourceGeneratorAttribute() { }
        protected abstract .<<<T1, T2, T3, T4, T5>>> GenerateDataSources(.DataGeneratorMetadata dataGeneratorMetadata);
        [.(typeof(.DataSourceGeneratorAttribute<T1, T2, T3, T4, T5>.<GenerateDataSourcesAsync>d__1))]
        protected override .<<.<<T1, T2, T3, T4, T5>>>> GenerateDataSourcesAsync(.DataGeneratorMetadata dataGeneratorMetadata) { }
    }
    public enum DataSourceLevel
    {
        Class = 0,
        Method = 1,
        Property = 2,
        Parameter = 3,
    }
    public class DedicatedThreadExecutor : .GenericAbstractExecutor, ., .
    {
        public DedicatedThreadExecutor() { }
        protected virtual void CleanUp() { }
        protected virtual void ConfigureThread(.Thread thread) { }
        protected override sealed . ExecuteAsync(<.> action) { }
        protected virtual void Initialize() { }
        public . OnTestRegistered(.TestRegisteredContext context) { }
    }
    public class DefaultExecutor : .GenericAbstractExecutor
    {
        public static readonly .DefaultExecutor Instance;
        protected override . ExecuteAsync(<.> action) { }
    }
    public static class Defaults
    {
        public static readonly  ForcefulExitTimeout;
        public static readonly  HookTimeout;
        public static readonly  ProcessExitHookDelay;
        public static readonly  TestTimeout;
    }
    public abstract class DependencyInjectionDataSourceAttribute<TScope> : .UntypedDataSourceGeneratorAttribute
    {
        protected DependencyInjectionDataSourceAttribute() { }
        public abstract object? Create(TScope scope,  type);
        public abstract TScope CreateScope(.DataGeneratorMetadata dataGeneratorMetadata);
        protected override .<<object?[]?>> GenerateDataSources(.DataGeneratorMetadata dataGeneratorMetadata) { }
    }
    [(.Class | .Method, AllowMultiple=true)]
    public class DependsOnAttribute : .TUnitAttribute
    {
        public DependsOnAttribute( testClass) { }
        public DependsOnAttribute(string testName) { }
        public DependsOnAttribute( testClass, string testName) { }
        public DependsOnAttribute(string testName, [] parameterTypes) { }
        public DependsOnAttribute( testClass, string testName, [] parameterTypes) { }
        public ? ClassMetadata { get; }
        public []? ParameterTypes { get; }
        public bool ProceedOnFailure { get; set; }
        public string? TestName { get; }
        public override string ToString() { }
        public .TestDependency ToTestDependency() { }
    }
    [(.Class | .Method, AllowMultiple=true)]
    public class DependsOnAttribute<T> : .DependsOnAttribute
    {
        public DependsOnAttribute() { }
        public DependsOnAttribute(string testName) { }
        public DependsOnAttribute(string testName, [] parameterTypes) { }
    }
    public abstract class DiscoveredTest
    {
        protected DiscoveredTest() { }
        public required .TestContext TestContext { get; init; }
        public .TestDetails TestDetails { get; }
        public .? TestExecutor { get; set; }
    }
    public class DiscoveredTestContext
    {
        public DiscoveredTestContext(string testName, .TestContext testContext) { }
        public .<<object?, string?>> ArgumentDisplayFormatters { get; }
        public .TestContext TestContext { get; }
        public .TestDetails TestDetails { get; }
        public string TestName { get; }
        public void AddArgumentDisplayFormatter(.ArgumentDisplayFormatter formatter) { }
        public void AddCategory(string category) { }
        public void AddParallelConstraint(. constraint) { }
        public void AddProperty(string key, string value) { }
        public string GetDisplayName() { }
        public void SetDisplayName(string displayName) { }
        public void SetDisplayNameFormatter( formatterType) { }
        public void SetPriority(. priority) { }
        public void SetRetryBackoff(int backoffMs, double backoffMultiplier) { }
        public void SetRetryLimit(int retryLimit) { }
        public void SetRetryLimit(int retryCount, <.TestContext, , int, .<bool>> shouldRetry) { }
    }
    public class DiscoveredTest<T> : .DiscoveredTest
        where T :  class
    {
        public DiscoveredTest() { }
    }
    public sealed class DiscoveryFailure : <.DiscoveryFailure>
    {
        public DiscoveryFailure() { }
        public required  Exception { get; init; }
        public string Reason { get; }
        public string? TestClassName { get; init; }
        public required string TestFilePath { get; init; }
        public required string TestId { get; init; }
        public required int TestLineNumber { get; init; }
        public required string TestMethodName { get; init; }
    }
    public class DiscoveryResult
    {
        public DiscoveryResult() { }
        public static .DiscoveryResult Empty { get; }
    }
    [(.Class | .Method, Inherited=false)]
    public sealed class DisplayNameAttribute : .DisplayNameFormatterAttribute, .IScopedAttribute
    {
        public DisplayNameAttribute(string displayName) { }
        public  ScopeType { get; }
        protected override string FormatDisplayName(.DiscoveredTestContext context) { }
    }
    [(.Assembly | .Class | .Method, Inherited=false)]
    public abstract class DisplayNameFormatterAttribute : .TUnitAttribute, ., .
    {
        protected DisplayNameFormatterAttribute() { }
        public int Order { get; }
        protected abstract string FormatDisplayName(.DiscoveredTestContext context);
        public . OnTestDiscovered(.DiscoveredTestContext context) { }
    }
    public class DynamicDiscoveryResult : .DiscoveryResult
    {
        public DynamicDiscoveryResult() { }
        public .<> Attributes { get; set; }
        public string? CreatorFilePath { get; set; }
        public int? CreatorLineNumber { get; set; }
        public string? DisplayName { get; set; }
        public int DynamicTestIndex { get; set; }
        public string? ParentTestId { get; set; }
        public .<string, object?>? Properties { get; set; }
        public .? Relationship { get; set; }
        public object?[]? TestClassArguments { get; set; }
        [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..NonPublicConstructors | ..PublicMethods | ..NonPublicMethods | ..PublicFields | ..NonPublicFields | ..PublicProperties)]
        public ? TestClassType { get; set; }
        public .? TestMethod { get; set; }
        public object?[]? TestMethodArguments { get; set; }
    }
    public class DynamicTestBuilderAttribute : .BaseTestAttribute
    {
        public DynamicTestBuilderAttribute([.] string file = "", [.] int line = 0) { }
    }
    public class DynamicTestBuilderContext
    {
        public DynamicTestBuilderContext(string filePath, int lineNumber) { }
        public string FilePath { get; }
        public int LineNumber { get; }
        public .<.AbstractDynamicTest> Tests { get; }
        [.("Adding dynamic tests requires reflection which is not supported in native AOT sce" +
            "narios.")]
        public void AddTest(.AbstractDynamicTest test) { }
    }
    public static class DynamicTestHelper
    {
        public static T Argument<T>() { }
    }
    public sealed class DynamicTestMetadata : .TestMetadata, .IDynamicTestMetadata
    {
        public DynamicTestMetadata(.DynamicDiscoveryResult dynamicResult) { }
        public override <.ExecutableTestCreationContext, .TestMetadata, .AbstractExecutableTest> CreateExecutableTestFactory { get; }
        public string? DisplayName { get; }
        public int DynamicTestIndex { get; }
        public string? ParentTestId { get; }
        public .<string, object?>? Properties { get; }
        public .? Relationship { get; }
    }
    public class DynamicTest<[.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..NonPublicConstructors | ..PublicMethods | ..NonPublicMethods | ..PublicFields | ..NonPublicFields | ..PublicProperties)]  T> : .AbstractDynamicTest<T>, .IDynamicTestCreatorLocation
        where T :  class
    {
        public DynamicTest() { }
        public .<> Attributes { get; set; }
        public string? CreatorFilePath { get; set; }
        public int? CreatorLineNumber { get; set; }
        public string? DisplayName { get; set; }
        public object?[]? TestClassArguments { get; set; }
        public .<<T>>? TestMethod { get; set; }
        public object?[]? TestMethodArguments { get; set; }
        public override .<.DiscoveryResult> GetTests() { }
    }
    public class EngineCancellationToken : 
    {
        public EngineCancellationToken() { }
        public .CancellationToken Token { get; }
        public void Dispose() { }
    }
    public sealed class ExcludeOnAttribute : .SkipAttribute
    {
        public ExcludeOnAttribute(. OperatingSystem) { }
        public override .<bool> ShouldSkip(.TestRegisteredContext context) { }
    }
    public sealed class ExecutableTest : .AbstractExecutableTest
    {
        public ExecutableTest(<.TestContext, .<object>> createInstance, <object, object?[], .TestContext, .CancellationToken, .> invokeTest) { }
        public override .<object> CreateInstanceAsync() { }
        public override . InvokeTestAsync(object instance, .CancellationToken cancellationToken) { }
    }
    public sealed class ExecutableTestCreationContext
    {
        public ExecutableTestCreationContext() { }
        public required object?[] Arguments { get; init; }
        public required object?[] ClassArguments { get; init; }
        public required .TestContext Context { get; init; }
        public required string DisplayName { get; init; }
        public [] ResolvedClassGenericArguments { get; init; }
        public [] ResolvedMethodGenericArguments { get; init; }
        public <.<object>>? TestClassInstanceFactory { get; init; }
        public required string TestId { get; init; }
    }
    [(.Assembly | .Class | .Method)]
    public class ExecutionPriorityAttribute : .SingleTUnitAttribute, .IScopedAttribute, ., .
    {
        public ExecutionPriorityAttribute(. priority = 2) { }
        public int Order { get; }
        public . Priority { get; }
        public  ScopeType { get; }
        public . OnTestDiscovered(.DiscoveredTestContext context) { }
    }
    public class ExpandedTest
    {
        public ExpandedTest() { }
        public object?[]? ClassArguments { get; init; }
        public bool IsSkipped { get; init; }
        public object?[]? MethodArguments { get; init; }
        public required .MethodMetadata MethodMetadata { get; init; }
        public .<string, object?>? PropertyValues { get; init; }
        public string? SkipReason { get; init; }
        public required string TestFilePath { get; init; }
        public required string TestId { get; init; }
        public required object TestInstance { get; init; }
        public required int TestLineNumber { get; init; }
        public required .MethodInfo TestMethod { get; init; }
        public required string TestName { get; init; }
        public ? Timeout { get; init; }
    }
    [(.Class | .Method)]
    public sealed class ExplicitAttribute : .TUnitAttribute
    {
        public ExplicitAttribute([.] string callerFile = "", [.] string callerMemberName = "") { }
        public string For { get; }
    }
    public class FailedDynamicTest<[.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..NonPublicConstructors | ..PublicMethods | ..NonPublicMethods | ..PublicProperties)]  T> : .AbstractDynamicTest
        where T :  class
    {
        public FailedDynamicTest() { }
        public  Exception { get; set; }
        public string MethodName { get; set; }
        public string TestFilePath { get; set; }
        public string TestId { get; set; }
        public int TestLineNumber { get; set; }
        public override .<.DiscoveryResult> GetTests() { }
    }
    [(.Class | .Method, AllowMultiple=true)]
    public sealed class GenerateGenericTestAttribute : 
    {
        public GenerateGenericTestAttribute(params [] typeArguments) { }
        public [] TypeArguments { get; }
    }
    public abstract class GenericAbstractExecutor : ., .
    {
        protected GenericAbstractExecutor() { }
        public int Order { get; }
        public . ExecuteAfterAssemblyHook(.MethodMetadata hookMethodInfo, .AssemblyHookContext context, <.> action) { }
        public . ExecuteAfterClassHook(.MethodMetadata hookMethodInfo, .ClassHookContext context, <.> action) { }
        public . ExecuteAfterTestDiscoveryHook(.MethodMetadata hookMethodInfo, .TestDiscoveryContext context, <.> action) { }
        public . ExecuteAfterTestHook(.MethodMetadata hookMethodInfo, .TestContext context, <.> action) { }
        public . ExecuteAfterTestSessionHook(.MethodMetadata hookMethodInfo, .TestSessionContext context, <.> action) { }
        protected abstract . ExecuteAsync(<.> action);
        public . ExecuteBeforeAssemblyHook(.MethodMetadata hookMethodInfo, .AssemblyHookContext context, <.> action) { }
        public . ExecuteBeforeClassHook(.MethodMetadata hookMethodInfo, .ClassHookContext context, <.> action) { }
        public . ExecuteBeforeTestDiscoveryHook(.MethodMetadata hookMethodInfo, .BeforeTestDiscoveryContext context, <.> action) { }
        public . ExecuteBeforeTestHook(.MethodMetadata hookMethodInfo, .TestContext context, <.> action) { }
        public . ExecuteBeforeTestSessionHook(.MethodMetadata hookMethodInfo, .TestSessionContext context, <.> action) { }
        public . ExecuteTest(.TestContext context, <.> action) { }
    }
    public sealed class GenericMethodInfo
    {
        public GenericMethodInfo() { }
        public .GenericParameterConstraints[] Constraints { get; init; }
        public string[] ParameterNames { get; init; }
        public int[] ParameterPositions { get; init; }
    }
    public sealed class GenericParameter : .TypeInfo, <.GenericParameter>
    {
        public GenericParameter(int Position, bool IsMethodParameter, string? Name = null) { }
        public bool IsMethodParameter { get; init; }
        public string? Name { get; init; }
        public int Position { get; init; }
        public override string ToString() { }
    }
    public sealed class GenericParameterConstraints
    {
        public GenericParameterConstraints() { }
        public ? BaseTypeConstraint { get; init; }
        public bool HasDefaultConstructorConstraint { get; init; }
        public bool HasNotNullConstraint { get; init; }
        public bool HasReferenceTypeConstraint { get; init; }
        public bool HasValueTypeConstraint { get; init; }
        public [] InterfaceConstraints { get; init; }
        public required string ParameterName { get; init; }
    }
    public sealed class GenericTestMetadata : .TestMetadata
    {
        public GenericTestMetadata() { }
        public .<string, .TestMetadata>? ConcreteInstantiations { get; init; }
        public override <.ExecutableTestCreationContext, .TestMetadata, .AbstractExecutableTest> CreateExecutableTestFactory { get; }
    }
    public sealed class GenericTypeInfo
    {
        public GenericTypeInfo() { }
        public .GenericParameterConstraints[] Constraints { get; init; }
        public string[] ParameterNames { get; init; }
    }
    public class GlobalContext : .Context
    {
        public . GlobalLogger { get; }
        public .TextWriter OriginalConsoleError { get; set; }
        public .TextWriter OriginalConsoleOut { get; set; }
        public string? TestFilter { get; }
        public new static .GlobalContext Current { get; }
    }
    public class GlobalSharedDataKey : .SharedDataKey, <.GlobalSharedDataKey>
    {
        public static readonly  RandomKey;
        public GlobalSharedDataKey( Type) { }
    }
    public class HookAttribute : .TUnitAttribute
    {
        public string File { get; }
        public .HookType HookType { get; }
        public int Line { get; }
        public int Order { get; init; }
    }
    public class HookRegisteredContext
    {
        public HookRegisteredContext(. hookMethod) { }
        public . HookMethod { get; }
        public string HookName { get; }
        public ? Timeout { get; set; }
    }
    public static class HookRegistrationIndices
    {
        public static int GetNextAfterAssemblyHookIndex() { }
        public static int GetNextAfterClassHookIndex() { }
        public static int GetNextAfterEveryAssemblyHookIndex() { }
        public static int GetNextAfterEveryClassHookIndex() { }
        public static int GetNextAfterEveryTestHookIndex() { }
        public static int GetNextAfterTestDiscoveryHookIndex() { }
        public static int GetNextAfterTestHookIndex() { }
        public static int GetNextAfterTestSessionHookIndex() { }
        public static int GetNextBeforeAssemblyHookIndex() { }
        public static int GetNextBeforeClassHookIndex() { }
        public static int GetNextBeforeEveryAssemblyHookIndex() { }
        public static int GetNextBeforeEveryClassHookIndex() { }
        public static int GetNextBeforeEveryTestHookIndex() { }
        public static int GetNextBeforeTestDiscoveryHookIndex() { }
        public static int GetNextBeforeTestHookIndex() { }
        public static int GetNextBeforeTestSessionHookIndex() { }
    }
    public enum HookType
    {
        Test = 0,
        Class = 1,
        Assembly = 2,
        TestSession = 3,
        TestDiscovery = 4,
    }
    public interface IAccessesInstanceData { }
    public interface IDataSourceAttribute
    {
        bool SkipIfEmpty { get; set; }
        .<<.<object?[]?>>> GetDataRowsAsync(.DataGeneratorMetadata dataGeneratorMetadata);
    }
    public interface IDataSourceMemberAttribute { }
    public interface IDynamicTestCreatorLocation
    {
        string? CreatorFilePath { get; set; }
        int? CreatorLineNumber { get; set; }
    }
    public interface IDynamicTestMetadata
    {
        string? DisplayName { get; }
        int DynamicTestIndex { get; }
    }
    public interface IDynamicTestSource
    {
        .<.AbstractDynamicTest> CollectDynamicTests(string sessionId);
    }
    public interface IMemberMetadata
    {
        string Name { get; }
    }
    public interface IRequiresImmediateInitialization { }
    public interface IScopedAttribute
    {
         ScopeType { get; }
    }
    public interface ITestDefinition { }
    public interface ITypedDataSourceAttribute<T> : .IDataSourceAttribute
    {
        .<<.<T>>> GetTypedDataRowsAsync(.DataGeneratorMetadata dataGeneratorMetadata);
    }
    [(.Class)]
    public sealed class InheritsTestsAttribute : .TUnitAttribute
    {
        public InheritsTestsAttribute() { }
    }
    [(.Method | .Property, AllowMultiple=true)]
    public class InstanceMethodDataSourceAttribute : .MethodDataSourceAttribute, .IAccessesInstanceData
    {
        public InstanceMethodDataSourceAttribute(string methodNameProvidingDataSource) { }
        public InstanceMethodDataSourceAttribute([.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods | ..NonPublicMethods | ..PublicProperties)]  classProvidingDataSource, string methodNameProvidingDataSource) { }
    }
    public class InvalidTestMetadataException : .TestBuilderException
    {
        public InvalidTestMetadataException(string message, .TestMetadata metadata) { }
        public InvalidTestMetadataException(string message, .TestMetadata metadata,  innerException) { }
    }
    [(.Parameter)]
    public class MatrixAttribute : .TUnitAttribute, .IDataSourceMemberAttribute
    {
        protected MatrixAttribute() { }
        public MatrixAttribute(params object?[]? objects) { }
        public object?[]? Excluding { get; init; }
        public virtual object?[] GetObjects(.DataGeneratorMetadata dataGeneratorMetadata) { }
    }
    [(.Parameter)]
    public class MatrixAttribute<T> : .MatrixAttribute, .<T>
    {
        public MatrixAttribute(params T?[]? objects) { }
    }
    [(.Class | .Method)]
    public sealed class MatrixDataSourceAttribute : .UntypedDataSourceGeneratorAttribute, .IAccessesInstanceData
    {
        public MatrixDataSourceAttribute() { }
        protected override .<<object?[]?>> GenerateDataSources(.DataGeneratorMetadata dataGeneratorMetadata) { }
    }
    [(.Class | .Method, AllowMultiple=true)]
    public class MatrixExclusionAttribute : .TUnitAttribute
    {
        public MatrixExclusionAttribute(params object?[]? objects) { }
        public object?[] Objects { get; }
    }
    [(.Parameter)]
    public class MatrixInstanceMethodAttribute<[.(..None | ..PublicMethods | ..NonPublicMethods | ..PublicProperties)]  TClass> : .MatrixMethodAttribute<TClass>, .IAccessesInstanceData
        where TClass :  class
    {
        public MatrixInstanceMethodAttribute(string methodName) { }
    }
    [(.Parameter)]
    public class MatrixMethodAttribute<[.(..None | ..PublicMethods | ..NonPublicMethods)]  TClass> : .MatrixAttribute
        where TClass :  class
    {
        public MatrixMethodAttribute(string methodName) { }
        public override object?[] GetObjects(.DataGeneratorMetadata dataGeneratorMetadata) { }
    }
    [(.Parameter)]
    public class MatrixRangeAttribute<T> : .MatrixAttribute<T>
        where T : .INumber<T>
    {
        public MatrixRangeAttribute(T min, T max) { }
        public MatrixRangeAttribute(T min, T max, T step) { }
    }
    public abstract class MemberMetadata : <.MemberMetadata>
    {
        protected MemberMetadata() { }
        public required string Name { get; init; }
        [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..NonPublicConstructors | ..PublicMethods | ..PublicProperties)]
        public abstract  Type { get; init; }
        public virtual bool Equals(.MemberMetadata? other) { }
        public override int GetHashCode() { }
        protected virtual bool PrintMembers(.StringBuilder stringBuilder) { }
    }
    [(.Class | .Method | .Property | .Parameter, AllowMultiple=true)]
    public class MethodDataSourceAttribute : , .IDataSourceAttribute
    {
        public MethodDataSourceAttribute(string methodNameProvidingDataSource) { }
        public MethodDataSourceAttribute([.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods | ..NonPublicMethods | ..PublicProperties)]  classProvidingDataSource, string methodNameProvidingDataSource) { }
        public object?[] Arguments { get; set; }
        [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods | ..NonPublicMethods | ..PublicProperties)]
        public ? ClassProvidingDataSource { get; }
        public <.DataGeneratorMetadata, .<<.<object?[]?>>>>? Factory { get; set; }
        public string MethodNameProvidingDataSource { get; }
        public bool SkipIfEmpty { get; set; }
        [.("Trimming", "IL2072", Justification="Method data sources require runtime discovery. AOT users should use Factory prope" +
            "rty.")]
        [.("Trimming", "IL2075", Justification="Method data sources require runtime discovery. AOT users should use Factory prope" +
            "rty.")]
        [.(typeof(.MethodDataSourceAttribute.<GetDataRowsAsync>d__21))]
        public .<<.<object?[]?>>> GetDataRowsAsync(.DataGeneratorMetadata dataGeneratorMetadata) { }
    }
    [(.Class | .Method | .Property | .Parameter, AllowMultiple=true)]
    public class MethodDataSourceAttribute<[.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods | ..NonPublicMethods | ..PublicProperties)]  T> : .MethodDataSourceAttribute
    {
        public MethodDataSourceAttribute(string methodNameProvidingDataSource) { }
    }
    [.DebuggerDisplay("{Type}.{Name}")]
    public class MethodMetadata : <.MethodMetadata>, .IMemberMetadata
    {
        public MethodMetadata() { }
        public required .ClassMetadata Class { get; init; }
        public required int GenericTypeCount { get; init; }
        public required string Name { get; init; }
        public required .ParameterMetadata[] Parameters { get; init; }
        public ? ReturnType { get; init; }
        public required .TypeInfo ReturnTypeInfo { get; init; }
        [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..NonPublicConstructors | ..PublicMethods | ..NonPublicMethods | ..PublicProperties)]
        public required  Type { get; init; }
        public required .TypeInfo TypeInfo { get; init; }
        public virtual bool Equals(.MethodMetadata? other) { }
        public override int GetHashCode() { }
        protected virtual bool PrintMembers(.StringBuilder stringBuilder) { }
    }
    [(.Assembly | .Class | .Method, AllowMultiple=false, Inherited=true)]
    public class NotDiscoverableAttribute : .TUnitAttribute, ., .
    {
        public NotDiscoverableAttribute() { }
        public NotDiscoverableAttribute(string reason) { }
        public int Order { get; }
        public string? Reason { get; }
        public . OnTestRegistered(.TestRegisteredContext context) { }
        public virtual .<bool> ShouldHide(.TestRegisteredContext context) { }
    }
    [(.Assembly | .Class | .Method)]
    public class NotInParallelAttribute : .SingleTUnitAttribute, .IScopedAttribute, ., .
    {
        public NotInParallelAttribute() { }
        public NotInParallelAttribute(string constraintKey) { }
        public NotInParallelAttribute(string[] constraintKeys) { }
        public string[] ConstraintKeys { get; }
        public int Order { get; init; }
        public  ScopeType { get; }
        public . OnTestDiscovered(.DiscoveredTestContext context) { }
    }
    public class NotInParallelConstraint : <.NotInParallelConstraint>, .
    {
        public NotInParallelConstraint(.<string> NotInParallelConstraintKeys) { }
        public .<string> NotInParallelConstraintKeys { get; init; }
        public int Order { get; set; }
    }
    public class ParallelGroupAttribute : .TUnitAttribute, ., .
    {
        public ParallelGroupAttribute(string group) { }
        public string Group { get; }
        public int Order { get; set; }
        public . OnTestDiscovered(.DiscoveredTestContext context) { }
    }
    public class ParallelGroupConstraint : , <.ParallelGroupConstraint>, <.ParallelGroupConstraint>, .
    {
        public ParallelGroupConstraint(string Group, int Order) { }
        public string Group { get; init; }
        public int Order { get; init; }
        public int CompareTo(.ParallelGroupConstraint? other) { }
        public int CompareTo(object? obj) { }
        public virtual bool Equals(.ParallelGroupConstraint? other) { }
        public override int GetHashCode() { }
    }
    public class ParallelLimitLockProvider
    {
        public ParallelLimitLockProvider() { }
    }
    [(.Assembly | .Class | .Method)]
    public sealed class ParallelLimiterAttribute<TParallelLimit> : .TUnitAttribute, ., .
        where TParallelLimit : ., new ()
    {
        public ParallelLimiterAttribute() { }
        public int Order { get; }
        public . OnTestRegistered(.TestRegisteredContext context) { }
    }
    [.DebuggerDisplay("{Type} {Name}")]
    public class ParameterMetadata : <.ParameterMetadata>, .IMemberMetadata
    {
        public ParameterMetadata([.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..NonPublicConstructors | ..PublicProperties)]  Type) { }
        public []? CachedDataSourceAttributes { get; }
        public object? CachedDefaultValue { get; }
        public bool? CachedIsOptional { get; }
        public bool? CachedIsParams { get; }
        public object? DefaultValue { get; }
        public bool IsNullable { get; init; }
        public bool IsOptional { get; }
        public bool IsParams { get; }
        public required string Name { get; init; }
        public int Position { get; init; }
        public required .ParameterInfo ReflectionInfo { get; set; }
        [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..NonPublicConstructors | ..PublicProperties)]
        public  Type { get; init; }
        public required .TypeInfo TypeInfo { get; init; }
    }
    [.DebuggerDisplay("{Type} {Name}")]
    public class ParameterMetadata<[.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..NonPublicConstructors | ..PublicProperties)]  T> : .ParameterMetadata, <.ParameterMetadata<T>>
    {
        public ParameterMetadata() { }
    }
    [(.Assembly | .Class | .Method, AllowMultiple=true)]
    public class PropertyAttribute : .TUnitAttribute, ., .
    {
        public PropertyAttribute(string name, string value) { }
        public string Name { get; }
        public int Order { get; }
        public string Value { get; }
        public . OnTestDiscovered(.DiscoveredTestContext context) { }
    }
    public sealed class PropertyDataSource
    {
        public PropertyDataSource() { }
        public required .IDataSourceAttribute DataSource { get; init; }
        public required string PropertyName { get; init; }
        public required  PropertyType { get; init; }
    }
    public sealed class PropertyInjectionData
    {
        public PropertyInjectionData() { }
        public .PropertyInjectionData[] NestedPropertyInjections { get; init; }
        public <object?, .<string, object?>>? NestedPropertyValueFactory { get; init; }
        public required string PropertyName { get; init; }
        public required  PropertyType { get; init; }
        public required <object, object?> Setter { get; init; }
        public required <object?> ValueFactory { get; init; }
    }
    public class PropertyInjectionException : .TestBuilderException
    {
        public PropertyInjectionException(string propertyName,  propertyType,  innerException) { }
        public string PropertyName { get; }
        public  PropertyType { get; }
    }
    [.DebuggerDisplay("{Type} {Name})")]
    public class PropertyMetadata : <.PropertyMetadata>, .IMemberMetadata
    {
        public PropertyMetadata() { }
        public required .ClassMetadata ClassMetadata { get; set; }
        public required .ClassMetadata ContainingTypeMetadata { get; set; }
        public <.IDataSourceAttribute>? CreateDataSource { get; init; }
        public required <object?, object?> Getter { get; init; }
        public bool IsInitOnly { get; init; }
        public bool IsNullable { get; init; }
        public bool IsRequired { get; init; }
        public required bool IsStatic { get; init; }
        public required string Name { get; init; }
        public required .PropertyInfo ReflectionInfo { get; init; }
        public <object, object?>? Setter { get; init; }
        [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..NonPublicConstructors | ..PublicProperties)]
        public required  Type { get; init; }
    }
    public static class PropertySourceRegistry
    {
        [.("Reflection discovery is used when source-generated metadata is not available")]
        public static .PropertyInjectionData[] DiscoverInjectableProperties([.(..None | ..PublicFields | ..NonPublicFields | ..PublicProperties)]  type) { }
        [return: .(new string[] {
                "Type",
                "Source"})]
        public static .<<, ..IPropertySource>> GetAllSources() { }
        public static .PropertyDataSource[]? GetPropertyDataSources( type) { }
        public static .PropertyInjectionData[]? GetPropertyInjectionData( type) { }
        public static ..IPropertySource? GetSource( type) { }
        public static void Register( type, ..IPropertySource source) { }
    }
    [(.Assembly, AllowMultiple=false, Inherited=false)]
    public sealed class ReflectionModeAttribute : 
    {
        public ReflectionModeAttribute() { }
    }
    [(.Assembly | .Class | .Method)]
    public sealed class RepeatAttribute : .TUnitAttribute, .IScopedAttribute
    {
        public RepeatAttribute(int times) { }
        public  ScopeType { get; }
        public int Times { get; }
    }
    public sealed class ResolvedDependency
    {
        public ResolvedDependency() { }
        public required .TestDependency Metadata { get; init; }
        public bool ProceedOnFailure { get; }
        public required .AbstractExecutableTest Test { get; init; }
    }
    [(.Assembly | .Class | .Method)]
    public class RetryAttribute : .TUnitAttribute, .IScopedAttribute, ., .
    {
        public RetryAttribute(int times) { }
        public int BackoffMs { get; set; }
        public double BackoffMultiplier { get; set; }
        public int Order { get; }
        public []? RetryOnExceptionTypes { get; set; }
        public  ScopeType { get; }
        public int Times { get; }
        public . OnTestDiscovered(.DiscoveredTestContext context) { }
        public virtual .<bool> ShouldRetry(.TestContext context,  exception, int currentRetryCount) { }
    }
    public sealed class RunOnAttribute : .SkipAttribute
    {
        public RunOnAttribute(. OperatingSystem) { }
        public override .<bool> ShouldSkip(.TestRegisteredContext context) { }
    }
    [.("windows")]
    public class STAThreadExecutor : .DedicatedThreadExecutor
    {
        public STAThreadExecutor() { }
        protected override void ConfigureThread(.Thread thread) { }
    }
    public class SharedDataKey : <.SharedDataKey>
    {
        public SharedDataKey(string Key,  Type) { }
        public string Key { get; init; }
        public  Type { get; init; }
    }
    public static class SharedDataSources
    {
        public static object? GetOrCreate(.SharedType sharedType, [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..NonPublicConstructors)]  type, ? testClassType, string? key, <object?> factory) { }
        public static object? GetOrCreate(.SharedType sharedType, [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..NonPublicConstructors)]  type, .DataGeneratorMetadata dataGeneratorMetadata, string? key, <object?> factory) { }
        public static T GetOrCreate<T>(.SharedType sharedType, ? testClassType = null, string? key = null)
            where T : new() { }
        public static T GetOrCreate<T>(.SharedType sharedType, .DataGeneratorMetadata dataGeneratorMetadata, string? key = null)
            where T : new() { }
        public static T GetOrCreate<T>(.SharedType sharedType, ? testClassType, string? key, <T> factory) { }
        public static T GetOrCreate<T>(.SharedType sharedType, .DataGeneratorMetadata dataGeneratorMetadata, string? key, <T> factory) { }
    }
    public enum SharedType
    {
        None = 0,
        PerClass = 1,
        PerAssembly = 2,
        PerTestSession = 3,
        Keyed = 4,
    }
    public class SingleTUnitAttribute : .TUnitAttribute { }
    public static class Skip
    {
        [.]
        public static void Test(string reason) { }
        public static void Unless([.(false)] bool condition, string reason) { }
        public static void When([.(true)] bool condition, string reason) { }
    }
    [(.Assembly | .Class | .Method, AllowMultiple=true)]
    public class SkipAttribute : , ., .
    {
        public SkipAttribute(string reason) { }
        public int Order { get; }
        public string Reason { get; }
        protected virtual string GetSkipReason(.TestRegisteredContext context) { }
        public . OnTestRegistered(.TestRegisteredContext context) { }
        public virtual .<bool> ShouldSkip(.TestRegisteredContext context) { }
    }
    [.StackTraceHidden]
    public class SourceRegistrar
    {
        public SourceRegistrar() { }
        public static bool IsEnabled { get; set; }
        public static void Register(..ITestSource testSource) { }
        public static void Register( testClassType, ..ITestSource testSource) { }
        public static void RegisterAssembly(<.Assembly> assemblyLoader) { }
        public static void RegisterDynamic(.IDynamicTestSource testSource) { }
        public static void RegisterGlobalInitializer(<.> initializer) { }
        public static void RegisterProperty(..IPropertySource propertySource) { }
    }
    public static class Sources
    {
        public static readonly .<.Assembly, .<.>> AfterAssemblyHooks;
        public static readonly .<, .<.>> AfterClassHooks;
        public static readonly .<.> AfterEveryAssemblyHooks;
        public static readonly .<.> AfterEveryClassHooks;
        public static readonly .<.> AfterEveryTestHooks;
        public static readonly .<.> AfterTestDiscoveryHooks;
        public static readonly .<, .<.>> AfterTestHooks;
        public static readonly .<.> AfterTestSessionHooks;
        public static readonly .<<.Assembly>> AssemblyLoaders;
        public static readonly .<.Assembly, .<.>> BeforeAssemblyHooks;
        public static readonly .<, .<.>> BeforeClassHooks;
        public static readonly .<.> BeforeEveryAssemblyHooks;
        public static readonly .<.> BeforeEveryClassHooks;
        public static readonly .<.> BeforeEveryTestHooks;
        public static readonly .<.> BeforeTestDiscoveryHooks;
        public static readonly .<, .<.>> BeforeTestHooks;
        public static readonly .<.> BeforeTestSessionHooks;
        public static readonly .<.IDynamicTestSource> DynamicTestSources;
        public static readonly .<<.>> GlobalInitializers;
        public static readonly .<..IPropertySource> PropertySources;
        public static readonly .<, .<..ITestSource>> TestSources;
    }
    [.("Reflection mode requires dynamic access for static property initialization")]
    public static class StaticPropertyReflectionInitializer
    {
        [.("Data source initialization may require dynamic code generation")]
        public static . InitializeAllStaticPropertiesAsync() { }
        [.("Data source initialization may require dynamic code generation")]
        public static . InitializeStaticPropertiesForType( type) { }
    }
    public class TUnitAttribute :  { }
    [(.Method)]
    public sealed class TestAttribute : .BaseTestAttribute
    {
        public TestAttribute([.] string file = "", [.] int line = 0) { }
    }
    public sealed class TestBuildContext : .Context, 
    {
        public TestBuildContext() { }
        public new static .TestBuildContext? Current { get; }
        public new void Dispose() { }
        public string GetCapturedErrorOutput() { }
        public string GetCapturedOutput() { }
    }
    public class TestBuilderContext : <.TestBuilderContext>
    {
        public TestBuilderContext() { }
        public .IDataSourceAttribute? DataSourceAttribute { get; set; }
        public string DefinitionId { get; }
        public .TestContextEvents Events { get; set; }
        [("Use StateBag property instead.")]
        public .<string, object?> ObjectBag { get; }
        public .<string, object?> StateBag { get; set; }
        public required .MethodMetadata TestMetadata { get; init; }
        public static .TestBuilderContext? Current { get; }
        public void RegisterForInitialization(object? obj) { }
    }
    public class TestBuilderContextAccessor
    {
        public TestBuilderContextAccessor(.TestBuilderContext context) { }
        public .TestBuilderContext Current { get; set; }
    }
    public class TestBuilderException : 
    {
        public TestBuilderException() { }
        public TestBuilderException(string message) { }
        public TestBuilderException(string message,  innerException) { }
        public .<string, object?> Context { get; set; }
        public .TestMetadata? TestMetadata { get; set; }
    }
    [(.Constructor)]
    public sealed class TestConstructorAttribute : .TUnitAttribute
    {
        public TestConstructorAttribute() { }
    }
    [.DebuggerDisplay("{.Name}.{GetDisplayName(),nq}")]
    public class TestContext : .Context, ., ., ., ., ., ., ., .
    {
        public TestContext(string testName,  serviceProvider, .ClassHookContext classContext, .TestBuilderContext testBuilderContext, .CancellationToken cancellationToken) { }
        public .ClassHookContext ClassContext { get; }
        public . Dependencies { get; }
        public . Events { get; }
        public . Execution { get; }
        public string Id { get; }
        public . Isolation { get; }
        public object Lock { get; }
        public . Metadata { get; }
        public . Output { get; }
        public . Parallelism { get; }
        public . StateBag { get; }
        public static . Configuration { get; }
        public new static .TestContext? Current { get; }
        public static string? OutputDirectory { get; }
        public static .<string, .<string>> Parameters { get; }
        public static string WorkingDirectory { get; set; }
        public override string GetErrorOutput() { }
        public override string GetStandardOutput() { }
        public static .TestContext? GetById(string id) { }
    }
    public class TestContextEvents : .
    {
        public TestContextEvents() { }
        public .AsyncEvent<.TestContext>? OnDispose { get; set; }
        public .AsyncEvent<.TestContext>? OnInitialize { get; set; }
        public .AsyncEvent<.TestContext>? OnTestEnd { get; set; }
        public .AsyncEvent<.TestContext>? OnTestRegistered { get; set; }
        [.(new string[] {
                "TestContext",
                "RetryAttempt"})]
        public .AsyncEvent<<.TestContext, int>>? OnTestRetry { get; set; }
        public .AsyncEvent<.TestContext>? OnTestSkipped { get; set; }
        public .AsyncEvent<.TestContext>? OnTestStart { get; set; }
    }
    public class TestDataCombination
    {
        public TestDataCombination() { }
        public string[]? Categories { get; init; }
        public <.<object?>>[] ClassDataFactories { get; init; }
        public int ClassDataSourceIndex { get; init; }
        public int ClassLoopIndex { get; init; }
        public ? DataGenerationException { get; init; }
        public string? DisplayName { get; init; }
        public <.<object?>>[] MethodDataFactories { get; init; }
        public int MethodDataSourceIndex { get; init; }
        public int MethodLoopIndex { get; init; }
        public int RepeatIndex { get; init; }
        public .<string, >? ResolvedGenericTypes { get; init; }
        public string? Skip { get; init; }
    }
    public class TestDataRow<T> : <.TestDataRow<T>>
    {
        public TestDataRow(T Data, string? DisplayName = null, string? Skip = null, string[]? Categories = null) { }
        public string[]? Categories { get; init; }
        public T Data { get; init; }
        public string? DisplayName { get; init; }
        public string? Skip { get; init; }
    }
    public class TestDefinition : .ITestDefinition
    {
        public TestDefinition() { }
    }
    public class TestDefinition<T> : .TestDefinition
        where T :  class
    {
        public TestDefinition() { }
    }
    public sealed class TestDependency : <.TestDependency>
    {
        public TestDependency() { }
        public int ClassGenericArity { get; init; }
        public ? ClassType { get; init; }
        public int MethodGenericArity { get; init; }
        public string? MethodName { get; init; }
        public []? MethodParameters { get; init; }
        public bool ProceedOnFailure { get; init; }
        public bool Equals(.TestDependency? other) { }
        public override bool Equals(object? obj) { }
        public override int GetHashCode() { }
        public bool Matches(.TestMetadata test, .TestMetadata? dependentTest = null) { }
        public override string ToString() { }
        public static .TestDependency FromClass( classType, bool proceedOnFailure = false) { }
        public static .TestDependency FromClassAndMethod( classType, string methodName, bool proceedOnFailure = false) { }
        public static .TestDependency FromMethodName(string methodName, bool proceedOnFailure = false) { }
    }
    public readonly struct TestDescriptor
    {
        public TestDescriptor() { }
        public string[] Categories { get; init; }
        public required string ClassName { get; init; }
        public string[] DependsOn { get; init; }
        public required string FilePath { get; init; }
        public required string FullyQualifiedName { get; init; }
        public bool HasDataSource { get; init; }
        public required int LineNumber { get; init; }
        public required <string, .CancellationToken, .<.TestMetadata>> Materializer { get; init; }
        public required string MethodName { get; init; }
        public string[] Properties { get; init; }
        public int RepeatCount { get; init; }
        public required string TestId { get; init; }
        public bool HasCategory(string category) { }
        public bool HasProperty(string key, string? value = null) { }
    }
    public class TestDetails : ., ., ., ., ., .
    {
        public TestDetails(.<> allAttributes) { }
        public . Attributes { get; }
        public required .<, .<>> AttributesByType { get; init; }
        public .<string> Categories { get; }
        public . Class { get; }
        public [] ClassGenericArguments { get; set; }
        public required object ClassInstance { get; set; }
        [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods | ..PublicProperties)]
        public required  ClassType { get; init; }
        public . Configuration { get; }
        public .<string, .<string>> CustomProperties { get; }
        public . Identity { get; }
        public . Location { get; }
        public . Method { get; }
        public [] MethodGenericArguments { get; set; }
        public required .MethodMetadata MethodMetadata { get; set; }
        public required string MethodName { get; init; }
        public int RetryBackoffMs { get; set; }
        public double RetryBackoffMultiplier { get; set; }
        public int RetryLimit { get; set; }
        public required  ReturnType { get; set; }
        public required object?[] TestClassArguments { get; set; }
        public .<string, object?> TestClassInjectedPropertyArguments { get; init; }
        public []? TestClassParameterTypes { get; set; }
        public string TestFilePath { get; set; }
        public required string TestId { get; init; }
        public int TestLineNumber { get; set; }
        public required object?[] TestMethodArguments { get; set; }
        public required string TestName { get; init; }
        public ? Timeout { get; set; }
        public .<> GetAllAttributes() { }
        public .<T> GetAttributes<T>()
            where T :  { }
        public bool HasAttribute<T>()
            where T :  { }
    }
    public class TestDetails<T> : .TestDetails
        where T :  class
    {
        public TestDetails(.<> allAttributes) { }
    }
    public class TestDiscoveryContext : .Context
    {
        public .<.TestContext> AllTests { get; }
        public .<.AssemblyHookContext> Assemblies { get; }
        public .BeforeTestDiscoveryContext BeforeTestDiscoveryContext { get; }
        public .<.ClassHookContext> TestClasses { get; }
        public required string? TestFilter { get; init; }
        public new static .TestDiscoveryContext? Current { get; }
        public void AddTests(.<.TestContext> tests) { }
    }
    public class TestInstantiationException : .TestBuilderException
    {
        public TestInstantiationException( testClassType,  innerException) { }
        public TestInstantiationException( testClassType, string message) { }
        public  TestClassType { get; }
    }
    public abstract class TestMetadata
    {
        protected TestMetadata() { }
        public required <[]> AttributeFactory { get; init; }
        public required .IDataSourceAttribute[] ClassDataSources { get; init; }
        public abstract <.ExecutableTestCreationContext, .TestMetadata, .AbstractExecutableTest> CreateExecutableTestFactory { get; }
        public required .IDataSourceAttribute[] DataSources { get; init; }
        public .TestDependency[] Dependencies { get; init; }
        public required string FilePath { get; init; }
        public .GenericMethodInfo? GenericMethodInfo { get; init; }
        public []? GenericMethodTypeArguments { get; init; }
        public .GenericTypeInfo? GenericTypeInfo { get; init; }
        public int InheritanceDepth { get; set; }
        public <[], object?[], object> InstanceFactory { get; init; }
        public required int LineNumber { get; init; }
        public required .MethodMetadata MethodMetadata { get; init; }
        public required .PropertyDataSource[] PropertyDataSources { get; init; }
        public .PropertyInjectionData[] PropertyInjections { get; init; }
        public int? RepeatCount { get; init; }
        [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods | ..PublicProperties)]
        public required  TestClassType { get; init; }
        public <object, object?[], .>? TestInvoker { get; init; }
        public required string TestMethodName { get; init; }
        public required string TestName { get; init; }
        public string TestSessionId { get; set; }
    }
    public class TestMetadata<[.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods | ..PublicProperties)]  T> : .TestMetadata, .
        where T :  class
    {
        public TestMetadata() { }
        public override <.ExecutableTestCreationContext, .TestMetadata, .AbstractExecutableTest> CreateExecutableTestFactory { get; }
        public new <[], object?[], T>? InstanceFactory { get; init; }
        public <T, object?[], .CancellationToken, .>? InvokeTypedTest { get; init; }
        public new <T, object?[], .>? TestInvoker { get; init; }
        public void UseRuntimeDataGeneration(string testSessionId) { }
    }
    public enum TestPhase
    {
        Discovery = 0,
        Registration = 1,
        BeforeTest = 2,
        Execution = 3,
        AfterTest = 4,
    }
    public class TestRegisteredContext
    {
        public TestRegisteredContext(.TestContext testContext) { }
        public string? CustomDisplayName { get; }
        public .DiscoveredTest DiscoveredTest { get; set; }
        [("Use StateBag property instead.")]
        public .<string, object?> ObjectBag { get; }
        public .<string, object?> StateBag { get; }
        public .TestContext TestContext { get; }
        public .TestDetails TestDetails { get; }
        public string TestName { get; }
        public void SetHookExecutor(. executor) { }
        public void SetParallelLimiter(. parallelLimit) { }
        public void SetSkipped(string reason) { }
        public void SetTestExecutor(. executor) { }
    }
    public class TestResult : <.TestResult>
    {
        public TestResult() { }
        public required string ComputerName { get; init; }
        public required ? Duration { get; init; }
        public required ? End { get; init; }
        public required ? Exception { get; init; }
        public bool IsOverridden { get; init; }
        public ? OriginalException { get; init; }
        public string? Output { get; }
        public string? OverrideReason { get; init; }
        public required ? Start { get; init; }
        public required .TestState State { get; init; }
    }
    public class TestSessionContext : .Context
    {
        public .<.TestContext> AllTests { get; }
        public .<.AssemblyHookContext> Assemblies { get; }
        public required string Id { get; init; }
        public .<.ClassHookContext> TestClasses { get; }
        public .TestDiscoveryContext TestDiscoveryContext { get; }
        public required string? TestFilter { get; init; }
        public new static .TestSessionContext? Current { get; }
        public static .TestBuilderContext GlobalStaticPropertyContext { get; }
        public void AddArtifact(.Artifact artifact) { }
        public void AddAssembly(.AssemblyHookContext assemblyHookContext) { }
    }
    public enum TestState
    {
        NotStarted = 0,
        WaitingForDependencies = 1,
        Queued = 2,
        Running = 3,
        Passed = 4,
        Failed = 5,
        Skipped = 6,
        Timeout = 7,
        Cancelled = 8,
    }
    public static class TestStateExtensions
    {
        public static bool IsFailure(this .TestState state) { }
        public static bool IsFinal(this .TestState state) { }
        public static bool IsSuccess(this .TestState state) { }
        public static bool IsTransient(this .TestState state) { }
    }
    [(.Assembly | .Class | .Method)]
    public class TimeoutAttribute : .TUnitAttribute, .IScopedAttribute, ., ., .
    {
        public TimeoutAttribute(int timeoutInMilliseconds) { }
        public int Order { get; }
        public  ScopeType { get; }
        public  Timeout { get; }
        public . OnHookRegistered(.HookRegisteredContext context) { }
        public . OnTestDiscovered(.DiscoveredTestContext context) { }
    }
    public class Timing : <.Timing>
    {
        public Timing(string StepName,  Start,  End) { }
        public  Duration { get; }
        public  End { get; init; }
        public  Start { get; init; }
        public string StepName { get; init; }
    }
    public sealed class TypeArrayComparer : .<[]>
    {
        public static readonly .TypeArrayComparer Instance;
        public bool Equals([]? x, []? y) { }
        public int GetHashCode([] obj) { }
    }
    public abstract class TypeInfo : <.TypeInfo>
    {
        protected TypeInfo() { }
    }
    public abstract class TypedDataSourceAttribute<T> : , .IDataSourceAttribute, .ITypedDataSourceAttribute<T>
    {
        protected TypedDataSourceAttribute() { }
        public virtual bool SkipIfEmpty { get; set; }
        [.(typeof(.TypedDataSourceAttribute<T>.<GetDataRowsAsync>d__5))]
        public .<<.<object?[]?>>> GetDataRowsAsync(.DataGeneratorMetadata dataGeneratorMetadata) { }
        public abstract .<<.<T>>> GetTypedDataRowsAsync(.DataGeneratorMetadata dataGeneratorMetadata);
    }
    [(.Class | .Method | .Property, AllowMultiple=true)]
    public abstract class UntypedDataSourceGeneratorAttribute : .AsyncUntypedDataSourceGeneratorAttribute
    {
        protected UntypedDataSourceGeneratorAttribute() { }
        protected abstract .<<object?[]?>> GenerateDataSources(.DataGeneratorMetadata dataGeneratorMetadata);
        [.(typeof(.UntypedDataSourceGeneratorAttribute.<GenerateDataSourcesAsync>d__1))]
        protected override sealed .<<.<object?[]?>>> GenerateDataSourcesAsync(.DataGeneratorMetadata dataGeneratorMetadata) { }
    }
}
namespace .AotCompatibility
{
    public enum AotCompatibilityMode
    {
        SourceGenerated = 0,
        ManuallyRegistered = 1,
        ConcreteTypesOnly = 2,
        TupleInterfaceBased = 3,
    }
    [(.Method)]
    public class AotCompatibleAttribute : 
    {
        public AotCompatibleAttribute() { }
        public string? Details { get; init; }
        public . Mode { get; init; }
    }
    public static class GenericTestRegistry
    {
        public static .MethodInfo? GetCompiledMethod( declaringType, string methodName, [] typeArguments) { }
        public static TDelegate? GetDirectDelegate<TDelegate>( declaringType, string methodName, [] typeArguments)
            where TDelegate :  { }
        public static .<[]> GetRegisteredCombinations( declaringType) { }
        public static bool IsMarkedAotCompatible(.MethodInfo method) { }
        public static bool IsRegistered( declaringType, string methodName, [] typeArguments) { }
        public static void MarkAsAotCompatible(.MethodInfo method) { }
        public static void RegisterDirectDelegate<T>( declaringType, string methodName, [] typeArguments, T delegateInstance)
            where T :  { }
        public static void RegisterGenericMethod( declaringType, string methodName, [] typeArguments, .MethodInfo compiledMethod) { }
    }
}
namespace .Attributes
{
    [(.Class | .Constructor | .Method | .Property)]
    public sealed class AotCompatibleAttribute : 
    {
        public AotCompatibleAttribute() { }
        public string? AlternativeForReflection { get; set; }
        public string? Notes { get; set; }
    }
    [(.Class | .Constructor | .Method | .Property)]
    public sealed class RequiresReflectionAttribute : 
    {
        public RequiresReflectionAttribute(string reason) { }
        public string? AotAlternative { get; set; }
        public string Reason { get; }
    }
}
namespace .Converters
{
    public static class AotConverterRegistry
    {
        public static void Register(. converter) { }
        public static void Register<TSource, TTarget>(<TSource, TTarget> converter) { }
        public static bool TryConvert( sourceType,  targetType, object? value, out object? result) { }
        public static bool TryGetConverter( sourceType,  targetType, out .? converter) { }
    }
    public class FuncAotConverter<TSource, TTarget> : .
    {
        public FuncAotConverter(<TSource, TTarget> converter) { }
        public  SourceType { get; }
        public  TargetType { get; }
        public object? Convert(object? value) { }
    }
    public interface IAotConverter
    {
         SourceType { get; }
         TargetType { get; }
        object? Convert(object? value);
    }
}
namespace .Data
{
    public class ScopedDictionary<TScope>
        where TScope :  notnull
    {
        public ScopedDictionary() { }
        public object? GetOrCreate(TScope scope,  type, <, object?> factory) { }
    }
    public class ThreadSafeDictionary<TKey, [.(..PublicParameterlessConstructor)]  TValue>
        where TKey :  notnull
    {
        public ThreadSafeDictionary() { }
        public TValue this[TKey key] { get; }
        public .<TKey> Keys { get; }
        public .<TValue> Values { get; }
        public TValue GetOrAdd(TKey key, <TKey, TValue> func) { }
        public TValue? Remove(TKey key) { }
        public bool TryGetValue(TKey key, [.(true)] out TValue? value) { }
    }
}
namespace .DataSources
{
    public static class TestDataFormatter
    {
        public static string CreateDisplayName(.TestMetadata metadata, object?[] arguments, .TestDataCombination? dataCombination = null) { }
        public static string CreateGenericDisplayName(.TestMetadata metadata, [] genericTypes, object?[] arguments) { }
        public static string FormatArguments(.TestContext context) { }
        public static string FormatArguments(object?[] arguments) { }
        public static string FormatArguments(object?[] arguments, .<<object?, string?>> formatters) { }
    }
}
namespace .Discovery
{
    public sealed class InitializerPropertyInfo
    {
        public InitializerPropertyInfo() { }
        public required <object, object?> GetValue { get; init; }
        public required string PropertyName { get; init; }
        public required  PropertyType { get; init; }
    }
    public static class InitializerPropertyRegistry
    {
        public static .[]? GetProperties( type) { }
        public static bool HasRegistration( type) { }
        public static void Register( type, .[] properties) { }
    }
}
namespace .Enums
{
    public enum DataGeneratorType
    {
        ClassParameters = 0,
        TestParameters = 1,
        Property = 2,
    }
    public enum EventReceiverStage
    {
        Early = 0,
        Late = 1,
    }
    public enum LogLevel
    {
        None = -1,
        Trace = 0,
        Debug = 1,
        Information = 2,
        Warning = 3,
        Error = 4,
        Critical = 5,
    }
    []
    public enum OS
    {
        Linux = 1,
        Windows = 2,
        MacOs = 4,
        Browser = 8,
    }
    public enum Priority
    {
        Low = 0,
        BelowNormal = 1,
        Normal = 2,
        AboveNormal = 3,
        High = 4,
        Critical = 5,
    }
    public enum TestRelationship
    {
        None = 0,
        Retry = 1,
        Generated = 2,
        Derived = 3,
    }
}
namespace .Events
{
    []
    public enum EventType
    {
        Initialize = 1,
        Dispose = 2,
        TestRegistered = 4,
        TestStart = 8,
        TestEnd = 16,
        TestSkipped = 32,
        FirstTestInClass = 64,
        FirstTestInAssembly = 128,
        FirstTestInTestSession = 256,
        LastTestInClass = 512,
        LastTestInAssembly = 1024,
        LastTestInTestSession = 2048,
        TestRetry = 2049,
        All = 4095,
    }
}
namespace .Exceptions
{
    public class AfterAssemblyException : .
    {
        public AfterAssemblyException(string message,  innerException) { }
    }
    public class AfterClassException : .
    {
        public AfterClassException(string message,  innerException) { }
    }
    public class AfterTestDiscoveryException : .
    {
        public AfterTestDiscoveryException(string message,  innerException) { }
    }
    public class AfterTestException : .
    {
        public AfterTestException(string message,  innerException) { }
    }
    public class AfterTestSessionException : .
    {
        public AfterTestSessionException(string message,  innerException) { }
    }
    public class BeforeAssemblyException : .
    {
        public BeforeAssemblyException(string message,  innerException) { }
    }
    public class BeforeClassException : .
    {
        public BeforeClassException(string message,  innerException) { }
    }
    public class BeforeTestDiscoveryException : .
    {
        public BeforeTestDiscoveryException(string message,  innerException) { }
    }
    public class BeforeTestException : .
    {
        public BeforeTestException(string message,  innerException) { }
    }
    public class BeforeTestSessionException : .
    {
        public BeforeTestSessionException(string message,  innerException) { }
    }
    public class CircularDependencyException : 
    {
        public CircularDependencyException() { }
        public CircularDependencyException(string message) { }
        public CircularDependencyException(string message,  innerException) { }
    }
    public class DependencyConflictException : . { }
    public class FailTestException : .
    {
        public FailTestException(string reason) { }
        public string Reason { get; }
    }
    public class GenericTypeResolutionException : 
    {
        public GenericTypeResolutionException(string message) { }
        public GenericTypeResolutionException(string message,  innerException) { }
    }
    public class InconclusiveTestException : .
    {
        public InconclusiveTestException(string message,  exception) { }
    }
    public class SkipTestException : .
    {
        public SkipTestException(string reason) { }
        public string Reason { get; }
    }
    public class TUnitException : 
    {
        public TUnitException() { }
        public TUnitException(string? message) { }
        public TUnitException(string? message, ? innerException) { }
    }
    public class TestDependencyException : .
    {
        public TestDependencyException(string dependencyName, bool proceedOnFailure) { }
        public string DependencyName { get; }
        public bool ProceedOnFailure { get; }
    }
    public class TestExecutionException : .
    {
        public TestExecutionException(? testException, .<> hookExceptions, .<> eventReceiverExceptions) { }
        public .<> EventReceiverExceptions { get; }
        public .<> HookExceptions { get; }
        public ? TestException { get; }
    }
    public class TestFailedInitializationException : 
    {
        public TestFailedInitializationException(string? message, ? innerException) { }
    }
    public class TestNotExecutedException : . { }
    public class TestRunCanceledException : .
    {
        public TestRunCanceledException() { }
    }
    public class TimeoutException : . { }
}
namespace .Executors
{
    [(.Assembly | .Class | .Method)]
    public class CultureAttribute : .TUnitAttribute, .IScopedAttribute, ., .
    {
        public CultureAttribute(.CultureInfo cultureInfo) { }
        public CultureAttribute(string cultureName) { }
        public int Order { get; }
        public  ScopeType { get; }
        public . OnTestRegistered(.TestRegisteredContext context) { }
    }
    public class HookExecutorAttribute : .TUnitAttribute
    {
        public HookExecutorAttribute( type) { }
        public  HookExecutorType { get; }
    }
    [(.Assembly | .Class | .Method)]
    public sealed class HookExecutorAttribute<T> : .
        where T : ., new ()
    {
        public HookExecutorAttribute() { }
    }
    [(.Assembly | .Class | .Method)]
    public class InvariantCultureAttribute : .
    {
        public InvariantCultureAttribute() { }
    }
    [(.Assembly | .Class | .Method)]
    [.("windows")]
    public class STAThreadExecutorAttribute : .TUnitAttribute, .IScopedAttribute, ., .
    {
        public STAThreadExecutorAttribute() { }
        public int Order { get; }
        public  ScopeType { get; }
        public . OnTestRegistered(.TestRegisteredContext context) { }
    }
    [(.Assembly | .Class | .Method)]
    public sealed class TestExecutorAttribute : .TUnitAttribute, .IScopedAttribute, ., .
    {
        public TestExecutorAttribute([.(..PublicConstructors)]  type) { }
        public int Order { get; }
        public  ScopeType { get; }
        public . OnTestRegistered(.TestRegisteredContext context) { }
    }
    [(.Assembly | .Class | .Method)]
    public sealed class TestExecutorAttribute<T> : .TUnitAttribute, .IScopedAttribute, ., .
        where T : ., new ()
    {
        public TestExecutorAttribute() { }
        public int Order { get; }
        public  ScopeType { get; }
        public . OnTestRegistered(.TestRegisteredContext context) { }
    }
}
namespace .Extensions
{
    public static class MetadataExtensions
    {
        public static  DeclaringType(this .MethodMetadata method) { }
        public static string DisplayName(this .MethodMetadata method) { }
        public static .<> GetCustomAttributes(this .MethodMetadata method) { }
        public static .MethodInfo GetReflectionInfo(this .MethodMetadata method) { }
        public static bool IsGenericMethodDefinition(this .MethodMetadata method) { }
        public static string MethodName(this .MethodMetadata method) { }
    }
    public static class ReflectionExtensions
    {
        public static [] GetCustomAttributesSafe(this .ICustomAttributeProvider provider, bool inherit = true) { }
        public static T[] GetCustomAttributesSafe<T>(this .ICustomAttributeProvider provider, bool inherit = true)
            where T :  { }
    }
    public static class TestContextExtensions
    {
        [.("Dynamic test metadata creation uses reflection")]
        public static . AddDynamicTest<[.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..NonPublicConstructors | ..PublicMethods | ..NonPublicMethods | ..PublicFields | ..NonPublicFields | ..PublicProperties)]  T>(this .TestContext context, .DynamicTest<T> dynamicTest)
            where T :  class { }
        [.("Creating test variants requires runtime compilation and reflection")]
        public static . CreateTestVariant(this .TestContext context, object?[]? arguments = null, .<string, object?>? properties = null, . relationship = 3, string? displayName = null) { }
        public static string GetClassTypeName(this .TestContext context) { }
    }
}
namespace .Helpers
{
    public static class ArgumentFormatter
    {
        public static string Format(object? o, .<<object?, string?>> formatters) { }
        public static string FormatArguments(.<object?> arguments) { }
        public static string GetConstantValue(.TestContext testContext, object? o) { }
    }
    public static class AttributeDictionaryHelper
    {
        public static .<, .<>> Empty { get; }
        public static .<, .<>> ToAttributeDictionary(this [] attributes) { }
    }
    public static class CastHelper
    {
        [.("AOT", "IL3050:Calling members annotated with \'RequiresDynamicCodeAttribute\' may break fu" +
            "nctionality when AOT compiling.")]
        public static object? Cast([.(..PublicParameterlessConstructor)]  type, object? value) { }
        public static T? Cast<[.(..PublicParameterlessConstructor)]  T>(object? value) { }
    }
    public static class ClassConstructorHelper
    {
        public static .ClassConstructorAttribute? GetClassConstructorAttribute([] attributes) { }
        public static bool HasClassConstructorAttribute([] attributes) { }
        public static .<object?> TryCreateInstanceWithClassConstructor(.<> attributes, [.(..PublicConstructors)]  testClassType, .TestBuilderContext testBuilderContext, string testSessionId) { }
        public static .<object?> TryCreateInstanceWithClassConstructor(.<> attributes, [.(..PublicConstructors)]  testClassType, string testSessionId, .TestContext testContext) { }
    }
    [.DebuggerDisplay("Count = {CurrentCount}")]
    public class Counter
    {
        public Counter() { }
        public int CurrentCount { get; }
        public event <int>? OnCountChanged;
        public int Add(int value) { }
        public int Decrement() { }
        public int Increment() { }
    }
    public static class DataConversionHelper
    {
        [.(typeof(..<ConvertAsyncEnumerableToObjectArrays>d__2<T>))]
        public static .<object?[]> ConvertAsyncEnumerableToObjectArrays<T>(.<T> source, [.] .CancellationToken ct = default) { }
        [.(typeof(..<ConvertAsyncEnumerableTupleToObjectArrays>d__3<T>))]
        public static .<object?[]> ConvertAsyncEnumerableTupleToObjectArrays<T>(.<T> source, [.] .CancellationToken ct = default)
            where T : . { }
        [.(typeof(..<ConvertToAsyncEnumerableInternal>d__1))]
        public static .<object?[]> ConvertToAsyncEnumerableInternal(.<object?[]> data, [.] .CancellationToken ct = default) { }
        public static .<object?[]> ConvertToObjectArrays(object? data) { }
        public static object?[] UnwrapTuple(. tuple) { }
        public static .<.<object?[]>> WrapTaskEnumerableAsObjectArrays<T>(.<.<T>> task) { }
    }
    public static class DataSourceHelpers
    {
        public static <.<object?>>[] HandleTupleValue(object? value, bool shouldUnwrap) { }
        public static object? InvokeIfFunc(object? value) { }
        public static T InvokeIfFunc<T>(object? value) { }
        public static bool IsTuple(object? obj) { }
        public static .<object?> ProcessDataSourceResult<T>(T data) { }
        public static .<object?> ProcessDataSourceResultGeneric<T>(T data) { }
        public static .<object?> ProcessEnumerableDataSource<T>(.<T> enumerable) { }
        public static <.<object?>>[] ProcessTestDataSource<T>(T data, int expectedParameterCount = -1) { }
        public static void RegisterTypeCreator<T>(<.MethodMetadata, string, .<T>> creator) { }
        [.("AOT", "IL3050:Calling members annotated with \'RequiresDynamicCodeAttribute\' may break fu" +
            "nctionality when AOT compiling", Justification="This method is only used in reflection mode. In AOT/source-gen mode, property inj" +
            "ection uses compile-time generated code.")]
        [.("Trimming", "IL2026:Members annotated with \'RequiresUnreferencedCodeAttribute\' require dynamic" +
            " access", Justification="This method is only used in reflection mode. In AOT/source-gen mode, property inj" +
            "ection uses compile-time generated code.")]
        public static .<object?> ResolveDataSourceForPropertyAsync([.(..None | ..PublicParameterlessConstructor | ..PublicFields | ..NonPublicFields | ..PublicProperties)]  containingType, string propertyName, .MethodMetadata testInformation, string testSessionId) { }
        public static object?[] ToObjectArray(this object? item) { }
        public static object?[] ToObjectArrayWithTypes(this object? item, []? expectedTypes) { }
        [return: .(new string[] {
                "success",
                "createdInstance"})]
        public static .<<bool, object?>> TryCreateWithInitializerAsync( type, .MethodMetadata testInformation, string testSessionId) { }
        public static object?[] UnwrapTupleAot(object? value) { }
    }
    public static class DecimalParsingHelper
    {
        public static decimal ParseDecimalWithCultureFallback(string value) { }
    }
    public static class GenericTypeHelper
    {
        public static  GetGenericTypeDefinition( type) { }
        public static bool IsConstructedGenericType( type) { }
        [.("MakeGenericType requires runtime code generation")]
        [.("MakeGenericType requires runtime code generation")]
        public static  MakeGenericTypeSafe( genericTypeDefinition, params [] typeArguments) { }
    }
    public static class ParallelTaskHelper
    {
        public static . ForEachAsync<T>(.<T> items, <T, .> action) { }
        public static . ForEachAsync<T>(T[] items, <T, .> action) { }
        public static . ForEachAsync<T>(.<T> items, <T, .CancellationToken, .> action, .CancellationToken cancellationToken) { }
        public static . ForEachAsync<T>(T[] items, <T, .CancellationToken, .> action, .CancellationToken cancellationToken) { }
        public static . ForEachWithIndexAsync<T>(T[] items, <T, int, .> action) { }
        public static . ForEachWithIndexAsync<T>(T[] items, <T, int, .CancellationToken, .> action, .CancellationToken cancellationToken) { }
    }
    public class ProcessorCountParallelLimit : .
    {
        public ProcessorCountParallelLimit() { }
        public int Limit { get; }
    }
    public sealed class ReferenceEqualityComparer : .<object>
    {
        public static readonly . Instance;
        public bool Equals(object? x, object? y) { }
        public int GetHashCode(object obj) { }
    }
    public static class TestClassTypeHelper
    {
        public static  GetTestClassType(.DataGeneratorMetadata dataGeneratorMetadata) { }
    }
    public static class TestNameGenerator
    {
        public static string GenerateTestName( testClass, .MethodInfo testMethod) { }
        public static string GenerateTestName(string className, string methodName) { }
    }
    public static class TupleFactory
    {
        public static object? CreateTuple([.(..PublicConstructors)]  tupleType, object?[] elements) { }
        public static bool IsTupleType( type) { }
        public static bool TryCreateTupleUsingReflection([.(..PublicConstructors)]  tupleType, object?[] elements, out object? result) { }
    }
    public static class TupleHelper
    {
        [.("Tuple expansion uses reflection as fallback")]
        public static .<object?[]> ExpandTupleArray(object? value) { }
        public static bool IsTupleArrayType( type) { }
        public static bool IsTupleType(. tuple) { }
        public static bool IsTupleType(? type) { }
        public static bool IsTupleType(object? obj) { }
        public static bool ShouldUnwrapForMethodArguments(object? value, int expectedParameterCount) { }
        public static object?[] UnwrapTuple(.? value) { }
        public static object?[] UnwrapTuple(object? value) { }
    }
}
namespace .Hooks
{
    public class AfterAssemblyHookMethod : .<.AssemblyHookContext>, <.>
    {
        public AfterAssemblyHookMethod() { }
        public override . ExecuteAsync(.AssemblyHookContext context, .CancellationToken cancellationToken) { }
    }
    public class AfterClassHookMethod : .<.ClassHookContext>, <.>
    {
        public AfterClassHookMethod() { }
        public override . ExecuteAsync(.ClassHookContext context, .CancellationToken cancellationToken) { }
    }
    public class AfterTestDiscoveryHookMethod : .<.TestDiscoveryContext>, <.>
    {
        public AfterTestDiscoveryHookMethod() { }
        public override . ExecuteAsync(.TestDiscoveryContext context, .CancellationToken cancellationToken) { }
    }
    public class AfterTestHookMethod : .<.TestContext>, <.>
    {
        public AfterTestHookMethod() { }
        public override . ExecuteAsync(.TestContext context, .CancellationToken cancellationToken) { }
    }
    public class AfterTestSessionHookMethod : .<.TestSessionContext>, <.>
    {
        public AfterTestSessionHookMethod() { }
        public override . ExecuteAsync(.TestSessionContext context, .CancellationToken cancellationToken) { }
    }
    public class BeforeAssemblyHookMethod : .<.AssemblyHookContext>, <.>
    {
        public BeforeAssemblyHookMethod() { }
        public override . ExecuteAsync(.AssemblyHookContext context, .CancellationToken cancellationToken) { }
    }
    public class BeforeClassHookMethod : .<.ClassHookContext>, <.>
    {
        public BeforeClassHookMethod() { }
        public override . ExecuteAsync(.ClassHookContext context, .CancellationToken cancellationToken) { }
    }
    public class BeforeTestDiscoveryHookMethod : .<.BeforeTestDiscoveryContext>, <.>
    {
        public BeforeTestDiscoveryHookMethod() { }
        public override . ExecuteAsync(.BeforeTestDiscoveryContext context, .CancellationToken cancellationToken) { }
    }
    public class BeforeTestHookMethod : .<.TestContext>, <.>
    {
        public BeforeTestHookMethod() { }
        public override . ExecuteAsync(.TestContext context, .CancellationToken cancellationToken) { }
    }
    public class BeforeTestSessionHookMethod : .<.TestSessionContext>, <.>
    {
        public BeforeTestSessionHookMethod() { }
        public override . ExecuteAsync(.TestSessionContext context, .CancellationToken cancellationToken) { }
    }
    public abstract class HookMethod : <.>
    {
        protected HookMethod() { }
        public virtual .Assembly? Assembly { get; }
        public .<> Attributes { get; }
        [.(..PublicMethods)]
        public abstract  ClassType { get; }
        public required . HookExecutor { get; init; }
        public required .MethodMetadata MethodInfo { get; init; }
        public string Name { get; }
        public required int Order { get; init; }
        public required int RegistrationIndex { get; init; }
        public ? Timeout { get; }
        public TAttribute? GetAttribute<TAttribute>()
            where TAttribute :  { }
    }
    public interface IExecutableHook<in T>
    {
        .MethodMetadata MethodInfo { get; }
        string Name { get; }
        int Order { get; }
        . ExecuteAsync(T context, .CancellationToken cancellationToken);
    }
    public interface IHookMessagePublisher
    {
        . Discover(string sessionId, string displayName, . hookMethod);
        . Push(string sessionId, string displayName, . hookMethod, <.> func);
    }
    public class InstanceHookMethod : ., <.>, .<.TestContext>
    {
        public InstanceHookMethod() { }
        public <object, .TestContext, .CancellationToken, .>? Body { get; init; }
        [.(..PublicMethods)]
        public override  ClassType { get; }
        public required  InitClassType { init; }
        public . ExecuteAsync(.TestContext context, .CancellationToken cancellationToken) { }
    }
    public class LastTestInAssemblyAdapter : .<.AssemblyHookContext>
    {
        public LastTestInAssemblyAdapter(. lastTestInAssemblyEventReceiver, .TestContext testContext) { }
        public .MethodMetadata MethodInfo { get; }
        public string Name { get; }
        public int Order { get; }
        public bool Execute(.AssemblyHookContext context, .CancellationToken cancellationToken) { }
        public . ExecuteAsync(.AssemblyHookContext context, .CancellationToken cancellationToken) { }
    }
    [.("Method with DynamicallyAccessedMembersAttribute accessed via reflection")]
    public class LastTestInClassAdapter : .<.ClassHookContext>
    {
        public LastTestInClassAdapter(. lastTestInClassEventReceiver, .TestContext testContext) { }
        public .MethodMetadata MethodInfo { get; }
        public string Name { get; }
        public int Order { get; }
        public bool Execute(.ClassHookContext context, .CancellationToken cancellationToken) { }
        public . ExecuteAsync(.ClassHookContext context, .CancellationToken cancellationToken) { }
    }
    public abstract class StaticHookMethod : ., <.>
    {
        protected StaticHookMethod() { }
        [.(..PublicMethods)]
        public override  ClassType { get; }
        public required string FilePath { get; init; }
        public required int LineNumber { get; init; }
    }
    public abstract class StaticHookMethod<T> : ., <.<T>>, .<T>
    {
        protected StaticHookMethod() { }
        public <T, .CancellationToken, .>? Body { get; init; }
        public abstract . ExecuteAsync(T context, .CancellationToken cancellationToken);
    }
}
namespace .Interfaces
{
    public sealed class CompileTimeResolvedData
    {
        public CompileTimeResolvedData() { }
        public .<object?[]> ClassData { get; init; }
        public .<object?[]> MethodData { get; init; }
        public .<string, object?> PropertyData { get; init; }
        public .<.IDataSourceAttribute> UnresolvedAttributes { get; init; }
    }
    public interface IAotCompatibleAsyncDataSource : . { }
    public interface IAotCompatibleDataSource : . { }
    public interface IAsyncDataSource
    {
        .<<object?[]>> GenerateDataFactoriesAsync(.DataSourceContext context, .CancellationToken cancellationToken = default);
    }
    public interface IAsyncDiscoveryInitializer : . { }
    public interface IAsyncInitializer
    {
        . InitializeAsync();
    }
    public interface IClassConstructor
    {
        .<object> Create([.(..PublicConstructors)]  type, .ClassConstructorMetadata classConstructorMetadata);
    }
    public interface ICompileTimeDataResolver
    {
        bool CanResolveAtCompileTime(.IDataSourceAttribute dataAttribute);
        .<.<object?[]>> ResolveClassDataAsync(.ClassMetadata classMetadata);
        .<.<object?[]>> ResolveMethodDataAsync(.MethodMetadata methodMetadata);
        .<.<string, object?>> ResolvePropertyDataAsync(.ClassMetadata classMetadata);
    }
    public interface IConfiguration
    {
        string? Get(string key);
    }
    public interface IContext
    {
        .TextWriter ErrorOutputWriter { get; }
        .TextWriter OutputWriter { get; }
        . GetDefaultLogger();
    }
    public interface IDataSource
    {
        .<<object?[]>> GenerateDataFactories(.DataSourceContext context);
    }
    public interface IDisposer
    {
        . DisposeAsync(object? obj);
    }
    public interface IEventReceiver
    {
        int Order { get; }
    }
    public interface IExecutionOrder
    {
        int Order { get; }
        int Priority { get; }
    }
    public interface IFirstTestInAssemblyEventReceiver : .
    {
        . OnFirstTestInAssembly(.AssemblyHookContext context, .TestContext testContext);
    }
    public interface IFirstTestInClassEventReceiver : .
    {
        . OnFirstTestInClass(.ClassHookContext context, .TestContext testContext);
    }
    public interface IFirstTestInTestSessionEventReceiver : .
    {
        . OnFirstTestInTestSession(.TestSessionContext current, .TestContext testContext);
    }
    public interface IGenericTypeResolver
    {
        [] ResolveGenericClassArguments([.(..PublicConstructors)]  genericTypeDefinition, object?[] constructorArguments);
        [] ResolveGenericMethodArguments(.MethodInfo genericMethodDefinition, object?[] runtimeArguments);
    }
    public interface IHasLoggers
    {
        .<.> Loggers { get; }
    }
    public interface IHookExecutor
    {
        . ExecuteAfterAssemblyHook(.MethodMetadata hookMethodInfo, .AssemblyHookContext context, <.> action);
        . ExecuteAfterClassHook(.MethodMetadata hookMethodInfo, .ClassHookContext context, <.> action);
        . ExecuteAfterTestDiscoveryHook(.MethodMetadata hookMethodInfo, .TestDiscoveryContext context, <.> action);
        . ExecuteAfterTestHook(.MethodMetadata hookMethodInfo, .TestContext context, <.> action);
        . ExecuteAfterTestSessionHook(.MethodMetadata hookMethodInfo, .TestSessionContext context, <.> action);
        . ExecuteBeforeAssemblyHook(.MethodMetadata hookMethodInfo, .AssemblyHookContext context, <.> action);
        . ExecuteBeforeClassHook(.MethodMetadata hookMethodInfo, .ClassHookContext context, <.> action);
        . ExecuteBeforeTestDiscoveryHook(.MethodMetadata hookMethodInfo, .BeforeTestDiscoveryContext context, <.> action);
        . ExecuteBeforeTestHook(.MethodMetadata hookMethodInfo, .TestContext context, <.> action);
        . ExecuteBeforeTestSessionHook(.MethodMetadata hookMethodInfo, .TestSessionContext context, <.> action);
    }
    public interface IHookRegisteredEventReceiver : .
    {
        . OnHookRegistered(.HookRegisteredContext context);
    }
    public interface IInfersType<T> { }
    public interface IKeyedDataSource
    {
        string Key { get; set; }
    }
    public interface ILastTestInAssemblyEventReceiver : .
    {
        . OnLastTestInAssembly(.AssemblyHookContext context, .TestContext testContext);
    }
    public interface ILastTestInClassEventReceiver : .
    {
        . OnLastTestInClass(.ClassHookContext context, .TestContext testContext);
    }
    public interface ILastTestInTestSessionEventReceiver : .
    {
        . OnLastTestInTestSession(.TestSessionContext current, .TestContext testContext);
    }
    public interface IParallelConstraint { }
    public interface IParallelLimit
    {
        int Limit { get; }
    }
    public interface ISourceGeneratedTestRegistry
    {
        <object>? GetClassFactory(string testId);
        <object, object?[], .<object?>>? GetMethodInvoker(string testId);
        <object?[], object>? GetParameterizedClassFactory(string testId);
        .<string> GetRegisteredTestIds();
        void RegisterClassFactory(string testId, <object> factory);
        void RegisterClassFactory(string testId, <object?[], object> factory);
        void RegisterMethodInvoker(string testId, <object, object?[], .<object?>> invoker);
    }
    public interface ITUnitPlugin : ., ., ., ., ., ., . { }
    public interface ITestClass
    {
        [] ClassGenericArguments { get; }
        object ClassInstance { get; }
        [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods | ..PublicProperties)]
         ClassType { get; }
        object?[] TestClassArguments { get; }
        .<string, object?> TestClassInjectedPropertyArguments { get; }
        []? TestClassParameterTypes { get; }
    }
    public interface ITestConfiguration
    {
        int RetryBackoffMs { get; }
        double RetryBackoffMultiplier { get; }
        int RetryLimit { get; }
        ? Timeout { get; }
    }
    public interface ITestDependencies
    {
        .<.TestDetails> DependsOn { get; }
        string? ParentTestId { get; }
        . Relationship { get; }
        .<.TestContext> GetTests(<.TestContext, bool> predicate);
        .<.TestContext> GetTests(string testName);
        .<.TestContext> GetTests(string testName,  classType);
    }
    public interface ITestDetailsMetadata
    {
        .<, .<>> AttributesByType { get; }
        .<string> Categories { get; }
        .<string, .<string>> CustomProperties { get; }
        .<> GetAllAttributes();
        .<T> GetAttributes<T>()
            where T : ;
        bool HasAttribute<T>()
            where T : ;
    }
    public interface ITestDiscoveryEventReceiver : .
    {
        . OnTestDiscovered(.DiscoveredTestContext context);
    }
    public interface ITestEndEventReceiver : .
    {
        . Stage { get; }
        . OnTestEnd(.TestContext context);
    }
    public interface ITestEvents
    {
        .AsyncEvent<.TestContext>? OnDispose { get; }
        .AsyncEvent<.TestContext>? OnInitialize { get; }
        .AsyncEvent<.TestContext>? OnTestEnd { get; }
        .AsyncEvent<.TestContext>? OnTestRegistered { get; }
        [.(new string[] {
                "TestContext",
                "RetryAttempt"})]
        .AsyncEvent<<.TestContext, int>>? OnTestRetry { get; }
        .AsyncEvent<.TestContext>? OnTestSkipped { get; }
        .AsyncEvent<.TestContext>? OnTestStart { get; }
    }
    public interface ITestExecution
    {
        .CancellationToken CancellationToken { get; }
        int CurrentRetryAttempt { get; }
        .? CustomHookExecutor { get; set; }
        bool IsNotDiscoverable { get; set; }
        .TestPhase Phase { get; }
        bool ReportResult { get; set; }
        .TestResult? Result { get; }
        <.TestContext, , int, .<bool>>? RetryFunc { get; }
        string? SkipReason { get; }
        ? TestEnd { get; }
        ? TestStart { get; }
        void AddLinkedCancellationToken(.CancellationToken cancellationToken);
        void OverrideResult(.TestState state, string reason);
    }
    public interface ITestExecutor
    {
        . ExecuteTest(.TestContext context, <.> action);
    }
    public interface ITestFinder
    {
        .<.TestContext> GetTests( classType);
        .TestContext[] GetTestsByNameAndParameters(string testName, .<> methodParameterTypes,  classType, .<> classParameterTypes, .<object?> classArguments);
    }
    public interface ITestIdentity
    {
        string MethodName { get; }
        string TestId { get; }
        string TestName { get; }
    }
    public interface ITestIsolation
    {
        int UniqueId { get; }
        string GetIsolatedName(string baseName);
        string GetIsolatedPrefix(string separator = "_");
    }
    public interface ITestLocation
    {
        string TestFilePath { get; }
        int TestLineNumber { get; }
    }
    public interface ITestMetadata
    {
        string DefinitionId { get; }
        string DisplayName { get; set; }
        ? DisplayNameFormatter { get; set; }
        .TestDetails TestDetails { get; }
        string TestName { get; }
    }
    public interface ITestMethod
    {
        [] MethodGenericArguments { get; }
        .MethodMetadata MethodMetadata { get; }
         ReturnType { get; }
        object?[] TestMethodArguments { get; }
    }
    public interface ITestNameFormatter
    {
        string BuildTestId(string template, int testIndex, int repeatIndex = 0, int classDataIndex = 0, int methodDataIndex = 0);
        string FormatArgumentValue(object? value);
        string FormatTestName(string template, object?[]? classArgs = null, object?[]? methodArgs = null, .<string, object?>? propertyValues = null);
    }
    public interface ITestOutput
    {
        .<.Artifact> Artifacts { get; }
        .TextWriter ErrorOutput { get; }
        .TextWriter StandardOutput { get; }
        .<.Timing> Timings { get; }
        void AttachArtifact(.Artifact artifact);
        void AttachArtifact(string filePath, string? displayName = null, string? description = null);
        string GetErrorOutput();
        string GetStandardOutput();
        void RecordTiming(.Timing timing);
        void WriteError(string message);
        void WriteLine(string message);
    }
    public interface ITestParallelization
    {
        .<.> Constraints { get; }
        . ExecutionPriority { get; set; }
        .? Limiter { get; }
        void AddConstraint(. constraint);
    }
    public interface ITestRegisteredEventReceiver : .
    {
        . OnTestRegistered(.TestRegisteredContext context);
    }
    public interface ITestRegistry
    {
        [.("Adding dynamic tests requires runtime compilation and reflection which are not su" +
            "pported in native AOT scenarios.")]
        . AddDynamicTest<[.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..NonPublicConstructors | ..PublicMethods | ..NonPublicMethods | ..PublicFields | ..NonPublicFields | ..PublicProperties)]  T>(.TestContext context, .DynamicTest<T> dynamicTest)
            where T :  class;
        [.("Creating test variants requires runtime compilation and reflection which are not " +
            "supported in native AOT scenarios.")]
        . CreateTestVariant(.TestContext currentContext, object?[]? arguments, .<string, object?>? properties, . relationship, string? displayName);
    }
    public interface ITestRetryEventReceiver : .
    {
        . OnTestRetry(.TestContext context, int retryAttempt);
    }
    public interface ITestSkippedEventReceiver : .
    {
        . OnTestSkipped(.TestContext context);
    }
    public interface ITestStartEventReceiver : .
    {
        . Stage { get; }
        . OnTestStart(.TestContext context);
    }
    public interface ITestStateBag
    {
        int Count { get; }
        object? this[string key] { get; set; }
        .<string, object?> Items { get; }
        bool ContainsKey(string key);
        T GetOrAdd<T>(string key, <string, T> valueFactory);
        bool TryGetValue<T>(string key, [.(false)] out T value);
        bool TryRemove(string key, [.(false)] out object? value);
    }
    public interface ITypedTestMetadata
    {
        [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods | ..PublicProperties)]
         TestClassType { get; }
    }
}
namespace .
{
    public interface IPropertySource
    {
        bool ShouldInitialize { get; }
         Type { get; }
        .<..PropertyInjectionMetadata> GetPropertyMetadata();
    }
    public interface ITestDescriptorSource
    {
        .<.TestDescriptor> EnumerateTestDescriptors();
    }
    public interface ITestSource
    {
        .<.TestMetadata> GetTestsAsync(string testSessionId, .CancellationToken cancellationToken = default);
    }
    public sealed class PropertyInjectionMetadata
    {
        public PropertyInjectionMetadata() { }
        [.(..None | ..PublicProperties | ..NonPublicProperties)]
        public required  ContainingType { get; init; }
        public required <.IDataSourceAttribute> CreateDataSource { get; init; }
        public required string PropertyName { get; init; }
        [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..NonPublicConstructors | ..PublicProperties)]
        public required  PropertyType { get; init; }
        public required <object, object?> SetProperty { get; init; }
    }
}
namespace .Logging
{
    public class DefaultLogger : .
    {
        public DefaultLogger(.Context context) { }
        protected .Context Context { get; }
        protected virtual string GenerateMessage(string message, ? exception, . logLevel) { }
        public override void Log<TState>(. logLevel, TState state, ? exception, <TState, ?, string> formatter) { }
        public override . LogAsync<TState>(. logLevel, TState state, ? exception, <TState, ?, string> formatter) { }
        public void PushProperties(.<string, .<object>> dictionary) { }
        public void PushProperty(string name, object? value) { }
        protected virtual void WriteToOutput(string message, bool isError) { }
        protected virtual . WriteToOutputAsync(string message, bool isError) { }
    }
    public interface ILogSink
    {
        bool IsEnabled(. level);
        void Log(. level, string message, ? exception, .Context? context);
        . LogAsync(. level, string message, ? exception, .Context? context);
    }
    public interface ILogger
    {
        bool IsEnabled(. logLevel);
        void Log<TState>(. logLevel, TState state, ? exception, <TState, ?, string> formatter);
        . LogAsync<TState>(. logLevel, TState state, ? exception, <TState, ?, string> formatter);
    }
    public interface ILogger<out TCategoryName> : . { }
    public enum LogLevel
    {
        Trace = 0,
        Debug = 1,
        Information = 2,
        Warning = 3,
        Error = 4,
        Critical = 5,
        None = 6,
    }
    public static class LoggingExtensions
    {
        public static void LogCritical(this . logger, string message) { }
        public static . LogCriticalAsync(this . logger, string message) { }
        public static void LogDebug(this . logger, string message) { }
        public static . LogDebugAsync(this . logger, string message) { }
        public static void LogError(this . logger,  ex) { }
        public static void LogError(this . logger, string message) { }
        public static void LogError(this . logger, string message,  ex) { }
        public static . LogErrorAsync(this . logger,  ex) { }
        public static . LogErrorAsync(this . logger, string message) { }
        public static . LogErrorAsync(this . logger, string message,  ex) { }
        public static void LogInformation(this . logger, string message) { }
        public static . LogInformationAsync(this . logger, string message) { }
        public static void LogTrace(this . logger, string message) { }
        public static . LogTraceAsync(this . logger, string message) { }
        public static void LogWarning(this . logger, string message) { }
        public static . LogWarningAsync(this . logger, string message) { }
    }
    public abstract class TUnitLogger : .
    {
        protected TUnitLogger() { }
        public virtual bool IsEnabled(. logLevel) { }
        public abstract void Log<TState>(. logLevel, TState state, ? exception, <TState, ?, string> formatter);
        public abstract . LogAsync<TState>(. logLevel, TState state, ? exception, <TState, ?, string> formatter);
    }
    public static class TUnitLoggerFactory
    {
        public static void AddSink(. sink) { }
        public static void AddSink<TSink>()
            where TSink : ., new () { }
    }
}
namespace .Models
{
    public enum ExecutionContextType
    {
        Parallel = 0,
        NotInParallel = 1,
        KeyedNotInParallel = 2,
        ParallelGroup = 3,
    }
    public class TestExecutionContext : <.>
    {
        public TestExecutionContext() { }
        public required . ContextType { get; init; }
        public string? GroupKey { get; init; }
        public int? Order { get; init; }
    }
    public class TestExecutionData
    {
        public TestExecutionData() { }
        public <.DataGeneratorMetadata, .CancellationToken, .<.<object?[]?>>>? AsyncDataExecutor { get; set; }
        public <.DataGeneratorMetadata, .CancellationToken, .<.<<.<object?[]?>>>>>? AsyncDataSourceResolver { get; set; }
        public <.<.<object?[]>>>? AsyncMethodDataResolver { get; set; }
        public ? ClassFactory { get; set; }
        public bool HasAsyncDataSource { get; }
        public bool HasMethodDataResolver { get; }
        public bool HasStronglyTypedDelegates { get; }
        public <.<object?[]>>? MethodDataResolver { get; set; }
        public ? MethodInvoker { get; set; }
    }
}
namespace .PropertyInjection
{
    public static class PropertyCacheKeyGenerator
    {
        public static string GetCacheKey(.PropertyInfo property) { }
        public static string GetCacheKey(..PropertyInjectionMetadata metadata) { }
    }
}
namespace .Services
{
    [.("Generic type resolution requires runtime type generation")]
    public class GenericTypeResolver : .
    {
        public GenericTypeResolver() { }
        public [] ResolveGenericClassArguments([.(..PublicConstructors)]  genericTypeDefinition, object?[] constructorArguments) { }
        public [] ResolveGenericMethodArguments(.MethodInfo genericMethodDefinition, object?[] runtimeArguments) { }
    }
    public interface IContextProvider
    {
        .BeforeTestDiscoveryContext BeforeTestDiscoveryContext { get; }
        .TestDiscoveryContext TestDiscoveryContext { get; }
        .TestSessionContext TestSessionContext { get; }
        .TestContext CreateTestContext(string testName, [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods | ..PublicProperties)]  classType, .TestBuilderContext testBuilderContext, .CancellationToken cancellationToken);
        .AssemblyHookContext GetOrCreateAssemblyContext(.Assembly assembly);
        .ClassHookContext GetOrCreateClassContext([.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods | ..PublicProperties)]  classType);
    }
    public static class ModeDetector
    {
        public static bool IsSourceGenerationAvailable { get; }
    }
    public class NoOpGenericTypeResolver : .
    {
        public NoOpGenericTypeResolver() { }
        public [] ResolveGenericClassArguments([.(..PublicConstructors)]  genericTypeDefinition, object?[] constructorArguments) { }
        public [] ResolveGenericMethodArguments(.MethodInfo genericMethodDefinition, object?[] runtimeArguments) { }
    }
    public static class ServiceProviderExtensions
    {
        public static object GetRequiredService(this  serviceProvider,  serviceType) { }
        public static T GetRequiredService<T>(this  serviceProvider)
            where T :  class { }
        public static T? GetService<T>(this  serviceProvider)
            where T :  class { }
    }
    public class TestExecutionRegistry : .
    {
        public TestExecutionRegistry() { }
        public static . Instance { get; }
        public void Clear() { }
        public <.DataGeneratorMetadata, .CancellationToken, .<.<object?[]?>>>? GetAsyncDataExecutor(string testId) { }
        public <.DataGeneratorMetadata, .CancellationToken, .<.<<.<object?[]?>>>>>? GetAsyncDataSourceResolver(string testId) { }
        public <.<.<object?[]>>>? GetAsyncMethodDataResolver(string testId) { }
        public <object>? GetClassFactory(string testId) { }
        public <.<object?[]>>? GetMethodDataResolver(string testId) { }
        public <object, object?[], .<object?>>? GetMethodInvoker(string testId) { }
        public . GetOrCreateTestData(string testId) { }
        public <object?[], object>? GetParameterizedClassFactory(string testId) { }
        public .<string> GetRegisteredTestIds() { }
        public T? GetStronglyTypedClassFactory<T>(string testId)
            where T :  { }
        public T? GetStronglyTypedMethodInvoker<T>(string testId)
            where T :  { }
        public .? GetTestData(string testId) { }
        public bool HasAsyncDataSourceResolver(string testId) { }
        public bool HasMethodDataResolver(string testId) { }
        public bool HasStronglyTypedFactory(string testId) { }
        public void RegisterAsyncDataExecutor(string testId, <.DataGeneratorMetadata, .CancellationToken, .<.<object?[]?>>> executor) { }
        public void RegisterAsyncDataSourceResolver(string testId, <.DataGeneratorMetadata, .CancellationToken, .<.<<.<object?[]?>>>>> resolver) { }
        public void RegisterAsyncMethodDataResolver(string testId, <.<.<object?[]>>> resolver) { }
        public void RegisterClassFactory(string testId, <object> factory) { }
        public void RegisterClassFactory(string testId, <object?[], object> factory) { }
        public void RegisterMethodDataResolver(string testId, <.<object?[]>> resolver) { }
        public void RegisterMethodInvoker(string testId, <object, object?[], .<object?>> invoker) { }
        public void RegisterStronglyTypedClassFactory<T>(string testId,  factory)
            where T :  class { }
        public void RegisterStronglyTypedClassFactory<T>(string testId, <T> factory)
            where T :  class { }
        public void RegisterStronglyTypedMethodInvoker<T>(string testId,  invoker)
            where T :  class { }
        public void RegisterTest(string testId, . data) { }
    }
    public class TestNameFormatter : .
    {
        public TestNameFormatter() { }
        public string BuildTestId(string template, int testIndex, int repeatIndex = 0, int classDataIndex = 0, int methodDataIndex = 0) { }
        public string FormatArgumentValue(object? value) { }
        public string FormatTestName(string template, object?[]? classArgs = null, object?[]? methodArgs = null, .<string, object?>? propertyValues = null) { }
    }
    public class TestServiceProvider : 
    {
        public TestServiceProvider() { }
        public . AddSingleton( serviceType, object service) { }
        public . AddSingleton<T>(T service)
            where T :  class { }
        public . AddTransient( serviceType, <object> factory) { }
        public . AddTransient<T>(<T> factory)
            where T :  class { }
        public object? GetService( serviceType) { }
    }
}
namespace .StaticProperties
{
    public sealed class StaticPropertyMetadata
    {
        public StaticPropertyMetadata() { }
        public required  DeclaringType { get; init; }
        public required <.<object?>> InitializerAsync { get; init; }
        public required string PropertyName { get; init; }
        public required  PropertyType { get; init; }
    }
    public static class StaticPropertyRegistry
    {
        public static .<.> GetRegisteredProperties() { }
        public static void Register(. metadata) { }
        public static bool TryGetInitializedValue( declaringType, string propertyName, out object? value) { }
    }
}