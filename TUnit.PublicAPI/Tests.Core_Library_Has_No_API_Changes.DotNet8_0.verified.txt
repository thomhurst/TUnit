[assembly: .(@", PublicKey=0024000004800000940000000602000000240000525341310004000001000100698a70398fa0b2230c5a72e3bd9d56b48f809f6173e49a19fbb942d621be93ad48c5566b47b28faabc359b9ad3ff4e00bbdea88f5bdfa250f391fedd28182b2e37b55d429c0151a42a98ea7a5821818cd15a79fef9903e8607a88304cf3e0317bf86ec96e32e1381535a6582251e5a6eed40b5a3ed82bc444598b1269cce57a7")]
[assembly: .(@", PublicKey=0024000004800000940000000602000000240000525341310004000001000100698a70398fa0b2230c5a72e3bd9d56b48f809f6173e49a19fbb942d621be93ad48c5566b47b28faabc359b9ad3ff4e00bbdea88f5bdfa250f391fedd28182b2e37b55d429c0151a42a98ea7a5821818cd15a79fef9903e8607a88304cf3e0317bf86ec96e32e1381535a6582251e5a6eed40b5a3ed82bc444598b1269cce57a7")]
[assembly: .(".NETCoreApp,Version=v8.0", FrameworkDisplayName=".NET 8.0")]
namespace 
{
    [(.Method)]
    public sealed class AfterAttribute : .HookAttribute
    {
        public AfterAttribute(.HookType hookType, [.] string file = "", [.] int line = 0) { }
    }
    [(.Method)]
    public sealed class AfterEveryAttribute : .HookAttribute
    {
        public AfterEveryAttribute(.HookType hookType, [.] string file = "", [.] int line = 0) { }
    }
    public abstract class ArgumentDisplayFormatter
    {
        protected ArgumentDisplayFormatter() { }
        public abstract bool CanHandle(object? value);
        public abstract string FormatValue(object? value);
    }
    public abstract class ArgumentDisplayFormatterAttribute : .TUnitAttribute, ., .
    {
        protected ArgumentDisplayFormatterAttribute() { }
        public abstract .ArgumentDisplayFormatter Formatter { get; }
        public virtual int Order { get; }
        public . OnTestDiscovered(.DiscoveredTestContext context) { }
    }
    [(.Assembly | .Class | .Method, AllowMultiple=true)]
    public class ArgumentDisplayFormatterAttribute<T> : .ArgumentDisplayFormatterAttribute
        where T : .ArgumentDisplayFormatter, new ()
    {
        public ArgumentDisplayFormatterAttribute() { }
        public override .ArgumentDisplayFormatter Formatter { get; }
    }
    [(.Class | .Method | .Property, AllowMultiple=true)]
    public sealed class ArgumentsAttribute : .TestDataAttribute
    {
        public ArgumentsAttribute(params object?[]? values) { }
        public object?[] Values { get; }
    }
    public class ArgumentsDataProvider : .IDataProvider
    {
        public ArgumentsDataProvider(params object?[] arguments) { }
        public .<.<object?[]>> GetData() { }
    }
    public class Artifact
    {
        public Artifact() { }
        public string? Description { get; init; }
        public required string DisplayName { get; init; }
        public required .FileInfo File { get; init; }
    }
    public class AssemblyHookContext : .Context
    {
        public .<.TestContext> AllTests { get; }
        public required .Assembly Assembly { get; init; }
        public .<.ClassHookContext> TestClasses { get; }
        public int TestCount { get; }
        public .TestSessionContext TestSessionContext { get; }
        public new static .AssemblyHookContext? Current { get; }
        public void AddClass(.ClassHookContext classHookContext) { }
    }
    [.DebuggerDisplay("{Name})")]
    public class AssemblyMetadata : <.AssemblyMetadata>
    {
        public AssemblyMetadata() { }
        public required string Name { get; init; }
        public virtual bool Equals(.AssemblyMetadata? other) { }
        public override int GetHashCode() { }
        public static .AssemblyMetadata GetOrAdd(string name, <.AssemblyMetadata> factory) { }
    }
    public static class AsyncConvert
    {
        public static . Convert( action) { }
        public static . Convert(<.> action) { }
        public static . Convert(<.> action) { }
        public static . ConvertObject(object? invoke) { }
        [.("Trimming", "IL2075:\'this\' argument does not satisfy \'DynamicallyAccessedMembersAttribute\' in " +
            "call to target method. The return value of the source method does not have match" +
            "ing annotations.")]
        public static bool TryGetAwaitableTask(object awaitable, [.(true)] out .? task) { }
    }
    public class AsyncDataGeneratorProvider : .IDataProvider
    {
        public AsyncDataGeneratorProvider(.IAsyncDataSourceGeneratorAttribute generator, .DataGeneratorMetadata metadata) { }
        public .<.<object?[]>> GetData() { }
    }
    [(.Class | .Method | .Property, AllowMultiple=true)]
    public abstract class AsyncDataSourceGeneratorAttribute<T> : .TestDataAttribute, .IAsyncDataSourceGeneratorAttribute, .IDataAttribute, .IRequiresImmediateInitialization
    {
        protected AsyncDataSourceGeneratorAttribute() { }
        [.(typeof(.AsyncDataSourceGeneratorAttribute<T>.<GenerateAsync>d__1))]
        public .<<.<T>>> GenerateAsync(.DataGeneratorMetadata dataGeneratorMetadata) { }
        protected abstract .<<.<T>>> GenerateDataSourcesAsync(.DataGeneratorMetadata dataGeneratorMetadata);
    }
    [(.Class | .Method, AllowMultiple=true)]
    public abstract class AsyncDataSourceGeneratorAttribute<T1, T2> : .TestDataAttribute, .IAsyncDataSourceGeneratorAttribute, .IDataAttribute, .IRequiresImmediateInitialization
    {
        protected AsyncDataSourceGeneratorAttribute() { }
        [.(typeof(.AsyncDataSourceGeneratorAttribute<T1, T2>.<GenerateAsync>d__1))]
        public .<<.<<T1, T2>>>> GenerateAsync(.DataGeneratorMetadata dataGeneratorMetadata) { }
        protected abstract .<<.<<T1, T2>>>> GenerateDataSourcesAsync(.DataGeneratorMetadata dataGeneratorMetadata);
    }
    [(.Class | .Method, AllowMultiple=true)]
    public abstract class AsyncDataSourceGeneratorAttribute<T1, T2, T3> : .TestDataAttribute, .IAsyncDataSourceGeneratorAttribute, .IDataAttribute, .IRequiresImmediateInitialization
    {
        protected AsyncDataSourceGeneratorAttribute() { }
        [.(typeof(.AsyncDataSourceGeneratorAttribute<T1, T2, T3>.<GenerateAsync>d__1))]
        public .<<.<<T1, T2, T3>>>> GenerateAsync(.DataGeneratorMetadata dataGeneratorMetadata) { }
        protected abstract .<<.<<T1, T2, T3>>>> GenerateDataSourcesAsync(.DataGeneratorMetadata dataGeneratorMetadata);
    }
    [(.Class | .Method, AllowMultiple=true)]
    public abstract class AsyncDataSourceGeneratorAttribute<T1, T2, T3, T4> : .TestDataAttribute, .IAsyncDataSourceGeneratorAttribute, .IDataAttribute, .IRequiresImmediateInitialization
    {
        protected AsyncDataSourceGeneratorAttribute() { }
        [.(typeof(.AsyncDataSourceGeneratorAttribute<T1, T2, T3, T4>.<GenerateAsync>d__1))]
        public .<<.<<T1, T2, T3, T4>>>> GenerateAsync(.DataGeneratorMetadata dataGeneratorMetadata) { }
        protected abstract .<<.<<T1, T2, T3, T4>>>> GenerateDataSourcesAsync(.DataGeneratorMetadata dataGeneratorMetadata);
    }
    [(.Class | .Method, AllowMultiple=true)]
    public abstract class AsyncDataSourceGeneratorAttribute<T1, T2, T3, T4, T5> : .TestDataAttribute, .IAsyncDataSourceGeneratorAttribute, .IDataAttribute, .IRequiresImmediateInitialization
    {
        protected AsyncDataSourceGeneratorAttribute() { }
        [.(typeof(.AsyncDataSourceGeneratorAttribute<T1, T2, T3, T4, T5>.<GenerateAsync>d__1))]
        public .<<.<<T1, T2, T3, T4, T5>>>> GenerateAsync(.DataGeneratorMetadata dataGeneratorMetadata) { }
        protected abstract .<<.<<T1, T2, T3, T4, T5>>>> GenerateDataSourcesAsync(.DataGeneratorMetadata dataGeneratorMetadata);
    }
    public sealed class AsyncDelegateDataSource : .TestDataSource
    {
        public AsyncDelegateDataSource(<.CancellationToken, .<object?[]>> asyncFactory, bool isShared = false) { }
        public override bool IsShared { get; }
        public override .<<object?[]>> GetDataFactories() { }
    }
    [("Use AsyncDelegateDataSource instead")]
    public sealed class AsyncDynamicTestDataSource : .TestDataSource
    {
        public AsyncDynamicTestDataSource(bool isShared = false) { }
        public required string FactoryKey { get; init; }
        public override bool IsShared { get; }
        public override .<<object?[]>> GetDataFactories() { }
    }
    public class AsyncEvent<TEventArgs>
    {
        public AsyncEvent() { }
        public int Order { get; set; }
        public static .AsyncEvent<TEventArgs> operator +(.AsyncEvent<TEventArgs>? e, <object, TEventArgs, .> callback) { }
        public class Invocation : .
        {
            public Invocation(<object, TEventArgs, .> factory, int order) { }
            public int Order { get; }
            public . InvokeAsync(object sender, TEventArgs eventArgs) { }
        }
    }
    [(.Class | .Method | .Property, AllowMultiple=true)]
    [.("AsyncUntypedDataSourceGeneratorAttribute requires dynamic code generation for run" +
        "time data source creation. Consider using strongly-typed AsyncDataSourceGenerato" +
        "rAttribute<T> overloads for AOT compatibility.")]
    [.("AsyncUntypedDataSourceGeneratorAttribute may require unreferenced code for runtim" +
        "e data source creation. Consider using strongly-typed AsyncDataSourceGeneratorAt" +
        "tribute<T> overloads for AOT compatibility.")]
    public abstract class AsyncUntypedDataSourceGeneratorAttribute : .TestDataAttribute, .IAsyncDataSourceGeneratorAttribute, .IDataAttribute, .IRequiresImmediateInitialization
    {
        protected AsyncUntypedDataSourceGeneratorAttribute() { }
        [.(typeof(.AsyncUntypedDataSourceGeneratorAttribute.<GenerateAsync>d__1))]
        public .<<.<object?[]?>>> GenerateAsync(.DataGeneratorMetadata dataGeneratorMetadata) { }
        protected abstract .<<.<object?[]?>>> GenerateDataSourcesAsync(.DataGeneratorMetadata dataGeneratorMetadata);
    }
    public abstract class BaseClassConstructorAttribute : .TUnitAttribute, .IDataAttribute
    {
        [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods | ..PublicProperties)]
        public abstract  ClassConstructorType { get; init; }
    }
    [(.Method)]
    public abstract class BaseTestAttribute : .TUnitAttribute
    {
        public readonly string File;
        public readonly int Line;
    }
    [(.Method)]
    public sealed class BeforeAttribute : .HookAttribute
    {
        public BeforeAttribute(.HookType hookType, [.] string file = "", [.] int line = 0) { }
    }
    [(.Method)]
    public sealed class BeforeEveryAttribute : .HookAttribute
    {
        public BeforeEveryAttribute(.HookType hookType, [.] string file = "", [.] int line = 0) { }
    }
    public class BeforeTestDiscoveryContext : .Context
    {
        public .GlobalContext GlobalContext { get; }
        public required string? TestFilter { get; init; }
        public new static .BeforeTestDiscoveryContext? Current { get; }
    }
    [(.Assembly | .Class | .Method, AllowMultiple=true)]
    public class CategoryAttribute : .TUnitAttribute, ., .
    {
        public CategoryAttribute(string category) { }
        public string Category { get; }
        public int Order { get; }
        public . OnTestDiscovered(.DiscoveredTestContext context) { }
    }
    [(.Assembly | .Class)]
    public class ClassConstructorAttribute : .BaseClassConstructorAttribute
    {
        public ClassConstructorAttribute([.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods | ..PublicProperties)]  classConstructorType) { }
        [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods | ..PublicProperties)]
        public override  ClassConstructorType { get; init; }
    }
    [(.Assembly | .Class)]
    public sealed class ClassConstructorAttribute<[.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods | ..PublicProperties)]  T> : .ClassConstructorAttribute
        where T : ., new ()
    {
        public ClassConstructorAttribute() { }
        [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods | ..PublicProperties)]
        public override  ClassConstructorType { get; init; }
    }
    public class ClassConstructorMetadata : <.ClassConstructorMetadata>
    {
        public ClassConstructorMetadata() { }
        public required .TestBuilderContext TestBuilderContext { get; init; }
        public required string TestSessionId { get; init; }
    }
    [(.Class | .Method | .Property, AllowMultiple=true)]
    [.("Trimming", "IL2109:Type derives from type with \'RequiresUnreferencedCodeAttribute\' which can " +
        "break functionality when trimming application code", Justification="The specific constructors (1-5 parameters) are AOT-compatible when used with type" +
        "of() expressions. Only the params constructor is incompatible.")]
    public sealed class ClassDataSourceAttribute : .UntypedDataSourceGeneratorAttribute, .IDataAttribute, .ISharedDataSourceAttribute
    {
        [.("AOT", "IL3050:Calling members annotated with \'RequiresDynamicCodeAttribute\' may break fu" +
            "nctionality when AOT compiling.")]
        [.("Trimming", "IL2026:Members annotated with \'RequiresUnreferencedCodeAttribute\' require dynamic" +
            " access otherwise can break functionality when trimming application code", Justification="<Pending>")]
        public ClassDataSourceAttribute([.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicProperties)]  type) { }
        [.("Reflection")]
        [.("Reflection")]
        public ClassDataSourceAttribute(params [] types) { }
        [.("AOT", "IL3050:Calling members annotated with \'RequiresDynamicCodeAttribute\' may break fu" +
            "nctionality when AOT compiling.")]
        [.("Trimming", "IL2026:Members annotated with \'RequiresUnreferencedCodeAttribute\' require dynamic" +
            " access otherwise can break functionality when trimming application code", Justification="<Pending>")]
        public ClassDataSourceAttribute([.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicProperties)]  type, [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicProperties)]  type2) { }
        [.("AOT", "IL3050:Calling members annotated with \'RequiresDynamicCodeAttribute\' may break fu" +
            "nctionality when AOT compiling.")]
        [.("Trimming", "IL2026:Members annotated with \'RequiresUnreferencedCodeAttribute\' require dynamic" +
            " access otherwise can break functionality when trimming application code", Justification="<Pending>")]
        public ClassDataSourceAttribute([.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicProperties)]  type, [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicProperties)]  type2, [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicProperties)]  type3) { }
        [.("AOT", "IL3050:Calling members annotated with \'RequiresDynamicCodeAttribute\' may break fu" +
            "nctionality when AOT compiling.")]
        [.("Trimming", "IL2026:Members annotated with \'RequiresUnreferencedCodeAttribute\' require dynamic" +
            " access otherwise can break functionality when trimming application code", Justification="<Pending>")]
        public ClassDataSourceAttribute([.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicProperties)]  type, [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicProperties)]  type2, [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicProperties)]  type3, [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicProperties)]  type4) { }
        [.("AOT", "IL3050:Calling members annotated with \'RequiresDynamicCodeAttribute\' may break fu" +
            "nctionality when AOT compiling.")]
        [.("Trimming", "IL2026:Members annotated with \'RequiresUnreferencedCodeAttribute\' require dynamic" +
            " access otherwise can break functionality when trimming application code", Justification="<Pending>")]
        public ClassDataSourceAttribute([.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicProperties)]  type, [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicProperties)]  type2, [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicProperties)]  type3, [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicProperties)]  type4, [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicProperties)]  type5) { }
        public string[] Keys { get; set; }
        public .SharedType[] Shared { get; set; }
        [.("Trimming", "IL2062:The parameter of method has a DynamicallyAccessedMembersAttribute, but the" +
            " value passed to it can not be statically analyzed.")]
        protected override .<<object?[]?>> GenerateDataSources(.DataGeneratorMetadata dataGeneratorMetadata) { }
        public .<string> GetKeys() { }
        public .<.SharedType> GetSharedTypes() { }
    }
    [(.Class | .Method | .Property, AllowMultiple=true)]
    public sealed class ClassDataSourceAttribute<[.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicProperties)]  T> : .DataSourceGeneratorAttribute<T>, .IDataAttribute, .ISharedDataSourceAttribute
    {
        public ClassDataSourceAttribute() { }
        public  ClassType { get; }
        public string Key { get; set; }
        public .SharedType Shared { get; set; }
        protected override .<<T>> GenerateDataSources(.DataGeneratorMetadata dataGeneratorMetadata) { }
        public .<string> GetKeys() { }
        public .<.SharedType> GetSharedTypes() { }
    }
    [(.Class | .Method, AllowMultiple=true)]
    public sealed class ClassDataSourceAttribute<[.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicProperties)]  T1, [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicProperties)]  T2> : .DataSourceGeneratorAttribute<T1, T2>, .IDataAttribute, .ISharedDataSourceAttribute
        where T1 : new()
        where T2 : new()
    {
        public ClassDataSourceAttribute() { }
        public string[] Keys { get; set; }
        public .SharedType[] Shared { get; set; }
        protected override .<<<T1, T2>>> GenerateDataSources(.DataGeneratorMetadata dataGeneratorMetadata) { }
        public .<string> GetKeys() { }
        public .<.SharedType> GetSharedTypes() { }
    }
    [(.Class | .Method, AllowMultiple=true)]
    public sealed class ClassDataSourceAttribute<[.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicProperties)]  T1, [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicProperties)]  T2, [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicProperties)]  T3> : .DataSourceGeneratorAttribute<T1, T2, T3>, .IDataAttribute, .ISharedDataSourceAttribute
        where T1 : new()
        where T2 : new()
        where T3 : new()
    {
        public ClassDataSourceAttribute() { }
        public string[] Keys { get; set; }
        public .SharedType[] Shared { get; set; }
        protected override .<<<T1, T2, T3>>> GenerateDataSources(.DataGeneratorMetadata dataGeneratorMetadata) { }
        public .<string> GetKeys() { }
        public .<.SharedType> GetSharedTypes() { }
    }
    [(.Class | .Method, AllowMultiple=true)]
    public sealed class ClassDataSourceAttribute<[.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicProperties)]  T1, [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicProperties)]  T2, [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicProperties)]  T3, [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicProperties)]  T4> : .DataSourceGeneratorAttribute<T1, T2, T3, T4>, .IDataAttribute, .ISharedDataSourceAttribute
        where T1 : new()
        where T2 : new()
        where T3 : new()
        where T4 : new()
    {
        public ClassDataSourceAttribute() { }
        public string[] Keys { get; set; }
        public .SharedType[] Shared { get; set; }
        protected override .<<<T1, T2, T3, T4>>> GenerateDataSources(.DataGeneratorMetadata dataGeneratorMetadata) { }
        public .<string> GetKeys() { }
        public .<.SharedType> GetSharedTypes() { }
    }
    [(.Class | .Method, AllowMultiple=true)]
    public sealed class ClassDataSourceAttribute<[.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicProperties)]  T1, [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicProperties)]  T2, [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicProperties)]  T3, [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicProperties)]  T4, [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicProperties)]  T5> : .DataSourceGeneratorAttribute<T1, T2, T3, T4, T5>, .IDataAttribute, .ISharedDataSourceAttribute
        where T1 : new()
        where T2 : new()
        where T3 : new()
        where T4 : new()
        where T5 : new()
    {
        public ClassDataSourceAttribute() { }
        public string[] Keys { get; set; }
        public .SharedType[] Shared { get; set; }
        protected override .<<<T1, T2, T3, T4, T5>>> GenerateDataSources(.DataGeneratorMetadata dataGeneratorMetadata) { }
        public .<string> GetKeys() { }
        public .<.SharedType> GetSharedTypes() { }
    }
    public class ClassHookContext : .Context
    {
        public .AssemblyHookContext AssemblyContext { get; }
        public required  ClassType { get; init; }
        public int TestCount { get; }
        public .<.TestContext> Tests { get; }
        public new static .ClassHookContext? Current { get; }
        public void AddTest(.TestContext testContext) { }
        public override bool Equals(object? obj) { }
        public override int GetHashCode() { }
    }
    [.DebuggerDisplay("{Type}")]
    public class ClassMetadata : .MemberMetadata, <.ClassMetadata>
    {
        public ClassMetadata() { }
        public required .AssemblyMetadata Assembly { get; init; }
        public required string? Namespace { get; init; }
        public required .ParameterMetadata[] Parameters { get; init; }
        public required .ClassMetadata? Parent { get; init; }
        public required .PropertyMetadata[] Properties { get; init; }
        [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..NonPublicConstructors | ..PublicMethods | ..NonPublicMethods | ..PublicProperties)]
        public override required  Type { get; init; }
        public required .TypeReference TypeReference { get; init; }
        public virtual bool Equals(.ClassMetadata? other) { }
        public override int GetHashCode() { }
        public static .ClassMetadata GetOrAdd(string name, <.ClassMetadata> factory) { }
    }
    public class CompileTimeDataGeneratorMetadata : .DataGeneratorMetadata, <.CompileTimeDataGeneratorMetadata>
    {
        public CompileTimeDataGeneratorMetadata() { }
    }
    public abstract class Context : , .
    {
        public .TextWriter ErrorOutputWriter { get; }
        public .TextWriter OutputWriter { get; }
        protected .Context? Parent { get; }
        public static .Context Current { get; }
        public void AddAsyncLocalValues() { }
        public void Dispose() { }
        public . GetDefaultLogger() { }
        public string GetErrorOutput() { }
        public string GetStandardOutput() { }
        public void RestoreExecutionContext() { }
    }
    public class CultureExecutor : .DedicatedThreadExecutor
    {
        public CultureExecutor(.CultureInfo cultureInfo) { }
        protected override void ConfigureThread(.Thread thread) { }
    }
    public class DataGeneratorMetadata : <.DataGeneratorMetadata>
    {
        public DataGeneratorMetadata() { }
        public required object?[]? ClassInstanceArguments { get; init; }
        public required .MemberMetadata[] MembersToGenerate { get; init; }
        public required .TestBuilderContextAccessor TestBuilderContext { get; init; }
        public required object? TestClassInstance { get; init; }
        public  TestClassType { get; }
        public required .MethodMetadata TestInformation { get; init; }
        public required string TestSessionId { get; init; }
        public required . Type { get; init; }
    }
    public sealed class DataSourceContext
    {
        public DataSourceContext( testClassType, .DataSourceLevel level, .MemberInfo? targetMember = null, .ParameterInfo? targetParameter = null, .<>? attributes = null, ? serviceProvider = null) { }
        public .<> Attributes { get; }
        public .DataSourceLevel Level { get; }
        public ? ServiceProvider { get; }
        public .MemberInfo? TargetMember { get; }
        public .ParameterInfo? TargetParameter { get; }
        public  TestClassType { get; }
    }
    public class DataSourceException : .TestBuilderException
    {
        public DataSourceException(string dataSourceName,  innerException) { }
        public DataSourceException(string dataSourceName, string message) { }
        public string DataSourceName { get; }
    }
    [(.Class | .Method | .Property, AllowMultiple=true)]
    public abstract class DataSourceGeneratorAttribute<T> : .AsyncDataSourceGeneratorAttribute<T>
    {
        protected DataSourceGeneratorAttribute() { }
        protected abstract .<<T>> GenerateDataSources(.DataGeneratorMetadata dataGeneratorMetadata);
        [.(typeof(.DataSourceGeneratorAttribute<T>.<GenerateDataSourcesAsync>d__1))]
        protected override .<<.<T>>> GenerateDataSourcesAsync(.DataGeneratorMetadata dataGeneratorMetadata) { }
    }
    [(.Class | .Method, AllowMultiple=true)]
    public abstract class DataSourceGeneratorAttribute<T1, T2> : .AsyncDataSourceGeneratorAttribute<T1, T2>
    {
        protected DataSourceGeneratorAttribute() { }
        protected abstract .<<<T1, T2>>> GenerateDataSources(.DataGeneratorMetadata dataGeneratorMetadata);
        [.(typeof(.DataSourceGeneratorAttribute<T1, T2>.<GenerateDataSourcesAsync>d__1))]
        protected override .<<.<<T1, T2>>>> GenerateDataSourcesAsync(.DataGeneratorMetadata dataGeneratorMetadata) { }
    }
    [(.Class | .Method, AllowMultiple=true)]
    public abstract class DataSourceGeneratorAttribute<T1, T2, T3> : .AsyncDataSourceGeneratorAttribute<T1, T2, T3>
    {
        protected DataSourceGeneratorAttribute() { }
        protected abstract .<<<T1, T2, T3>>> GenerateDataSources(.DataGeneratorMetadata dataGeneratorMetadata);
        [.(typeof(.DataSourceGeneratorAttribute<T1, T2, T3>.<GenerateDataSourcesAsync>d__1))]
        protected override sealed .<<.<<T1, T2, T3>>>> GenerateDataSourcesAsync(.DataGeneratorMetadata dataGeneratorMetadata) { }
    }
    [(.Class | .Method, AllowMultiple=true)]
    public abstract class DataSourceGeneratorAttribute<T1, T2, T3, T4> : .AsyncDataSourceGeneratorAttribute<T1, T2, T3, T4>
    {
        protected DataSourceGeneratorAttribute() { }
        protected abstract .<<<T1, T2, T3, T4>>> GenerateDataSources(.DataGeneratorMetadata dataGeneratorMetadata);
        [.(typeof(.DataSourceGeneratorAttribute<T1, T2, T3, T4>.<GenerateDataSourcesAsync>d__1))]
        protected override .<<.<<T1, T2, T3, T4>>>> GenerateDataSourcesAsync(.DataGeneratorMetadata dataGeneratorMetadata) { }
    }
    [(.Class | .Method, AllowMultiple=true)]
    public abstract class DataSourceGeneratorAttribute<T1, T2, T3, T4, T5> : .AsyncDataSourceGeneratorAttribute<T1, T2, T3, T4, T5>
    {
        protected DataSourceGeneratorAttribute() { }
        protected abstract .<<<T1, T2, T3, T4, T5>>> GenerateDataSources(.DataGeneratorMetadata dataGeneratorMetadata);
        [.(typeof(.DataSourceGeneratorAttribute<T1, T2, T3, T4, T5>.<GenerateDataSourcesAsync>d__1))]
        protected override .<<.<<T1, T2, T3, T4, T5>>>> GenerateDataSourcesAsync(.DataGeneratorMetadata dataGeneratorMetadata) { }
    }
    public enum DataSourceLevel
    {
        Class = 0,
        Method = 1,
        Property = 2,
        Parameter = 3,
    }
    public class DedicatedThreadExecutor : .GenericAbstractExecutor, ., .
    {
        public DedicatedThreadExecutor() { }
        protected virtual void CleanUp() { }
        protected virtual void ConfigureThread(.Thread thread) { }
        protected override sealed . ExecuteAsync(<.> action) { }
        protected virtual void Initialize() { }
        public . OnTestRegistered(.TestRegisteredContext context) { }
    }
    public class DefaultExecutor : .GenericAbstractExecutor
    {
        public static readonly .DefaultExecutor Instance;
        protected override . ExecuteAsync(<.> action) { }
    }
    public sealed class DelegateDataSource : .TestDataSource
    {
        public DelegateDataSource(<.<object?[]>> factory, bool isShared = false) { }
        public override bool IsShared { get; }
        public override .<<object?[]>> GetDataFactories() { }
    }
    [.("DependencyInjectionDataSourceAttribute requires dynamic code generation for depen" +
        "dency injection container access. This attribute is inherently incompatible with" +
        " AOT compilation.")]
    [.("DependencyInjectionDataSourceAttribute may require unreferenced code for dependen" +
        "cy injection container access. This attribute is inherently incompatible with AO" +
        "T compilation.")]
    public abstract class DependencyInjectionDataSourceAttribute<TScope> : .UntypedDataSourceGeneratorAttribute
    {
        protected DependencyInjectionDataSourceAttribute() { }
        public abstract object? Create(TScope scope,  type);
        public abstract TScope CreateScope(.DataGeneratorMetadata dataGeneratorMetadata);
        protected override .<<object?[]?>> GenerateDataSources(.DataGeneratorMetadata dataGeneratorMetadata) { }
    }
    [(.Class | .Method, AllowMultiple=true)]
    public class DependsOnAttribute : .TUnitAttribute
    {
        public DependsOnAttribute( testClass) { }
        public DependsOnAttribute(string testName) { }
        public DependsOnAttribute( testClass, string testName) { }
        public DependsOnAttribute(string testName, [] parameterTypes) { }
        public DependsOnAttribute( testClass, string testName, [] parameterTypes) { }
        public ? ClassMetadata { get; }
        public []? ParameterTypes { get; }
        public bool ProceedOnFailure { get; set; }
        public string? TestName { get; }
        public override string ToString() { }
        public .TestDependency ToTestDependency() { }
    }
    [(.Class | .Method, AllowMultiple=true)]
    public class DependsOnAttribute<T> : .DependsOnAttribute
    {
        public DependsOnAttribute() { }
        public DependsOnAttribute(string testName) { }
        public DependsOnAttribute(string testName, [] parameterTypes) { }
    }
    public abstract class DiscoveredTest
    {
        protected DiscoveredTest() { }
        public required .TestContext TestContext { get; init; }
        public .TestDetails TestDetails { get; }
        public .? TestExecutor { get; set; }
    }
    public class DiscoveredTestContext
    {
        public DiscoveredTestContext(string testName, string displayName, .TestDetails testDetails) { }
        public .<<object?, string?>> ArgumentDisplayFormatters { get; }
        public string DisplayName { get; }
        public bool RunOnTestDiscovery { get; }
        public .TestDetails TestDetails { get; }
        public string TestName { get; }
        public void AddArgumentDisplayFormatter(.ArgumentDisplayFormatter formatter) { }
        public void AddCategory(string category) { }
        public void AddProperty(string key, string value) { }
        public string GetTestDisplayName() { }
        public void SetDisplayName(string displayName) { }
        public void SetDisplayNameFormatter( formatterType) { }
        public void SetParallelConstraint(object constraint) { }
        public void SetPriority(. priority) { }
        public void SetRetryCount(int retryCount, <.TestContext, , int, .<bool>> shouldRetry) { }
        public void SetRetryLimit(int retryLimit) { }
        public void SetRunOnDiscovery(bool runOnDiscovery) { }
        public void TransferTo(.TestContext testContext) { }
    }
    public class DiscoveredTest<T> : .DiscoveredTest
        where T :  class
    {
        public DiscoveredTest() { }
    }
    public sealed class DiscoveryFailure : <.DiscoveryFailure>
    {
        public DiscoveryFailure() { }
        public required  Exception { get; init; }
        public string Reason { get; }
        public string? TestClassName { get; init; }
        public required string TestFilePath { get; init; }
        public required string TestId { get; init; }
        public required int TestLineNumber { get; init; }
        public required string TestMethodName { get; init; }
    }
    public class DiscoveryResult
    {
        public DiscoveryResult() { }
        public static .DiscoveryResult Empty { get; }
    }
    [(.Method, Inherited=false)]
    public sealed class DisplayNameAttribute : .DisplayNameFormatterAttribute
    {
        public DisplayNameAttribute(string displayName) { }
        protected override string FormatDisplayName(.DiscoveredTestContext context) { }
    }
    [(.Assembly | .Class | .Method, Inherited=false)]
    public abstract class DisplayNameFormatterAttribute : .TUnitAttribute, ., .
    {
        protected DisplayNameFormatterAttribute() { }
        public int Order { get; }
        protected abstract string FormatDisplayName(.DiscoveredTestContext context);
        public . OnTestDiscovered(.DiscoveredTestContext context) { }
    }
    public class DynamicDiscoveryResult : .DiscoveryResult
    {
        public DynamicDiscoveryResult() { }
        public .<> Attributes { get; set; }
        public object?[]? TestClassArguments { get; set; }
        public ? TestClassType { get; set; }
        public .? TestMethod { get; set; }
        public object?[]? TestMethodArguments { get; set; }
    }
    public sealed class DynamicExecutableTest : .ExecutableTest
    {
        public DynamicExecutableTest(<.<object>> createInstance, <object, object?[], .> invokeTest) { }
        public override .<object> CreateInstanceAsync() { }
        public override . InvokeTestAsync(object instance, .CancellationToken cancellationToken) { }
    }
    public abstract class DynamicTest
    {
        protected DynamicTest() { }
        public abstract .<.DiscoveryResult> GetTests();
    }
    [.("TUnitWIP0001")]
    public class DynamicTestBuilderAttribute : .BaseTestAttribute
    {
        public DynamicTestBuilderAttribute([.] string file = "", [.] int line = 0) { }
    }
    public class DynamicTestBuilderContext
    {
        public DynamicTestBuilderContext(string filePath, int lineNumber) { }
        public string FilePath { get; }
        public int LineNumber { get; }
        public .<.DynamicTest> Tests { get; }
        public void AddTest(.DynamicTest test) { }
    }
    [("Use DelegateDataSource instead")]
    public sealed class DynamicTestDataSource : .TestDataSource
    {
        public DynamicTestDataSource(bool isShared = false) { }
        public required string FactoryKey { get; init; }
        public override bool IsShared { get; }
        public override .<<object?[]>> GetDataFactories() { }
    }
    public static class DynamicTestHelper
    {
        public static T Argument<T>() { }
    }
    public class DynamicTestInstance<T> : .DynamicTest<T>
        where T :  class
    {
        public DynamicTestInstance() { }
        public .<> Attributes { get; set; }
        public object?[]? TestClassArguments { get; set; }
        public .<<T>>? TestMethod { get; set; }
        public object?[]? TestMethodArguments { get; set; }
        public override .<.DiscoveryResult> GetTests() { }
    }
    public abstract class DynamicTest<T> : .DynamicTest
        where T :  class
    {
        protected DynamicTest() { }
    }
    public class EmptyDataProvider : .IDataProvider
    {
        public EmptyDataProvider() { }
        public .<.<object?[]>> GetData() { }
    }
    public class EngineCancellationToken : 
    {
        public EngineCancellationToken() { }
        public .CancellationToken Token { get; }
        public void Dispose() { }
    }
    public sealed class ExcludeOnAttribute : .SkipAttribute
    {
        public ExcludeOnAttribute(. OperatingSystem) { }
        public override .<bool> ShouldSkip(.TestRegisteredContext context) { }
    }
    public abstract class ExecutableTest
    {
        protected ExecutableTest() { }
        public required <.TestContext, .CancellationToken, .>[] AfterTestHooks { get; init; }
        public required object?[] Arguments { get; init; }
        public required <.TestContext, .CancellationToken, .>[] BeforeTestHooks { get; init; }
        public object?[] ClassArguments { get; init; }
        public required .TestContext Context { get; init; }
        public .ExecutableTest[] Dependencies { get; set; }
        public required string DisplayName { get; init; }
        public ? Duration { get; }
        public ? EndTime { get; set; }
        public virtual .TestMetadata Metadata { get; init; }
        public .<string, object?> PropertyValues { get; init; }
        public .TestResult? Result { get; set; }
        public ? StartTime { get; set; }
        public .TestState State { get; set; }
        public required string TestId { get; init; }
        public abstract .<object> CreateInstanceAsync();
        public abstract . InvokeTestAsync(object instance, .CancellationToken cancellationToken);
    }
    public sealed class ExecutableTestCreationContext
    {
        public ExecutableTestCreationContext() { }
        public required <.TestContext, .CancellationToken, .>[] AfterTestHooks { get; init; }
        public required object?[] Arguments { get; init; }
        public required <.TestContext, .CancellationToken, .>[] BeforeTestHooks { get; init; }
        public required object?[] ClassArguments { get; init; }
        public required .TestContext Context { get; init; }
        public required string DisplayName { get; init; }
        public required .<string, object?> PropertyValues { get; init; }
        public required string TestId { get; init; }
    }
    public sealed class ExecutableTest<T> : .ExecutableTest
        where T :  class
    {
        public ExecutableTest() { }
        public required <.<T>> CreateTypedInstance { get; init; }
        public required <T, object?[], .CancellationToken, .> InvokeTypedTest { get; init; }
        public override .TestMetadata Metadata { get; init; }
        public .TestMetadata<T> TypedMetadata { get; }
        public .<string, <T, object?>> TypedPropertySetters { get; init; }
        public override .<object> CreateInstanceAsync() { }
        public override . InvokeTestAsync(object instance, .CancellationToken cancellationToken) { }
    }
    [(.Assembly | .Class | .Method)]
    public class ExecutionPriorityAttribute : .SingleTUnitAttribute, ., .
    {
        public ExecutionPriorityAttribute(. priority = 2) { }
        public int Order { get; }
        public . Priority { get; }
        public . OnTestDiscovered(.DiscoveredTestContext context) { }
    }
    public class ExpandedTest
    {
        public ExpandedTest() { }
        public object?[]? ClassArguments { get; init; }
        public bool IsSkipped { get; init; }
        public object?[]? MethodArguments { get; init; }
        public required .MethodMetadata MethodMetadata { get; init; }
        public .<string, object?>? PropertyValues { get; init; }
        public string? SkipReason { get; init; }
        public required string TestFilePath { get; init; }
        public required string TestId { get; init; }
        public required object TestInstance { get; init; }
        public required int TestLineNumber { get; init; }
        public required .MethodInfo TestMethod { get; init; }
        public required string TestName { get; init; }
        public ? Timeout { get; init; }
    }
    [(.Class | .Method)]
    public sealed class ExplicitAttribute : .TUnitAttribute
    {
        public ExplicitAttribute([.] string callerFile = "", [.] string callerMemberName = "") { }
        public string For { get; }
    }
    public class FailedDynamicTest<T> : .DynamicTest
        where T :  class
    {
        public FailedDynamicTest() { }
        public  Exception { get; set; }
        public string MethodName { get; set; }
        public string TestFilePath { get; set; }
        public string TestId { get; set; }
        public int TestLineNumber { get; set; }
        public override .<.DiscoveryResult> GetTests() { }
    }
    [(.Class | .Method, AllowMultiple=true)]
    public sealed class GenerateGenericTestAttribute : 
    {
        public GenerateGenericTestAttribute(params [] typeArguments) { }
        public [] TypeArguments { get; }
    }
    public abstract class GenericAbstractExecutor : ., .
    {
        protected GenericAbstractExecutor() { }
        public int Order { get; }
        public . ExecuteAfterAssemblyHook(.MethodMetadata hookMethodInfo, .AssemblyHookContext context, <.> action) { }
        public . ExecuteAfterClassHook(.MethodMetadata hookMethodInfo, .ClassHookContext context, <.> action) { }
        public . ExecuteAfterTestDiscoveryHook(.MethodMetadata hookMethodInfo, .TestDiscoveryContext context, <.> action) { }
        public . ExecuteAfterTestHook(.MethodMetadata hookMethodInfo, .TestContext context, <.> action) { }
        public . ExecuteAfterTestSessionHook(.MethodMetadata hookMethodInfo, .TestSessionContext context, <.> action) { }
        protected abstract . ExecuteAsync(<.> action);
        public . ExecuteBeforeAssemblyHook(.MethodMetadata hookMethodInfo, .AssemblyHookContext context, <.> action) { }
        public . ExecuteBeforeClassHook(.MethodMetadata hookMethodInfo, .ClassHookContext context, <.> action) { }
        public . ExecuteBeforeTestDiscoveryHook(.MethodMetadata hookMethodInfo, .BeforeTestDiscoveryContext context, <.> action) { }
        public . ExecuteBeforeTestHook(.MethodMetadata hookMethodInfo, .TestContext context, <.> action) { }
        public . ExecuteBeforeTestSessionHook(.MethodMetadata hookMethodInfo, .TestSessionContext context, <.> action) { }
        public . ExecuteTest(.TestContext context, <.> action) { }
    }
    public sealed class GenericMethodInfo
    {
        public GenericMethodInfo() { }
        public .GenericParameterConstraints[] Constraints { get; init; }
        public string[] ParameterNames { get; init; }
        public int[] ParameterPositions { get; init; }
    }
    public sealed class GenericParameterConstraints
    {
        public GenericParameterConstraints() { }
        public ? BaseTypeConstraint { get; init; }
        public bool HasDefaultConstructorConstraint { get; init; }
        public bool HasNotNullConstraint { get; init; }
        public bool HasReferenceTypeConstraint { get; init; }
        public bool HasValueTypeConstraint { get; init; }
        public [] InterfaceConstraints { get; init; }
        public required string ParameterName { get; init; }
    }
    public sealed class GenericTypeInfo
    {
        public GenericTypeInfo() { }
        public .GenericParameterConstraints[] Constraints { get; init; }
        public string[] ParameterNames { get; init; }
    }
    public class GlobalContext : .Context
    {
        public .TextWriter OriginalConsoleError { get; set; }
        public .TextWriter OriginalConsoleOut { get; set; }
        public string? TestFilter { get; }
        public new static .GlobalContext Current { get; }
    }
    public class GlobalSharedDataKey : .SharedDataKey, <.GlobalSharedDataKey>
    {
        public static readonly  RandomKey;
        public GlobalSharedDataKey( Type) { }
    }
    public class HookAttribute : .TUnitAttribute
    {
        public string File { get; }
        public .HookType HookType { get; }
        public int Line { get; }
        public int Order { get; init; }
    }
    public enum HookLevel
    {
        Assembly = 0,
        Class = 1,
        Test = 2,
    }
    public sealed class HookMetadata
    {
        public HookMetadata() { }
        public ? DeclaringType { get; init; }
        public string? DelegateKey { get; init; }
        public <object, .TestContext, .>? HookInvoker { get; init; }
        public bool IsAsync { get; init; }
        public bool IsStatic { get; init; }
        public required .HookLevel Level { get; init; }
        public required string Name { get; init; }
        public int Order { get; init; }
        public bool ReturnsValueTask { get; init; }
    }
    public enum HookType
    {
        Test = 0,
        Class = 1,
        Assembly = 2,
        TestSession = 3,
        TestDiscovery = 4,
    }
    public interface IAccessesInstanceData { }
    public interface IAsyncDataSourceGeneratorAttribute : .IDataAttribute, .IRequiresImmediateInitialization
    {
        .<<.<object?[]?>>> GenerateAsync(.DataGeneratorMetadata dataGeneratorMetadata);
    }
    public interface IAsyncInitializable
    {
        . InitializeAsync();
    }
    public interface IDataAttribute { }
    public interface IDataProvider
    {
        .<.<object?[]>> GetData();
    }
    public interface IDynamicTestSource
    {
        .<.DynamicTest> CollectDynamicTests(string sessionId);
    }
    public interface IRequiresImmediateInitialization { }
    public interface ISharedDataSourceAttribute : .IDataAttribute
    {
        .<string> GetKeys();
        .<.SharedType> GetSharedTypes();
    }
    public interface ITestDefinition { }
    [(.Class)]
    public sealed class InheritsTestsAttribute : .TUnitAttribute
    {
        public InheritsTestsAttribute() { }
    }
    [(.Property)]
    public sealed class InjectAttribute : 
    {
        public InjectAttribute() { }
        public int Order { get; set; }
        public bool Required { get; set; }
        public object? ServiceKey { get; set; }
    }
    [(.Method, AllowMultiple=true)]
    public class InstanceMethodDataSourceAttribute : .MethodDataSourceAttribute, .IAccessesInstanceData
    {
        public InstanceMethodDataSourceAttribute(string methodNameProvidingDataSource) { }
        public InstanceMethodDataSourceAttribute([.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods | ..PublicProperties)]  classProvidingDataSource, string methodNameProvidingDataSource) { }
    }
    [(.Method, AllowMultiple=true)]
    public class InstanceMethodDataSourceAttribute<[.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods | ..PublicProperties)]  T> : .MethodDataSourceAttribute<T>, .IAccessesInstanceData
    {
        public InstanceMethodDataSourceAttribute(string methodNameProvidingDataSource) { }
    }
    public class InvalidTestMetadataException : .TestBuilderException
    {
        public InvalidTestMetadataException(string message, .TestMetadata metadata) { }
        public InvalidTestMetadataException(string message, .TestMetadata metadata,  innerException) { }
    }
    [(.Parameter)]
    public class MatrixAttribute : .TestDataAttribute
    {
        protected MatrixAttribute() { }
        public MatrixAttribute(params object?[]? objects) { }
        public object?[]? Excluding { get; init; }
        public virtual object?[] GetObjects(object? instance) { }
    }
    [(.Parameter)]
    public class MatrixAttribute<T> : .MatrixAttribute
    {
        public MatrixAttribute(params T?[]? objects) { }
    }
    [(.Class | .Method)]
    [.("MatrixDataSourceAttribute requires dynamic code generation for runtime matrix gen" +
        "eration and enum reflection. This attribute is inherently incompatible with AOT " +
        "compilation.")]
    [.("MatrixDataSourceAttribute may require unreferenced code for enum reflection and m" +
        "atrix generation. This attribute is inherently incompatible with AOT compilation" +
        ".")]
    public sealed class MatrixDataSourceAttribute : .UntypedDataSourceGeneratorAttribute
    {
        public MatrixDataSourceAttribute() { }
        protected override .<<object?[]?>> GenerateDataSources(.DataGeneratorMetadata dataGeneratorMetadata) { }
    }
    [(.Class | .Method, AllowMultiple=true)]
    public class MatrixExclusionAttribute : .TUnitAttribute
    {
        public MatrixExclusionAttribute(params object?[]? objects) { }
        public object?[] Objects { get; }
    }
    [(.Parameter)]
    public class MatrixInstanceMethodAttribute<[.(..None | ..PublicMethods | ..NonPublicMethods | ..PublicProperties)]  TClass> : .MatrixMethodAttribute<TClass>, .IAccessesInstanceData
        where TClass :  class
    {
        public MatrixInstanceMethodAttribute(string methodName) { }
    }
    [(.Parameter)]
    public class MatrixMethodAttribute<[.(..None | ..PublicMethods | ..NonPublicMethods)]  TClass> : .MatrixAttribute
        where TClass :  class
    {
        public MatrixMethodAttribute(string methodName) { }
        public override object?[] GetObjects(object? instance) { }
    }
    [(.Parameter)]
    public class MatrixRangeAttribute<T> : .MatrixAttribute<T>
        where T : .INumber<T>
    {
        public MatrixRangeAttribute(T min, T max) { }
        public MatrixRangeAttribute(T min, T max, T step) { }
    }
    public abstract class MemberMetadata : <.MemberMetadata>
    {
        protected MemberMetadata() { }
        public required string Name { get; init; }
        [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..NonPublicConstructors | ..PublicMethods | ..NonPublicMethods | ..PublicProperties)]
        public abstract  Type { get; init; }
        public virtual bool Equals(.MemberMetadata? other) { }
        public override int GetHashCode() { }
        protected virtual bool PrintMembers(.StringBuilder stringBuilder) { }
    }
    public class MethodDataProvider : .IDataProvider
    {
        public MethodDataProvider(<.<object?>> valuesProvider) { }
        public MethodDataProvider(<.<.<object?>>> valuesProvider) { }
        public MethodDataProvider(<.<object?>> valueProvider) { }
        public MethodDataProvider(<object?> valueProvider) { }
        public .<.<object?[]>> GetData() { }
    }
    [(.Class | .Method | .Property, AllowMultiple=true)]
    public class MethodDataSourceAttribute : .TestDataAttribute
    {
        public MethodDataSourceAttribute(string methodNameProvidingDataSource) { }
        public MethodDataSourceAttribute([.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods | ..PublicProperties)]  classProvidingDataSource, string methodNameProvidingDataSource) { }
        public object?[] Arguments { get; set; }
        [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods | ..PublicProperties)]
        public ? ClassProvidingDataSource { get; }
        public string MethodNameProvidingDataSource { get; }
    }
    [(.Class | .Method | .Property, AllowMultiple=true)]
    public class MethodDataSourceAttribute<[.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods | ..PublicProperties)]  T> : .MethodDataSourceAttribute
    {
        public MethodDataSourceAttribute(string methodNameProvidingDataSource) { }
    }
    [.DebuggerDisplay("{Type}.{Name}")]
    public class MethodMetadata : .MemberMetadata, <.MethodMetadata>
    {
        public MethodMetadata() { }
        public required .ClassMetadata Class { get; init; }
        public required int GenericTypeCount { get; init; }
        public required .ParameterMetadata[] Parameters { get; init; }
        public ? ReturnType { get; init; }
        public required .TypeReference ReturnTypeReference { get; init; }
        [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..NonPublicConstructors | ..PublicMethods | ..NonPublicMethods | ..PublicProperties)]
        public override required  Type { get; init; }
        public required .TypeReference TypeReference { get; init; }
        public virtual bool Equals(.MethodMetadata? other) { }
        public override int GetHashCode() { }
        protected override bool PrintMembers(.StringBuilder stringBuilder) { }
    }
    [(.Assembly | .Class | .Method)]
    public class NotInParallelAttribute : .SingleTUnitAttribute, ., .
    {
        public NotInParallelAttribute() { }
        public NotInParallelAttribute(string constraintKey) { }
        public NotInParallelAttribute(string[] constraintKeys) { }
        public string[] ConstraintKeys { get; }
        public int Order { get; init; }
        public . OnTestDiscovered(.DiscoveredTestContext context) { }
    }
    public class NotInParallelConstraint : <.NotInParallelConstraint>, .
    {
        public NotInParallelConstraint(.<string> NotInParallelConstraintKeys) { }
        public .<string> NotInParallelConstraintKeys { get; init; }
        public int Order { get; set; }
    }
    public static class ObjectInitializer
    {
        public static . InitializeAsync(object? obj, .CancellationToken cancellationToken = default) { }
    }
    public class ParallelGroupAttribute : .TUnitAttribute, ., .
    {
        public ParallelGroupAttribute(string group) { }
        public string Group { get; }
        public int Order { get; set; }
        public . OnTestDiscovered(.DiscoveredTestContext context) { }
    }
    public class ParallelGroupConstraint : , <.ParallelGroupConstraint>, <.ParallelGroupConstraint>, .
    {
        public ParallelGroupConstraint(string Group, int Order) { }
        public string Group { get; init; }
        public int Order { get; init; }
        public int CompareTo(.ParallelGroupConstraint? other) { }
        public int CompareTo(object? obj) { }
        public virtual bool Equals(.ParallelGroupConstraint? other) { }
        public override int GetHashCode() { }
    }
    public class ParallelLimitLockProvider
    {
        public ParallelLimitLockProvider() { }
    }
    [(.Assembly | .Class | .Method)]
    public sealed class ParallelLimiterAttribute<TParallelLimit> : .TUnitAttribute, ., .
        where TParallelLimit : ., new ()
    {
        public ParallelLimiterAttribute() { }
        public int Order { get; }
        public . OnTestRegistered(.TestRegisteredContext context) { }
    }
    [.DebuggerDisplay("{Type} {Name})")]
    public class ParameterMetadata : .MemberMetadata, <.ParameterMetadata>
    {
        public ParameterMetadata([.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods | ..PublicProperties)]  Type) { }
        public object? DefaultValue { get; }
        public bool IsOptional { get; }
        public bool IsParams { get; }
        public required .ParameterInfo ReflectionInfo { get; set; }
        public override  Type { get; init; }
        public required .TypeReference TypeReference { get; init; }
    }
    [.DebuggerDisplay("{Type} {Name})")]
    public class ParameterMetadata<[.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods | ..PublicProperties)]  T> : .ParameterMetadata, <.ParameterMetadata<T>>
    {
        public ParameterMetadata() { }
    }
    [(.Assembly | .Class | .Method, AllowMultiple=true)]
    public class PropertyAttribute : .TUnitAttribute, ., .
    {
        public PropertyAttribute(string name, string value) { }
        public string Name { get; }
        public int Order { get; }
        public string Value { get; }
        public . OnTestDiscovered(.DiscoveredTestContext context) { }
    }
    public sealed class PropertyDataSource
    {
        public PropertyDataSource() { }
        public required .TestDataSource DataSource { get; init; }
        public required string PropertyName { get; init; }
        public required  PropertyType { get; init; }
    }
    public sealed class PropertyInjectionData
    {
        public PropertyInjectionData() { }
        public required string PropertyName { get; init; }
        public required  PropertyType { get; init; }
        public required <object, object?> Setter { get; init; }
        public required <object?> ValueFactory { get; init; }
    }
    public class PropertyInjectionException : .TestBuilderException
    {
        public PropertyInjectionException(string propertyName,  propertyType,  innerException) { }
        public string PropertyName { get; }
        public  PropertyType { get; }
    }
    [.DebuggerDisplay("{Type} {Name})")]
    public class PropertyMetadata : .MemberMetadata, <.PropertyMetadata>
    {
        public PropertyMetadata() { }
        public .ClassMetadata? ClassMetadata { get; set; }
        public required <object?, object?> Getter { get; init; }
        public required bool IsStatic { get; init; }
        public string? Key { get; init; }
        public required .PropertyInfo ReflectionInfo { get; init; }
        public .SharedType Shared { get; init; }
        [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..NonPublicConstructors | ..PublicMethods | ..NonPublicMethods | ..PublicProperties)]
        public override required  Type { get; init; }
    }
    [(.Assembly | .Class | .Method)]
    public sealed class RepeatAttribute : .TUnitAttribute
    {
        public RepeatAttribute(int times) { }
        public int Times { get; }
    }
    public class ResettableLazy<[.(..PublicConstructors)]  T> : 
        where T :  class
    {
        protected readonly string SessionId;
        protected <T> _factory;
        public ResettableLazy(<T> factory, string sessionId, .TestBuilderContext testBuilderContext) { }
        protected ResettableLazy(. classConstructor, string sessionId, .TestBuilderContext testBuilderContext) { }
        public .? ClassConstructor { get; protected set; }
        public .TestBuilderContext TestBuilderContext { get; }
        public T Value { get; }
        public .ResettableLazy<T> Clone() { }
        public . DisposeAsync() { }
        public virtual . ResetLazy() { }
        protected static . DisposeAsync(object? obj) { }
    }
    public class ResettableLazy<[.(..PublicConstructors)]  TClassConstructor, [.(..PublicConstructors)]  T> : .ResettableLazy<T>
        where TClassConstructor : ., new ()
        where T :  class
    {
        public ResettableLazy(string sessionId, .TestBuilderContext testBuilderContext) { }
        public override . ResetLazy() { }
    }
    [(.Assembly | .Class | .Method)]
    public class RetryAttribute : .TUnitAttribute, ., .
    {
        public RetryAttribute(int times) { }
        public int Order { get; }
        public int Times { get; }
        public . OnTestDiscovered(.DiscoveredTestContext context) { }
        public virtual .<bool> ShouldRetry(.TestContext context,  exception, int currentRetryCount) { }
    }
    public sealed class RunOnAttribute : .SkipAttribute
    {
        public RunOnAttribute(. OperatingSystem) { }
        public override .<bool> ShouldSkip(.TestRegisteredContext context) { }
    }
    public class RunOnDiscoveryAttribute : .TUnitAttribute, ., .
    {
        public RunOnDiscoveryAttribute() { }
        public int Order { get; }
        public . OnTestDiscovered(.DiscoveredTestContext context) { }
    }
    [.("windows")]
    public class STAThreadExecutor : .DedicatedThreadExecutor
    {
        public STAThreadExecutor() { }
        protected override void ConfigureThread(.Thread thread) { }
    }
    public class SharedDataKey : <.SharedDataKey>
    {
        public SharedDataKey(string Key,  Type) { }
        public string Key { get; init; }
        public  Type { get; init; }
    }
    public enum SharedType
    {
        None = 0,
        PerClass = 1,
        PerAssembly = 2,
        PerTestSession = 3,
        Keyed = 4,
    }
    public class SingleTUnitAttribute : .TUnitAttribute { }
    public static class Skip
    {
        [.]
        public static void Test(string reason) { }
        public static void Unless([.(false)] bool condition, string reason) { }
        public static void When([.(true)] bool condition, string reason) { }
    }
    [(.Assembly | .Class | .Method, AllowMultiple=true)]
    public class SkipAttribute : , ., .
    {
        public SkipAttribute(string reason) { }
        public int Order { get; }
        public string Reason { get; }
        public . OnTestRegistered(.TestRegisteredContext context) { }
        public virtual .<bool> ShouldSkip(.TestRegisteredContext context) { }
    }
    [.StackTraceHidden]
    public class SourceRegistrar
    {
        public SourceRegistrar() { }
        public static bool IsEnabled { get; set; }
        public static void Register(..ITestSource testSource) { }
        public static void RegisterAssembly(<.Assembly> assemblyLoader) { }
        public static void RegisterAssemblyHookSource(..IAssemblyHookSource testSource) { }
        public static void RegisterClassHookSource(..IClassHookSource testSource) { }
        public static void RegisterDynamic(.IDynamicTestSource testSource) { }
        public static void RegisterGlobalInitializer(<.> initializer) { }
        public static void RegisterProperty(..IPropertySource propertySource) { }
        public static void RegisterTestDiscoveryHookSource(..ITestDiscoveryHookSource testSource) { }
        public static void RegisterTestHookSource(..ITestHookSource testSource) { }
        public static void RegisterTestSessionHookSource(..ITestSessionHookSource testSource) { }
    }
    public sealed class StaticTestDataSource : .TestDataSource
    {
        public StaticTestDataSource(params object?[][] data) { }
        public override bool IsShared { get; }
        public override .<<object?[]>> GetDataFactories() { }
    }
    public class TUnitAttribute :  { }
    public sealed class TaskDelegateDataSource : .TestDataSource
    {
        public TaskDelegateDataSource(<.<.<object?[]>>> taskFactory, bool isShared = false) { }
        public override bool IsShared { get; }
        public override .<<object?[]>> GetDataFactories() { }
    }
    [(.Method)]
    public sealed class TestAttribute : .BaseTestAttribute
    {
        public TestAttribute([.] string file = "", [.] int line = 0) { }
    }
    public class TestBuilderContext : <.TestBuilderContext>
    {
        public TestBuilderContext() { }
        public .ClassMetadata? ClassInformation { get; init; }
        public .IDataAttribute? DataAttribute { get; set; }
        public .TestContextEvents Events { get; }
        public  Id { get; }
        public .MethodMetadata? MethodInformation { get; init; }
        public .<string, object?> ObjectBag { get; }
        public string? TestMethodName { get; init; }
        public static .TestBuilderContext? Current { get; }
        public void RegisterForInitialization(object? obj) { }
    }
    public class TestBuilderContextAccessor
    {
        public TestBuilderContextAccessor(.TestBuilderContext context) { }
        public .TestBuilderContext Current { get; set; }
    }
    public class TestBuilderException : 
    {
        public TestBuilderException() { }
        public TestBuilderException(string message) { }
        public TestBuilderException(string message,  innerException) { }
        public .<string, object?> Context { get; set; }
        public .TestMetadata? TestMetadata { get; set; }
    }
    public class TestContext : .Context
    {
        public TestContext(string testName, string displayName) { }
        public TestContext(string testName, string displayName, .CancellationToken cancellationToken,  serviceProvider) { }
        public .<<object?, string?>> ArgumentDisplayFormatters { get; }
        public .<string, object?> Artifacts { get; }
        public .CancellationToken CancellationToken { get; set; }
        public .ClassHookContext? ClassContext { get; set; }
        public .<.TestDetails> Dependencies { get; }
        public string DisplayName { get; }
        public ? DisplayNameFormatter { get; set; }
        public .TestContextEvents Events { get; }
        public . ExecutionPriority { get; set; }
        public .CancellationTokenSource? LinkedCancellationTokens { get; set; }
        public object Lock { get; }
        public .<string, object?> ObjectBag { get; }
        public .? ParallelConstraint { get; set; }
        public .? ParallelLimiter { get; }
        public .TestPhase Phase { get; set; }
        public bool ReportResult { get; set; }
        public .TestResult? Result { get; set; }
        public ? ServiceProvider { get; }
        public <.TestContext, , int, .<bool>>? ShouldRetryFunc { get; set; }
        public string? SkipReason { get; set; }
        public .TestDetails TestDetails { get; set; }
        public string TestName { get; }
        public  TestStart { get; set; }
        public .<.Timing> Timings { get; }
        public static . Configuration { get; }
        public new static .TestContext? Current { get; }
        [get: .("SingleFile", "IL3000:Avoid accessing Assembly file path when publishing as a single file", Justification="Dynamic code check implemented")]
        public static string? OutputDirectory { get; }
        public static .<string, string> Parameters { get; }
        public static string WorkingDirectory { get; set; }
        public void AddArtifact(.Artifact artifact) { }
        public void AddArtifact(string name, object? value) { }
        public new void AddAsyncLocalValues() { }
        public void AddLinkedCancellationToken(.CancellationToken cancellationToken) { }
        public new string GetErrorOutput() { }
        public string GetOutput() { }
        public T? GetService<T>()
            where T :  class { }
        public string GetTestDisplayName() { }
        public .<.TestContext> GetTests(<.TestContext, bool> predicate) { }
        public .<.TestContext> GetTests(string testName) { }
        public void OverrideResult(string reason) { }
        public void OverrideResult(. status, string reason) { }
        public . ReregisterTestWithArguments(object?[]? methodArguments = null, .<string, object?>? objectBag = null) { }
        public void SetParallelLimiter(. parallelLimit) { }
        public void WriteError(string message) { }
        public void WriteLine(string message) { }
    }
    public static class TestContextConfiguration
    {
        public static ? GetDisplayNameFormatter(this .TestContext context) { }
        public static .? GetParallelConstraint(this .TestContext context) { }
        public static .? GetParallelLimiter(this .TestContext context) { }
        public static <.TestContext, , int, .<bool>>? GetShouldRetryFunc(this .TestContext context) { }
        public static string? GetSkipReason(this .TestContext context) { }
        public static void SetSkipReason(this .TestContext context, string reason) { }
    }
    public class TestContextEvents : <.TestContextEvents>
    {
        public TestContextEvents() { }
        public .AsyncEvent<.TestContext>? OnDispose { get; set; }
        public .AsyncEvent<.TestContext>? OnInitialize { get; set; }
        public .AsyncEvent<.TestContext>? OnTestEnd { get; set; }
        public .AsyncEvent<.TestContext>? OnTestRegistered { get; set; }
        [.(new string[] {
                null,
                "RetryAttempt"})]
        public .AsyncEvent<<.TestContext, int>>? OnTestRetry { get; set; }
        public .AsyncEvent<.TestContext>? OnTestSkipped { get; set; }
        public .AsyncEvent<.TestContext>? OnTestStart { get; set; }
    }
    public static class TestContextFactory
    {
        public static .TestContext CreateFromDiscovery(.DiscoveredTestContext discoveryContext, .CancellationToken cancellationToken,  serviceProvider) { }
    }
    public class TestDataAttribute : .TUnitAttribute, .IDataAttribute
    {
        public TestDataAttribute() { }
        public bool AccessesInstanceData { get; init; }
    }
    public class TestDataCombination
    {
        public TestDataCombination() { }
        public <.<object?>>[] ClassDataFactories { get; init; }
        public int ClassDataSourceIndex { get; init; }
        public int ClassLoopIndex { get; init; }
        public ? DataGenerationException { get; init; }
        public string? DisplayName { get; init; }
        public <.<object?>>[] MethodDataFactories { get; init; }
        public int MethodDataSourceIndex { get; init; }
        public int MethodLoopIndex { get; init; }
        public .<string, <.<object?>>> PropertyValueFactories { get; init; }
        public int RepeatIndex { get; init; }
    }
    public abstract class TestDataSource : .
    {
        protected TestDataSource() { }
        public abstract bool IsShared { get; }
        public .<<object?[]>> GenerateDataFactories(.DataSourceContext context) { }
        public abstract .<<object?[]>> GetDataFactories();
        protected static object?[] CloneArguments(object?[] args) { }
    }
    public class TestDefinition : .ITestDefinition
    {
        public TestDefinition() { }
    }
    public class TestDefinition<T> : .TestDefinition
        where T :  class
    {
        public TestDefinition() { }
    }
    public sealed class TestDependency : <.TestDependency>
    {
        public TestDependency() { }
        public int ClassGenericArity { get; init; }
        public ? ClassType { get; init; }
        public int MethodGenericArity { get; init; }
        public string? MethodName { get; init; }
        public []? MethodParameters { get; init; }
        public bool Equals(.TestDependency? other) { }
        public override bool Equals(object? obj) { }
        public override int GetHashCode() { }
        public bool Matches(.TestMetadata test, .TestMetadata? dependentTest = null) { }
        public override string ToString() { }
        public static .TestDependency FromClass( classType) { }
        public static .TestDependency FromClassAndMethod( classType, string methodName) { }
        public static .TestDependency FromMethodName(string methodName) { }
    }
    public class TestDetails
    {
        public TestDetails() { }
        public required .<> Attributes { get; init; }
        public .<string> Categories { get; }
        public required object? ClassInstance { get; set; }
        public required .ClassMetadata ClassMetadata { get; set; }
        public object?[] ClassMetadataArguments { get; }
        public required  ClassType { get; init; }
        public .<string, .<string>> CustomProperties { get; }
        public string? DisplayName { get; set; }
        public required .MethodMetadata MethodMetadata { get; set; }
        public required string MethodName { get; init; }
        public int RetryLimit { get; set; }
        public required  ReturnType { get; set; }
        public required object?[] TestClassArguments { get; set; }
        public .<string, object?> TestClassInjectedPropertyArguments { get; init; }
        public []? TestClassParameterTypes { get; set; }
        public string TestFilePath { get; set; }
        public required string TestId { get; init; }
        public int TestLineNumber { get; set; }
        public required object?[] TestMethodArguments { get; set; }
        public []? TestMethodParameterTypes { get; set; }
        public required string TestName { get; init; }
        public ? Timeout { get; set; }
    }
    public class TestDetails<T> : .TestDetails
        where T :  class
    {
        public TestDetails() { }
    }
    public class TestDiscoveryContext : .Context
    {
        public .<.TestContext> AllTests { get; }
        public .<.AssemblyHookContext> Assemblies { get; }
        public .BeforeTestDiscoveryContext BeforeTestDiscoveryContext { get; }
        public .<.ClassHookContext> TestClasses { get; }
        public required string? TestFilter { get; init; }
        public new static .TestDiscoveryContext? Current { get; }
        public void AddTests(.<.TestContext> tests) { }
    }
    public sealed class TestHooks
    {
        public TestHooks() { }
        public .HookMetadata[] AfterClass { get; init; }
        public .HookMetadata[] AfterTest { get; init; }
        public .HookMetadata[] BeforeClass { get; init; }
        public .HookMetadata[] BeforeTest { get; init; }
    }
    public class TestInstantiationException : .TestBuilderException
    {
        public TestInstantiationException( testClassType,  innerException) { }
        public TestInstantiationException( testClassType, string message) { }
        public  TestClassType { get; }
    }
    public abstract class TestMetadata
    {
        protected TestMetadata() { }
        public required <[]> AttributeFactory { get; init; }
        public bool CanRunInParallel { get; init; }
        public string[] Categories { get; init; }
        public .TestDataSource[] ClassDataSources { get; init; }
        public abstract <.ExecutableTestCreationContext, .TestMetadata, .ExecutableTest> CreateExecutableTestFactory { get; }
        public abstract <.<.TestDataCombination>> DataCombinationGenerator { get; }
        public .TestDataSource[] DataSources { get; init; }
        public .TestDependency[] Dependencies { get; init; }
        public string? FilePath { get; init; }
        public .GenericMethodInfo? GenericMethodInfo { get; init; }
        public []? GenericMethodTypeArguments { get; init; }
        public .GenericTypeInfo? GenericTypeInfo { get; init; }
        public .TestHooks Hooks { get; init; }
        public <object?[], object>? InstanceFactory { get; init; }
        public bool IsSkipped { get; init; }
        public int? LineNumber { get; init; }
        public required .MethodMetadata MethodMetadata { get; init; }
        public int ParameterCount { get; init; }
        public [] ParameterTypes { get; init; }
        public .PropertyDataSource[] PropertyDataSources { get; init; }
        public .PropertyInjectionData[] PropertyInjections { get; init; }
        public .<string, <object, object?>> PropertySetters { get; init; }
        public int RetryCount { get; init; }
        public string? SkipReason { get; init; }
        public required  TestClassType { get; init; }
        public <object, object?[], .>? TestInvoker { get; init; }
        public required string TestMethodName { get; init; }
        public string[] TestMethodParameterTypes { get; init; }
        public required string TestName { get; init; }
        public int? TimeoutMs { get; init; }
    }
    public class TestMetadata<T> : .TestMetadata, .
        where T :  class
    {
        public TestMetadata() { }
        public <.ExecutableTestCreationContext, .TestMetadata<T>, .ExecutableTest>? CreateExecutableTest { get; init; }
        public override <.ExecutableTestCreationContext, .TestMetadata, .ExecutableTest> CreateExecutableTestFactory { get; }
        public <.<T>>? CreateTypedInstance { get; init; }
        public override <.<.TestDataCombination>> DataCombinationGenerator { get; }
        public new <object?[], T>? InstanceFactory { get; init; }
        public <T, object?[], .CancellationToken, .>? InvokeTypedTest { get; init; }
        public new .<string, <T, object?>> PropertySetters { get; init; }
        public new <T, object?[], .>? TestInvoker { get; init; }
        public void SetDataCombinationGenerator(<.<.TestDataCombination>> generator) { }
    }
    public enum TestPhase
    {
        Discovery = 0,
        Registration = 1,
        BeforeTest = 2,
        Execution = 3,
        AfterTest = 4,
    }
    public class TestRegisteredContext
    {
        public TestRegisteredContext(.TestContext testContext) { }
        public .DiscoveredTest DiscoveredTest { get; set; }
        public string DisplayName { get; }
        public .<string, object?> ObjectBag { get; }
        public .TestContext TestContext { get; }
        public .TestDetails TestDetails { get; }
        public string TestName { get; }
        public void SetParallelLimiter(. parallelLimit) { }
        public void SetTestExecutor(. executor) { }
    }
    public class TestResult : <.TestResult>
    {
        public TestResult() { }
        public required string ComputerName { get; init; }
        public required ? Duration { get; init; }
        public required ? End { get; init; }
        public required ? Exception { get; init; }
        public bool IsOverridden { get; set; }
        public string? Output { get; }
        public string? OverrideReason { get; set; }
        public required ? Start { get; init; }
        public required . Status { get; init; }
    }
    public class TestSessionContext : .Context
    {
        public .<.TestContext> AllTests { get; }
        public .<.AssemblyHookContext> Assemblies { get; }
        public required string Id { get; init; }
        public .<.ClassHookContext> TestClasses { get; }
        public .BeforeTestDiscoveryContext TestDiscoveryContext { get; }
        public required string? TestFilter { get; init; }
        public new static .TestSessionContext? Current { get; }
        public void AddArtifact(.Artifact artifact) { }
        public void AddAssembly(.AssemblyHookContext assemblyHookContext) { }
    }
    public enum TestState
    {
        NotStarted = 0,
        WaitingForDependencies = 1,
        Queued = 2,
        Running = 3,
        Passed = 4,
        Failed = 5,
        Skipped = 6,
        Timeout = 7,
        Cancelled = 8,
    }
    [(.Assembly | .Class | .Method)]
    public class TimeoutAttribute : .TUnitAttribute, ., .
    {
        public TimeoutAttribute(int timeoutInMilliseconds) { }
        public int Order { get; }
        public  Timeout { get; }
        public . OnTestDiscovered(.DiscoveredTestContext context) { }
    }
    public class Timing : <.Timing>
    {
        public Timing(string StepName,  Start,  End) { }
        public  Duration { get; }
        public  End { get; init; }
        public  Start { get; init; }
        public string StepName { get; init; }
    }
    public sealed class TypeArrayComparer : .<[]>
    {
        public static readonly .TypeArrayComparer Instance;
        public bool Equals([]? x, []? y) { }
        public int GetHashCode([] obj) { }
    }
    public sealed class TypeReference
    {
        public TypeReference() { }
        public int ArrayRank { get; set; }
        public string? AssemblyQualifiedName { get; set; }
        public .TypeReference? ElementType { get; set; }
        public .<.TypeReference> GenericArguments { get; set; }
        public string? GenericParameterName { get; set; }
        public int GenericParameterPosition { get; set; }
        public bool IsArray { get; set; }
        public bool IsByRef { get; set; }
        public bool IsGenericParameter { get; set; }
        public bool IsMethodGenericParameter { get; set; }
        public bool IsPointer { get; set; }
        public static .TypeReference CreateArray(.TypeReference elementType, int rank = 1) { }
        public static .TypeReference CreateConcrete(string assemblyQualifiedName) { }
        public static .TypeReference CreateConstructedGeneric(string genericTypeDefinition, params .TypeReference[] genericArguments) { }
        public static .TypeReference CreateGenericParameter(int position, bool isMethodParameter, string? name = null) { }
    }
    [.("TypeResolver uses dynamic type creation for generics, arrays, and other complex t" +
        "ypes")]
    [.("TypeResolver uses  which may require types that aren\'t statically ref" +
        "erenced")]
    public sealed class TypeResolver
    {
        public TypeResolver(? declaringType = null, .MethodInfo? declaringMethod = null) { }
        [.("AOT", "IL2055:MakeGenericType", Justification="TypeResolver is not AOT-compatible by design")]
        [.("AOT", "IL2057:TypeGetType", Justification="TypeResolver is not AOT-compatible by design")]
        [.("AOT", "IL2073:ReturnValueMismatch", Justification="TypeResolver is not AOT-compatible by design")]
        [.("AOT", "IL3050:RequiresDynamicCode", Justification="TypeResolver is not AOT-compatible by design")]
        public  Resolve(.TypeReference typeReference) { }
        public [] ResolveMany(.<.TypeReference> typeReferences) { }
        public static .TypeResolver CreateSimple() { }
        public static .TypeResolver FromTestInstance(object testInstance, .MethodInfo? testMethod = null) { }
    }
    [(.Class | .Method | .Property, AllowMultiple=true)]
    [.("UntypedDataSourceGeneratorAttribute requires dynamic code generation for runtime " +
        "data source creation. Consider using strongly-typed AsyncDataSourceGeneratorAttr" +
        "ibute<T> overloads for AOT compatibility.")]
    [.("UntypedDataSourceGeneratorAttribute may require unreferenced code for runtime dat" +
        "a source creation. Consider using strongly-typed AsyncDataSourceGeneratorAttribu" +
        "te<T> overloads for AOT compatibility.")]
    public abstract class UntypedDataSourceGeneratorAttribute : .AsyncUntypedDataSourceGeneratorAttribute
    {
        protected UntypedDataSourceGeneratorAttribute() { }
        protected abstract .<<object?[]?>> GenerateDataSources(.DataGeneratorMetadata dataGeneratorMetadata);
        [.(typeof(.UntypedDataSourceGeneratorAttribute.<GenerateDataSourcesAsync>d__1))]
        protected override sealed .<<.<object?[]?>>> GenerateDataSourcesAsync(.DataGeneratorMetadata dataGeneratorMetadata) { }
    }
}
namespace .Data
{
    public class GetOnlyDictionary<TKey, TValue>
        where TKey :  notnull
    {
        public GetOnlyDictionary() { }
        public TValue this[TKey key] { get; }
        public .<TKey> Keys { get; }
        public .<TValue> Values { get; }
        public TValue GetOrAdd(TKey key, <TKey, TValue> func) { }
        public TValue GetOrAdd(TKey key, <TKey, TValue> func, out bool previouslyExisted) { }
        public TValue? Remove(TKey key) { }
        public bool TryGetValue(TKey key, [.(true)] out TValue? value) { }
    }
}
namespace .DataSourceGenerators
{
    public class ArgumentsDataSourceGenerator : .<.ArgumentsAttribute>
    {
        public ArgumentsDataSourceGenerator() { }
        [.(typeof(..<GenerateDataCombinationsAsync>d__0))]
        public .<.TestDataCombination> GenerateDataCombinationsAsync(.ArgumentsAttribute attribute, . context) { }
    }
    public class AsyncDataSourceGenerator : .
    {
        public AsyncDataSourceGenerator() { }
        [.(typeof(..<GenerateDataCombinationsAsync>d__0))]
        public .<.TestDataCombination> GenerateDataCombinationsAsync(.IAsyncDataSourceGeneratorAttribute attribute, . context) { }
    }
    [.("Untyped async data sources require dynamic code generation")]
    public class AsyncUntypedDataSourceGenerator : .
    {
        public AsyncUntypedDataSourceGenerator() { }
        [.(typeof(..<GenerateDataCombinationsAsync>d__0))]
        public .<.TestDataCombination> GenerateDataCombinationsAsync(.IAsyncDataSourceGeneratorAttribute attribute, . context) { }
    }
    public class DataSourceGenerationContext
    {
        public DataSourceGenerationContext() { }
        public required int DataSourceIndex { get; init; }
        public required [] ParameterTypes { get; init; }
        [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods | ..PublicProperties)]
        public required  TestClassType { get; init; }
        public required string TestMethodName { get; init; }
    }
    public interface IAsyncDataSourceGenerator
    {
        .<.TestDataCombination> GenerateDataCombinationsAsync(.IAsyncDataSourceGeneratorAttribute attribute, . context);
    }
    public interface IDataSourceGenerator<TAttribute>
        where TAttribute : .TestDataAttribute
    {
        .<.TestDataCombination> GenerateDataCombinationsAsync(TAttribute attribute, . context);
    }
    public class MethodDataSourceGenerator : .<.MethodDataSourceAttribute>
    {
        public MethodDataSourceGenerator() { }
        [.(typeof(..<GenerateDataCombinationsAsync>d__0))]
        public .<.TestDataCombination> GenerateDataCombinationsAsync(.MethodDataSourceAttribute attribute, . context) { }
    }
}
namespace .Enums
{
    public enum DataGeneratorType
    {
        ClassParameters = 0,
        TestParameters = 1,
        Property = 2,
    }
    public enum LogLevel
    {
        None = -1,
        Trace = 0,
        Debug = 1,
        Information = 2,
        Warning = 3,
        Error = 4,
        Critical = 5,
    }
    []
    public enum OS
    {
        Linux = 1,
        Windows = 2,
        MacOs = 4,
    }
    public enum Priority
    {
        Low = 0,
        BelowNormal = 1,
        Normal = 2,
        AboveNormal = 3,
        High = 4,
        Critical = 5,
    }
    public enum Status
    {
        None = 0,
        Passed = 1,
        Failed = 2,
        Skipped = 3,
        Cancelled = 4,
    }
    public enum TestExecutionMode
    {
        SourceGeneration = 0,
        Reflection = 1,
    }
}
namespace .Events
{
    []
    public enum EventType
    {
        Initialize = 1,
        Dispose = 2,
        TestRegistered = 4,
        TestStart = 8,
        TestEnd = 16,
        TestSkipped = 32,
        FirstTestInClass = 64,
        FirstTestInAssembly = 128,
        FirstTestInTestSession = 256,
        LastTestInClass = 512,
        LastTestInAssembly = 1024,
        LastTestInTestSession = 2048,
        TestRetry = 2049,
        All = 4095,
    }
}
namespace .Examples
{
    public static class AotAsyncDataSourceBenefits { }
    public static class AotMethodDataSourceBenefits { }
    public static class GeneratedAotAsyncDataSourceExample
    {
        public static void RegisterFactories() { }
        public static class MyAsyncApiDataSource_AotFactory
        {
            public static readonly <.DataGeneratorMetadata, .CancellationToken, .<<.<object?[]?>>>> AsyncFactory;
            public static readonly <.DataGeneratorMetadata, .CancellationToken, .<.<<.<object?[]?>>>>> ListFactory;
            [.(typeof(..MyAsyncApiDataSource_AotFactory.<GenerateDataAsync>d__0))]
            public static .<<.<object?[]?>>> GenerateDataAsync(.DataGeneratorMetadata metadata, [.] .CancellationToken cancellationToken = default) { }
            public static .<.<<.<object?[]?>>>> GenerateDataListAsync(.DataGeneratorMetadata metadata, .CancellationToken cancellationToken = default) { }
        }
        public static class MyAsyncTests_MyAsyncTest_AsyncDataResolver
        {
            public static .<.<<.<object?[]?>>>> ResolveAllAsyncDataAsync(.DataGeneratorMetadata metadata, .CancellationToken cancellationToken = default) { }
            public static .<.<object?[]?>> ResolveAndExecuteAllAsyncDataAsync(.DataGeneratorMetadata metadata, .CancellationToken cancellationToken = default) { }
        }
    }
    public static class GeneratedAotMethodDataSourceExample
    {
        public static void RegisterFactories() { }
        public static class MyTests_GetTestData_DataSourceFactory
        {
            public static readonly <.<object?[]>> Factory;
            public static .<object?[]> GetData() { }
        }
        public static class MyTests_MyTest_MethodDataResolver
        {
            public static .<object?[]> ResolveAllMethodData() { }
            public static .<.<object?[]>> ResolveAllMethodDataAsync() { }
        }
    }
    public class MyAsyncApiDataSource : .AsyncDataSourceGeneratorAttribute<string>
    {
        public MyAsyncApiDataSource() { }
        [.(typeof(..<GenerateDataSourcesAsync>d__0))]
        protected override .<<.<string>>> GenerateDataSourcesAsync(.DataGeneratorMetadata dataGeneratorMetadata) { }
    }
    public class MyAsyncTests
    {
        public MyAsyncTests() { }
        public . MyAsyncTest(string apiResult) { }
    }
    public class MyTests
    {
        public MyTests() { }
        public void MyTest(string input, int number) { }
        public static .<object[]> GetTestData() { }
    }
}
namespace .Exceptions
{
    public class AfterAssemblyException : .
    {
        public AfterAssemblyException(string message,  innerException) { }
    }
    public class AfterClassException : .
    {
        public AfterClassException(string message,  innerException) { }
    }
    public class AfterTestDiscoveryException : .
    {
        public AfterTestDiscoveryException(string message,  innerException) { }
    }
    public class AfterTestException : .
    {
        public AfterTestException(string message,  innerException) { }
    }
    public class AfterTestSessionException : .
    {
        public AfterTestSessionException(string message,  innerException) { }
    }
    public class BeforeAssemblyException : .
    {
        public BeforeAssemblyException(string message,  innerException) { }
    }
    public class BeforeClassException : .
    {
        public BeforeClassException(string message,  innerException) { }
    }
    public class BeforeTestDiscoveryException : .
    {
        public BeforeTestDiscoveryException(string message,  innerException) { }
    }
    public class BeforeTestException : .
    {
        public BeforeTestException(string message,  innerException) { }
    }
    public class BeforeTestSessionException : .
    {
        public BeforeTestSessionException(string message,  innerException) { }
    }
    public class DependencyConflictException : . { }
    public class FailTestException : .
    {
        public FailTestException(string reason) { }
        public string Reason { get; }
    }
    public class GenericTypeResolutionException : 
    {
        public GenericTypeResolutionException(string message) { }
        public GenericTypeResolutionException(string message,  innerException) { }
    }
    public class InconclusiveTestException : .
    {
        public InconclusiveTestException(string message,  exception) { }
    }
    public class SkipTestException : .
    {
        public SkipTestException(string reason) { }
        public string Reason { get; }
    }
    public class TUnitException : 
    {
        public TUnitException() { }
        public TUnitException(string? message) { }
        public TUnitException(string? message, ? innerException) { }
    }
    public class TestFailedInitializationException : 
    {
        public TestFailedInitializationException(string? message, ? innerException) { }
    }
    public class TestNotExecutedException : . { }
    public class TestRunCanceledException : .
    {
        public TestRunCanceledException() { }
    }
    public class TimeoutException : . { }
}
namespace .Executors
{
    [(.Assembly | .Class | .Method)]
    public class CultureAttribute : .TUnitAttribute, ., .
    {
        public CultureAttribute(.CultureInfo cultureInfo) { }
        public CultureAttribute(string cultureName) { }
        public int Order { get; }
        public . OnTestRegistered(.TestRegisteredContext context) { }
    }
    public class HookExecutorAttribute : .TUnitAttribute
    {
        public HookExecutorAttribute( type) { }
        public  HookExecutorType { get; }
    }
    [(.Assembly | .Class | .Method)]
    public sealed class HookExecutorAttribute<T> : .
        where T : ., new ()
    {
        public HookExecutorAttribute() { }
    }
    [(.Assembly | .Class | .Method)]
    public class InvariantCultureAttribute : .
    {
        public InvariantCultureAttribute() { }
    }
    [(.Assembly | .Class | .Method)]
    [.("windows")]
    public class STAThreadExecutorAttribute : .TUnitAttribute, ., .
    {
        public STAThreadExecutorAttribute() { }
        public int Order { get; }
        public . OnTestRegistered(.TestRegisteredContext context) { }
    }
    [(.Assembly | .Class | .Method)]
    public sealed class TestExecutorAttribute : .TUnitAttribute, ., .
    {
        public TestExecutorAttribute([.(..PublicConstructors)]  type) { }
        public int Order { get; }
        public . OnTestRegistered(.TestRegisteredContext context) { }
    }
    [(.Assembly | .Class | .Method)]
    public sealed class TestExecutorAttribute<T> : .TUnitAttribute, ., .
        where T : ., new ()
    {
        public TestExecutorAttribute() { }
        public int Order { get; }
        public . OnTestRegistered(.TestRegisteredContext context) { }
    }
}
namespace .Extensions
{
    public static class ClassConstructorExtensions
    {
        public static T Create<[.(..PublicConstructors)]  T>(this . classConstructor, .ClassConstructorMetadata classConstructorMetadata)
            where T :  class { }
    }
    public static class MetadataExtensions
    {
        public static  DeclaringType(this .MethodMetadata method) { }
        public static string DisplayName(this .MethodMetadata method) { }
        public static .<> GetCustomAttributes(this .MethodMetadata method) { }
        public static .MethodInfo GetReflectionInfo(this .MethodMetadata method) { }
        public static bool IsGenericMethodDefinition(this .MethodMetadata method) { }
        public static string MethodName(this .MethodMetadata method) { }
    }
    public static class ReflectionExtensions
    {
        public static [] GetCustomAttributesSafe(this .ICustomAttributeProvider provider, bool inherit = true) { }
        public static T[] GetCustomAttributesSafe<T>(this .ICustomAttributeProvider provider, bool inherit = true)
            where T :  { }
    }
    public static class TestContextExtensions
    {
        [.("Uses MakeGenericMethod for dynamic test registration")]
        public static . AddDynamicTest<T>(this .TestContext context, .DynamicTestInstance<T> dynamicTest)
            where T :  class { }
        [.("Uses MakeGenericMethod for dynamic test registration")]
        public static void AddTest<T>(this .TestContext context, .DynamicTestInstance<T> dynamicTest)
            where T :  class { }
        public static string GetClassTypeName(this .TestContext context) { }
        public static string GetDisplayName(this .TestContext context) { }
        public static T? GetService<T>(this .TestContext context)
            where T :  class { }
    }
}
namespace .Helpers
{
    public static class CastHelper
    {
        [.("", "IL2072")]
        public static object? Cast([.(..PublicMethods)]  type, object? value) { }
        [.("", "IL2072")]
        public static T? Cast<[.(..PublicMethods)]  T>(object? value) { }
        public static .MethodInfo? GetConversionMethod([.(..PublicMethods)]  baseType, [.(..PublicMethods)]  targetType) { }
    }
    [.DebuggerDisplay("Count = {CurrentCount}")]
    public class Counter
    {
        public <int>? OnCountChanged;
        public Counter() { }
        public int CurrentCount { get; }
        public int Decrement() { }
        public int Increment() { }
    }
    public static class DataConversionHelper
    {
        [.(typeof(..<ConvertAsyncEnumerableToObjectArrays>d__2<T>))]
        public static .<object?[]> ConvertAsyncEnumerableToObjectArrays<T>(.<T> source, [.] .CancellationToken ct = default) { }
        [.(typeof(..<ConvertAsyncEnumerableTuple2ToObjectArrays>d__3<T1?, T2?>?))]
        public static .<object?[]> ConvertAsyncEnumerableTuple2ToObjectArrays<T1, T2>(.<<T1, T2>> source, [.] .CancellationToken ct = default) { }
        [.(typeof(..<ConvertAsyncEnumerableTuple3ToObjectArrays>d__4<T1?, T2?, T3?>?))]
        public static .<object?[]> ConvertAsyncEnumerableTuple3ToObjectArrays<T1, T2, T3>(.<<T1, T2, T3>> source, [.] .CancellationToken ct = default) { }
        [.(typeof(..<ConvertAsyncEnumerableTuple4ToObjectArrays>d__5<T1?, T2?, T3?, T4?>?))]
        public static .<object?[]> ConvertAsyncEnumerableTuple4ToObjectArrays<T1, T2, T3, T4>(.<<T1, T2, T3, T4>> source, [.] .CancellationToken ct = default) { }
        [.(typeof(..<ConvertAsyncEnumerableTuple5ToObjectArrays>d__6<T1?, T2?, T3?, T4?, T5?>?))]
        public static .<object?[]> ConvertAsyncEnumerableTuple5ToObjectArrays<T1, T2, T3, T4, T5>(.<<T1, T2, T3, T4, T5>> source, [.] .CancellationToken ct = default) { }
        [.(typeof(..<ConvertToAsyncEnumerableInternal>d__1?))]
        public static .<object?[]> ConvertToAsyncEnumerableInternal(.<object?[]> data, [.] .CancellationToken ct = default) { }
        public static .<object?[]> ConvertToObjectArrays(object? data) { }
        public static object?[] UnwrapTuple(. tuple) { }
        public static object?[] UnwrapTuple<T1, T2>(<T1, T2> tuple) { }
        public static object?[] UnwrapTuple<T1, T2, T3>(<T1, T2, T3> tuple) { }
        public static object?[] UnwrapTuple<T1, T2, T3, T4>(<T1, T2, T3, T4> tuple) { }
        public static object?[] UnwrapTuple<T1, T2, T3, T4, T5>(<T1, T2, T3, T4, T5> tuple) { }
        public static object?[] UnwrapTuple<T1, T2, T3, T4, T5, T6>(<T1, T2, T3, T4, T5, T6> tuple) { }
        public static object?[] UnwrapTuple<T1, T2, T3, T4, T5, T6, T7>(<T1, T2, T3, T4, T5, T6, T7> tuple) { }
        public static object?[] UnwrapTuple<T1, T2, T3, T4, T5, T6, T7, T8>(<T1, T2, T3, T4, T5, T6, T7, <T8>> tuple) { }
        public static object?[] UnwrapTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9>(<T1, T2, T3, T4, T5, T6, T7, <T8, T9>> tuple) { }
        public static object?[] UnwrapTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(<T1, T2, T3, T4, T5, T6, T7, <T8, T9, T10>> tuple) { }
        public static .<.<object?[]>> WrapTaskEnumerableAsObjectArrays<T>(.<.<T>> task) { }
    }
    public class DataSourceInitializationException : 
    {
        public DataSourceInitializationException(string message) { }
        public DataSourceInitializationException(string message,  innerException) { }
    }
    public class ProcessorCountParallelLimit : .
    {
        public ProcessorCountParallelLimit() { }
        public int Limit { get; }
    }
    public class ReferenceEqualityComparer : .<object>
    {
        public ReferenceEqualityComparer() { }
        public bool Equals(object? x, object? y) { }
        public int GetHashCode(object obj) { }
    }
    public static class TupleHelper
    {
        public static bool IsTupleType( type) { }
        public static bool ShouldUnwrapForMethodArguments(object? value, int expectedParameterCount) { }
        [.("ReflectionAnalysis", "IL2075:UnrecognizedReflectionPattern", Justification="This method specifically handles tuple types which have known structure")]
        public static object?[] UnwrapTuple(object? value) { }
    }
}
namespace .Hooks
{
    public class AfterAssemblyHookMethod : .<.AssemblyHookContext>, <.>
    {
        public AfterAssemblyHookMethod() { }
        public override . ExecuteAsync(.AssemblyHookContext context, .CancellationToken cancellationToken) { }
    }
    public class AfterClassHookMethod : .<.ClassHookContext>, <.>
    {
        public AfterClassHookMethod() { }
        public override . ExecuteAsync(.ClassHookContext context, .CancellationToken cancellationToken) { }
    }
    public class AfterTestDiscoveryHookMethod : .<.TestDiscoveryContext>, <.>
    {
        public AfterTestDiscoveryHookMethod() { }
        public override . ExecuteAsync(.TestDiscoveryContext context, .CancellationToken cancellationToken) { }
    }
    public class AfterTestHookMethod : .<.TestContext>, <.>
    {
        public AfterTestHookMethod() { }
        public override . ExecuteAsync(.TestContext context, .CancellationToken cancellationToken) { }
    }
    public class AfterTestSessionHookMethod : .<.TestSessionContext>, <.>
    {
        public AfterTestSessionHookMethod() { }
        public override . ExecuteAsync(.TestSessionContext context, .CancellationToken cancellationToken) { }
    }
    public class BeforeAssemblyHookMethod : .<.AssemblyHookContext>, <.>
    {
        public BeforeAssemblyHookMethod() { }
        public override . ExecuteAsync(.AssemblyHookContext context, .CancellationToken cancellationToken) { }
    }
    public class BeforeClassHookMethod : .<.ClassHookContext>, <.>
    {
        public BeforeClassHookMethod() { }
        public override . ExecuteAsync(.ClassHookContext context, .CancellationToken cancellationToken) { }
    }
    public class BeforeTestDiscoveryHookMethod : .<.BeforeTestDiscoveryContext>, <.>
    {
        public BeforeTestDiscoveryHookMethod() { }
        public override . ExecuteAsync(.BeforeTestDiscoveryContext context, .CancellationToken cancellationToken) { }
    }
    public class BeforeTestHookMethod : .<.TestContext>, <.>
    {
        public BeforeTestHookMethod() { }
        public override . ExecuteAsync(.TestContext context, .CancellationToken cancellationToken) { }
    }
    public class BeforeTestSessionHookMethod : .<.TestSessionContext>, <.>
    {
        public BeforeTestSessionHookMethod() { }
        public override . ExecuteAsync(.TestSessionContext context, .CancellationToken cancellationToken) { }
    }
    public class HookMethod
    {
        public HookMethod(. instanceHookMethod) { }
        public HookMethod(. staticHookMethod) { }
        public .? InstanceHookMethod { get; }
        public .? StaticHookMethod { get; }
        public static . op_Implicit(. instanceHookMethod) { }
        public static . op_Implicit(. staticHookMethod) { }
    }
    public interface IExecutableHook<in T>
    {
        .MethodMetadata MethodInfo { get; }
        string Name { get; }
        int Order { get; }
        . ExecuteAsync(T context, .CancellationToken cancellationToken);
    }
    public interface IHookMessagePublisher
    {
        . Discover(string sessionId, string displayName, . hookMethod);
        . Push(string sessionId, string displayName, . hookMethod, <.> func);
    }
    public class InstanceHookMethod : <.>, .<.TestContext>
    {
        public InstanceHookMethod() { }
        public .Assembly Assembly { get; }
        public .<> Attributes { get; }
        public <object, .TestContext, .CancellationToken, .>? Body { get; init; }
        [.(..PublicMethods)]
        public required  ClassType { get; init; }
        public required . HookExecutor { get; init; }
        public required .MethodMetadata MethodInfo { get; init; }
        public string Name { get; }
        public required int Order { get; init; }
        public ? Timeout { get; }
        public . ExecuteAsync(.TestContext context, .CancellationToken cancellationToken) { }
        public TAttribute? GetAttribute<TAttribute>()
            where TAttribute :  { }
    }
    public class LastTestInAssemblyAdapter : .<.AssemblyHookContext>
    {
        public LastTestInAssemblyAdapter(. lastTestInAssemblyEventReceiver, .TestContext testContext) { }
        public .MethodMetadata MethodInfo { get; }
        public string Name { get; }
        public int Order { get; }
        public bool Execute(.AssemblyHookContext context, .CancellationToken cancellationToken) { }
        public . ExecuteAsync(.AssemblyHookContext context, .CancellationToken cancellationToken) { }
    }
    public class LastTestInClassAdapter : .<.ClassHookContext>
    {
        public LastTestInClassAdapter(. lastTestInClassEventReceiver, .TestContext testContext) { }
        public .MethodMetadata MethodInfo { get; }
        public string Name { get; }
        public int Order { get; }
        public bool Execute(.ClassHookContext context, .CancellationToken cancellationToken) { }
        public . ExecuteAsync(.ClassHookContext context, .CancellationToken cancellationToken) { }
    }
    public abstract class StaticHookMethod : <.>
    {
        protected StaticHookMethod() { }
        public .Assembly? Assembly { get; }
        public .<> Attributes { get; }
        public  ClassType { get; }
        public required string FilePath { get; init; }
        public required . HookExecutor { get; init; }
        public required int LineNumber { get; init; }
        public required .MethodMetadata MethodInfo { get; init; }
        public string Name { get; }
        public required int Order { get; init; }
        public ? Timeout { get; }
        public TAttribute? GetAttribute<TAttribute>()
            where TAttribute :  { }
    }
    public abstract class StaticHookMethod<T> : ., <.<T>>, .<T>
    {
        protected StaticHookMethod() { }
        public <T, .CancellationToken, .>? Body { get; init; }
        public abstract . ExecuteAsync(T context, .CancellationToken cancellationToken);
    }
}
namespace .Interfaces
{
    public sealed class CompileTimeResolvedData
    {
        public CompileTimeResolvedData() { }
        public .<object?[]> ClassData { get; init; }
        public .<object?[]> MethodData { get; init; }
        public .<string, object?> PropertyData { get; init; }
        public int TotalVariations { get; }
        public .<.IDataAttribute> UnresolvedAttributes { get; init; }
    }
    public interface IAotCompatibleDataSource : . { }
    public interface IAsyncInitializer
    {
        . InitializeAsync();
    }
    public interface IClassConstructor
    {
        object Create([.(..PublicConstructors)]  type, .ClassConstructorMetadata classConstructorMetadata);
    }
    public interface ICompileTimeDataResolver
    {
        bool CanResolveAtCompileTime(.IDataAttribute dataAttribute);
        .<.<object?[]>> ResolveClassDataAsync(.ClassMetadata classMetadata);
        .<.<object?[]>> ResolveMethodDataAsync(.MethodMetadata methodMetadata);
        .<.<string, object?>> ResolvePropertyDataAsync(.ClassMetadata classMetadata);
    }
    public interface IConfiguration
    {
        string? Get(string key);
    }
    public interface IContext
    {
        .TextWriter ErrorOutputWriter { get; }
        .TextWriter OutputWriter { get; }
        . GetDefaultLogger();
    }
    public interface IDataSource
    {
        bool IsShared { get; }
        .<<object?[]>> GenerateDataFactories(.DataSourceContext context);
    }
    public interface IDataSourceProvider
    {
        bool IsCacheable { get; }
        .<object?[]> GetData(.DataSourceContext context);
    }
    public interface IEventReceiver
    {
        int Order { get; }
    }
    public interface IExecutionOrder
    {
        int Order { get; }
        int Priority { get; }
    }
    public interface IFirstTestInAssemblyEventReceiver : .
    {
        . OnFirstTestInAssembly(.AssemblyHookContext context, .TestContext testContext);
    }
    public interface IFirstTestInClassEventReceiver : .
    {
        . OnFirstTestInClass(.ClassHookContext context, .TestContext testContext);
    }
    public interface IFirstTestInTestSessionEventReceiver : .
    {
        . OnFirstTestInTestSession(.TestSessionContext current, .TestContext testContext);
    }
    public interface IGenericTypeResolver
    {
        [] ResolveGenericClassArguments([.(..PublicConstructors)]  genericTypeDefinition, object?[] constructorArguments);
        [] ResolveGenericMethodArguments(.MethodInfo genericMethodDefinition, object?[] runtimeArguments);
    }
    public interface IHasLoggers
    {
        .<.> Loggers { get; }
    }
    public interface IHookExecutor
    {
        . ExecuteAfterAssemblyHook(.MethodMetadata hookMethodInfo, .AssemblyHookContext context, <.> action);
        . ExecuteAfterClassHook(.MethodMetadata hookMethodInfo, .ClassHookContext context, <.> action);
        . ExecuteAfterTestDiscoveryHook(.MethodMetadata hookMethodInfo, .TestDiscoveryContext context, <.> action);
        . ExecuteAfterTestHook(.MethodMetadata hookMethodInfo, .TestContext context, <.> action);
        . ExecuteAfterTestSessionHook(.MethodMetadata hookMethodInfo, .TestSessionContext context, <.> action);
        . ExecuteBeforeAssemblyHook(.MethodMetadata hookMethodInfo, .AssemblyHookContext context, <.> action);
        . ExecuteBeforeClassHook(.MethodMetadata hookMethodInfo, .ClassHookContext context, <.> action);
        . ExecuteBeforeTestDiscoveryHook(.MethodMetadata hookMethodInfo, .BeforeTestDiscoveryContext context, <.> action);
        . ExecuteBeforeTestHook(.MethodMetadata hookMethodInfo, .TestContext context, <.> action);
        . ExecuteBeforeTestSessionHook(.MethodMetadata hookMethodInfo, .TestSessionContext context, <.> action);
    }
    public interface ILastTestInAssemblyEventReceiver : .
    {
        . OnLastTestInAssembly(.AssemblyHookContext context, .TestContext testContext);
    }
    public interface ILastTestInClassEventReceiver : .
    {
        . OnLastTestInClass(.ClassHookContext context, .TestContext testContext);
    }
    public interface ILastTestInTestSessionEventReceiver : .
    {
        . OnLastTestInTestSession(.TestSessionContext current, .TestContext testContext);
    }
    public interface IModeDetector
    {
        bool IsDynamicCodeSupported { get; }
        bool IsReflectionModeRequested { get; }
        bool IsSourceGenerationAvailable { get; }
        . DetectMode();
    }
    public interface IParallelConstraint { }
    public interface IParallelLimit
    {
        int Limit { get; }
    }
    public interface ISourceGeneratedTestRegistry
    {
        <object>? GetClassFactory(string testId);
        <object, object?[], .<object?>>? GetMethodInvoker(string testId);
        <object?[], object>? GetParameterizedClassFactory(string testId);
        .<string, <object, object?>> GetPropertySetters(string testId);
        .<string> GetRegisteredTestIds();
        void RegisterClassFactory(string testId, <object> factory);
        void RegisterClassFactory(string testId, <object?[], object> factory);
        void RegisterMethodInvoker(string testId, <object, object?[], .<object?>> invoker);
        void RegisterPropertySetter(string testId, string propertyName, <object, object?> setter);
    }
    public interface ITestDiscoveryEventReceiver : .
    {
        . OnTestDiscovered(.DiscoveredTestContext context);
    }
    public interface ITestEndEventReceiver : .
    {
        . OnTestEnd(.TestContext context);
    }
    public interface ITestExecutor
    {
        . ExecuteTest(.TestContext context, <.> action);
    }
    public interface ITestFinder
    {
        .<.TestContext> GetTests( classType);
        .TestContext[] GetTestsByNameAndParameters(string testName, .<> methodParameterTypes,  classType, .<> classParameterTypes, .<object?> classArguments);
    }
    public interface ITestInstanceFactory
    {
        .<object> CreateInstanceAsync( type, object?[] args);
        .<object?> InvokeMethodAsync(object instance, .MethodInfo method, object?[] args);
        . SetPropertyAsync(object instance, .PropertyInfo property, object? value);
    }
    public interface ITestNameFormatter
    {
        string BuildTestId(string template, int testIndex, int repeatIndex = 0, int classDataIndex = 0, int methodDataIndex = 0);
        string FormatArgumentValue(object? value);
        string FormatTestName(string template, object?[]? classArgs = null, object?[]? methodArgs = null, .<string, object?>? propertyValues = null);
    }
    public interface ITestRegisteredEventReceiver : .
    {
        . OnTestRegistered(.TestRegisteredContext context);
    }
    public interface ITestRetryEventReceiver : .
    {
        . OnTestRetry(.TestContext context, int retryAttempt);
    }
    public interface ITestSkippedEventReceiver : .
    {
        . OnTestSkipped(.TestContext context);
    }
    public interface ITestStartEventReceiver : .
    {
        . OnTestStart(.TestContext context);
    }
    public interface ITypedTestMetadata
    {
         TestClassType { get; }
    }
}
namespace .
{
    public interface IAssemblyHookSource
    {
        .<.<.AssemblyHookContext>> CollectAfterAssemblyHooks(string sessionId);
        .<.<.AssemblyHookContext>> CollectAfterEveryAssemblyHooks(string sessionId);
        .<.<.AssemblyHookContext>> CollectBeforeAssemblyHooks(string sessionId);
        .<.<.AssemblyHookContext>> CollectBeforeEveryAssemblyHooks(string sessionId);
    }
    public interface IClassHookSource
    {
        .<.<.ClassHookContext>> CollectAfterClassHooks(string sessionId);
        .<.<.ClassHookContext>> CollectAfterEveryClassHooks(string sessionId);
        .<.<.ClassHookContext>> CollectBeforeClassHooks(string sessionId);
        .<.<.ClassHookContext>> CollectBeforeEveryClassHooks(string sessionId);
    }
    public interface IPropertySource
    {
        string PropertyName { get; }
        bool ShouldInitialize { get; }
         Type { get; }
        . InitializeAsync(object instance);
    }
    public interface ITestDiscoveryHookSource
    {
        .<.<.TestDiscoveryContext>> CollectAfterTestDiscoveryHooks(string sessionId);
        .<.<.BeforeTestDiscoveryContext>> CollectBeforeTestDiscoveryHooks(string sessionId);
    }
    public interface ITestHookSource
    {
        .<.<.TestContext>> CollectAfterEveryTestHooks(string sessionId);
        .<.> CollectAfterTestHooks(string sessionId);
        .<.<.TestContext>> CollectBeforeEveryTestHooks(string sessionId);
        .<.> CollectBeforeTestHooks(string sessionId);
    }
    public interface ITestSessionHookSource
    {
        .<.<.TestSessionContext>> CollectAfterTestSessionHooks(string sessionId);
        .<.<.TestSessionContext>> CollectBeforeTestSessionHooks(string sessionId);
    }
    public interface ITestSource
    {
        .<.<.TestMetadata>> GetTestsAsync();
    }
}
namespace .Logging
{
    public class DefaultLogger : .
    {
        public DefaultLogger(.Context context) { }
        public override void Log<TState>(. logLevel, TState state, ? exception, <TState, ?, string> formatter) { }
        public override . LogAsync<TState>(. logLevel, TState state, ? exception, <TState, ?, string> formatter) { }
        public void PushProperties(.<string, .<object>> dictionary) { }
        public void PushProperty(string name, object? value) { }
    }
    public interface ILogger
    {
        bool IsEnabled(. logLevel);
        void Log<TState>(. logLevel, TState state, ? exception, <TState, ?, string> formatter);
        . LogAsync<TState>(. logLevel, TState state, ? exception, <TState, ?, string> formatter);
    }
    public interface ILogger<out TCategoryName> : . { }
    public enum LogLevel
    {
        Trace = 0,
        Debug = 1,
        Information = 2,
        Warning = 3,
        Error = 4,
        Critical = 5,
        None = 6,
    }
    public static class LoggingExtensions
    {
        public static void LogCritical(this . logger, string message) { }
        public static . LogCriticalAsync(this . logger, string message) { }
        public static void LogDebug(this . logger, string message) { }
        public static . LogDebugAsync(this . logger, string message) { }
        public static void LogError(this . logger,  ex) { }
        public static void LogError(this . logger, string message) { }
        public static void LogError(this . logger, string message,  ex) { }
        public static . LogErrorAsync(this . logger,  ex) { }
        public static . LogErrorAsync(this . logger, string message) { }
        public static . LogErrorAsync(this . logger, string message,  ex) { }
        public static void LogInformation(this . logger, string message) { }
        public static . LogInformationAsync(this . logger, string message) { }
        public static void LogTrace(this . logger, string message) { }
        public static . LogTraceAsync(this . logger, string message) { }
        public static void LogWarning(this . logger, string message) { }
        public static . LogWarningAsync(this . logger, string message) { }
    }
    public abstract class TUnitLogger : .
    {
        protected TUnitLogger() { }
        public virtual bool IsEnabled(. logLevel) { }
        public abstract void Log<TState>(. logLevel, TState state, ? exception, <TState, ?, string> formatter);
        public abstract . LogAsync<TState>(. logLevel, TState state, ? exception, <TState, ?, string> formatter);
    }
}
namespace .Models
{
    public class TestExecutionData
    {
        public TestExecutionData() { }
        public <.DataGeneratorMetadata, .CancellationToken, .<.<object?[]?>>>? AsyncDataExecutor { get; set; }
        public <.DataGeneratorMetadata, .CancellationToken, .<.<<.<object?[]?>>>>>? AsyncDataSourceResolver { get; set; }
        public <.<.<object?[]>>>? AsyncMethodDataResolver { get; set; }
        public ? ClassFactory { get; set; }
        public bool HasAsyncDataSource { get; }
        public bool HasMethodDataResolver { get; }
        public bool HasStronglyTypedDelegates { get; }
        public <.<object?[]>>? MethodDataResolver { get; set; }
        public ? MethodInvoker { get; set; }
        public .<string, <object, object?>> PropertySetters { get; }
    }
}
namespace .Services
{
    [.("AOT", "IL3050")]
    [.("Trimming", "IL2026")]
    [.("Trimming", "IL2067")]
    public class AotTestInstanceFactory : .
    {
        public AotTestInstanceFactory() { }
        public .<object> CreateInstanceAsync( type, object?[] args) { }
        public .<object?> InvokeMethodAsync(object instance, .MethodInfo method, object?[] args) { }
        public . SetPropertyAsync(object instance, .PropertyInfo property, object? value) { }
    }
    [.("Generic type resolution requires runtime type generation")]
    [.("Generic type resolution may access types not preserved by trimming")]
    public class GenericTypeResolver : .
    {
        public GenericTypeResolver() { }
        public [] ResolveGenericClassArguments([.(..PublicConstructors)]  genericTypeDefinition, object?[] constructorArguments) { }
        public [] ResolveGenericMethodArguments(.MethodInfo genericMethodDefinition, object?[] runtimeArguments) { }
    }
    public class ModeDetector : .
    {
        public ModeDetector(bool isReflectionModeRequested = false) { }
        public bool IsDynamicCodeSupported { get; }
        public bool IsReflectionModeRequested { get; }
        public bool IsSourceGenerationAvailable { get; }
        public static . Mode { get; }
        public . DetectMode() { }
    }
    public class NoOpGenericTypeResolver : .
    {
        public NoOpGenericTypeResolver() { }
        public [] ResolveGenericClassArguments([.(..PublicConstructors)]  genericTypeDefinition, object?[] constructorArguments) { }
        public [] ResolveGenericMethodArguments(.MethodInfo genericMethodDefinition, object?[] runtimeArguments) { }
    }
    public static class ServiceProviderExtensions
    {
        public static object GetRequiredService(this  serviceProvider,  serviceType) { }
        public static T GetRequiredService<T>(this  serviceProvider)
            where T :  class { }
        public static T? GetService<T>(this  serviceProvider)
            where T :  class { }
    }
    public class TestExecutionRegistry : .
    {
        public TestExecutionRegistry() { }
        public static . Instance { get; }
        public void Clear() { }
        public <.DataGeneratorMetadata, .CancellationToken, .<.<object?[]?>>>? GetAsyncDataExecutor(string testId) { }
        public <.DataGeneratorMetadata, .CancellationToken, .<.<<.<object?[]?>>>>>? GetAsyncDataSourceResolver(string testId) { }
        public <.<.<object?[]>>>? GetAsyncMethodDataResolver(string testId) { }
        public <object>? GetClassFactory(string testId) { }
        public <.<object?[]>>? GetMethodDataResolver(string testId) { }
        public <object, object?[], .<object?>>? GetMethodInvoker(string testId) { }
        public . GetOrCreateTestData(string testId) { }
        public <object?[], object>? GetParameterizedClassFactory(string testId) { }
        public .<string, <object, object?>> GetPropertySetters(string testId) { }
        public .<string> GetRegisteredTestIds() { }
        public T? GetStronglyTypedClassFactory<T>(string testId)
            where T :  { }
        public T? GetStronglyTypedMethodInvoker<T>(string testId)
            where T :  { }
        public .? GetTestData(string testId) { }
        public bool HasAsyncDataSourceResolver(string testId) { }
        public bool HasMethodDataResolver(string testId) { }
        public bool HasStronglyTypedFactory(string testId) { }
        public void RegisterAsyncDataExecutor(string testId, <.DataGeneratorMetadata, .CancellationToken, .<.<object?[]?>>> executor) { }
        public void RegisterAsyncDataSourceResolver(string testId, <.DataGeneratorMetadata, .CancellationToken, .<.<<.<object?[]?>>>>> resolver) { }
        public void RegisterAsyncMethodDataResolver(string testId, <.<.<object?[]>>> resolver) { }
        public void RegisterClassFactory(string testId, <object> factory) { }
        public void RegisterClassFactory(string testId, <object?[], object> factory) { }
        public void RegisterMethodDataResolver(string testId, <.<object?[]>> resolver) { }
        public void RegisterMethodInvoker(string testId, <object, object?[], .<object?>> invoker) { }
        public void RegisterPropertySetter(string testId, string propertyName, <object, object?> setter) { }
        public void RegisterStronglyTypedClassFactory<T>(string testId,  factory)
            where T :  class { }
        public void RegisterStronglyTypedClassFactory<T>(string testId, <T> factory)
            where T :  class { }
        public void RegisterStronglyTypedMethodInvoker<T>(string testId,  invoker)
            where T :  class { }
        public void RegisterTest(string testId, . data) { }
    }
    public class TestNameFormatter : .
    {
        public TestNameFormatter() { }
        public string BuildTestId(string template, int testIndex, int repeatIndex = 0, int classDataIndex = 0, int methodDataIndex = 0) { }
        public string FormatArgumentValue(object? value) { }
        public string FormatTestName(string template, object?[]? classArgs = null, object?[]? methodArgs = null, .<string, object?>? propertyValues = null) { }
    }
    public class TestServiceProvider : 
    {
        public TestServiceProvider() { }
        public . AddSingleton( serviceType, object service) { }
        public . AddSingleton<T>(T service)
            where T :  class { }
        public . AddTransient( serviceType, <object> factory) { }
        public . AddTransient<T>(<T> factory)
            where T :  class { }
        public object? GetService( serviceType) { }
    }
}