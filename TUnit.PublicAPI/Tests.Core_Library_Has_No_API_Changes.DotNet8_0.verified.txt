[assembly: .(@", PublicKey=0024000004800000940000000602000000240000525341310004000001000100698a70398fa0b2230c5a72e3bd9d56b48f809f6173e49a19fbb942d621be93ad48c5566b47b28faabc359b9ad3ff4e00bbdea88f5bdfa250f391fedd28182b2e37b55d429c0151a42a98ea7a5821818cd15a79fef9903e8607a88304cf3e0317bf86ec96e32e1381535a6582251e5a6eed40b5a3ed82bc444598b1269cce57a7")]
[assembly: .(@", PublicKey=0024000004800000940000000602000000240000525341310004000001000100698a70398fa0b2230c5a72e3bd9d56b48f809f6173e49a19fbb942d621be93ad48c5566b47b28faabc359b9ad3ff4e00bbdea88f5bdfa250f391fedd28182b2e37b55d429c0151a42a98ea7a5821818cd15a79fef9903e8607a88304cf3e0317bf86ec96e32e1381535a6582251e5a6eed40b5a3ed82bc444598b1269cce57a7")]
[assembly: .(".NETCoreApp,Version=v8.0", FrameworkDisplayName=".NET 8.0")]
namespace 
{
    [.DebuggerDisplay("{.Name}.{}")]
    public abstract class AbstractExecutableTest
    {
        protected AbstractExecutableTest() { }
        public required object?[] Arguments { get; init; }
        public object?[] ClassArguments { get; init; }
        public . CompletionTask { get; }
        public required .TestContext Context { get; init; }
        public .ResolvedDependency[] Dependencies { get; set; }
        public ? Duration { get; }
        public ? EndTime { get; set; }
        public virtual .TestMetadata Metadata { get; init; }
        public .TestResult? Result { get; set; }
        public ? StartTime { get; set; }
        public .TestState State { get; set; }
        public required string TestId { get; init; }
        public abstract .<object> CreateInstanceAsync();
        public abstract . InvokeTestAsync(object instance, .CancellationToken cancellationToken);
    }
    [(.Method)]
    public sealed class AfterAttribute : .HookAttribute
    {
        public AfterAttribute(.HookType hookType, [.] string file = "", [.] int line = 0) { }
    }
    [(.Method)]
    public sealed class AfterEveryAttribute : .HookAttribute
    {
        public AfterEveryAttribute(.HookType hookType, [.] string file = "", [.] int line = 0) { }
    }
    public abstract class ArgumentDisplayFormatter
    {
        protected ArgumentDisplayFormatter() { }
        public abstract bool CanHandle(object? value);
        public abstract string FormatValue(object? value);
    }
    public abstract class ArgumentDisplayFormatterAttribute : .TUnitAttribute, ., .
    {
        protected ArgumentDisplayFormatterAttribute() { }
        public abstract .ArgumentDisplayFormatter Formatter { get; }
        public virtual int Order { get; }
        public . OnTestDiscovered(.DiscoveredTestContext context) { }
    }
    [(.Assembly | .Class | .Method, AllowMultiple=true)]
    public class ArgumentDisplayFormatterAttribute<T> : .ArgumentDisplayFormatterAttribute
        where T : .ArgumentDisplayFormatter, new ()
    {
        public ArgumentDisplayFormatterAttribute() { }
        public override .ArgumentDisplayFormatter Formatter { get; }
    }
    [(.Class | .Method | .Property, AllowMultiple=true)]
    public sealed class ArgumentsAttribute : , .IDataSourceAttribute
    {
        public ArgumentsAttribute(params object?[]? values) { }
        public object?[] Values { get; }
        [.(typeof(.ArgumentsAttribute.<GetDataRowsAsync>d__4))]
        public .<<.<object?[]?>>> GetDataRowsAsync(.DataGeneratorMetadata dataGeneratorMetadata) { }
    }
    [(.Class | .Method | .Property, AllowMultiple=true)]
    public sealed class ArgumentsAttribute<T> : .TypedDataSourceAttribute<T>
    {
        public ArgumentsAttribute(T value) { }
        [.(typeof(.ArgumentsAttribute<T>.<GetTypedDataRowsAsync>d__2))]
        public override .<<.<T>>> GetTypedDataRowsAsync(.DataGeneratorMetadata dataGeneratorMetadata) { }
    }
    public class Artifact
    {
        public Artifact() { }
        public string? Description { get; init; }
        public required string DisplayName { get; init; }
        public required .FileInfo File { get; init; }
    }
    [.DebuggerDisplay("{().Name}")]
    public class AssemblyHookContext : .Context
    {
        public .<.TestContext> AllTests { get; }
        public required .Assembly Assembly { get; init; }
        public .<.ClassHookContext> TestClasses { get; }
        public int TestCount { get; }
        public .TestSessionContext TestSessionContext { get; }
        public new static .AssemblyHookContext? Current { get; }
        public void AddClass(.ClassHookContext classHookContext) { }
    }
    [.DebuggerDisplay("{Name})")]
    public class AssemblyMetadata : <.AssemblyMetadata>
    {
        public AssemblyMetadata() { }
        public required string Name { get; init; }
        public virtual bool Equals(.AssemblyMetadata? other) { }
        public override int GetHashCode() { }
        public static .AssemblyMetadata GetOrAdd(string name, <.AssemblyMetadata> factory) { }
    }
    public static class AsyncConvert
    {
        public static . Convert( action) { }
        public static . Convert(<.> action) { }
        public static . Convert(<.> action) { }
        public static . ConvertObject(object? invoke) { }
        [.("Trimming", "IL2075:\'this\' argument does not satisfy \'DynamicallyAccessedMembersAttribute\' in " +
            "call to target method. The return value of the source method does not have match" +
            "ing annotations.", Justification="GetAwaiter pattern detection for custom awaitables. For AOT, use standard Task/Va" +
            "lueTask types or implement IAsyncEnumerable.")]
        public static bool TryGetAwaitableTask(object awaitable, [.(true)] out .? task) { }
    }
    [(.Class | .Method | .Property, AllowMultiple=true)]
    public abstract class AsyncDataSourceGeneratorAttribute<[.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods)]  T> : .TypedDataSourceAttribute<T>
    {
        protected AsyncDataSourceGeneratorAttribute() { }
        protected abstract .<<.<T>>> GenerateDataSourcesAsync(.DataGeneratorMetadata dataGeneratorMetadata);
        [.(typeof(.AsyncDataSourceGeneratorAttribute<T>.<GetTypedDataRowsAsync>d__1))]
        public override .<<.<T>>> GetTypedDataRowsAsync(.DataGeneratorMetadata dataGeneratorMetadata) { }
    }
    [(.Class | .Method, AllowMultiple=true)]
    public abstract class AsyncDataSourceGeneratorAttribute<[.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods)]  T1, [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods)]  T2> : .TypedDataSourceAttribute<<T1, T2>>
    {
        protected AsyncDataSourceGeneratorAttribute() { }
        protected abstract .<<.<<T1, T2>>>> GenerateDataSourcesAsync(.DataGeneratorMetadata dataGeneratorMetadata);
        [.(typeof(.AsyncDataSourceGeneratorAttribute<T1, T2>.<GetTypedDataRowsAsync>d__1))]
        public override .<<.<<T1, T2>>>> GetTypedDataRowsAsync(.DataGeneratorMetadata dataGeneratorMetadata) { }
    }
    [(.Class | .Method, AllowMultiple=true)]
    public abstract class AsyncDataSourceGeneratorAttribute<[.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods)]  T1, [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods)]  T2, [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods)]  T3> : .TypedDataSourceAttribute<<T1, T2, T3>>
    {
        protected AsyncDataSourceGeneratorAttribute() { }
        protected abstract .<<.<<T1, T2, T3>>>> GenerateDataSourcesAsync(.DataGeneratorMetadata dataGeneratorMetadata);
        [.(typeof(.AsyncDataSourceGeneratorAttribute<T1, T2, T3>.<GetTypedDataRowsAsync>d__1))]
        public override .<<.<<T1, T2, T3>>>> GetTypedDataRowsAsync(.DataGeneratorMetadata dataGeneratorMetadata) { }
    }
    [(.Class | .Method, AllowMultiple=true)]
    public abstract class AsyncDataSourceGeneratorAttribute<[.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods)]  T1, [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods)]  T2, [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods)]  T3, [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods)]  T4> : .TypedDataSourceAttribute<<T1, T2, T3, T4>>
    {
        protected AsyncDataSourceGeneratorAttribute() { }
        protected abstract .<<.<<T1, T2, T3, T4>>>> GenerateDataSourcesAsync(.DataGeneratorMetadata dataGeneratorMetadata);
        [.(typeof(.AsyncDataSourceGeneratorAttribute<T1, T2, T3, T4>.<GetTypedDataRowsAsync>d__1))]
        public override .<<.<<T1, T2, T3, T4>>>> GetTypedDataRowsAsync(.DataGeneratorMetadata dataGeneratorMetadata) { }
    }
    [(.Class | .Method, AllowMultiple=true)]
    public abstract class AsyncDataSourceGeneratorAttribute<[.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods)]  T1, [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods)]  T2, [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods)]  T3, [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods)]  T4, [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods)]  T5> : .TypedDataSourceAttribute<<T1, T2, T3, T4, T5>>
    {
        protected AsyncDataSourceGeneratorAttribute() { }
        protected abstract .<<.<<T1, T2, T3, T4, T5>>>> GenerateDataSourcesAsync(.DataGeneratorMetadata dataGeneratorMetadata);
        [.(typeof(.AsyncDataSourceGeneratorAttribute<T1, T2, T3, T4, T5>.<GetTypedDataRowsAsync>d__1))]
        public override .<<.<<T1, T2, T3, T4, T5>>>> GetTypedDataRowsAsync(.DataGeneratorMetadata dataGeneratorMetadata) { }
    }
    public class AsyncEvent<TEventArgs>
    {
        public AsyncEvent() { }
        public int Order { get; set; }
        public .AsyncEvent<TEventArgs> InsertAtFront(<object, TEventArgs, .> callback) { }
        public static .AsyncEvent<TEventArgs> operator +(.AsyncEvent<TEventArgs>? e, <object, TEventArgs, .> callback) { }
        public class Invocation : .
        {
            public Invocation(<object, TEventArgs, .> factory, int order) { }
            public int Order { get; }
            public . InvokeAsync(object sender, TEventArgs eventArgs) { }
        }
    }
    [(.Class | .Method | .Property, AllowMultiple=true)]
    [.("AsyncUntypedDataSourceGeneratorAttribute requires dynamic code generation for run" +
        "time data source creation. Consider using strongly-typed AsyncDataSourceGenerato" +
        "rAttribute<T> overloads for AOT compatibility.")]
    [.("AsyncUntypedDataSourceGeneratorAttribute may require unreferenced code for runtim" +
        "e data source creation. Consider using strongly-typed AsyncDataSourceGeneratorAt" +
        "tribute<T> overloads for AOT compatibility.")]
    public abstract class AsyncUntypedDataSourceGeneratorAttribute : , .IDataSourceAttribute
    {
        protected AsyncUntypedDataSourceGeneratorAttribute() { }
        [.(typeof(.AsyncUntypedDataSourceGeneratorAttribute.<GenerateAsync>d__1))]
        public .<<.<object?[]?>>> GenerateAsync(.DataGeneratorMetadata dataGeneratorMetadata) { }
        protected abstract .<<.<object?[]?>>> GenerateDataSourcesAsync(.DataGeneratorMetadata dataGeneratorMetadata);
        public .<<.<object?[]?>>> GetDataRowsAsync(.DataGeneratorMetadata dataGeneratorMetadata) { }
    }
    [(.Method)]
    public abstract class BaseTestAttribute : .TUnitAttribute
    {
        public readonly string File;
        public readonly int Line;
    }
    [(.Method)]
    public sealed class BeforeAttribute : .HookAttribute
    {
        public BeforeAttribute(.HookType hookType, [.] string file = "", [.] int line = 0) { }
    }
    [(.Method)]
    public sealed class BeforeEveryAttribute : .HookAttribute
    {
        public BeforeEveryAttribute(.HookType hookType, [.] string file = "", [.] int line = 0) { }
    }
    public class BeforeTestDiscoveryContext : .Context
    {
        public .GlobalContext GlobalContext { get; }
        public required string? TestFilter { get; init; }
        public new static .BeforeTestDiscoveryContext? Current { get; }
    }
    [(.Assembly | .Class | .Method, AllowMultiple=true)]
    public class CategoryAttribute : .TUnitAttribute, ., .
    {
        public CategoryAttribute(string category) { }
        public string Category { get; }
        public int Order { get; }
        public . OnTestDiscovered(.DiscoveredTestContext context) { }
    }
    [(.Assembly | .Class)]
    public class ClassConstructorAttribute : .TUnitAttribute
    {
        public ClassConstructorAttribute([.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods | ..PublicProperties)]  classConstructorType) { }
        [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods | ..PublicProperties)]
        public  ClassConstructorType { get; init; }
    }
    [(.Assembly | .Class)]
    public sealed class ClassConstructorAttribute<[.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods | ..PublicProperties)]  T> : .ClassConstructorAttribute
        where T : ., new ()
    {
        public ClassConstructorAttribute() { }
    }
    public class ClassConstructorMetadata : <.ClassConstructorMetadata>
    {
        public ClassConstructorMetadata() { }
        public required .TestBuilderContext TestBuilderContext { get; init; }
        public required string TestSessionId { get; init; }
    }
    [(.Class | .Method | .Property, AllowMultiple=true)]
    [.("Trimming", "IL2109:Type derives from type with \'RequiresUnreferencedCodeAttribute\' which can " +
        "break functionality when trimming application code", Justification="The specific constructors (1-5 parameters) are AOT-compatible when used with type" +
        "of() expressions. Only the params constructor is incompatible.")]
    public sealed class ClassDataSourceAttribute : .UntypedDataSourceGeneratorAttribute
    {
        [.("AOT", "IL3050:Calling members annotated with \'RequiresDynamicCodeAttribute\' may break fu" +
            "nctionality when AOT compiling.")]
        [.("Trimming", "IL2026:Members annotated with \'RequiresUnreferencedCodeAttribute\' require dynamic" +
            " access otherwise can break functionality when trimming application code", Justification="<Pending>")]
        public ClassDataSourceAttribute([.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods | ..PublicProperties)]  type) { }
        [.("Reflection")]
        [.("Reflection")]
        public ClassDataSourceAttribute(params [] types) { }
        [.("AOT", "IL3050:Calling members annotated with \'RequiresDynamicCodeAttribute\' may break fu" +
            "nctionality when AOT compiling.")]
        [.("Trimming", "IL2026:Members annotated with \'RequiresUnreferencedCodeAttribute\' require dynamic" +
            " access otherwise can break functionality when trimming application code", Justification="<Pending>")]
        public ClassDataSourceAttribute([.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods | ..PublicProperties)]  type, [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods | ..PublicProperties)]  type2) { }
        [.("AOT", "IL3050:Calling members annotated with \'RequiresDynamicCodeAttribute\' may break fu" +
            "nctionality when AOT compiling.")]
        [.("Trimming", "IL2026:Members annotated with \'RequiresUnreferencedCodeAttribute\' require dynamic" +
            " access otherwise can break functionality when trimming application code", Justification="<Pending>")]
        public ClassDataSourceAttribute([.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods | ..PublicProperties)]  type, [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods | ..PublicProperties)]  type2, [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods | ..PublicProperties)]  type3) { }
        [.("AOT", "IL3050:Calling members annotated with \'RequiresDynamicCodeAttribute\' may break fu" +
            "nctionality when AOT compiling.")]
        [.("Trimming", "IL2026:Members annotated with \'RequiresUnreferencedCodeAttribute\' require dynamic" +
            " access otherwise can break functionality when trimming application code", Justification="<Pending>")]
        public ClassDataSourceAttribute([.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods | ..PublicProperties)]  type, [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods | ..PublicProperties)]  type2, [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods | ..PublicProperties)]  type3, [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods | ..PublicProperties)]  type4) { }
        [.("AOT", "IL3050:Calling members annotated with \'RequiresDynamicCodeAttribute\' may break fu" +
            "nctionality when AOT compiling.")]
        [.("Trimming", "IL2026:Members annotated with \'RequiresUnreferencedCodeAttribute\' require dynamic" +
            " access otherwise can break functionality when trimming application code", Justification="<Pending>")]
        public ClassDataSourceAttribute([.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods | ..PublicProperties)]  type, [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods | ..PublicProperties)]  type2, [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods | ..PublicProperties)]  type3, [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods | ..PublicProperties)]  type4, [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods | ..PublicProperties)]  type5) { }
        public string[] Keys { get; set; }
        public .SharedType[] Shared { get; set; }
        [.("Trimming", "IL2062:The parameter of method has a DynamicallyAccessedMembersAttribute, but the" +
            " value passed to it can not be statically analyzed.")]
        protected override .<<object?[]?>> GenerateDataSources(.DataGeneratorMetadata dataGeneratorMetadata) { }
        public .<string> GetKeys() { }
        public .<.SharedType> GetSharedTypes() { }
    }
    [(.Class | .Method | .Property, AllowMultiple=true)]
    public sealed class ClassDataSourceAttribute<[.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods | ..PublicProperties)]  T> : .DataSourceGeneratorAttribute<T>
    {
        public ClassDataSourceAttribute() { }
        public  ClassType { get; }
        public string Key { get; set; }
        public .SharedType Shared { get; set; }
        protected override .<<T>> GenerateDataSources(.DataGeneratorMetadata dataGeneratorMetadata) { }
        public .<string> GetKeys() { }
        public .<.SharedType> GetSharedTypes() { }
    }
    [(.Class | .Method, AllowMultiple=true)]
    public sealed class ClassDataSourceAttribute<[.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods | ..PublicProperties)]  T1, [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods | ..PublicProperties)]  T2> : .DataSourceGeneratorAttribute<T1, T2>
        where T1 : new()
        where T2 : new()
    {
        public ClassDataSourceAttribute() { }
        public string[] Keys { get; set; }
        public .SharedType[] Shared { get; set; }
        protected override .<<<T1, T2>>> GenerateDataSources(.DataGeneratorMetadata dataGeneratorMetadata) { }
        public .<string> GetKeys() { }
        public .<.SharedType> GetSharedTypes() { }
    }
    [(.Class | .Method, AllowMultiple=true)]
    public sealed class ClassDataSourceAttribute<[.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods | ..PublicProperties)]  T1, [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods | ..PublicProperties)]  T2, [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods | ..PublicProperties)]  T3> : .DataSourceGeneratorAttribute<T1, T2, T3>
        where T1 : new()
        where T2 : new()
        where T3 : new()
    {
        public ClassDataSourceAttribute() { }
        public string[] Keys { get; set; }
        public .SharedType[] Shared { get; set; }
        protected override .<<<T1, T2, T3>>> GenerateDataSources(.DataGeneratorMetadata dataGeneratorMetadata) { }
        public .<string> GetKeys() { }
        public .<.SharedType> GetSharedTypes() { }
    }
    [(.Class | .Method, AllowMultiple=true)]
    public sealed class ClassDataSourceAttribute<[.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods | ..PublicProperties)]  T1, [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods | ..PublicProperties)]  T2, [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods | ..PublicProperties)]  T3, [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods | ..PublicProperties)]  T4> : .DataSourceGeneratorAttribute<T1, T2, T3, T4>
        where T1 : new()
        where T2 : new()
        where T3 : new()
        where T4 : new()
    {
        public ClassDataSourceAttribute() { }
        public string[] Keys { get; set; }
        public .SharedType[] Shared { get; set; }
        protected override .<<<T1, T2, T3, T4>>> GenerateDataSources(.DataGeneratorMetadata dataGeneratorMetadata) { }
        public .<string> GetKeys() { }
        public .<.SharedType> GetSharedTypes() { }
    }
    [(.Class | .Method, AllowMultiple=true)]
    public sealed class ClassDataSourceAttribute<[.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods | ..PublicProperties)]  T1, [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods | ..PublicProperties)]  T2, [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods | ..PublicProperties)]  T3, [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods | ..PublicProperties)]  T4, [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods | ..PublicProperties)]  T5> : .DataSourceGeneratorAttribute<T1, T2, T3, T4, T5>
        where T1 : new()
        where T2 : new()
        where T3 : new()
        where T4 : new()
        where T5 : new()
    {
        public ClassDataSourceAttribute() { }
        public string[] Keys { get; set; }
        public .SharedType[] Shared { get; set; }
        protected override .<<<T1, T2, T3, T4, T5>>> GenerateDataSources(.DataGeneratorMetadata dataGeneratorMetadata) { }
        public .<string> GetKeys() { }
        public .<.SharedType> GetSharedTypes() { }
    }
    [.DebuggerDisplay("{}")]
    public class ClassHookContext : .Context
    {
        public .AssemblyHookContext AssemblyContext { get; }
        [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods | ..PublicProperties)]
        public required  ClassType { get; init; }
        public int TestCount { get; }
        public .<.TestContext> Tests { get; }
        public new static .ClassHookContext? Current { get; }
        public void AddTest(.TestContext testContext) { }
        public override bool Equals(object? obj) { }
        public override int GetHashCode() { }
    }
    [.DebuggerDisplay("{Type}")]
    public class ClassMetadata : .MemberMetadata, <.ClassMetadata>
    {
        public ClassMetadata() { }
        public required .AssemblyMetadata Assembly { get; init; }
        public required string? Namespace { get; init; }
        public required .ParameterMetadata[] Parameters { get; init; }
        public required .ClassMetadata? Parent { get; init; }
        public required .PropertyMetadata[] Properties { get; init; }
        [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..NonPublicConstructors | ..PublicMethods | ..NonPublicMethods | ..PublicProperties)]
        public override required  Type { get; init; }
        public required .TypeReference TypeReference { get; init; }
        public virtual bool Equals(.ClassMetadata? other) { }
        public override int GetHashCode() { }
        public static .ClassMetadata GetOrAdd(string name, <.ClassMetadata> factory) { }
    }
    public abstract class Context : , .
    {
        public .TextWriter ErrorOutputWriter { get; }
        public .TextWriter OutputWriter { get; }
        protected .Context? Parent { get; }
        public static .Context Current { get; }
        public void AddAsyncLocalValues() { }
        public void Dispose() { }
        public . GetDefaultLogger() { }
        public string GetErrorOutput() { }
        public string GetStandardOutput() { }
        public void RestoreExecutionContext() { }
    }
    public class ContextProvider : .
    {
        public ContextProvider( serviceProvider, string testSessionId, string? testFilter) { }
        public .BeforeTestDiscoveryContext BeforeTestDiscoveryContext { get; }
        public .GlobalContext GlobalContext { get; }
        public .TestDiscoveryContext TestDiscoveryContext { get; }
        public .TestSessionContext TestSessionContext { get; }
        public .TestContext CreateTestContext(string testName, [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods | ..PublicProperties)]  classType, .TestBuilderContext testBuilderContext, .CancellationToken cancellationToken) { }
        public .AssemblyHookContext GetOrCreateAssemblyContext(.Assembly assembly) { }
        public .ClassHookContext GetOrCreateClassContext([.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods | ..PublicProperties)]  classType) { }
    }
    public class CultureExecutor : .DedicatedThreadExecutor
    {
        public CultureExecutor(.CultureInfo cultureInfo) { }
        protected override void ConfigureThread(.Thread thread) { }
    }
    public class DataGenerationException : 
    {
        public DataGenerationException(string message) { }
        public DataGenerationException(string message,  innerException) { }
        public DataGenerationException(string message, object? dataSource) { }
        public DataGenerationException(string message, object? dataSource,  innerException) { }
        public object? DataSource { get; }
        public string? DataSourceTypeName { get; }
        public string? TestClassName { get; }
        public string? TestMethodName { get; }
        public override string ToString() { }
        public .DataGenerationException WithTestContext(string? className, string? methodName) { }
    }
    public class DataGeneratorMetadata : <.DataGeneratorMetadata>
    {
        public DataGeneratorMetadata() { }
        public required object?[]? ClassInstanceArguments { get; init; }
        public required .MemberMetadata[] MembersToGenerate { get; init; }
        public required .TestBuilderContextAccessor? TestBuilderContext { get; init; }
        public required object? TestClassInstance { get; init; }
        public required .MethodMetadata? TestInformation { get; init; }
        public required string TestSessionId { get; init; }
        public required . Type { get; init; }
    }
    public sealed class DataSourceContext
    {
        public DataSourceContext( testClassType, .DataSourceLevel level, .MemberInfo? targetMember = null, .ParameterInfo? targetParameter = null, .<>? attributes = null, ? serviceProvider = null) { }
        public .<> Attributes { get; }
        public .DataSourceLevel Level { get; }
        public ? ServiceProvider { get; }
        public .MemberInfo? TargetMember { get; }
        public .ParameterInfo? TargetParameter { get; }
        public  TestClassType { get; }
    }
    public class DataSourceException : .TestBuilderException
    {
        public DataSourceException(string dataSourceName,  innerException) { }
        public DataSourceException(string dataSourceName, string message) { }
        public string DataSourceName { get; }
    }
    [(.Class | .Method | .Property, AllowMultiple=true)]
    public abstract class DataSourceGeneratorAttribute<[.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods)]  T> : .AsyncDataSourceGeneratorAttribute<T>
    {
        protected DataSourceGeneratorAttribute() { }
        protected abstract .<<T>> GenerateDataSources(.DataGeneratorMetadata dataGeneratorMetadata);
        [.(typeof(.DataSourceGeneratorAttribute<T>.<GenerateDataSourcesAsync>d__1))]
        protected override .<<.<T>>> GenerateDataSourcesAsync(.DataGeneratorMetadata dataGeneratorMetadata) { }
    }
    [(.Class | .Method, AllowMultiple=true)]
    public abstract class DataSourceGeneratorAttribute<[.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods)]  T1, [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods)]  T2> : .AsyncDataSourceGeneratorAttribute<T1, T2>
    {
        protected DataSourceGeneratorAttribute() { }
        protected abstract .<<<T1, T2>>> GenerateDataSources(.DataGeneratorMetadata dataGeneratorMetadata);
        [.(typeof(.DataSourceGeneratorAttribute<T1, T2>.<GenerateDataSourcesAsync>d__1))]
        protected override .<<.<<T1, T2>>>> GenerateDataSourcesAsync(.DataGeneratorMetadata dataGeneratorMetadata) { }
    }
    [(.Class | .Method, AllowMultiple=true)]
    public abstract class DataSourceGeneratorAttribute<[.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods)]  T1, [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods)]  T2, [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods)]  T3> : .AsyncDataSourceGeneratorAttribute<T1, T2, T3>
    {
        protected DataSourceGeneratorAttribute() { }
        protected abstract .<<<T1, T2, T3>>> GenerateDataSources(.DataGeneratorMetadata dataGeneratorMetadata);
        [.(typeof(.DataSourceGeneratorAttribute<T1, T2, T3>.<GenerateDataSourcesAsync>d__1))]
        protected override sealed .<<.<<T1, T2, T3>>>> GenerateDataSourcesAsync(.DataGeneratorMetadata dataGeneratorMetadata) { }
    }
    [(.Class | .Method, AllowMultiple=true)]
    public abstract class DataSourceGeneratorAttribute<[.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods)]  T1, [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods)]  T2, [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods)]  T3, [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods)]  T4> : .AsyncDataSourceGeneratorAttribute<T1, T2, T3, T4>
    {
        protected DataSourceGeneratorAttribute() { }
        protected abstract .<<<T1, T2, T3, T4>>> GenerateDataSources(.DataGeneratorMetadata dataGeneratorMetadata);
        [.(typeof(.DataSourceGeneratorAttribute<T1, T2, T3, T4>.<GenerateDataSourcesAsync>d__1))]
        protected override .<<.<<T1, T2, T3, T4>>>> GenerateDataSourcesAsync(.DataGeneratorMetadata dataGeneratorMetadata) { }
    }
    [(.Class | .Method, AllowMultiple=true)]
    public abstract class DataSourceGeneratorAttribute<[.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods)]  T1, [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods)]  T2, [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods)]  T3, [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods)]  T4, [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods)]  T5> : .AsyncDataSourceGeneratorAttribute<T1, T2, T3, T4, T5>
    {
        protected DataSourceGeneratorAttribute() { }
        protected abstract .<<<T1, T2, T3, T4, T5>>> GenerateDataSources(.DataGeneratorMetadata dataGeneratorMetadata);
        [.(typeof(.DataSourceGeneratorAttribute<T1, T2, T3, T4, T5>.<GenerateDataSourcesAsync>d__1))]
        protected override .<<.<<T1, T2, T3, T4, T5>>>> GenerateDataSourcesAsync(.DataGeneratorMetadata dataGeneratorMetadata) { }
    }
    public enum DataSourceLevel
    {
        Class = 0,
        Method = 1,
        Property = 2,
        Parameter = 3,
    }
    public static class DataSourcePropertyInjectionRegistry
    {
        public static .PropertyInjectionData[]? GetInjectionData( dataSourceType) { }
        public static .PropertyDataSource[]? GetPropertyDataSources( dataSourceType) { }
        public static void Register( dataSourceType, .PropertyInjectionData[] injectionData, .PropertyDataSource[] propertyDataSources) { }
    }
    public class DedicatedThreadExecutor : .GenericAbstractExecutor, ., .
    {
        public DedicatedThreadExecutor() { }
        protected virtual void CleanUp() { }
        protected virtual void ConfigureThread(.Thread thread) { }
        protected override sealed . ExecuteAsync(<.> action) { }
        protected virtual void Initialize() { }
        public . OnTestRegistered(.TestRegisteredContext context) { }
    }
    public class DefaultExecutor : .GenericAbstractExecutor
    {
        public static readonly .DefaultExecutor Instance;
        protected override . ExecuteAsync(<.> action) { }
    }
    [.("DependencyInjectionDataSourceAttribute requires dynamic code generation for depen" +
        "dency injection container access. This attribute is inherently incompatible with" +
        " AOT compilation.")]
    [.("DependencyInjectionDataSourceAttribute may require unreferenced code for dependen" +
        "cy injection container access. This attribute is inherently incompatible with AO" +
        "T compilation.")]
    public abstract class DependencyInjectionDataSourceAttribute<TScope> : .UntypedDataSourceGeneratorAttribute
    {
        protected DependencyInjectionDataSourceAttribute() { }
        public abstract object? Create(TScope scope,  type);
        public abstract TScope CreateScope(.DataGeneratorMetadata dataGeneratorMetadata);
        protected override .<<object?[]?>> GenerateDataSources(.DataGeneratorMetadata dataGeneratorMetadata) { }
    }
    [(.Class | .Method, AllowMultiple=true)]
    public class DependsOnAttribute : .TUnitAttribute
    {
        public DependsOnAttribute( testClass) { }
        public DependsOnAttribute(string testName) { }
        public DependsOnAttribute( testClass, string testName) { }
        public DependsOnAttribute(string testName, [] parameterTypes) { }
        public DependsOnAttribute( testClass, string testName, [] parameterTypes) { }
        public ? ClassMetadata { get; }
        public []? ParameterTypes { get; }
        public bool ProceedOnFailure { get; set; }
        public string? TestName { get; }
        public override string ToString() { }
        public .TestDependency ToTestDependency() { }
    }
    [(.Class | .Method, AllowMultiple=true)]
    public class DependsOnAttribute<T> : .DependsOnAttribute
    {
        public DependsOnAttribute() { }
        public DependsOnAttribute(string testName) { }
        public DependsOnAttribute(string testName, [] parameterTypes) { }
    }
    public abstract class DiscoveredTest
    {
        protected DiscoveredTest() { }
        public required .TestContext TestContext { get; init; }
        public .TestDetails TestDetails { get; }
        public .? TestExecutor { get; set; }
    }
    public class DiscoveredTestContext
    {
        public DiscoveredTestContext(string testName, .TestContext testContext) { }
        public .<<object?, string?>> ArgumentDisplayFormatters { get; }
        public bool RunOnTestDiscovery { get; }
        public .TestContext TestContext { get; }
        public .TestDetails TestDetails { get; }
        public string TestName { get; }
        public void AddArgumentDisplayFormatter(.ArgumentDisplayFormatter formatter) { }
        public void AddCategory(string category) { }
        public void AddProperty(string key, string value) { }
        public string GetDisplayName() { }
        public void SetDisplayName(string displayName) { }
        public void SetDisplayNameFormatter( formatterType) { }
        public void SetParallelConstraint(. constraint) { }
        public void SetPriority(. priority) { }
        public void SetRetryLimit(int retryLimit) { }
        public void SetRetryLimit(int retryCount, <.TestContext, , int, .<bool>> shouldRetry) { }
        public void SetRunOnDiscovery(bool runOnDiscovery) { }
    }
    public class DiscoveredTest<T> : .DiscoveredTest
        where T :  class
    {
        public DiscoveredTest() { }
    }
    public sealed class DiscoveryFailure : <.DiscoveryFailure>
    {
        public DiscoveryFailure() { }
        public required  Exception { get; init; }
        public string Reason { get; }
        public string? TestClassName { get; init; }
        public required string TestFilePath { get; init; }
        public required string TestId { get; init; }
        public required int TestLineNumber { get; init; }
        public required string TestMethodName { get; init; }
    }
    public class DiscoveryResult
    {
        public DiscoveryResult() { }
        public static .DiscoveryResult Empty { get; }
    }
    [(.Method, Inherited=false)]
    public sealed class DisplayNameAttribute : .DisplayNameFormatterAttribute, .IScopedAttribute, .IScopedAttribute<.DisplayNameAttribute>
    {
        public DisplayNameAttribute(string displayName) { }
        protected override string FormatDisplayName(.DiscoveredTestContext context) { }
    }
    [(.Assembly | .Class | .Method, Inherited=false)]
    public abstract class DisplayNameFormatterAttribute : .TUnitAttribute, ., .
    {
        protected DisplayNameFormatterAttribute() { }
        public int Order { get; }
        protected abstract string FormatDisplayName(.DiscoveredTestContext context);
        public . OnTestDiscovered(.DiscoveredTestContext context) { }
    }
    public class DynamicDiscoveryResult : .DiscoveryResult
    {
        public DynamicDiscoveryResult() { }
        public .<> Attributes { get; set; }
        public object?[]? TestClassArguments { get; set; }
        [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..NonPublicConstructors | ..PublicMethods | ..NonPublicMethods | ..PublicProperties)]
        public ? TestClassType { get; set; }
        public .? TestMethod { get; set; }
        public object?[]? TestMethodArguments { get; set; }
    }
    public abstract class DynamicTest
    {
        protected DynamicTest() { }
        public abstract .<.DiscoveryResult> GetTests();
    }
    [.("TUnitWIP0001")]
    public class DynamicTestBuilderAttribute : .BaseTestAttribute
    {
        public DynamicTestBuilderAttribute([.] string file = "", [.] int line = 0) { }
    }
    public class DynamicTestBuilderContext
    {
        public DynamicTestBuilderContext(string filePath, int lineNumber) { }
        public string FilePath { get; }
        public int LineNumber { get; }
        public .<.DynamicTest> Tests { get; }
        public void AddTest(.DynamicTest test) { }
    }
    public static class DynamicTestHelper
    {
        public static T Argument<T>() { }
    }
    public class DynamicTestInstance<[.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..NonPublicConstructors | ..PublicMethods | ..NonPublicMethods | ..PublicProperties)]  T> : .DynamicTest<T>
        where T :  class
    {
        public DynamicTestInstance() { }
        public .<> Attributes { get; set; }
        public object?[]? TestClassArguments { get; set; }
        public .<<T>>? TestMethod { get; set; }
        public object?[]? TestMethodArguments { get; set; }
        public override .<.DiscoveryResult> GetTests() { }
    }
    public abstract class DynamicTest<[.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..NonPublicConstructors | ..PublicMethods | ..NonPublicMethods | ..PublicProperties)]  T> : .DynamicTest
        where T :  class
    {
        protected DynamicTest() { }
    }
    public class EngineCancellationToken : 
    {
        public EngineCancellationToken() { }
        public .CancellationToken Token { get; }
        public void Dispose() { }
    }
    public sealed class ExcludeOnAttribute : .SkipAttribute
    {
        public ExcludeOnAttribute(. OperatingSystem) { }
        public override .<bool> ShouldSkip(.TestRegisteredContext context) { }
    }
    public sealed class ExecutableTest : .AbstractExecutableTest
    {
        public ExecutableTest(<.TestContext, .<object>> createInstance, <object, object?[], .TestContext, .CancellationToken, .> invokeTest) { }
        public override .<object> CreateInstanceAsync() { }
        public override . InvokeTestAsync(object instance, .CancellationToken cancellationToken) { }
    }
    public sealed class ExecutableTestCreationContext
    {
        public ExecutableTestCreationContext() { }
        public required object?[] Arguments { get; init; }
        public required object?[] ClassArguments { get; init; }
        public required .TestContext Context { get; init; }
        public required string DisplayName { get; init; }
        public [] ResolvedClassGenericArguments { get; init; }
        public [] ResolvedMethodGenericArguments { get; init; }
        public required string TestId { get; init; }
    }
    [(.Assembly | .Class | .Method)]
    public class ExecutionPriorityAttribute : .SingleTUnitAttribute, .IScopedAttribute, .IScopedAttribute<.ExecutionPriorityAttribute>, ., .
    {
        public ExecutionPriorityAttribute(. priority = 2) { }
        public int Order { get; }
        public . Priority { get; }
        public . OnTestDiscovered(.DiscoveredTestContext context) { }
    }
    public class ExpandedTest
    {
        public ExpandedTest() { }
        public object?[]? ClassArguments { get; init; }
        public bool IsSkipped { get; init; }
        public object?[]? MethodArguments { get; init; }
        public required .MethodMetadata MethodMetadata { get; init; }
        public .<string, object?>? PropertyValues { get; init; }
        public string? SkipReason { get; init; }
        public required string TestFilePath { get; init; }
        public required string TestId { get; init; }
        public required object TestInstance { get; init; }
        public required int TestLineNumber { get; init; }
        public required .MethodInfo TestMethod { get; init; }
        public required string TestName { get; init; }
        public ? Timeout { get; init; }
    }
    [(.Class | .Method)]
    public sealed class ExplicitAttribute : .TUnitAttribute
    {
        public ExplicitAttribute([.] string callerFile = "", [.] string callerMemberName = "") { }
        public string For { get; }
    }
    public class FailedDynamicTest<[.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..NonPublicConstructors | ..PublicMethods | ..NonPublicMethods | ..PublicProperties)]  T> : .DynamicTest
        where T :  class
    {
        public FailedDynamicTest() { }
        public  Exception { get; set; }
        public string MethodName { get; set; }
        public string TestFilePath { get; set; }
        public string TestId { get; set; }
        public int TestLineNumber { get; set; }
        public override .<.DiscoveryResult> GetTests() { }
    }
    [(.Class | .Method, AllowMultiple=true)]
    public sealed class GenerateGenericTestAttribute : 
    {
        public GenerateGenericTestAttribute(params [] typeArguments) { }
        public [] TypeArguments { get; }
    }
    public abstract class GenericAbstractExecutor : ., .
    {
        protected GenericAbstractExecutor() { }
        public int Order { get; }
        public . ExecuteAfterAssemblyHook(.MethodMetadata hookMethodInfo, .AssemblyHookContext context, <.> action) { }
        public . ExecuteAfterClassHook(.MethodMetadata hookMethodInfo, .ClassHookContext context, <.> action) { }
        public . ExecuteAfterTestDiscoveryHook(.MethodMetadata hookMethodInfo, .TestDiscoveryContext context, <.> action) { }
        public . ExecuteAfterTestHook(.MethodMetadata hookMethodInfo, .TestContext context, <.> action) { }
        public . ExecuteAfterTestSessionHook(.MethodMetadata hookMethodInfo, .TestSessionContext context, <.> action) { }
        protected abstract . ExecuteAsync(<.> action);
        public . ExecuteBeforeAssemblyHook(.MethodMetadata hookMethodInfo, .AssemblyHookContext context, <.> action) { }
        public . ExecuteBeforeClassHook(.MethodMetadata hookMethodInfo, .ClassHookContext context, <.> action) { }
        public . ExecuteBeforeTestDiscoveryHook(.MethodMetadata hookMethodInfo, .BeforeTestDiscoveryContext context, <.> action) { }
        public . ExecuteBeforeTestHook(.MethodMetadata hookMethodInfo, .TestContext context, <.> action) { }
        public . ExecuteBeforeTestSessionHook(.MethodMetadata hookMethodInfo, .TestSessionContext context, <.> action) { }
        public . ExecuteTest(.TestContext context, <.> action) { }
    }
    public sealed class GenericMethodInfo
    {
        public GenericMethodInfo() { }
        public .GenericParameterConstraints[] Constraints { get; init; }
        public string[] ParameterNames { get; init; }
        public int[] ParameterPositions { get; init; }
    }
    public sealed class GenericParameterConstraints
    {
        public GenericParameterConstraints() { }
        public ? BaseTypeConstraint { get; init; }
        public bool HasDefaultConstructorConstraint { get; init; }
        public bool HasNotNullConstraint { get; init; }
        public bool HasReferenceTypeConstraint { get; init; }
        public bool HasValueTypeConstraint { get; init; }
        public [] InterfaceConstraints { get; init; }
        public required string ParameterName { get; init; }
    }
    public sealed class GenericTestMetadata : .TestMetadata
    {
        public GenericTestMetadata() { }
        public .<string, .TestMetadata>? ConcreteInstantiations { get; init; }
        public override <.ExecutableTestCreationContext, .TestMetadata, .AbstractExecutableTest> CreateExecutableTestFactory { get; }
    }
    public sealed class GenericTypeInfo
    {
        public GenericTypeInfo() { }
        public .GenericParameterConstraints[] Constraints { get; init; }
        public string[] ParameterNames { get; init; }
    }
    public class GlobalContext : .Context
    {
        public .TextWriter OriginalConsoleError { get; set; }
        public .TextWriter OriginalConsoleOut { get; set; }
        public string? TestFilter { get; }
        public new static .GlobalContext Current { get; }
    }
    public class GlobalSharedDataKey : .SharedDataKey, <.GlobalSharedDataKey>
    {
        public static readonly  RandomKey;
        public GlobalSharedDataKey( Type) { }
    }
    public class HookAttribute : .TUnitAttribute
    {
        public string File { get; }
        public .HookType HookType { get; }
        public int Line { get; }
        public int Order { get; init; }
    }
    public static class HookRegistrationIndices
    {
        public static int GetNextAfterAssemblyHookIndex() { }
        public static int GetNextAfterClassHookIndex() { }
        public static int GetNextAfterEveryAssemblyHookIndex() { }
        public static int GetNextAfterEveryClassHookIndex() { }
        public static int GetNextAfterEveryTestHookIndex() { }
        public static int GetNextAfterTestDiscoveryHookIndex() { }
        public static int GetNextAfterTestHookIndex() { }
        public static int GetNextAfterTestSessionHookIndex() { }
        public static int GetNextBeforeAssemblyHookIndex() { }
        public static int GetNextBeforeClassHookIndex() { }
        public static int GetNextBeforeEveryAssemblyHookIndex() { }
        public static int GetNextBeforeEveryClassHookIndex() { }
        public static int GetNextBeforeEveryTestHookIndex() { }
        public static int GetNextBeforeTestDiscoveryHookIndex() { }
        public static int GetNextBeforeTestHookIndex() { }
        public static int GetNextBeforeTestSessionHookIndex() { }
    }
    public enum HookType
    {
        Test = 0,
        Class = 1,
        Assembly = 2,
        TestSession = 3,
        TestDiscovery = 4,
    }
    public interface IAccessesInstanceData { }
    public interface IDataSourceAttribute
    {
        .<<.<object?[]?>>> GetDataRowsAsync(.DataGeneratorMetadata dataGeneratorMetadata);
    }
    public interface IDynamicTestMetadata { }
    public interface IDynamicTestSource
    {
        .<.DynamicTest> CollectDynamicTests(string sessionId);
    }
    public interface IRequiresImmediateInitialization { }
    public interface IScopedAttribute { }
    public interface IScopedAttribute<T> : .IScopedAttribute
        where T :  { }
    public interface ITestDefinition { }
    public interface ITypedDataSourceAttribute<T> : .IDataSourceAttribute
    {
        .<<.<T>>> GetTypedDataRowsAsync(.DataGeneratorMetadata dataGeneratorMetadata);
    }
    [(.Class)]
    public sealed class InheritsTestsAttribute : .TUnitAttribute
    {
        public InheritsTestsAttribute() { }
    }
    [(.Method, AllowMultiple=true)]
    public class InstanceMethodDataSourceAttribute : .MethodDataSourceAttribute, .IAccessesInstanceData
    {
        public InstanceMethodDataSourceAttribute(string methodNameProvidingDataSource) { }
    }
    public class InvalidTestMetadataException : .TestBuilderException
    {
        public InvalidTestMetadataException(string message, .TestMetadata metadata) { }
        public InvalidTestMetadataException(string message, .TestMetadata metadata,  innerException) { }
    }
    [(.Parameter)]
    public class MatrixAttribute : .TUnitAttribute
    {
        protected MatrixAttribute() { }
        public MatrixAttribute(params object?[]? objects) { }
        public object?[]? Excluding { get; init; }
        public virtual object?[] GetObjects(.DataGeneratorMetadata dataGeneratorMetadata) { }
    }
    [(.Parameter)]
    public class MatrixAttribute<T> : .MatrixAttribute, .<T>
    {
        public MatrixAttribute(params T?[]? objects) { }
    }
    [(.Class | .Method)]
    [.("AOT", "IL2109:Type \'MatrixDataSourceAttribute\' derives from base class with RequiresUnre" +
        "ferencedCodeAttribute", Justification="Matrix data source implementation is AOT-compatible with proper enum field preser" +
        "vation")]
    public sealed class MatrixDataSourceAttribute : .UntypedDataSourceGeneratorAttribute, .IAccessesInstanceData
    {
        public MatrixDataSourceAttribute() { }
        protected override .<<object?[]?>> GenerateDataSources(.DataGeneratorMetadata dataGeneratorMetadata) { }
    }
    [(.Class | .Method, AllowMultiple=true)]
    public class MatrixExclusionAttribute : .TUnitAttribute
    {
        public MatrixExclusionAttribute(params object?[]? objects) { }
        public object?[] Objects { get; }
    }
    [(.Parameter)]
    public class MatrixInstanceMethodAttribute<[.(..None | ..PublicMethods | ..NonPublicMethods | ..PublicProperties)]  TClass> : .MatrixMethodAttribute<TClass>, .IAccessesInstanceData
        where TClass :  class
    {
        public MatrixInstanceMethodAttribute(string methodName) { }
    }
    [(.Parameter)]
    public class MatrixMethodAttribute<[.(..None | ..PublicMethods | ..NonPublicMethods)]  TClass> : .MatrixAttribute
        where TClass :  class
    {
        public MatrixMethodAttribute(string methodName) { }
        public override object?[] GetObjects(.DataGeneratorMetadata dataGeneratorMetadata) { }
    }
    [(.Parameter)]
    public class MatrixRangeAttribute<T> : .MatrixAttribute<T>
        where T : .INumber<T>
    {
        public MatrixRangeAttribute(T min, T max) { }
        public MatrixRangeAttribute(T min, T max, T step) { }
    }
    public abstract class MemberMetadata : <.MemberMetadata>
    {
        protected MemberMetadata() { }
        public required string Name { get; init; }
        [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..NonPublicConstructors | ..PublicMethods | ..NonPublicMethods | ..PublicProperties)]
        public abstract  Type { get; init; }
        public virtual bool Equals(.MemberMetadata? other) { }
        public override int GetHashCode() { }
        protected virtual bool PrintMembers(.StringBuilder stringBuilder) { }
    }
    [(.Class | .Method | .Property, AllowMultiple=true)]
    public class MethodDataSourceAttribute : , .IDataSourceAttribute
    {
        public MethodDataSourceAttribute(string methodNameProvidingDataSource) { }
        public MethodDataSourceAttribute([.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods | ..NonPublicMethods | ..PublicProperties)]  classProvidingDataSource, string methodNameProvidingDataSource) { }
        public object?[] Arguments { get; set; }
        [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods | ..NonPublicMethods | ..PublicProperties)]
        public ? ClassProvidingDataSource { get; }
        public <.DataGeneratorMetadata, .<<.<object?[]?>>>>? Factory { get; set; }
        public string MethodNameProvidingDataSource { get; }
        [.("AOT", "IL2072:UnrecognizedReflectionPattern", Justification="Data source methods use dynamic patterns")]
        [.("AOT", "IL2075:UnrecognizedReflectionPattern", Justification="Data source methods use dynamic patterns")]
        [.(typeof(.MethodDataSourceAttribute.<GetDataRowsAsync>d__17))]
        public .<<.<object?[]?>>> GetDataRowsAsync(.DataGeneratorMetadata dataGeneratorMetadata) { }
    }
    [(.Class | .Method | .Property, AllowMultiple=true)]
    public class MethodDataSourceAttribute<[.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods | ..NonPublicMethods | ..PublicProperties)]  T> : .MethodDataSourceAttribute
    {
        public MethodDataSourceAttribute(string methodNameProvidingDataSource) { }
    }
    [.DebuggerDisplay("{Type}.{Name}")]
    public class MethodMetadata : .MemberMetadata, <.MethodMetadata>
    {
        public MethodMetadata() { }
        public required .ClassMetadata Class { get; init; }
        public required int GenericTypeCount { get; init; }
        public required .ParameterMetadata[] Parameters { get; init; }
        public ? ReturnType { get; init; }
        public required .TypeReference ReturnTypeReference { get; init; }
        [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..NonPublicConstructors | ..PublicMethods | ..NonPublicMethods | ..PublicProperties)]
        public override required  Type { get; init; }
        public required .TypeReference TypeReference { get; init; }
        public virtual bool Equals(.MethodMetadata? other) { }
        public override int GetHashCode() { }
        protected override bool PrintMembers(.StringBuilder stringBuilder) { }
    }
    [(.Assembly | .Class | .Method)]
    public class NotInParallelAttribute : .SingleTUnitAttribute, .IScopedAttribute, .IScopedAttribute<.NotInParallelAttribute>, ., .
    {
        public NotInParallelAttribute() { }
        public NotInParallelAttribute(string constraintKey) { }
        public NotInParallelAttribute(string[] constraintKeys) { }
        public string[] ConstraintKeys { get; }
        public int Order { get; init; }
        public . OnTestDiscovered(.DiscoveredTestContext context) { }
    }
    public class NotInParallelConstraint : <.NotInParallelConstraint>, .
    {
        public NotInParallelConstraint(.<string> NotInParallelConstraintKeys) { }
        public .<string> NotInParallelConstraintKeys { get; init; }
        public int Order { get; set; }
    }
    public static class ObjectInitializer
    {
        public static . InitializeAsync(object? obj, .CancellationToken cancellationToken = default) { }
    }
    public class ParallelGroupAttribute : .TUnitAttribute, ., .
    {
        public ParallelGroupAttribute(string group) { }
        public string Group { get; }
        public int Order { get; set; }
        public . OnTestDiscovered(.DiscoveredTestContext context) { }
    }
    public class ParallelGroupConstraint : , <.ParallelGroupConstraint>, <.ParallelGroupConstraint>, .
    {
        public ParallelGroupConstraint(string Group, int Order) { }
        public string Group { get; init; }
        public int Order { get; init; }
        public int CompareTo(.ParallelGroupConstraint? other) { }
        public int CompareTo(object? obj) { }
        public virtual bool Equals(.ParallelGroupConstraint? other) { }
        public override int GetHashCode() { }
    }
    public class ParallelLimitLockProvider
    {
        public ParallelLimitLockProvider() { }
    }
    [(.Assembly | .Class | .Method)]
    public sealed class ParallelLimiterAttribute<TParallelLimit> : .TUnitAttribute, ., .
        where TParallelLimit : ., new ()
    {
        public ParallelLimiterAttribute() { }
        public int Order { get; }
        public . OnTestRegistered(.TestRegisteredContext context) { }
    }
    [.DebuggerDisplay("{Type} {Name}")]
    public class ParameterMetadata : .MemberMetadata, <.ParameterMetadata>
    {
        public ParameterMetadata([.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods | ..PublicProperties)]  Type) { }
        public object? DefaultValue { get; }
        public bool IsNullable { get; init; }
        public bool IsOptional { get; }
        public bool IsParams { get; }
        public required .ParameterInfo ReflectionInfo { get; set; }
        public override  Type { get; init; }
        public required .TypeReference TypeReference { get; init; }
    }
    [.DebuggerDisplay("{Type} {Name}")]
    public class ParameterMetadata<[.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods | ..PublicProperties)]  T> : .ParameterMetadata, <.ParameterMetadata<T>>
    {
        public ParameterMetadata() { }
    }
    [(.Assembly | .Class | .Method, AllowMultiple=true)]
    public class PropertyAttribute : .TUnitAttribute, ., .
    {
        public PropertyAttribute(string name, string value) { }
        public string Name { get; }
        public int Order { get; }
        public string Value { get; }
        public . OnTestDiscovered(.DiscoveredTestContext context) { }
    }
    public sealed class PropertyDataSource
    {
        public PropertyDataSource() { }
        public required .IDataSourceAttribute DataSource { get; init; }
        public required string PropertyName { get; init; }
        public required  PropertyType { get; init; }
    }
    public sealed class PropertyInjectionData
    {
        public PropertyInjectionData() { }
        public .PropertyInjectionData[] NestedPropertyInjections { get; init; }
        public <object?, .<string, object?>>? NestedPropertyValueFactory { get; init; }
        public required string PropertyName { get; init; }
        public required  PropertyType { get; init; }
        public required <object, object?> Setter { get; init; }
        public required <object?> ValueFactory { get; init; }
    }
    public class PropertyInjectionException : .TestBuilderException
    {
        public PropertyInjectionException(string propertyName,  propertyType,  innerException) { }
        public string PropertyName { get; }
        public  PropertyType { get; }
    }
    public sealed class PropertyInjectionService
    {
        public PropertyInjectionService() { }
        public static . InjectPropertiesIntoArgumentsAsync(object?[] arguments, .<string, object?> objectBag, .MethodMetadata methodMetadata, .TestContextEvents events) { }
        public static . InjectPropertiesIntoObjectAsync(object instance, .<string, object?> objectBag, .MethodMetadata methodMetadata, .TestContextEvents events) { }
    }
    public static class PropertyInjector
    {
        public static .PropertyInjectionData CreatePropertyInjection(.PropertyInfo property) { }
        public static <object, object?> CreatePropertySetter(.PropertyInfo property) { }
        public static .PropertyInjectionData[] DiscoverInjectableProperties([.(..PublicProperties)]  type) { }
        [.("Trimming", "IL2072:Target parameter argument does not satisfy \'DynamicallyAccessedMembersAttr" +
            "ibute\' in call to target method. The return value of the source method does not " +
            "have matching annotations.")]
        public static . InjectPropertiesAsync(.TestContext testContext, object instance, .PropertyDataSource[] propertyDataSources, .PropertyInjectionData[] injectionData, .MethodMetadata testInformation, string testSessionId) { }
    }
    [.DebuggerDisplay("{Type} {Name})")]
    public class PropertyMetadata : .MemberMetadata, <.PropertyMetadata>
    {
        public PropertyMetadata() { }
        public required .ClassMetadata ClassMetadata { get; set; }
        public required .ClassMetadata ContainingTypeMetadata { get; set; }
        public required <object?, object?> Getter { get; init; }
        public bool IsNullable { get; init; }
        public required bool IsStatic { get; init; }
        public required .PropertyInfo ReflectionInfo { get; init; }
        [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..NonPublicConstructors | ..PublicMethods | ..NonPublicMethods | ..PublicProperties)]
        public override required  Type { get; init; }
    }
    public static class PropertySourceRegistry
    {
        public static ..IPropertySource? GetSource( type) { }
        public static void Register( type, ..IPropertySource source) { }
    }
    [(.Assembly | .Class | .Method)]
    public sealed class RepeatAttribute : .TUnitAttribute, .IScopedAttribute, .IScopedAttribute<.RepeatAttribute>
    {
        public RepeatAttribute(int times) { }
        public int Times { get; }
    }
    public class ResettableLazy<[.(..PublicConstructors)]  T> : 
        where T :  class
    {
        protected readonly string SessionId;
        protected <.<T>> _factory;
        public ResettableLazy(<.<T>> factory, string sessionId, .TestBuilderContext testBuilderContext) { }
        protected ResettableLazy(. classConstructor, string sessionId, .TestBuilderContext testBuilderContext) { }
        public .? ClassConstructor { get; protected set; }
        public .TestBuilderContext TestBuilderContext { get; }
        public .<T> Value { get; }
        public .ResettableLazy<T> Clone() { }
        public . DisposeAsync() { }
        public virtual . ResetLazy() { }
        protected static . DisposeAsync(object? obj) { }
    }
    public class ResettableLazy<[.(..PublicConstructors)]  TClassConstructor, [.(..PublicConstructors)]  T> : .ResettableLazy<T>
        where TClassConstructor : ., new ()
        where T :  class
    {
        public ResettableLazy(string sessionId, .TestBuilderContext testBuilderContext) { }
        public override . ResetLazy() { }
    }
    public sealed class ResolvedDependency
    {
        public ResolvedDependency() { }
        public required .TestDependency Metadata { get; init; }
        public bool ProceedOnFailure { get; }
        public required .AbstractExecutableTest Test { get; init; }
    }
    [(.Assembly | .Class | .Method)]
    public class RetryAttribute : .TUnitAttribute, .IScopedAttribute, .IScopedAttribute<.RetryAttribute>, ., .
    {
        public RetryAttribute(int times) { }
        public int Order { get; }
        public int Times { get; }
        public . OnTestDiscovered(.DiscoveredTestContext context) { }
        public virtual .<bool> ShouldRetry(.TestContext context,  exception, int currentRetryCount) { }
    }
    public sealed class RunOnAttribute : .SkipAttribute
    {
        public RunOnAttribute(. OperatingSystem) { }
        public override .<bool> ShouldSkip(.TestRegisteredContext context) { }
    }
    public class RunOnDiscoveryAttribute : .TUnitAttribute, ., .
    {
        public RunOnDiscoveryAttribute() { }
        public int Order { get; }
        public . OnTestDiscovered(.DiscoveredTestContext context) { }
    }
    [.("windows")]
    public class STAThreadExecutor : .DedicatedThreadExecutor
    {
        public STAThreadExecutor() { }
        protected override void ConfigureThread(.Thread thread) { }
    }
    public class SharedDataKey : <.SharedDataKey>
    {
        public SharedDataKey(string Key,  Type) { }
        public string Key { get; init; }
        public  Type { get; init; }
    }
    public enum SharedType
    {
        None = 0,
        PerClass = 1,
        PerAssembly = 2,
        PerTestSession = 3,
        Keyed = 4,
    }
    public class SingleTUnitAttribute : .TUnitAttribute { }
    public static class Skip
    {
        [.]
        public static void Test(string reason) { }
        public static void Unless([.(false)] bool condition, string reason) { }
        public static void When([.(true)] bool condition, string reason) { }
    }
    [(.Assembly | .Class | .Method, AllowMultiple=true)]
    public class SkipAttribute : , ., .
    {
        public SkipAttribute(string reason) { }
        public int Order { get; }
        public string Reason { get; }
        public . OnTestRegistered(.TestRegisteredContext context) { }
        public virtual .<bool> ShouldSkip(.TestRegisteredContext context) { }
    }
    [.StackTraceHidden]
    public class SourceRegistrar
    {
        public SourceRegistrar() { }
        public static bool IsEnabled { get; set; }
        public static void Register(..ITestSource testSource) { }
        public static void Register( testClassType, ..ITestSource testSource) { }
        public static void RegisterAssembly(<.Assembly> assemblyLoader) { }
        public static void RegisterDynamic(.IDynamicTestSource testSource) { }
        public static void RegisterGlobalInitializer(<.> initializer) { }
        public static void RegisterProperty(..IPropertySource propertySource) { }
    }
    public static class Sources
    {
        public static readonly .<.Assembly, .<.>> AfterAssemblyHooks;
        public static readonly .<, .<.>> AfterClassHooks;
        public static readonly .<.> AfterEveryAssemblyHooks;
        public static readonly .<.> AfterEveryClassHooks;
        public static readonly .<.> AfterEveryTestHooks;
        public static readonly .<.> AfterTestDiscoveryHooks;
        public static readonly .<, .<.>> AfterTestHooks;
        public static readonly .<.> AfterTestSessionHooks;
        public static readonly .<<.Assembly>> AssemblyLoaders;
        public static readonly .<.Assembly, .<.>> BeforeAssemblyHooks;
        public static readonly .<, .<.>> BeforeClassHooks;
        public static readonly .<.> BeforeEveryAssemblyHooks;
        public static readonly .<.> BeforeEveryClassHooks;
        public static readonly .<.> BeforeEveryTestHooks;
        public static readonly .<.> BeforeTestDiscoveryHooks;
        public static readonly .<, .<.>> BeforeTestHooks;
        public static readonly .<.> BeforeTestSessionHooks;
        public static readonly .<.IDynamicTestSource> DynamicTestSources;
        public static readonly .<<.>> GlobalInitializers;
        public static readonly .<..IPropertySource> PropertySources;
        public static readonly .<, .<..ITestSource>> TestSources;
    }
    [.("Trimming", "IL2026:Members annotated with \'RequiresUnreferencedCodeAttribute\' require dynamic" +
        " access", Justification="Reflection mode requires dynamic access")]
    [.("Trimming", "IL2067:Target parameter argument does not satisfy annotation requirements", Justification="Reflection mode requires dynamic access")]
    [.("Trimming", "IL2070:\'this\' argument does not satisfy \'" +
        "perties\'", Justification="Reflection mode requires dynamic access")]
    [.("Trimming", "IL2075:\'this\' argument does not satisfy \'" +
        "perties\'", Justification="Reflection mode requires dynamic access")]
    public static class StaticPropertyReflectionInitializer
    {
        public static . InitializeAllStaticPropertiesAsync() { }
        public static . InitializeStaticPropertiesForType( type) { }
    }
    public class TUnitAttribute :  { }
    [(.Method)]
    public sealed class TestAttribute : .BaseTestAttribute
    {
        public TestAttribute([.] string file = "", [.] int line = 0) { }
    }
    public class TestBuilderContext : <.TestBuilderContext>
    {
        public TestBuilderContext() { }
        public .IDataSourceAttribute? DataSourceAttribute { get; set; }
        public .TestContextEvents Events { get; set; }
        public  Id { get; }
        public .<string, object?> ObjectBag { get; set; }
        public required .MethodMetadata TestMetadata { get; init; }
        public static .TestBuilderContext? Current { get; }
        public void RegisterForInitialization(object? obj) { }
    }
    public class TestBuilderContextAccessor
    {
        public TestBuilderContextAccessor(.TestBuilderContext context) { }
        public .TestBuilderContext Current { get; set; }
    }
    public class TestBuilderException : 
    {
        public TestBuilderException() { }
        public TestBuilderException(string message) { }
        public TestBuilderException(string message,  innerException) { }
        public .<string, object?> Context { get; set; }
        public .TestMetadata? TestMetadata { get; set; }
    }
    [(.Constructor)]
    public sealed class TestConstructorAttribute : .TUnitAttribute
    {
        public TestConstructorAttribute() { }
    }
    [.DebuggerDisplay("{.Name}.{GetDisplayName(),nq}")]
    public class TestContext : .Context
    {
        public TestContext(string testName,  serviceProvider, .ClassHookContext classContext, .TestBuilderContext testBuilderContext, .CancellationToken cancellationToken) { }
        public .<<object?, string?>> ArgumentDisplayFormatters { get; }
        public .<string, object?> Artifacts { get; }
        public .CancellationToken CancellationToken { get; set; }
        public .ClassHookContext ClassContext { get; }
        public .<.TestDetails> Dependencies { get; }
        public ? DisplayNameFormatter { get; set; }
        public .TestContextEvents Events { get; }
        public . ExecutionPriority { get; set; }
        public .CancellationTokenSource? LinkedCancellationTokens { get; set; }
        public object Lock { get; }
        public .<string, object?> ObjectBag { get; }
        public .? ParallelConstraint { get; set; }
        public .? ParallelLimiter { get; }
        public .TestPhase Phase { get; set; }
        public bool ReportResult { get; set; }
        public .TestResult? Result { get; set; }
        public <.TestContext, , int, .<bool>>? RetryFunc { get; set; }
        public string? SkipReason { get; set; }
        public .TestDetails TestDetails { get; set; }
        public ? TestEnd { get; set; }
        public string TestName { get; }
        public  TestStart { get; set; }
        public .<.Timing> Timings { get; }
        public static . Configuration { get; }
        public new static .TestContext? Current { get; }
        [get: .("SingleFile", "IL3000:Avoid accessing Assembly file path when publishing as a single file", Justification="Dynamic code check implemented")]
        public static string? OutputDirectory { get; }
        public static .<string, .<string>> Parameters { get; }
        public static string WorkingDirectory { get; set; }
        public void AddArtifact(.Artifact artifact) { }
        public void AddArtifact(string name, object? value) { }
        public void AddLinkedCancellationToken(.CancellationToken cancellationToken) { }
        public string GetDisplayName() { }
        public new string GetErrorOutput() { }
        public string GetOutput() { }
        public T? GetService<T>()
            where T :  class { }
        public .<.TestContext> GetTests(<.TestContext, bool> predicate) { }
        public .<.TestContext> GetTests(string testName) { }
        public .<.TestContext> GetTests(string testName,  classType) { }
        public void OverrideResult(string reason) { }
        public void OverrideResult(.TestState state, string reason) { }
        [("This method is non-functional after the removal of ITestFinder. It will be remove" +
            "d in a future version.")]
        public . ReregisterTestWithArguments(object?[]? methodArguments = null, .<string, object?>? objectBag = null) { }
        public void SetParallelLimiter(. parallelLimit) { }
        public void WriteError(string message) { }
        public void WriteLine(string message) { }
    }
    public class TestContextEvents : <.TestContextEvents>
    {
        public TestContextEvents() { }
        public .AsyncEvent<.TestContext>? OnDispose { get; set; }
        public .AsyncEvent<.TestContext>? OnInitialize { get; set; }
        public .AsyncEvent<.TestContext>? OnTestEnd { get; set; }
        public .AsyncEvent<.TestContext>? OnTestRegistered { get; set; }
        [.(new string[] {
                null,
                "RetryAttempt"})]
        public .AsyncEvent<<.TestContext, int>>? OnTestRetry { get; set; }
        public .AsyncEvent<.TestContext>? OnTestSkipped { get; set; }
        public .AsyncEvent<.TestContext>? OnTestStart { get; set; }
    }
    public class TestDataCombination
    {
        public TestDataCombination() { }
        public <.<object?>>[] ClassDataFactories { get; init; }
        public int ClassDataSourceIndex { get; init; }
        public int ClassLoopIndex { get; init; }
        public ? DataGenerationException { get; init; }
        public string? DisplayName { get; init; }
        public <.<object?>>[] MethodDataFactories { get; init; }
        public int MethodDataSourceIndex { get; init; }
        public int MethodLoopIndex { get; init; }
        public int RepeatIndex { get; init; }
        public .<string, >? ResolvedGenericTypes { get; init; }
    }
    public class TestDefinition : .ITestDefinition
    {
        public TestDefinition() { }
    }
    public class TestDefinition<T> : .TestDefinition
        where T :  class
    {
        public TestDefinition() { }
    }
    public sealed class TestDependency : <.TestDependency>
    {
        public TestDependency() { }
        public int ClassGenericArity { get; init; }
        public ? ClassType { get; init; }
        public int MethodGenericArity { get; init; }
        public string? MethodName { get; init; }
        public []? MethodParameters { get; init; }
        public bool ProceedOnFailure { get; init; }
        public bool Equals(.TestDependency? other) { }
        public override bool Equals(object? obj) { }
        public override int GetHashCode() { }
        public bool Matches(.TestMetadata test, .TestMetadata? dependentTest = null) { }
        public override string ToString() { }
        public static .TestDependency FromClass( classType) { }
        public static .TestDependency FromClassAndMethod( classType, string methodName) { }
        public static .TestDependency FromMethodName(string methodName) { }
    }
    public class TestDetails
    {
        public TestDetails() { }
        public required .<> Attributes { get; init; }
        public .<string> Categories { get; }
        public [] ClassGenericArguments { get; set; }
        public required object ClassInstance { get; set; }
        public object?[] ClassMetadataArguments { get; }
        public required  ClassType { get; init; }
        public .<string, .<string>> CustomProperties { get; }
        public [] MethodGenericArguments { get; set; }
        public required .MethodMetadata MethodMetadata { get; set; }
        public required string MethodName { get; init; }
        public int RetryLimit { get; set; }
        public required  ReturnType { get; set; }
        public required object?[] TestClassArguments { get; set; }
        public .<string, object?> TestClassInjectedPropertyArguments { get; init; }
        public []? TestClassParameterTypes { get; set; }
        public string TestFilePath { get; set; }
        public required string TestId { get; init; }
        public int TestLineNumber { get; set; }
        public required object?[] TestMethodArguments { get; set; }
        public []? TestMethodParameterTypes { get; set; }
        public required string TestName { get; init; }
        public ? Timeout { get; set; }
    }
    public class TestDetails<T> : .TestDetails
        where T :  class
    {
        public TestDetails() { }
    }
    public class TestDiscoveryContext : .Context
    {
        public .<.TestContext> AllTests { get; }
        public .<.AssemblyHookContext> Assemblies { get; }
        public .BeforeTestDiscoveryContext BeforeTestDiscoveryContext { get; }
        public .<.ClassHookContext> TestClasses { get; }
        public required string? TestFilter { get; init; }
        public new static .TestDiscoveryContext? Current { get; }
        public void AddTests(.<.TestContext> tests) { }
    }
    public class TestInstantiationException : .TestBuilderException
    {
        public TestInstantiationException( testClassType,  innerException) { }
        public TestInstantiationException( testClassType, string message) { }
        public  TestClassType { get; }
    }
    public abstract class TestMetadata
    {
        protected TestMetadata() { }
        public required <[]> AttributeFactory { get; init; }
        public required .IDataSourceAttribute[] ClassDataSources { get; init; }
        public abstract <.ExecutableTestCreationContext, .TestMetadata, .AbstractExecutableTest> CreateExecutableTestFactory { get; }
        public required .IDataSourceAttribute[] DataSources { get; init; }
        public .TestDependency[] Dependencies { get; init; }
        public string? FilePath { get; init; }
        public .GenericMethodInfo? GenericMethodInfo { get; init; }
        public []? GenericMethodTypeArguments { get; init; }
        public .GenericTypeInfo? GenericTypeInfo { get; init; }
        public <[], object?[], object> InstanceFactory { get; init; }
        public int? LineNumber { get; init; }
        public required .MethodMetadata MethodMetadata { get; init; }
        public int ParameterCount { get; init; }
        public [] ParameterTypes { get; init; }
        public required .PropertyDataSource[] PropertyDataSources { get; init; }
        public .PropertyInjectionData[] PropertyInjections { get; init; }
        [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods | ..PublicProperties)]
        public required  TestClassType { get; init; }
        public <object, object?[], .>? TestInvoker { get; init; }
        public required string TestMethodName { get; init; }
        public string[] TestMethodParameterTypes { get; init; }
        public required string TestName { get; init; }
        public string TestSessionId { get; set; }
    }
    public class TestMetadata<[.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods | ..PublicProperties)]  T> : .TestMetadata, .
        where T :  class
    {
        public TestMetadata() { }
        public override <.ExecutableTestCreationContext, .TestMetadata, .AbstractExecutableTest> CreateExecutableTestFactory { get; }
        public new <[], object?[], T>? InstanceFactory { get; init; }
        public <T, object?[], .CancellationToken, .>? InvokeTypedTest { get; init; }
        public new <T, object?[], .>? TestInvoker { get; init; }
        public void UseRuntimeDataGeneration(string testSessionId) { }
    }
    public enum TestPhase
    {
        Discovery = 0,
        Registration = 1,
        BeforeTest = 2,
        Execution = 3,
        AfterTest = 4,
    }
    public class TestRegisteredContext
    {
        public TestRegisteredContext(.TestContext testContext) { }
        public string? CustomDisplayName { get; }
        public .DiscoveredTest DiscoveredTest { get; set; }
        public .<string, object?> ObjectBag { get; }
        public .TestContext TestContext { get; }
        public .TestDetails TestDetails { get; }
        public string TestName { get; }
        public void SetParallelLimiter(. parallelLimit) { }
        public void SetTestExecutor(. executor) { }
    }
    public class TestResult : <.TestResult>
    {
        public TestResult() { }
        public required string ComputerName { get; init; }
        public required ? Duration { get; init; }
        public required ? End { get; init; }
        public required ? Exception { get; init; }
        public bool IsOverridden { get; set; }
        public string? Output { get; }
        public string? OverrideReason { get; set; }
        public required ? Start { get; init; }
        public required .TestState State { get; init; }
    }
    public class TestSessionContext : .Context
    {
        public .<.TestContext> AllTests { get; }
        public .<.AssemblyHookContext> Assemblies { get; }
        public required string Id { get; init; }
        public .<.ClassHookContext> TestClasses { get; }
        public .BeforeTestDiscoveryContext TestDiscoveryContext { get; }
        public required string? TestFilter { get; init; }
        public new static .TestSessionContext? Current { get; }
        public void AddArtifact(.Artifact artifact) { }
        public void AddAssembly(.AssemblyHookContext assemblyHookContext) { }
    }
    public enum TestState
    {
        NotStarted = 0,
        WaitingForDependencies = 1,
        Queued = 2,
        Running = 3,
        Passed = 4,
        Failed = 5,
        Skipped = 6,
        Timeout = 7,
        Cancelled = 8,
    }
    public static class TestStateExtensions
    {
        public static bool IsFailure(this .TestState state) { }
        public static bool IsFinal(this .TestState state) { }
        public static bool IsSuccess(this .TestState state) { }
        public static bool IsTransient(this .TestState state) { }
    }
    [(.Assembly | .Class | .Method)]
    public class TimeoutAttribute : .TUnitAttribute, .IScopedAttribute, .IScopedAttribute<.TimeoutAttribute>, ., .
    {
        public TimeoutAttribute(int timeoutInMilliseconds) { }
        public int Order { get; }
        public  Timeout { get; }
        public . OnTestDiscovered(.DiscoveredTestContext context) { }
    }
    public class Timing : <.Timing>
    {
        public Timing(string StepName,  Start,  End) { }
        public  Duration { get; }
        public  End { get; init; }
        public  Start { get; init; }
        public string StepName { get; init; }
    }
    public sealed class TypeArrayComparer : .<[]>
    {
        public static readonly .TypeArrayComparer Instance;
        public bool Equals([]? x, []? y) { }
        public int GetHashCode([] obj) { }
    }
    public sealed class TypeReference
    {
        public TypeReference() { }
        public int ArrayRank { get; set; }
        public string? AssemblyQualifiedName { get; set; }
        public .TypeReference? ElementType { get; set; }
        public .<.TypeReference> GenericArguments { get; set; }
        public string? GenericParameterName { get; set; }
        public int GenericParameterPosition { get; set; }
        public bool IsArray { get; set; }
        public bool IsByRef { get; set; }
        public bool IsGenericParameter { get; set; }
        public bool IsMethodGenericParameter { get; set; }
        public bool IsPointer { get; set; }
        public static .TypeReference CreateArray(.TypeReference elementType, int rank = 1) { }
        public static .TypeReference CreateConcrete(string assemblyQualifiedName) { }
        public static .TypeReference CreateConstructedGeneric(string genericTypeDefinition, params .TypeReference[] genericArguments) { }
        public static .TypeReference CreateGenericParameter(int position, bool isMethodParameter, string? name = null) { }
    }
    public static class TypeRegistry
    {
        public static .<string, > GetAllRegisteredTypes() { }
        public static void RegisterArrayType( elementType, int rank,  arrayType) { }
        public static void RegisterByRefType( elementType,  byRefType) { }
        public static void RegisterConstructedGenericType( genericDefinition, [] genericArguments,  constructedType) { }
        public static void RegisterPointerType( elementType,  pointerType) { }
        public static void RegisterType(string assemblyQualifiedName,  type) { }
    }
    public sealed class TypeResolver
    {
        public TypeResolver(? declaringType = null, .MethodInfo? declaringMethod = null) { }
        public  Resolve(.TypeReference typeReference) { }
        public [] ResolveMany(.<.TypeReference> typeReferences) { }
        public static .TypeResolver CreateSimple() { }
        public static .TypeResolver FromTestInstance(object testInstance, .MethodInfo? testMethod = null) { }
    }
    public abstract class TypedDataSourceAttribute<T> : , .IDataSourceAttribute, .ITypedDataSourceAttribute<T>
    {
        protected TypedDataSourceAttribute() { }
        [.(typeof(.TypedDataSourceAttribute<T>.<GetDataRowsAsync>d__1))]
        public .<<.<object?[]?>>> GetDataRowsAsync(.DataGeneratorMetadata dataGeneratorMetadata) { }
        public abstract .<<.<T>>> GetTypedDataRowsAsync(.DataGeneratorMetadata dataGeneratorMetadata);
    }
    [(.Class | .Method | .Property, AllowMultiple=true)]
    [.("UntypedDataSourceGeneratorAttribute requires dynamic code generation for runtime " +
        "data source creation. Consider using strongly-typed AsyncDataSourceGeneratorAttr" +
        "ibute<T> overloads for AOT compatibility.")]
    [.("UntypedDataSourceGeneratorAttribute may require unreferenced code for runtime dat" +
        "a source creation. Consider using strongly-typed AsyncDataSourceGeneratorAttribu" +
        "te<T> overloads for AOT compatibility.")]
    public abstract class UntypedDataSourceGeneratorAttribute : .AsyncUntypedDataSourceGeneratorAttribute
    {
        protected UntypedDataSourceGeneratorAttribute() { }
        protected abstract .<<object?[]?>> GenerateDataSources(.DataGeneratorMetadata dataGeneratorMetadata);
        [.(typeof(.UntypedDataSourceGeneratorAttribute.<GenerateDataSourcesAsync>d__1))]
        protected override sealed .<<.<object?[]?>>> GenerateDataSourcesAsync(.DataGeneratorMetadata dataGeneratorMetadata) { }
    }
}
namespace .Attributes
{
    [(.Class | .Constructor | .Method | .Property)]
    public sealed class AotCompatibleAttribute : 
    {
        public AotCompatibleAttribute() { }
        public string? AlternativeForReflection { get; set; }
        public string? Notes { get; set; }
    }
    [(.Class | .Constructor | .Method | .Property)]
    public sealed class RequiresReflectionAttribute : 
    {
        public RequiresReflectionAttribute(string reason) { }
        public string? AotAlternative { get; set; }
        public string Reason { get; }
    }
}
namespace .Converters
{
    public static class AotConverterRegistry
    {
        public static void Register(. converter) { }
        public static bool TryConvert( sourceType,  targetType, object? value, out object? result) { }
        public static bool TryGetConverter( sourceType,  targetType, out .? converter) { }
    }
    public interface IAotConverter
    {
         SourceType { get; }
         TargetType { get; }
        object? Convert(object? value);
    }
}
namespace .Data
{
    public class GetOnlyDictionary<TKey, TValue>
        where TKey :  notnull
    {
        public GetOnlyDictionary() { }
        public TValue this[TKey key] { get; }
        public .<TKey> Keys { get; }
        public .<TValue> Values { get; }
        public TValue GetOrAdd(TKey key, <TKey, TValue> func) { }
        public TValue? Remove(TKey key) { }
        public bool TryGetValue(TKey key, [.(true)] out TValue? value) { }
    }
}
namespace .DataSources
{
    public static class DataSourceProcessor
    {
        [.("This method may create types at runtime")]
        [.("This method uses reflection to process data sources")]
        public static .<.<object?[]>> ProcessGeneratorItemAsync(object? item) { }
        [.("This method uses reflection for tuple processing")]
        public static .<object?[]> ProcessMethodDataSourceResult(object? result) { }
        public static .<.<object?[]>> ProcessTypedArrayGeneratorItemAsync<T>(<.<T[]>> taskFunc) { }
        public static .<.<object?[]>> ProcessTypedGeneratorItemAsync<T>(<.<T>> taskFunc) { }
        public static object? ResolveTypedValue<T>(<T> func) { }
        public static .<object?> ResolveTypedValueAsync<T>(<.<T>> taskFunc) { }
        [.("This method may invoke methods dynamically")]
        [.("This method uses reflection to resolve values")]
        public static .<object?> ResolveValueAsync(object? value) { }
    }
    public static class TestDataFormatter
    {
        public static string CreateDisplayName(.TestMetadata metadata, object?[] arguments, .TestDataCombination? dataCombination = null) { }
        public static string CreateGenericDisplayName(.TestMetadata metadata, [] genericTypes, object?[] arguments) { }
        public static string FormatArguments(.TestContext context) { }
        public static string FormatArguments(object?[] arguments) { }
        public static string FormatArguments(object?[] arguments, .<<object?, string?>> formatters) { }
    }
}
namespace .Enums
{
    public enum DataGeneratorType
    {
        ClassParameters = 0,
        TestParameters = 1,
        Property = 2,
    }
    public enum LogLevel
    {
        None = -1,
        Trace = 0,
        Debug = 1,
        Information = 2,
        Warning = 3,
        Error = 4,
        Critical = 5,
    }
    []
    public enum OS
    {
        Linux = 1,
        Windows = 2,
        MacOs = 4,
    }
    public enum Priority
    {
        Low = 0,
        BelowNormal = 1,
        Normal = 2,
        AboveNormal = 3,
        High = 4,
        Critical = 5,
    }
}
namespace .Events
{
    []
    public enum EventType
    {
        Initialize = 1,
        Dispose = 2,
        TestRegistered = 4,
        TestStart = 8,
        TestEnd = 16,
        TestSkipped = 32,
        FirstTestInClass = 64,
        FirstTestInAssembly = 128,
        FirstTestInTestSession = 256,
        LastTestInClass = 512,
        LastTestInAssembly = 1024,
        LastTestInTestSession = 2048,
        TestRetry = 2049,
        All = 4095,
    }
}
namespace .Exceptions
{
    public class AfterAssemblyException : .
    {
        public AfterAssemblyException(string message,  innerException) { }
    }
    public class AfterClassException : .
    {
        public AfterClassException(string message,  innerException) { }
    }
    public class AfterTestDiscoveryException : .
    {
        public AfterTestDiscoveryException(string message,  innerException) { }
    }
    public class AfterTestException : .
    {
        public AfterTestException(string message,  innerException) { }
    }
    public class AfterTestSessionException : .
    {
        public AfterTestSessionException(string message,  innerException) { }
    }
    public class BeforeAssemblyException : .
    {
        public BeforeAssemblyException(string message,  innerException) { }
    }
    public class BeforeClassException : .
    {
        public BeforeClassException(string message,  innerException) { }
    }
    public class BeforeTestDiscoveryException : .
    {
        public BeforeTestDiscoveryException(string message,  innerException) { }
    }
    public class BeforeTestException : .
    {
        public BeforeTestException(string message,  innerException) { }
    }
    public class BeforeTestSessionException : .
    {
        public BeforeTestSessionException(string message,  innerException) { }
    }
    public class DependencyConflictException : . { }
    public class FailTestException : .
    {
        public FailTestException(string reason) { }
        public string Reason { get; }
    }
    public class GenericTypeResolutionException : 
    {
        public GenericTypeResolutionException(string message) { }
        public GenericTypeResolutionException(string message,  innerException) { }
    }
    public class InconclusiveTestException : .
    {
        public InconclusiveTestException(string message,  exception) { }
    }
    public class SkipTestException : .
    {
        public SkipTestException(string reason) { }
        public string Reason { get; }
    }
    public class TUnitException : 
    {
        public TUnitException() { }
        public TUnitException(string? message) { }
        public TUnitException(string? message, ? innerException) { }
    }
    public class TestFailedInitializationException : 
    {
        public TestFailedInitializationException(string? message, ? innerException) { }
    }
    public class TestNotExecutedException : . { }
    public class TestRunCanceledException : .
    {
        public TestRunCanceledException() { }
    }
    public class TimeoutException : . { }
}
namespace .Executors
{
    [(.Assembly | .Class | .Method)]
    public class CultureAttribute : .TUnitAttribute, ., .
    {
        public CultureAttribute(.CultureInfo cultureInfo) { }
        public CultureAttribute(string cultureName) { }
        public int Order { get; }
        public . OnTestRegistered(.TestRegisteredContext context) { }
    }
    public class HookExecutorAttribute : .TUnitAttribute
    {
        public HookExecutorAttribute( type) { }
        public  HookExecutorType { get; }
    }
    [(.Assembly | .Class | .Method)]
    public sealed class HookExecutorAttribute<T> : .
        where T : ., new ()
    {
        public HookExecutorAttribute() { }
    }
    [(.Assembly | .Class | .Method)]
    public class InvariantCultureAttribute : .
    {
        public InvariantCultureAttribute() { }
    }
    [(.Assembly | .Class | .Method)]
    [.("windows")]
    public class STAThreadExecutorAttribute : .TUnitAttribute, ., .
    {
        public STAThreadExecutorAttribute() { }
        public int Order { get; }
        public . OnTestRegistered(.TestRegisteredContext context) { }
    }
    [(.Assembly | .Class | .Method)]
    public sealed class TestExecutorAttribute : .TUnitAttribute, ., .
    {
        public TestExecutorAttribute([.(..PublicConstructors)]  type) { }
        public int Order { get; }
        public . OnTestRegistered(.TestRegisteredContext context) { }
    }
    [(.Assembly | .Class | .Method)]
    public sealed class TestExecutorAttribute<T> : .TUnitAttribute, ., .
        where T : ., new ()
    {
        public TestExecutorAttribute() { }
        public int Order { get; }
        public . OnTestRegistered(.TestRegisteredContext context) { }
    }
}
namespace .Extensions
{
    public static class ClassConstructorExtensions
    {
        public static .<T> Create<[.(..PublicConstructors)]  T>(this . classConstructor, .ClassConstructorMetadata classConstructorMetadata)
            where T :  class { }
    }
    public static class MetadataExtensions
    {
        public static  DeclaringType(this .MethodMetadata method) { }
        public static string DisplayName(this .MethodMetadata method) { }
        public static .<> GetCustomAttributes(this .MethodMetadata method) { }
        public static .MethodInfo GetReflectionInfo(this .MethodMetadata method) { }
        public static bool IsGenericMethodDefinition(this .MethodMetadata method) { }
        public static string MethodName(this .MethodMetadata method) { }
    }
    public static class ReflectionExtensions
    {
        public static [] GetCustomAttributesSafe(this .ICustomAttributeProvider provider, bool inherit = true) { }
        public static T[] GetCustomAttributesSafe<T>(this .ICustomAttributeProvider provider, bool inherit = true)
            where T :  { }
    }
    public static class TestContextExtensions
    {
        public static . AddDynamicTest<[.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..NonPublicConstructors | ..PublicMethods | ..NonPublicMethods | ..PublicProperties)]  T>(this .TestContext context, .DynamicTestInstance<T> dynamicTest)
            where T :  class { }
        public static string GetClassTypeName(this .TestContext context) { }
        public static T? GetService<T>(this .TestContext context)
            where T :  class { }
    }
}
namespace .Helpers
{
    public static class ArgumentFormatter
    {
        public static string Format(object? o, .<<object?, string?>> formatters) { }
        public static string FormatArguments(.<object?> arguments) { }
        public static string GetConstantValue(.TestContext testContext, object? o) { }
    }
    public static class CastHelper
    {
        [.("AOT", "IL3050", Justification="Reflection-based conversion is a fallback for runtime scenarios. AOT applications" +
            " should use explicit conversions.")]
        [.("Trimming", "IL2072", Justification="Type conversion uses DynamicallyAccessedMembers for known conversion patterns. Fo" +
            "r AOT scenarios, use explicit type conversions.")]
        public static object? Cast([.(..None | ..PublicMethods | ..NonPublicMethods)]  type, object? value) { }
        [.("AOT", "IL3050", Justification="Reflection-based conversion is a fallback for runtime scenarios. AOT applications" +
            " should use explicit conversions.")]
        [.("Trimming", "IL2072", Justification="Type conversion uses DynamicallyAccessedMembers for known conversion patterns. Fo" +
            "r AOT scenarios, use explicit type conversions.")]
        public static T? Cast<[.(..None | ..PublicMethods | ..NonPublicMethods)]  T>(object? value) { }
        public static .MethodInfo? GetConversionMethod([.(..None | ..PublicMethods | ..NonPublicMethods)]  baseType, [.(..None | ..PublicMethods | ..NonPublicMethods)]  targetType) { }
    }
    public static class ClassConstructorHelper
    {
        public static .ClassConstructorAttribute? GetClassConstructorAttribute([] attributes) { }
        public static bool HasClassConstructorAttribute([] attributes) { }
        public static .<object?> TryCreateInstanceWithClassConstructor(.<> attributes, [.(..PublicConstructors)]  testClassType, string testSessionId, .TestContext testContext) { }
        public static .<object?> TryCreateInstanceWithClassConstructor(.<> attributes, [.(..PublicConstructors)]  testClassType, string testSessionId, .TestContextEvents events, .<string, object?> objectBag, .MethodMetadata methodMetadata) { }
    }
    [.DebuggerDisplay("Count = {CurrentCount}")]
    public class Counter
    {
        public <int>? OnCountChanged;
        public Counter() { }
        public int CurrentCount { get; }
        public int Decrement() { }
        public int Increment() { }
    }
    public static class DataConversionHelper
    {
        [.(typeof(..<ConvertAsyncEnumerableToObjectArrays>d__2<T>))]
        public static .<object?[]> ConvertAsyncEnumerableToObjectArrays<T>(.<T> source, [.] .CancellationToken ct = default) { }
        [.(typeof(..<ConvertAsyncEnumerableTuple2ToObjectArrays>d__3<T1?, T2?>?))]
        public static .<object?[]> ConvertAsyncEnumerableTuple2ToObjectArrays<T1, T2>(.<<T1, T2>> source, [.] .CancellationToken ct = default) { }
        [.(typeof(..<ConvertAsyncEnumerableTuple3ToObjectArrays>d__4<T1?, T2?, T3?>?))]
        public static .<object?[]> ConvertAsyncEnumerableTuple3ToObjectArrays<T1, T2, T3>(.<<T1, T2, T3>> source, [.] .CancellationToken ct = default) { }
        [.(typeof(..<ConvertAsyncEnumerableTuple4ToObjectArrays>d__5<T1?, T2?, T3?, T4?>?))]
        public static .<object?[]> ConvertAsyncEnumerableTuple4ToObjectArrays<T1, T2, T3, T4>(.<<T1, T2, T3, T4>> source, [.] .CancellationToken ct = default) { }
        [.(typeof(..<ConvertAsyncEnumerableTuple5ToObjectArrays>d__6<T1?, T2?, T3?, T4?, T5?>?))]
        public static .<object?[]> ConvertAsyncEnumerableTuple5ToObjectArrays<T1, T2, T3, T4, T5>(.<<T1, T2, T3, T4, T5>> source, [.] .CancellationToken ct = default) { }
        [.(typeof(..<ConvertToAsyncEnumerableInternal>d__1?))]
        public static .<object?[]> ConvertToAsyncEnumerableInternal(.<object?[]> data, [.] .CancellationToken ct = default) { }
        public static .<object?[]> ConvertToObjectArrays(object? data) { }
        public static object?[] UnwrapTuple(. tuple) { }
        public static object?[] UnwrapTuple<T1, T2>(<T1, T2> tuple) { }
        public static object?[] UnwrapTuple<T1, T2, T3>(<T1, T2, T3> tuple) { }
        public static object?[] UnwrapTuple<T1, T2, T3, T4>(<T1, T2, T3, T4> tuple) { }
        public static object?[] UnwrapTuple<T1, T2, T3, T4, T5>(<T1, T2, T3, T4, T5> tuple) { }
        public static object?[] UnwrapTuple<T1, T2, T3, T4, T5, T6>(<T1, T2, T3, T4, T5, T6> tuple) { }
        public static object?[] UnwrapTuple<T1, T2, T3, T4, T5, T6, T7>(<T1, T2, T3, T4, T5, T6, T7> tuple) { }
        public static object?[] UnwrapTuple<T1, T2, T3, T4, T5, T6, T7, T8>(<T1, T2, T3, T4, T5, T6, T7, <T8>> tuple) { }
        public static object?[] UnwrapTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9>(<T1, T2, T3, T4, T5, T6, T7, <T8, T9>> tuple) { }
        public static object?[] UnwrapTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(<T1, T2, T3, T4, T5, T6, T7, <T8, T9, T10>> tuple) { }
        public static .<.<object?[]>> WrapTaskEnumerableAsObjectArrays<T>(.<.<T>> task) { }
    }
    public static class DataSourceHelpers
    {
        public static <.<object?>>[] HandleTupleValue(object? value, bool shouldUnwrap) { }
        public static . InitializeDataSourcePropertiesAsync(object? instance, .MethodMetadata testInformation, string testSessionId) { }
        public static object? InvokeIfFunc(object? value) { }
        public static T InvokeIfFunc<T>(object? value) { }
        public static bool IsTuple(object? obj) { }
        public static .<object?> ProcessDataSourceResult<T>(T data) { }
        public static .<object?> ProcessDataSourceResultGeneric<T>(T data) { }
        public static .<object?> ProcessEnumerableDataSource<T>(.<T> enumerable) { }
        public static <.<object?>>[] ProcessTestDataSource<T>(T data, int expectedParameterCount = -1) { }
        public static void RegisterPropertyInitializer<T>(<T, .MethodMetadata, string, .> initializer) { }
        public static object?[] ToObjectArray(this object? item) { }
        public static object?[] UnwrapTuple<T1>(<T1> tuple) { }
        public static object?[] UnwrapTuple<T1, T2>(<T1, T2> tuple) { }
        public static object?[] UnwrapTuple<T1, T2, T3>(<T1, T2, T3> tuple) { }
        public static object?[] UnwrapTuple<T1, T2, T3, T4>(<T1, T2, T3, T4> tuple) { }
        public static object?[] UnwrapTuple<T1, T2, T3, T4, T5>(<T1, T2, T3, T4, T5> tuple) { }
        public static object?[] UnwrapTuple<T1, T2, T3, T4, T5, T6>(<T1, T2, T3, T4, T5, T6> tuple) { }
        public static object?[] UnwrapTuple<T1, T2, T3, T4, T5, T6, T7>(<T1, T2, T3, T4, T5, T6, T7> tuple) { }
        [.("Trimming", "IL2091:Target generic argument does not satisfy \'DynamicallyAccessedMembersAttrib" +
            "ute\' in target method or type.", Justification="We handle specific known tuple types without reflection")]
        public static object?[] UnwrapTupleAot(object? value) { }
    }
    public static class GenericTypeHelper
    {
        public static  GetGenericTypeDefinition( type) { }
        public static bool IsConstructedGenericType( type) { }
        [.("AOT", "IL2055:UnrecognizedReflectionPattern", Justification="MakeGenericType is used as a fallback. AOT analyzer warns at compile time.")]
        [.("AOT", "IL3050:RequiresDynamicCode", Justification="MakeGenericType is used as a fallback. AOT analyzer warns at compile time.")]
        public static  MakeGenericTypeSafe( genericTypeDefinition, params [] typeArguments) { }
    }
    public class ProcessorCountParallelLimit : .
    {
        public ProcessorCountParallelLimit() { }
        public int Limit { get; }
    }
    public class ReferenceEqualityComparer : .<object>
    {
        public ReferenceEqualityComparer() { }
        public bool Equals(object? x, object? y) { }
        public int GetHashCode(object obj) { }
    }
    public static class TestClassTypeHelper
    {
        public static ? GetTestClassType(.DataGeneratorMetadata dataGeneratorMetadata) { }
    }
    public static class TestNameGenerator
    {
        public static string GenerateTestName( testClass, .MethodInfo testMethod) { }
        public static string GenerateTestName(string className, string methodName) { }
    }
    public static class TupleFactory
    {
        public static object? CreateTuple([.(..PublicConstructors)]  tupleType, object?[] elements) { }
        public static bool IsTupleType( type) { }
        public static bool TryCreateTupleUsingReflection([.(..PublicConstructors)]  tupleType, object?[] elements, out object? result) { }
    }
    public static class TupleHelper
    {
        [.("ReflectionAnalysis", "IL2075:UnrecognizedReflectionPattern", Justification="Reflection is used as a fallback. AOT analyzer warns at compile time.")]
        public static .<object?[]> ExpandTupleArray(object? value) { }
        public static bool IsTupleArrayType( type) { }
        public static bool IsTupleType( type) { }
        public static bool ShouldUnwrapForMethodArguments(object? value, int expectedParameterCount) { }
        [.("ReflectionAnalysis", "IL2075:UnrecognizedReflectionPattern", Justification="Reflection is used as a fallback. AOT analyzer warns at compile time.")]
        public static object?[] UnwrapTuple(object? value) { }
    }
}
namespace .Hooks
{
    public class AfterAssemblyHookMethod : .<.AssemblyHookContext>, <.>
    {
        public AfterAssemblyHookMethod() { }
        public override . ExecuteAsync(.AssemblyHookContext context, .CancellationToken cancellationToken) { }
    }
    public class AfterClassHookMethod : .<.ClassHookContext>, <.>
    {
        public AfterClassHookMethod() { }
        public override . ExecuteAsync(.ClassHookContext context, .CancellationToken cancellationToken) { }
    }
    public class AfterTestDiscoveryHookMethod : .<.TestDiscoveryContext>, <.>
    {
        public AfterTestDiscoveryHookMethod() { }
        public override . ExecuteAsync(.TestDiscoveryContext context, .CancellationToken cancellationToken) { }
    }
    public class AfterTestHookMethod : .<.TestContext>, <.>
    {
        public AfterTestHookMethod() { }
        public override . ExecuteAsync(.TestContext context, .CancellationToken cancellationToken) { }
    }
    public class AfterTestSessionHookMethod : .<.TestSessionContext>, <.>
    {
        public AfterTestSessionHookMethod() { }
        public override . ExecuteAsync(.TestSessionContext context, .CancellationToken cancellationToken) { }
    }
    public class BeforeAssemblyHookMethod : .<.AssemblyHookContext>, <.>
    {
        public BeforeAssemblyHookMethod() { }
        public override . ExecuteAsync(.AssemblyHookContext context, .CancellationToken cancellationToken) { }
    }
    public class BeforeClassHookMethod : .<.ClassHookContext>, <.>
    {
        public BeforeClassHookMethod() { }
        public override . ExecuteAsync(.ClassHookContext context, .CancellationToken cancellationToken) { }
    }
    public class BeforeTestDiscoveryHookMethod : .<.BeforeTestDiscoveryContext>, <.>
    {
        public BeforeTestDiscoveryHookMethod() { }
        public override . ExecuteAsync(.BeforeTestDiscoveryContext context, .CancellationToken cancellationToken) { }
    }
    public class BeforeTestHookMethod : .<.TestContext>, <.>
    {
        public BeforeTestHookMethod() { }
        public override . ExecuteAsync(.TestContext context, .CancellationToken cancellationToken) { }
    }
    public class BeforeTestSessionHookMethod : .<.TestSessionContext>, <.>
    {
        public BeforeTestSessionHookMethod() { }
        public override . ExecuteAsync(.TestSessionContext context, .CancellationToken cancellationToken) { }
    }
    public class HookMethod
    {
        public HookMethod(. instanceHookMethod) { }
        public HookMethod(. staticHookMethod) { }
        public .? InstanceHookMethod { get; }
        public .? StaticHookMethod { get; }
        public static . op_Implicit(. instanceHookMethod) { }
        public static . op_Implicit(. staticHookMethod) { }
    }
    public interface IExecutableHook<in T>
    {
        .MethodMetadata MethodInfo { get; }
        string Name { get; }
        int Order { get; }
        . ExecuteAsync(T context, .CancellationToken cancellationToken);
    }
    public interface IHookMessagePublisher
    {
        . Discover(string sessionId, string displayName, . hookMethod);
        . Push(string sessionId, string displayName, . hookMethod, <.> func);
    }
    public class InstanceHookMethod : <.>, .<.TestContext>
    {
        public InstanceHookMethod() { }
        public .Assembly Assembly { get; }
        public .<> Attributes { get; }
        public <object, .TestContext, .CancellationToken, .>? Body { get; init; }
        [.(..PublicMethods)]
        public required  ClassType { get; init; }
        public required . HookExecutor { get; init; }
        public required .MethodMetadata MethodInfo { get; init; }
        public string Name { get; }
        public required int Order { get; init; }
        public required int RegistrationIndex { get; init; }
        public ? Timeout { get; }
        public . ExecuteAsync(.TestContext context, .CancellationToken cancellationToken) { }
        public TAttribute? GetAttribute<TAttribute>()
            where TAttribute :  { }
    }
    public class LastTestInAssemblyAdapter : .<.AssemblyHookContext>
    {
        public LastTestInAssemblyAdapter(. lastTestInAssemblyEventReceiver, .TestContext testContext) { }
        public .MethodMetadata MethodInfo { get; }
        public string Name { get; }
        public int Order { get; }
        public bool Execute(.AssemblyHookContext context, .CancellationToken cancellationToken) { }
        public . ExecuteAsync(.AssemblyHookContext context, .CancellationToken cancellationToken) { }
    }
    [.("Trimming", "IL2111:Method with parameters or return value with `DynamicallyAccessedMembersAtt" +
        "ribute` is accessed via reflection. Trimmer can\'t guarantee availability of the " +
        "requirements of the method.")]
    public class LastTestInClassAdapter : .<.ClassHookContext>
    {
        public LastTestInClassAdapter(. lastTestInClassEventReceiver, .TestContext testContext) { }
        public .MethodMetadata MethodInfo { get; }
        public string Name { get; }
        public int Order { get; }
        public bool Execute(.ClassHookContext context, .CancellationToken cancellationToken) { }
        public . ExecuteAsync(.ClassHookContext context, .CancellationToken cancellationToken) { }
    }
    public abstract class StaticHookMethod : <.>
    {
        protected StaticHookMethod() { }
        public .Assembly? Assembly { get; }
        public .<> Attributes { get; }
        public  ClassType { get; }
        public required string FilePath { get; init; }
        public required . HookExecutor { get; init; }
        public required int LineNumber { get; init; }
        public required .MethodMetadata MethodInfo { get; init; }
        public string Name { get; }
        public required int Order { get; init; }
        public required int RegistrationIndex { get; init; }
        public ? Timeout { get; }
        public TAttribute? GetAttribute<TAttribute>()
            where TAttribute :  { }
    }
    public abstract class StaticHookMethod<T> : ., <.<T>>, .<T>
    {
        protected StaticHookMethod() { }
        public <T, .CancellationToken, .>? Body { get; init; }
        public abstract . ExecuteAsync(T context, .CancellationToken cancellationToken);
    }
}
namespace .Interfaces
{
    public sealed class CompileTimeResolvedData
    {
        public CompileTimeResolvedData() { }
        public .<object?[]> ClassData { get; init; }
        public .<object?[]> MethodData { get; init; }
        public .<string, object?> PropertyData { get; init; }
        public .<.IDataSourceAttribute> UnresolvedAttributes { get; init; }
    }
    public interface IAotCompatibleAsyncDataSource : . { }
    public interface IAotCompatibleDataSource : . { }
    public interface IAsyncDataSource
    {
        .<<object?[]>> GenerateDataFactoriesAsync(.DataSourceContext context, .CancellationToken cancellationToken = default);
    }
    public interface IAsyncInitializer
    {
        . InitializeAsync();
    }
    public interface IClassConstructor
    {
        .<object> Create([.(..PublicConstructors)]  type, .ClassConstructorMetadata classConstructorMetadata);
    }
    public interface ICompileTimeDataResolver
    {
        bool CanResolveAtCompileTime(.IDataSourceAttribute dataAttribute);
        .<.<object?[]>> ResolveClassDataAsync(.ClassMetadata classMetadata);
        .<.<object?[]>> ResolveMethodDataAsync(.MethodMetadata methodMetadata);
        .<.<string, object?>> ResolvePropertyDataAsync(.ClassMetadata classMetadata);
    }
    public interface IConfiguration
    {
        string? Get(string key);
    }
    public interface IContext
    {
        .TextWriter ErrorOutputWriter { get; }
        .TextWriter OutputWriter { get; }
        . GetDefaultLogger();
    }
    public interface IDataSource
    {
        .<<object?[]>> GenerateDataFactories(.DataSourceContext context);
    }
    public interface IEventReceiver
    {
        int Order { get; }
    }
    public interface IExecutionOrder
    {
        int Order { get; }
        int Priority { get; }
    }
    public interface IFirstTestInAssemblyEventReceiver : .
    {
        . OnFirstTestInAssembly(.AssemblyHookContext context, .TestContext testContext);
    }
    public interface IFirstTestInClassEventReceiver : .
    {
        . OnFirstTestInClass(.ClassHookContext context, .TestContext testContext);
    }
    public interface IFirstTestInTestSessionEventReceiver : .
    {
        . OnFirstTestInTestSession(.TestSessionContext current, .TestContext testContext);
    }
    public interface IGenericTypeResolver
    {
        [] ResolveGenericClassArguments([.(..PublicConstructors)]  genericTypeDefinition, object?[] constructorArguments);
        [] ResolveGenericMethodArguments(.MethodInfo genericMethodDefinition, object?[] runtimeArguments);
    }
    public interface IHasLoggers
    {
        .<.> Loggers { get; }
    }
    public interface IHookExecutor
    {
        . ExecuteAfterAssemblyHook(.MethodMetadata hookMethodInfo, .AssemblyHookContext context, <.> action);
        . ExecuteAfterClassHook(.MethodMetadata hookMethodInfo, .ClassHookContext context, <.> action);
        . ExecuteAfterTestDiscoveryHook(.MethodMetadata hookMethodInfo, .TestDiscoveryContext context, <.> action);
        . ExecuteAfterTestHook(.MethodMetadata hookMethodInfo, .TestContext context, <.> action);
        . ExecuteAfterTestSessionHook(.MethodMetadata hookMethodInfo, .TestSessionContext context, <.> action);
        . ExecuteBeforeAssemblyHook(.MethodMetadata hookMethodInfo, .AssemblyHookContext context, <.> action);
        . ExecuteBeforeClassHook(.MethodMetadata hookMethodInfo, .ClassHookContext context, <.> action);
        . ExecuteBeforeTestDiscoveryHook(.MethodMetadata hookMethodInfo, .BeforeTestDiscoveryContext context, <.> action);
        . ExecuteBeforeTestHook(.MethodMetadata hookMethodInfo, .TestContext context, <.> action);
        . ExecuteBeforeTestSessionHook(.MethodMetadata hookMethodInfo, .TestSessionContext context, <.> action);
    }
    public interface IInfersType<T> { }
    public interface ILastTestInAssemblyEventReceiver : .
    {
        . OnLastTestInAssembly(.AssemblyHookContext context, .TestContext testContext);
    }
    public interface ILastTestInClassEventReceiver : .
    {
        . OnLastTestInClass(.ClassHookContext context, .TestContext testContext);
    }
    public interface ILastTestInTestSessionEventReceiver : .
    {
        . OnLastTestInTestSession(.TestSessionContext current, .TestContext testContext);
    }
    public interface IParallelConstraint { }
    public interface IParallelLimit
    {
        int Limit { get; }
    }
    public interface ISourceGeneratedTestRegistry
    {
        <object>? GetClassFactory(string testId);
        <object, object?[], .<object?>>? GetMethodInvoker(string testId);
        <object?[], object>? GetParameterizedClassFactory(string testId);
        .<string> GetRegisteredTestIds();
        void RegisterClassFactory(string testId, <object> factory);
        void RegisterClassFactory(string testId, <object?[], object> factory);
        void RegisterMethodInvoker(string testId, <object, object?[], .<object?>> invoker);
    }
    public interface ITestDiscoveryEventReceiver : .
    {
        . OnTestDiscovered(.DiscoveredTestContext context);
    }
    public interface ITestEndEventReceiver : .
    {
        . OnTestEnd(.TestContext context);
    }
    public interface ITestExecutor
    {
        . ExecuteTest(.TestContext context, <.> action);
    }
    public interface ITestFinder
    {
        .<.TestContext> GetTests( classType);
        .TestContext[] GetTestsByNameAndParameters(string testName, .<> methodParameterTypes,  classType, .<> classParameterTypes, .<object?> classArguments);
    }
    public interface ITestNameFormatter
    {
        string BuildTestId(string template, int testIndex, int repeatIndex = 0, int classDataIndex = 0, int methodDataIndex = 0);
        string FormatArgumentValue(object? value);
        string FormatTestName(string template, object?[]? classArgs = null, object?[]? methodArgs = null, .<string, object?>? propertyValues = null);
    }
    public interface ITestRegisteredEventReceiver : .
    {
        . OnTestRegistered(.TestRegisteredContext context);
    }
    public interface ITestRegistry
    {
        . AddDynamicTest<[.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..NonPublicConstructors | ..PublicMethods | ..NonPublicMethods | ..PublicProperties)]  T>(.TestContext context, .DynamicTestInstance<T> dynamicTest)
            where T :  class;
    }
    public interface ITestRetryEventReceiver : .
    {
        . OnTestRetry(.TestContext context, int retryAttempt);
    }
    public interface ITestSkippedEventReceiver : .
    {
        . OnTestSkipped(.TestContext context);
    }
    public interface ITestStartEventReceiver : .
    {
        . OnTestStart(.TestContext context);
    }
    public interface ITypedTestMetadata
    {
        [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods | ..PublicProperties)]
         TestClassType { get; }
    }
}
namespace .
{
    public interface IPropertySource
    {
        bool ShouldInitialize { get; }
         Type { get; }
        .<..PropertyInjectionMetadata> GetPropertyMetadata();
    }
    public interface ITestSource
    {
        .<.<.TestMetadata>> GetTestsAsync(string testSessionId);
    }
    public sealed class PropertyInjectionMetadata
    {
        public PropertyInjectionMetadata() { }
        [.(..PublicProperties)]
        public required  ContainingType { get; init; }
        public required <.IDataSourceAttribute> CreateDataSource { get; init; }
        public required string PropertyName { get; init; }
        [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..NonPublicConstructors | ..PublicMethods | ..NonPublicMethods | ..PublicProperties)]
        public required  PropertyType { get; init; }
        public required <object, object?> SetProperty { get; init; }
    }
}
namespace .Logging
{
    public class DefaultLogger : .
    {
        public DefaultLogger(.Context context) { }
        public override void Log<TState>(. logLevel, TState state, ? exception, <TState, ?, string> formatter) { }
        public override . LogAsync<TState>(. logLevel, TState state, ? exception, <TState, ?, string> formatter) { }
        public void PushProperties(.<string, .<object>> dictionary) { }
        public void PushProperty(string name, object? value) { }
    }
    public interface ILogger
    {
        bool IsEnabled(. logLevel);
        void Log<TState>(. logLevel, TState state, ? exception, <TState, ?, string> formatter);
        . LogAsync<TState>(. logLevel, TState state, ? exception, <TState, ?, string> formatter);
    }
    public interface ILogger<out TCategoryName> : . { }
    public enum LogLevel
    {
        Trace = 0,
        Debug = 1,
        Information = 2,
        Warning = 3,
        Error = 4,
        Critical = 5,
        None = 6,
    }
    public static class LoggingExtensions
    {
        public static void LogCritical(this . logger, string message) { }
        public static . LogCriticalAsync(this . logger, string message) { }
        public static void LogDebug(this . logger, string message) { }
        public static . LogDebugAsync(this . logger, string message) { }
        public static void LogError(this . logger,  ex) { }
        public static void LogError(this . logger, string message) { }
        public static void LogError(this . logger, string message,  ex) { }
        public static . LogErrorAsync(this . logger,  ex) { }
        public static . LogErrorAsync(this . logger, string message) { }
        public static . LogErrorAsync(this . logger, string message,  ex) { }
        public static void LogInformation(this . logger, string message) { }
        public static . LogInformationAsync(this . logger, string message) { }
        public static void LogTrace(this . logger, string message) { }
        public static . LogTraceAsync(this . logger, string message) { }
        public static void LogWarning(this . logger, string message) { }
        public static . LogWarningAsync(this . logger, string message) { }
    }
    public abstract class TUnitLogger : .
    {
        protected TUnitLogger() { }
        public virtual bool IsEnabled(. logLevel) { }
        public abstract void Log<TState>(. logLevel, TState state, ? exception, <TState, ?, string> formatter);
        public abstract . LogAsync<TState>(. logLevel, TState state, ? exception, <TState, ?, string> formatter);
    }
}
namespace .Models
{
    public class TestExecutionData
    {
        public TestExecutionData() { }
        public <.DataGeneratorMetadata, .CancellationToken, .<.<object?[]?>>>? AsyncDataExecutor { get; set; }
        public <.DataGeneratorMetadata, .CancellationToken, .<.<<.<object?[]?>>>>>? AsyncDataSourceResolver { get; set; }
        public <.<.<object?[]>>>? AsyncMethodDataResolver { get; set; }
        public ? ClassFactory { get; set; }
        public bool HasAsyncDataSource { get; }
        public bool HasMethodDataResolver { get; }
        public bool HasStronglyTypedDelegates { get; }
        public <.<object?[]>>? MethodDataResolver { get; set; }
        public ? MethodInvoker { get; set; }
    }
}
namespace .ReferenceTracking
{
    public static class DataSourceReferenceExtensions
    {
        public static void TrackClassArguments(this .TestContext context) { }
        public static void TrackMethodArguments(this .TestContext context) { }
        public static void TrackPropertyArguments(this .TestContext context) { }
    }
}
namespace .Services
{
    [.("Generic type resolution requires runtime type generation")]
    [.("Generic type resolution may access types not preserved by trimming")]
    public class GenericTypeResolver : .
    {
        public GenericTypeResolver() { }
        public [] ResolveGenericClassArguments([.(..PublicConstructors)]  genericTypeDefinition, object?[] constructorArguments) { }
        public [] ResolveGenericMethodArguments(.MethodInfo genericMethodDefinition, object?[] runtimeArguments) { }
    }
    public interface IContextProvider
    {
        .BeforeTestDiscoveryContext BeforeTestDiscoveryContext { get; }
        .TestDiscoveryContext TestDiscoveryContext { get; }
        .TestSessionContext TestSessionContext { get; }
        .TestContext CreateTestContext(string testName, [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods | ..PublicProperties)]  classType, .TestBuilderContext testBuilderContext, .CancellationToken cancellationToken);
        .AssemblyHookContext GetOrCreateAssemblyContext(.Assembly assembly);
        .ClassHookContext GetOrCreateClassContext([.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods | ..PublicProperties)]  classType);
    }
    public static class ModeDetector
    {
        public static bool IsSourceGenerationAvailable { get; }
    }
    public class NoOpGenericTypeResolver : .
    {
        public NoOpGenericTypeResolver() { }
        public [] ResolveGenericClassArguments([.(..PublicConstructors)]  genericTypeDefinition, object?[] constructorArguments) { }
        public [] ResolveGenericMethodArguments(.MethodInfo genericMethodDefinition, object?[] runtimeArguments) { }
    }
    public static class ServiceProviderExtensions
    {
        public static object GetRequiredService(this  serviceProvider,  serviceType) { }
        public static T GetRequiredService<T>(this  serviceProvider)
            where T :  class { }
        public static T? GetService<T>(this  serviceProvider)
            where T :  class { }
    }
    public class TestExecutionRegistry : .
    {
        public TestExecutionRegistry() { }
        public static . Instance { get; }
        public void Clear() { }
        public <.DataGeneratorMetadata, .CancellationToken, .<.<object?[]?>>>? GetAsyncDataExecutor(string testId) { }
        public <.DataGeneratorMetadata, .CancellationToken, .<.<<.<object?[]?>>>>>? GetAsyncDataSourceResolver(string testId) { }
        public <.<.<object?[]>>>? GetAsyncMethodDataResolver(string testId) { }
        public <object>? GetClassFactory(string testId) { }
        public <.<object?[]>>? GetMethodDataResolver(string testId) { }
        public <object, object?[], .<object?>>? GetMethodInvoker(string testId) { }
        public . GetOrCreateTestData(string testId) { }
        public <object?[], object>? GetParameterizedClassFactory(string testId) { }
        public .<string> GetRegisteredTestIds() { }
        public T? GetStronglyTypedClassFactory<T>(string testId)
            where T :  { }
        public T? GetStronglyTypedMethodInvoker<T>(string testId)
            where T :  { }
        public .? GetTestData(string testId) { }
        public bool HasAsyncDataSourceResolver(string testId) { }
        public bool HasMethodDataResolver(string testId) { }
        public bool HasStronglyTypedFactory(string testId) { }
        public void RegisterAsyncDataExecutor(string testId, <.DataGeneratorMetadata, .CancellationToken, .<.<object?[]?>>> executor) { }
        public void RegisterAsyncDataSourceResolver(string testId, <.DataGeneratorMetadata, .CancellationToken, .<.<<.<object?[]?>>>>> resolver) { }
        public void RegisterAsyncMethodDataResolver(string testId, <.<.<object?[]>>> resolver) { }
        public void RegisterClassFactory(string testId, <object> factory) { }
        public void RegisterClassFactory(string testId, <object?[], object> factory) { }
        public void RegisterMethodDataResolver(string testId, <.<object?[]>> resolver) { }
        public void RegisterMethodInvoker(string testId, <object, object?[], .<object?>> invoker) { }
        public void RegisterStronglyTypedClassFactory<T>(string testId,  factory)
            where T :  class { }
        public void RegisterStronglyTypedClassFactory<T>(string testId, <T> factory)
            where T :  class { }
        public void RegisterStronglyTypedMethodInvoker<T>(string testId,  invoker)
            where T :  class { }
        public void RegisterTest(string testId, . data) { }
    }
    public class TestNameFormatter : .
    {
        public TestNameFormatter() { }
        public string BuildTestId(string template, int testIndex, int repeatIndex = 0, int classDataIndex = 0, int methodDataIndex = 0) { }
        public string FormatArgumentValue(object? value) { }
        public string FormatTestName(string template, object?[]? classArgs = null, object?[]? methodArgs = null, .<string, object?>? propertyValues = null) { }
    }
    public class TestServiceProvider : 
    {
        public TestServiceProvider() { }
        public . AddSingleton( serviceType, object service) { }
        public . AddSingleton<T>(T service)
            where T :  class { }
        public . AddTransient( serviceType, <object> factory) { }
        public . AddTransient<T>(<T> factory)
            where T :  class { }
        public object? GetService( serviceType) { }
    }
}