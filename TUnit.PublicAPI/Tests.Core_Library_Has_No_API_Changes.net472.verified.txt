[assembly: .(@", PublicKey=0024000004800000940000000602000000240000525341310004000001000100698a70398fa0b2230c5a72e3bd9d56b48f809f6173e49a19fbb942d621be93ad48c5566b47b28faabc359b9ad3ff4e00bbdea88f5bdfa250f391fedd28182b2e37b55d429c0151a42a98ea7a5821818cd15a79fef9903e8607a88304cf3e0317bf86ec96e32e1381535a6582251e5a6eed40b5a3ed82bc444598b1269cce57a7")]
[assembly: .(@", PublicKey=0024000004800000940000000602000000240000525341310004000001000100698a70398fa0b2230c5a72e3bd9d56b48f809f6173e49a19fbb942d621be93ad48c5566b47b28faabc359b9ad3ff4e00bbdea88f5bdfa250f391fedd28182b2e37b55d429c0151a42a98ea7a5821818cd15a79fef9903e8607a88304cf3e0317bf86ec96e32e1381535a6582251e5a6eed40b5a3ed82bc444598b1269cce57a7")]
[assembly: .(".NETStandard,Version=v2.0", FrameworkDisplayName=".NET Standard 2.0")]
namespace 
{
    [(.Method)]
    public sealed class AfterAttribute : .HookAttribute
    {
        public AfterAttribute(.HookType hookType, [.] string file = "", [.] int line = 0) { }
    }
    [(.Method)]
    public sealed class AfterEveryAttribute : .HookAttribute
    {
        public AfterEveryAttribute(.HookType hookType, [.] string file = "", [.] int line = 0) { }
    }
    public class AfterTestContext
    {
        public .TestContext TestContext { get; }
        public .TestDetails TestDetails { get; }
        public void OverrideResult( exception, string reason) { }
        public void OverrideResult(. status, string reason) { }
        public static .TestContext op_Implicit(.AfterTestContext afterTestContext) { }
    }
    public abstract class ArgumentDisplayFormatter
    {
        protected ArgumentDisplayFormatter() { }
        public abstract bool CanHandle(object? value);
        public abstract string FormatValue(object? value);
    }
    public abstract class ArgumentDisplayFormatterAttribute : .TUnitAttribute, ., .
    {
        protected ArgumentDisplayFormatterAttribute() { }
        public abstract .ArgumentDisplayFormatter Formatter { get; }
        public virtual int Order { get; }
        public void OnTestDiscovery(.DiscoveredTestContext discoveredTestContext) { }
    }
    [(.Assembly | .Class | .Method, AllowMultiple=true)]
    public class ArgumentDisplayFormatterAttribute<T> : .ArgumentDisplayFormatterAttribute
        where T : .ArgumentDisplayFormatter, new ()
    {
        public ArgumentDisplayFormatterAttribute() { }
        public override .ArgumentDisplayFormatter Formatter { get; }
    }
    [(.Class | .Method | .Property, AllowMultiple=true)]
    public sealed class ArgumentsAttribute : .TestDataAttribute
    {
        public ArgumentsAttribute() { }
        public ArgumentsAttribute(params object?[]? values) { }
        public object?[] Values { get; }
    }
    public class Artifact
    {
        public Artifact() { }
        public string? Description { get; init; }
        public required string DisplayName { get; init; }
        public required .FileInfo File { get; init; }
    }
    public class AssemblyHookContext : .Context
    {
        public .<.TestContext> AllTests { get; }
        public required .Assembly Assembly { get; init; }
        public .<.ClassHookContext> TestClasses { get; }
        public int TestCount { get; }
        public .TestSessionContext TestSessionContext { get; }
        public new static .AssemblyHookContext? Current { get; }
        public void AddClass(.ClassHookContext classHookContext) { }
    }
    public static class AsyncConvert
    {
        public static . Convert( action) { }
        public static . Convert(<.> action) { }
        public static . Convert(<.> action) { }
        public static . ConvertObject(object? invoke) { }
        public static bool TryGetAwaitableTask(object awaitable, [.(true)] out .? task) { }
    }
    [(.Class | .Method | .Property, AllowMultiple=true)]
    public abstract class AsyncDataSourceGeneratorAttribute<T> : .TestDataAttribute, .IAsyncDataSourceGeneratorAttribute, .IDataAttribute
    {
        protected AsyncDataSourceGeneratorAttribute() { }
        [.(typeof(.AsyncDataSourceGeneratorAttribute<T>.<GenerateAsync>d__1))]
        public .<<.<T>>> GenerateAsync(.DataGeneratorMetadata dataGeneratorMetadata) { }
        protected abstract .<<.<T>>> GenerateDataSourcesAsync(.DataGeneratorMetadata dataGeneratorMetadata);
    }
    [(.Class | .Method, AllowMultiple=true)]
    public abstract class AsyncDataSourceGeneratorAttribute<T1, T2> : .TestDataAttribute, .IAsyncDataSourceGeneratorAttribute, .IDataAttribute
    {
        protected AsyncDataSourceGeneratorAttribute() { }
        [.(typeof(.AsyncDataSourceGeneratorAttribute<T1, T2>.<GenerateAsync>d__1))]
        public .<<.<<T1, T2>>>> GenerateAsync(.DataGeneratorMetadata dataGeneratorMetadata) { }
        protected abstract .<<.<<T1, T2>>>> GenerateDataSourcesAsync(.DataGeneratorMetadata dataGeneratorMetadata);
    }
    [(.Class | .Method, AllowMultiple=true)]
    public abstract class AsyncDataSourceGeneratorAttribute<T1, T2, T3> : .TestDataAttribute, .IAsyncDataSourceGeneratorAttribute, .IDataAttribute
    {
        protected AsyncDataSourceGeneratorAttribute() { }
        [.(typeof(.AsyncDataSourceGeneratorAttribute<T1, T2, T3>.<GenerateAsync>d__1))]
        public .<<.<<T1, T2, T3>>>> GenerateAsync(.DataGeneratorMetadata dataGeneratorMetadata) { }
        protected abstract .<<.<<T1, T2, T3>>>> GenerateDataSourcesAsync(.DataGeneratorMetadata dataGeneratorMetadata);
    }
    [(.Class | .Method, AllowMultiple=true)]
    public abstract class AsyncDataSourceGeneratorAttribute<T1, T2, T3, T4> : .TestDataAttribute, .IAsyncDataSourceGeneratorAttribute, .IDataAttribute
    {
        protected AsyncDataSourceGeneratorAttribute() { }
        [.(typeof(.AsyncDataSourceGeneratorAttribute<T1, T2, T3, T4>.<GenerateAsync>d__1))]
        public .<<.<<T1, T2, T3, T4>>>> GenerateAsync(.DataGeneratorMetadata dataGeneratorMetadata) { }
        protected abstract .<<.<<T1, T2, T3, T4>>>> GenerateDataSourcesAsync(.DataGeneratorMetadata dataGeneratorMetadata);
    }
    [(.Class | .Method, AllowMultiple=true)]
    public abstract class AsyncDataSourceGeneratorAttribute<T1, T2, T3, T4, T5> : .TestDataAttribute, .IAsyncDataSourceGeneratorAttribute, .IDataAttribute
    {
        protected AsyncDataSourceGeneratorAttribute() { }
        [.(typeof(.AsyncDataSourceGeneratorAttribute<T1, T2, T3, T4, T5>.<GenerateAsync>d__1))]
        public .<<.<<T1, T2, T3, T4, T5>>>> GenerateAsync(.DataGeneratorMetadata dataGeneratorMetadata) { }
        protected abstract .<<.<<T1, T2, T3, T4, T5>>>> GenerateDataSourcesAsync(.DataGeneratorMetadata dataGeneratorMetadata);
    }
    public class AsyncEvent<TEventArgs>
    {
        public AsyncEvent() { }
        public int Order { get; set; }
        public static .AsyncEvent<TEventArgs> operator +(.AsyncEvent<TEventArgs>? e, <object, TEventArgs, .> callback) { }
        public class Invocation : .
        {
            public Invocation(<object, TEventArgs, .> factory, int order) { }
            public int Order { get; }
            public . InvokeAsync(object sender, TEventArgs eventArgs) { }
        }
    }
    [(.Class | .Method | .Property, AllowMultiple=true)]
    public abstract class AsyncUntypedDataSourceGeneratorAttribute : .TestDataAttribute, .IAsyncDataSourceGeneratorAttribute, .IDataAttribute
    {
        protected AsyncUntypedDataSourceGeneratorAttribute() { }
        [.(typeof(.AsyncUntypedDataSourceGeneratorAttribute.<GenerateAsync>d__1))]
        public .<<.<object?[]?>>> GenerateAsync(.DataGeneratorMetadata dataGeneratorMetadata) { }
        protected abstract .<<.<object?[]?>>> GenerateDataSourcesAsync(.DataGeneratorMetadata dataGeneratorMetadata);
    }
    public abstract class BaseClassConstructorAttribute : .TUnitAttribute, .IDataAttribute
    {
        public abstract  ClassConstructorType { get; init; }
    }
    [(.Method)]
    public abstract class BaseTestAttribute : .TUnitAttribute
    {
        public readonly string File;
        public readonly int Line;
    }
    [(.Method)]
    public sealed class BeforeAttribute : .HookAttribute
    {
        public BeforeAttribute(.HookType hookType, [.] string file = "", [.] int line = 0) { }
    }
    [(.Method)]
    public sealed class BeforeEveryAttribute : .HookAttribute
    {
        public BeforeEveryAttribute(.HookType hookType, [.] string file = "", [.] int line = 0) { }
    }
    public class BeforeTestContext
    {
        public .TestContext TestContext { get; }
        public .TestDetails TestDetails { get; }
        public void AddAsyncLocalValues() { }
        public void AddLinkedCancellationToken(.CancellationToken cancellationToken) { }
        public void SetHookExecutor(. hookExecutor) { }
        public void SetTestExecutor(. testExecutor) { }
        public static .TestContext op_Implicit(.BeforeTestContext beforeTestContext) { }
    }
    public class BeforeTestDiscoveryContext : .Context
    {
        public .GlobalContext GlobalContext { get; }
        public required string? TestFilter { get; init; }
        public new static .BeforeTestDiscoveryContext? Current { get; }
    }
    [(.Assembly | .Class | .Method, AllowMultiple=true)]
    public class CategoryAttribute : .TUnitAttribute, ., .
    {
        public CategoryAttribute(string category) { }
        public string Category { get; }
        public int Order { get; }
        public void OnTestDiscovery(.DiscoveredTestContext discoveredTestContext) { }
    }
    [(.Assembly | .Class)]
    public class ClassConstructorAttribute : .BaseClassConstructorAttribute
    {
        public ClassConstructorAttribute( classConstructorType) { }
        public override  ClassConstructorType { get; init; }
    }
    [(.Assembly | .Class)]
    public sealed class ClassConstructorAttribute<T> : .ClassConstructorAttribute
        where T : ., new ()
    {
        public ClassConstructorAttribute() { }
        public override  ClassConstructorType { get; init; }
    }
    public class ClassConstructorMetadata : <.ClassConstructorMetadata>
    {
        public ClassConstructorMetadata() { }
        public required .TestBuilderContext TestBuilderContext { get; init; }
        public required string TestSessionId { get; init; }
    }
    [(.Class | .Method | .Property, AllowMultiple=true)]
    public sealed class ClassDataSourceAttribute : .AsyncUntypedDataSourceGeneratorAttribute, .IDataAttribute, .ISharedDataSourceAttribute
    {
        public ClassDataSourceAttribute( type) { }
        public ClassDataSourceAttribute(params [] types) { }
        public ClassDataSourceAttribute( type,  type2) { }
        public ClassDataSourceAttribute( type,  type2,  type3) { }
        public ClassDataSourceAttribute( type,  type2,  type3,  type4) { }
        public ClassDataSourceAttribute( type,  type2,  type3,  type4,  type5) { }
        public string[] Keys { get; set; }
        public .SharedType[] Shared { get; set; }
        [.(typeof(.ClassDataSourceAttribute.<GenerateDataSourcesAsync>d__15))]
        protected override .<<.<object?[]?>>> GenerateDataSourcesAsync(.DataGeneratorMetadata dataGeneratorMetadata) { }
        public .<string> GetKeys() { }
        public .<.SharedType> GetSharedTypes() { }
    }
    [(.Class | .Method | .Property, AllowMultiple=true)]
    public sealed class ClassDataSourceAttribute<T> : .AsyncDataSourceGeneratorAttribute<T>, .IDataAttribute, .ISharedDataSourceAttribute
    {
        public ClassDataSourceAttribute() { }
        public  ClassType { get; }
        public string Key { get; set; }
        public .SharedType Shared { get; set; }
        [.(typeof(.ClassDataSourceAttribute<T>.<GenerateDataSourcesAsync>d__10))]
        protected override .<<.<T>>> GenerateDataSourcesAsync(.DataGeneratorMetadata dataGeneratorMetadata) { }
        public .<string> GetKeys() { }
        public .<.SharedType> GetSharedTypes() { }
    }
    [(.Class | .Method, AllowMultiple=true)]
    public sealed class ClassDataSourceAttribute<T1, T2> : .AsyncDataSourceGeneratorAttribute<T1, T2>, .IDataAttribute, .ISharedDataSourceAttribute
        where T1 : new()
        where T2 : new()
    {
        public ClassDataSourceAttribute() { }
        public string[] Keys { get; set; }
        public .SharedType[] Shared { get; set; }
        [.(typeof(.ClassDataSourceAttribute<T1, T2>.<GenerateDataSourcesAsync>d__8))]
        protected override .<<.<<T1, T2>>>> GenerateDataSourcesAsync(.DataGeneratorMetadata dataGeneratorMetadata) { }
        public .<string> GetKeys() { }
        public .<.SharedType> GetSharedTypes() { }
    }
    [(.Class | .Method, AllowMultiple=true)]
    public sealed class ClassDataSourceAttribute<T1, T2, T3> : .AsyncDataSourceGeneratorAttribute<T1, T2, T3>, .IDataAttribute, .ISharedDataSourceAttribute
        where T1 : new()
        where T2 : new()
        where T3 : new()
    {
        public ClassDataSourceAttribute() { }
        public string[] Keys { get; set; }
        public .SharedType[] Shared { get; set; }
        [.(typeof(.ClassDataSourceAttribute<T1, T2, T3>.<GenerateDataSourcesAsync>d__8))]
        protected override .<<.<<T1, T2, T3>>>> GenerateDataSourcesAsync(.DataGeneratorMetadata dataGeneratorMetadata) { }
        public .<string> GetKeys() { }
        public .<.SharedType> GetSharedTypes() { }
    }
    [(.Class | .Method, AllowMultiple=true)]
    public sealed class ClassDataSourceAttribute<T1, T2, T3, T4> : .AsyncDataSourceGeneratorAttribute<T1, T2, T3, T4>, .IDataAttribute, .ISharedDataSourceAttribute
        where T1 : new()
        where T2 : new()
        where T3 : new()
        where T4 : new()
    {
        public ClassDataSourceAttribute() { }
        public string[] Keys { get; set; }
        public .SharedType[] Shared { get; set; }
        [.(typeof(.ClassDataSourceAttribute<T1, T2, T3, T4>.<GenerateDataSourcesAsync>d__8))]
        protected override .<<.<<T1, T2, T3, T4>>>> GenerateDataSourcesAsync(.DataGeneratorMetadata dataGeneratorMetadata) { }
        public .<string> GetKeys() { }
        public .<.SharedType> GetSharedTypes() { }
    }
    [(.Class | .Method, AllowMultiple=true)]
    public sealed class ClassDataSourceAttribute<T1, T2, T3, T4, T5> : .AsyncDataSourceGeneratorAttribute<T1, T2, T3, T4, T5>, .IDataAttribute, .ISharedDataSourceAttribute
        where T1 : new()
        where T2 : new()
        where T3 : new()
        where T4 : new()
        where T5 : new()
    {
        public ClassDataSourceAttribute() { }
        public string[] Keys { get; set; }
        public .SharedType[] Shared { get; set; }
        [.(typeof(.ClassDataSourceAttribute<T1, T2, T3, T4, T5>.<GenerateDataSourcesAsync>d__8))]
        protected override .<<.<<T1, T2, T3, T4, T5>>>> GenerateDataSourcesAsync(.DataGeneratorMetadata dataGeneratorMetadata) { }
        public .<string> GetKeys() { }
        public .<.SharedType> GetSharedTypes() { }
    }
    public class ClassHookContext : .Context
    {
        public .AssemblyHookContext AssemblyContext { get; }
        public required  ClassType { get; init; }
        public int TestCount { get; }
        public .<.TestContext> Tests { get; }
        public new static .ClassHookContext? Current { get; }
        public void AddTest(.TestContext testContext) { }
        public override bool Equals(object? obj) { }
        public override int GetHashCode() { }
    }
    public abstract class Context : , .
    {
        public .TextWriter ErrorOutputWriter { get; }
        public .TextWriter OutputWriter { get; }
        protected .Context? Parent { get; }
        public static .Context Current { get; }
        public void AddAsyncLocalValues() { }
        public void Dispose() { }
        public . GetDefaultLogger() { }
        public string GetErrorOutput() { }
        public string GetStandardOutput() { }
        public void RestoreExecutionContext() { }
    }
    public class CultureExecutor : .DedicatedThreadExecutor
    {
        public CultureExecutor(.CultureInfo cultureInfo) { }
        protected override void ConfigureThread(.Thread thread) { }
    }
    public class DataGeneratorMetadata : <.DataGeneratorMetadata>
    {
        public DataGeneratorMetadata() { }
        public required object?[]? ClassInstanceArguments { get; init; }
        public required .TestMember[] MembersToGenerate { get; init; }
        public required .TestBuilderContextAccessor TestBuilderContext { get; init; }
        public required object? TestClassInstance { get; init; }
        public  TestClassType { get; }
        public required .TestMethod TestInformation { get; init; }
        public required string TestSessionId { get; init; }
        public required . Type { get; init; }
    }
    [(.Class | .Method | .Property, AllowMultiple=true)]
    public abstract class DataSourceGeneratorAttribute<T> : .AsyncDataSourceGeneratorAttribute<T>
    {
        protected DataSourceGeneratorAttribute() { }
        protected abstract .<<T>> GenerateDataSources(.DataGeneratorMetadata dataGeneratorMetadata);
        [.(typeof(.DataSourceGeneratorAttribute<T>.<GenerateDataSourcesAsync>d__1))]
        protected override .<<.<T>>> GenerateDataSourcesAsync(.DataGeneratorMetadata dataGeneratorMetadata) { }
    }
    [(.Class | .Method, AllowMultiple=true)]
    public abstract class DataSourceGeneratorAttribute<T1, T2> : .AsyncDataSourceGeneratorAttribute<T1, T2>
    {
        protected DataSourceGeneratorAttribute() { }
        protected abstract .<<<T1, T2>>> GenerateDataSources(.DataGeneratorMetadata dataGeneratorMetadata);
        [.(typeof(.DataSourceGeneratorAttribute<T1, T2>.<GenerateDataSourcesAsync>d__1))]
        protected override .<<.<<T1, T2>>>> GenerateDataSourcesAsync(.DataGeneratorMetadata dataGeneratorMetadata) { }
    }
    [(.Class | .Method, AllowMultiple=true)]
    public abstract class DataSourceGeneratorAttribute<T1, T2, T3> : .AsyncDataSourceGeneratorAttribute<T1, T2, T3>
    {
        protected DataSourceGeneratorAttribute() { }
        protected abstract .<<<T1, T2, T3>>> GenerateDataSources(.DataGeneratorMetadata dataGeneratorMetadata);
        [.(typeof(.DataSourceGeneratorAttribute<T1, T2, T3>.<GenerateDataSourcesAsync>d__1))]
        protected override .<<.<<T1, T2, T3>>>> GenerateDataSourcesAsync(.DataGeneratorMetadata dataGeneratorMetadata) { }
    }
    [(.Class | .Method, AllowMultiple=true)]
    public abstract class DataSourceGeneratorAttribute<T1, T2, T3, T4> : .AsyncDataSourceGeneratorAttribute<T1, T2, T3, T4>
    {
        protected DataSourceGeneratorAttribute() { }
        protected abstract .<<<T1, T2, T3, T4>>> GenerateDataSources(.DataGeneratorMetadata dataGeneratorMetadata);
        [.(typeof(.DataSourceGeneratorAttribute<T1, T2, T3, T4>.<GenerateDataSourcesAsync>d__1))]
        protected override .<<.<<T1, T2, T3, T4>>>> GenerateDataSourcesAsync(.DataGeneratorMetadata dataGeneratorMetadata) { }
    }
    [(.Class | .Method, AllowMultiple=true)]
    public abstract class DataSourceGeneratorAttribute<T1, T2, T3, T4, T5> : .AsyncDataSourceGeneratorAttribute<T1, T2, T3, T4, T5>
    {
        protected DataSourceGeneratorAttribute() { }
        protected abstract .<<<T1, T2, T3, T4, T5>>> GenerateDataSources(.DataGeneratorMetadata dataGeneratorMetadata);
        [.(typeof(.DataSourceGeneratorAttribute<T1, T2, T3, T4, T5>.<GenerateDataSourcesAsync>d__1))]
        protected override .<<.<<T1, T2, T3, T4, T5>>>> GenerateDataSourcesAsync(.DataGeneratorMetadata dataGeneratorMetadata) { }
    }
    public class DedicatedThreadExecutor : .GenericAbstractExecutor, ., .
    {
        public DedicatedThreadExecutor() { }
        protected virtual void CleanUp() { }
        protected virtual void ConfigureThread(.Thread thread) { }
        protected override sealed . ExecuteAsync(<.> action) { }
        protected virtual void Initialize() { }
        public . OnTestRegistered(.TestRegisteredContext context) { }
    }
    public class DefaultExecutor : .GenericAbstractExecutor
    {
        public static readonly .DefaultExecutor Instance;
        protected override . ExecuteAsync(<.> action) { }
    }
    public abstract class DependencyInjectionDataSourceAttribute<TScope> : .UntypedDataSourceGeneratorAttribute
    {
        protected DependencyInjectionDataSourceAttribute() { }
        public abstract object? Create(TScope scope,  type);
        public abstract TScope CreateScope(.DataGeneratorMetadata dataGeneratorMetadata);
        protected override .<<object?[]?>> GenerateDataSources(.DataGeneratorMetadata dataGeneratorMetadata) { }
    }
    [(.Class | .Method, AllowMultiple=true)]
    public class DependsOnAttribute : .TUnitAttribute
    {
        public DependsOnAttribute( testClass) { }
        public DependsOnAttribute(string testName) { }
        public DependsOnAttribute( testClass, string testName) { }
        public DependsOnAttribute(string testName, [] parameterTypes) { }
        public DependsOnAttribute( testClass, string testName, [] parameterTypes) { }
        public []? ParameterTypes { get; }
        public bool ProceedOnFailure { get; set; }
        public ? TestClass { get; }
        public string? TestName { get; }
        public override string ToString() { }
    }
    [(.Class | .Method, AllowMultiple=true)]
    public class DependsOnAttribute<T> : .DependsOnAttribute
    {
        public DependsOnAttribute() { }
        public DependsOnAttribute(string testName) { }
        public DependsOnAttribute(string testName, [] parameterTypes) { }
    }
    public class DiscoveredTestContext
    {
        public bool RunOnTestDiscovery { get; set; }
        public .TestContext TestContext { get; }
        public .TestDetails TestDetails { get; }
        public void AddArgumentDisplayFormatter(.ArgumentDisplayFormatter formatter) { }
        public void AddCategory(string category) { }
        public void AddProperty(string key, string value) { }
        public void SetDisplayName(string displayName) { }
        public void SetParallelConstraint(. parallelConstraint) { }
        public void SetRetryCount(int times) { }
        public void SetRetryCount(int times, <.TestContext, , int, .<bool>> shouldRetry) { }
    }
    [(.Method, Inherited=false)]
    public sealed class DisplayNameAttribute : .DisplayNameFormatterAttribute
    {
        public DisplayNameAttribute(string displayName) { }
        protected override string FormatDisplayName(.TestContext testContext) { }
    }
    [(.Assembly | .Class | .Method, Inherited=false)]
    public abstract class DisplayNameFormatterAttribute : .TUnitAttribute, ., .
    {
        protected DisplayNameFormatterAttribute() { }
        public int Order { get; }
        protected abstract string FormatDisplayName(.TestContext testContext);
        public void OnTestDiscovery(.DiscoveredTestContext discoveredTestContext) { }
    }
    public abstract class DynamicTest : <.DynamicTest>
    {
        protected DynamicTest() { }
        public [] Attributes { get; init; }
        public .<string, object?>? Properties { get; init; }
        public object?[]? TestClassArguments { get; init; }
        public abstract  TestClassType { get; }
        public abstract string TestId { get; }
        public required object?[] TestMethodArguments { get; init; }
        public string? TestName { get; init; }
        public abstract .<.TestMetadata> BuildTestMetadatas();
        protected .TestMethod BuildTestMethod(.MethodInfo methodInfo) { }
        protected .TestAssembly GenerateAssembly() { }
        protected .TestClass GenerateClass() { }
        protected .TestParameter GenerateParameter(.ParameterInfo parameter) { }
        public [] GetAttributes() { }
        protected .TestParameter[] GetParameters(.ParameterInfo[] parameters) { }
        public static T Argument<T>() { }
        protected static .TestProperty GenerateProperty(.<string, object?> property) { }
    }
    public class DynamicTestBuilderAttribute : .BaseTestAttribute
    {
        public DynamicTestBuilderAttribute([.] string file = "", [.] int line = 0) { }
    }
    public class DynamicTestBuilderContext
    {
        public DynamicTestBuilderContext(.TestContext testContext) { }
        public DynamicTestBuilderContext(string filePath, int lineNumber) { }
        public .<.DynamicTest> Tests { get; }
        public void AddTest<TClass>(.DynamicTest<TClass> dynamicTest)
            where TClass :  class { }
        public . AddTestAtRuntime<TClass>(.TestContext testContext, .DynamicTest<TClass> dynamicTest)
            where TClass :  class { }
    }
    public class DynamicTest<TClass> : .DynamicTest, <.DynamicTest<TClass>>
        where TClass :  class
    {
        public DynamicTest() { }
        public override  TestClassType { get; }
        public override string TestId { get; }
        public required .<<TClass>> TestMethod { get; init; }
        public override .<.TestMetadata> BuildTestMetadatas() { }
        public class MethodBody : <.DynamicTest<TClass>.MethodBody>
        {
            public MethodBody() { }
            public <TClass>? SynchronousBody { get; init; }
            public <TClass, .>? TaskBody { get; init; }
            public static .DynamicTest<TClass>.MethodBody op_Implicit(<TClass> action) { }
            public static .DynamicTest<TClass>.MethodBody op_Implicit(<TClass, .> taskBody) { }
        }
    }
    public class EngineCancellationToken : 
    {
        public EngineCancellationToken() { }
        public .CancellationToken Token { get; }
        public void Dispose() { }
    }
    public sealed class ExcludeOnAttribute : .SkipAttribute
    {
        public ExcludeOnAttribute(. OperatingSystem) { }
        public override .<bool> ShouldSkip(.BeforeTestContext context) { }
    }
    [(.Class | .Method)]
    public sealed class ExplicitAttribute : .TUnitAttribute
    {
        public ExplicitAttribute([.] string callerFile = "", [.] string callerMemberName = "") { }
        public string For { get; }
    }
    public class FailedDynamicTest<TClassType> : <.FailedDynamicTest<TClassType>>
        where TClassType :  class
    {
        public FailedDynamicTest() { }
        public required  Exception { get; init; }
        public required string MethodName { get; init; }
        public required string TestFilePath { get; init; }
        public required string TestId { get; init; }
        public required int TestLineNumber { get; init; }
        public static .DynamicTest<TClassType> op_Implicit(.FailedDynamicTest<TClassType> failedTestMetadata) { }
    }
    public class FailedTestMetadata<TClassType> : <.FailedTestMetadata<TClassType>>
        where TClassType :  class
    {
        public FailedTestMetadata() { }
        public required  Exception { get; init; }
        public required string MethodName { get; init; }
        public required string TestFilePath { get; init; }
        public required string TestId { get; init; }
        public required int TestLineNumber { get; init; }
        public static .TestMetadata<TClassType> op_Implicit(.FailedTestMetadata<TClassType> failedTestMetadata) { }
    }
    public abstract class GenericAbstractExecutor : ., .
    {
        protected GenericAbstractExecutor() { }
        public int Order { get; }
        public . ExecuteAfterAssemblyHook(.TestMethod hookMethodInfo, .AssemblyHookContext context, <.> action) { }
        public . ExecuteAfterClassHook(.TestMethod hookMethodInfo, .ClassHookContext context, <.> action) { }
        public . ExecuteAfterTestDiscoveryHook(.TestMethod hookMethodInfo, .TestDiscoveryContext context, <.> action) { }
        public . ExecuteAfterTestHook(.TestMethod hookMethodInfo, .TestContext context, <.> action) { }
        public . ExecuteAfterTestSessionHook(.TestMethod hookMethodInfo, .TestSessionContext context, <.> action) { }
        protected abstract . ExecuteAsync(<.> action);
        public . ExecuteBeforeAssemblyHook(.TestMethod hookMethodInfo, .AssemblyHookContext context, <.> action) { }
        public . ExecuteBeforeClassHook(.TestMethod hookMethodInfo, .ClassHookContext context, <.> action) { }
        public . ExecuteBeforeTestDiscoveryHook(.TestMethod hookMethodInfo, .BeforeTestDiscoveryContext context, <.> action) { }
        public . ExecuteBeforeTestHook(.TestMethod hookMethodInfo, .TestContext context, <.> action) { }
        public . ExecuteBeforeTestSessionHook(.TestMethod hookMethodInfo, .TestSessionContext context, <.> action) { }
        public . ExecuteTest(.TestContext context, <.> action) { }
    }
    public class GlobalContext : .Context
    {
        public .TextWriter OriginalConsoleError { get; set; }
        public .TextWriter OriginalConsoleOut { get; set; }
        public string? TestFilter { get; }
        public new static .GlobalContext Current { get; }
    }
    public class GlobalSharedDataKey : .SharedDataKey, <.GlobalSharedDataKey>
    {
        public static readonly  RandomKey;
        public GlobalSharedDataKey( Type) { }
    }
    public class HookAttribute : .TUnitAttribute
    {
        public string File { get; }
        public .HookType HookType { get; }
        public int Line { get; }
        public int Order { get; init; }
    }
    public enum HookType
    {
        Test = 0,
        Class = 1,
        Assembly = 2,
        TestSession = 3,
        TestDiscovery = 4,
    }
    public interface IAccessesInstanceData { }
    public interface IAsyncDataSourceGeneratorAttribute : .IDataAttribute
    {
        .<<.<object?[]?>>> GenerateAsync(.DataGeneratorMetadata dataGeneratorMetadata);
    }
    public interface IDataAttribute { }
    public interface IDynamicTestRegistrar
    {
        . Register<TClass>(.DynamicTest<TClass> dynamicTest)
            where TClass :  class;
    }
    public interface ISharedDataSourceAttribute : .IDataAttribute
    {
        .<string> GetKeys();
        .<.SharedType> GetSharedTypes();
    }
    [(.Class)]
    public sealed class InheritsTestsAttribute : .TUnitAttribute
    {
        public InheritsTestsAttribute() { }
    }
    [(.Method, AllowMultiple=true)]
    public class InstanceMethodDataSourceAttribute : .MethodDataSourceAttribute, .IAccessesInstanceData
    {
        public InstanceMethodDataSourceAttribute(string methodNameProvidingDataSource) { }
        public InstanceMethodDataSourceAttribute( classProvidingDataSource, string methodNameProvidingDataSource) { }
    }
    [(.Method, AllowMultiple=true)]
    public class InstanceMethodDataSourceAttribute<T> : .MethodDataSourceAttribute<T>, .IAccessesInstanceData
    {
        public InstanceMethodDataSourceAttribute(string methodNameProvidingDataSource) { }
    }
    [(.Parameter)]
    public class MatrixAttribute : .TestDataAttribute
    {
        protected MatrixAttribute() { }
        public MatrixAttribute(params object?[]? objects) { }
        public object?[]? Excluding { get; init; }
        public virtual object?[] GetObjects(object? instance) { }
    }
    [(.Parameter)]
    public class MatrixAttribute<T> : .MatrixAttribute
    {
        public MatrixAttribute(params T?[]? objects) { }
    }
    [(.Class | .Method)]
    public sealed class MatrixDataSourceAttribute : .UntypedDataSourceGeneratorAttribute
    {
        public MatrixDataSourceAttribute() { }
        protected override .<<object?[]?>> GenerateDataSources(.DataGeneratorMetadata dataGeneratorMetadata) { }
    }
    [(.Class | .Method, AllowMultiple=true)]
    public class MatrixExclusionAttribute : .TUnitAttribute
    {
        public MatrixExclusionAttribute(params object?[]? objects) { }
        public object?[] Objects { get; }
    }
    [(.Parameter)]
    public class MatrixInstanceMethodAttribute<TClass> : .MatrixMethodAttribute<TClass>, .IAccessesInstanceData
        where TClass :  class
    {
        public MatrixInstanceMethodAttribute(string methodName) { }
    }
    [(.Parameter)]
    public class MatrixMethodAttribute<TClass> : .MatrixAttribute
        where TClass :  class
    {
        public MatrixMethodAttribute(string methodName) { }
        public override object?[] GetObjects(object? instance) { }
    }
    [(.Class | .Method | .Property, AllowMultiple=true)]
    public class MethodDataSourceAttribute : .TestDataAttribute
    {
        public MethodDataSourceAttribute(string methodNameProvidingDataSource) { }
        public MethodDataSourceAttribute( classProvidingDataSource, string methodNameProvidingDataSource) { }
        public object?[] Arguments { get; set; }
        public ? ClassProvidingDataSource { get; }
        public string MethodNameProvidingDataSource { get; }
    }
    [(.Class | .Method | .Property, AllowMultiple=true)]
    public class MethodDataSourceAttribute<T> : .MethodDataSourceAttribute
    {
        public MethodDataSourceAttribute(string methodNameProvidingDataSource) { }
    }
    [(.Assembly | .Class | .Method)]
    public class NotInParallelAttribute : .SingleTUnitAttribute, ., .
    {
        public NotInParallelAttribute() { }
        public NotInParallelAttribute(string constraintKey) { }
        public NotInParallelAttribute(string[] constraintKeys) { }
        public string[] ConstraintKeys { get; }
        public int Order { get; init; }
        public void OnTestDiscovery(.DiscoveredTestContext discoveredTestContext) { }
    }
    public class NotInParallelConstraint : <.NotInParallelConstraint>, .
    {
        public NotInParallelConstraint(.<string> NotInParallelConstraintKeys) { }
        public .<string> NotInParallelConstraintKeys { get; init; }
        public int Order { get; set; }
    }
    public static class ObjectInitializer
    {
        public static . InitializeAsync(object? obj, .CancellationToken cancellationToken = default) { }
    }
    public class ParallelGroupAttribute : .TUnitAttribute, ., .
    {
        public ParallelGroupAttribute(string group) { }
        public string Group { get; }
        public int Order { get; set; }
        public void OnTestDiscovery(.DiscoveredTestContext discoveredTestContext) { }
    }
    public class ParallelGroupConstraint : , <.ParallelGroupConstraint>, <.ParallelGroupConstraint>, .
    {
        public ParallelGroupConstraint(string Group, int Order) { }
        public string Group { get; init; }
        public int Order { get; init; }
        public int CompareTo(.ParallelGroupConstraint? other) { }
        public int CompareTo(object? obj) { }
        public virtual bool Equals(.ParallelGroupConstraint? other) { }
        public override int GetHashCode() { }
    }
    public class ParallelLimitLockProvider
    {
        public ParallelLimitLockProvider() { }
    }
    [(.Assembly | .Class | .Method)]
    public sealed class ParallelLimiterAttribute<TParallelLimit> : .TUnitAttribute, ., .
        where TParallelLimit : ., new ()
    {
        public ParallelLimiterAttribute() { }
        public int Order { get; }
        public . OnTestRegistered(.TestRegisteredContext testRegisteredContext) { }
    }
    [(.Assembly | .Class | .Method, AllowMultiple=true)]
    public class PropertyAttribute : .TUnitAttribute, ., .
    {
        public PropertyAttribute(string name, string value) { }
        public string Name { get; }
        public int Order { get; }
        public string Value { get; }
        public void OnTestDiscovery(.DiscoveredTestContext discoveredTestContext) { }
    }
    [(.Assembly | .Class | .Method)]
    public sealed class RepeatAttribute : .TUnitAttribute
    {
        public RepeatAttribute(int times) { }
        public int Times { get; }
    }
    public class ResettableLazy<T> : 
        where T :  class
    {
        protected readonly string SessionId;
        protected <T> _factory;
        public ResettableLazy(<T> factory, string sessionId, .TestBuilderContext testBuilderContext) { }
        protected ResettableLazy(. classConstructor, string sessionId, .TestBuilderContext testBuilderContext) { }
        public .? ClassConstructor { get; protected set; }
        public .TestBuilderContext TestBuilderContext { get; }
        public T Value { get; }
        public .ResettableLazy<T> Clone() { }
        public . DisposeAsync() { }
        public virtual . ResetLazy() { }
        protected static . DisposeAsync(object? obj) { }
    }
    public class ResettableLazy<TClassConstructor, T> : .ResettableLazy<T>
        where TClassConstructor : ., new ()
        where T :  class
    {
        public ResettableLazy(string sessionId, .TestBuilderContext testBuilderContext) { }
        public override . ResetLazy() { }
    }
    [(.Assembly | .Class | .Method)]
    public class RetryAttribute : .TUnitAttribute, ., .
    {
        public RetryAttribute(int times) { }
        public int Order { get; }
        public int Times { get; }
        public void OnTestDiscovery(.DiscoveredTestContext discoveredTestContext) { }
        public virtual .<bool> ShouldRetry(.TestContext context,  exception, int currentRetryCount) { }
    }
    public sealed class RunOnAttribute : .SkipAttribute
    {
        public RunOnAttribute(. OperatingSystem) { }
        public override .<bool> ShouldSkip(.BeforeTestContext context) { }
    }
    public class RunOnDiscoveryAttribute : .TUnitAttribute, ., .
    {
        public RunOnDiscoveryAttribute() { }
        public int Order { get; }
        public void OnTestDiscovery(.DiscoveredTestContext discoveredTestContext) { }
    }
    public class STAThreadExecutor : .DedicatedThreadExecutor
    {
        public STAThreadExecutor() { }
        protected override void ConfigureThread(.Thread thread) { }
    }
    public class SharedDataKey : <.SharedDataKey>
    {
        public SharedDataKey(string Key,  Type) { }
        public string Key { get; init; }
        public  Type { get; init; }
    }
    public enum SharedType
    {
        None = 0,
        PerClass = 1,
        PerAssembly = 2,
        PerTestSession = 3,
        Keyed = 4,
    }
    public class SingleTUnitAttribute : .TUnitAttribute { }
    public static class Skip
    {
        [.]
        public static void Test(string reason) { }
        public static void Unless([.(false)] bool condition, string reason) { }
        public static void When([.(true)] bool condition, string reason) { }
    }
    [(.Assembly | .Class | .Method)]
    public class SkipAttribute : .TUnitAttribute, ., .
    {
        public SkipAttribute(string reason) { }
        public int Order { get; }
        public string Reason { get; protected set; }
        public . OnTestRegistered(.TestRegisteredContext context) { }
        public virtual .<bool> ShouldSkip(.BeforeTestContext context) { }
    }
    []
    public class SourceGeneratedAssemblyInformation : .TestAssembly, <.SourceGeneratedAssemblyInformation>
    {
        public SourceGeneratedAssemblyInformation() { }
    }
    []
    public abstract class SourceGeneratedMemberInformation : .TestMember, <.SourceGeneratedMemberInformation>
    {
        protected SourceGeneratedMemberInformation() { }
    }
    []
    public class SourceGeneratedMethodInformation : .TestMethod, <.SourceGeneratedMethodInformation>
    {
        public SourceGeneratedMethodInformation() { }
    }
    []
    public class SourceGeneratedParameterInformation : .TestParameter, <.SourceGeneratedParameterInformation>
    {
        public SourceGeneratedParameterInformation( Type) { }
    }
    public class SourceGeneratedParameterInformation<T> : .TestParameter<T>, <.SourceGeneratedParameterInformation<T>>
    {
        public SourceGeneratedParameterInformation() { }
    }
    []
    public class SourceGeneratedPropertyInformation : .TestProperty, <.SourceGeneratedPropertyInformation>
    {
        public SourceGeneratedPropertyInformation() { }
    }
    public class SourceRegistrar
    {
        public SourceRegistrar() { }
        public static bool IsEnabled { get; set; }
        public static void Register(..ITestSource testSource) { }
        public static void RegisterAssembly(<.Assembly> assemblyLoader) { }
        public static void RegisterAssemblyHookSource(..IAssemblyHookSource testSource) { }
        public static void RegisterClassHookSource(..IClassHookSource testSource) { }
        public static void RegisterDynamic(..IDynamicTestSource testSource) { }
        public static void RegisterGlobalInitializer(<.> initializer) { }
        public static void RegisterProperty<T>() { }
        public static void RegisterTestDiscoveryHookSource(..ITestDiscoveryHookSource testSource) { }
        public static void RegisterTestHookSource(..ITestHookSource testSource) { }
        public static void RegisterTestSessionHookSource(..ITestSessionHookSource testSource) { }
    }
    public class TUnitAttribute :  { }
    [.DebuggerDisplay("{Name})")]
    public class TestAssembly : <.TestAssembly>
    {
        public TestAssembly() { }
        public required [] Attributes { get; init; }
        public required string Name { get; init; }
        public virtual bool Equals(.TestAssembly? other) { }
        public override int GetHashCode() { }
        public static .TestAssembly GetOrAdd(string name, <.TestAssembly> factory) { }
    }
    [(.Method)]
    public sealed class TestAttribute : .BaseTestAttribute
    {
        public TestAttribute([.] string file = "", [.] int line = 0) { }
    }
    public class TestBuilderContext : <.TestBuilderContext>
    {
        public TestBuilderContext() { }
        public .TestClass? ClassInformation { get; init; }
        public .<.IDataAttribute> DataAttributes { get; }
        public .TestContextEvents Events { get; }
        public  Id { get; }
        public .TestMethod? MethodInformation { get; init; }
        public .<string, object?> ObjectBag { get; }
        public string? TestMethodName { get; init; }
        public static .TestBuilderContext? Current { get; }
        public void RegisterForInitialization(object? obj) { }
    }
    public class TestBuilderContextAccessor
    {
        public TestBuilderContextAccessor(.TestBuilderContext context) { }
        public .TestBuilderContext Current { get; set; }
    }
    [.DebuggerDisplay("{Type})")]
    public class TestClass : .TestMember, <.TestClass>
    {
        public TestClass() { }
        public required .TestAssembly Assembly { get; init; }
        public required string? Namespace { get; init; }
        public required .TestParameter[] Parameters { get; init; }
        public required .TestClass? Parent { get; init; }
        public required .TestProperty[] Properties { get; init; }
        public override required  Type { get; init; }
        public virtual bool Equals(.TestClass? other) { }
        public override int GetHashCode() { }
        public static .TestClass GetOrAdd(string name, <.TestClass> factory) { }
    }
    [.DebuggerDisplay("{.Name}.{}")]
    public class TestContext : .Context
    {
        public readonly object Lock;
        public .<.ArgumentDisplayFormatter> ArgumentDisplayFormatters { get; }
        public .AssemblyHookContext AssemblyContext { get; }
        public .CancellationToken CancellationToken { get; }
        public .ClassHookContext ClassContext { get; }
        public int CurrentRetryAttempt { get; }
        public .TestContext[] Dependencies { get; }
        public .TestContextEvents Events { get; }
        public bool IsRegistered { get; }
        public .<string, object?> ObjectBag { get; }
        public .TestResult? Result { get; }
        public .TestDetails TestDetails { get; }
        public ? TestStart { get; }
        public .<.Timing> Timings { get; }
        public static . Configuration { get; }
        public new static .TestContext? Current { get; }
        public static string? OutputDirectory { get; }
        public static .<string, string> Parameters { get; }
        public static string WorkingDirectory { get; set; }
        public void AddArtifact(.Artifact artifact) { }
        public void SuppressReportingResult() { }
    }
    public class TestContextEvents : <.TestContextEvents>
    {
        public TestContextEvents() { }
        public .AsyncEvent<.TestContext>? OnDispose { get; set; }
        public .AsyncEvent<<.AssemblyHookContext, .TestContext>>? OnFirstTestInAssembly { get; set; }
        public .AsyncEvent<<.ClassHookContext, .TestContext>>? OnFirstTestInClass { get; set; }
        public .AsyncEvent<<.TestSessionContext, .TestContext>>? OnFirstTestInTestSession { get; set; }
        public .AsyncEvent<.TestContext>? OnInitialize { get; set; }
        public .AsyncEvent<<.AssemblyHookContext, .TestContext>>? OnLastTestInAssembly { get; set; }
        public .AsyncEvent<<.ClassHookContext, .TestContext>>? OnLastTestInClass { get; set; }
        public .AsyncEvent<<.TestSessionContext, .TestContext>>? OnLastTestInTestSession { get; set; }
        public .AsyncEvent<.AfterTestContext>? OnTestEnd { get; set; }
        public .AsyncEvent<.TestRegisteredContext>? OnTestRegistered { get; set; }
        [.(new string[] {
                null,
                "RetryAttempt"})]
        public .AsyncEvent<<.TestContext, int>>? OnTestRetry { get; set; }
        public .AsyncEvent<.TestContext>? OnTestSkipped { get; set; }
        public .AsyncEvent<.BeforeTestContext>? OnTestStart { get; set; }
    }
    public class TestDataAttribute : .TUnitAttribute, .IDataAttribute
    {
        public TestDataAttribute() { }
        public bool AccessesInstanceData { get; init; }
    }
    public abstract class TestDetails : <.TestDetails>
    {
        protected TestDetails() { }
        [..JsonIgnore]
        public [] AssemblyAttributes { get; }
        [..JsonIgnore]
        public [] Attributes { get; }
        public .<string> Categories { get; }
        [..JsonIgnore]
        public [] ClassAttributes { get; }
        public abstract object ClassInstance { get; }
        public required int CurrentRepeatAttempt { get; init; }
        public .<string, .<string>> CustomProperties { get; }
        [..JsonIgnore]
        public required [] DataAttributes { get; init; }
        [..JsonIgnore]
        public [] DynamicAttributes { get; init; }
        public .? ParallelConstraint { get; }
        public .? ParallelLimit { get; }
        public required int RepeatLimit { get; init; }
        public int RetryLimit { get; }
        public required  ReturnType { get; init; }
        [..JsonIgnore]
        public [] TestAttributes { get; }
        public .TestClass TestClass { get; }
        public required object?[] TestClassArguments { get; init; }
        public required .<string, object?> TestClassInjectedPropertyArguments { get; init; }
        public [] TestClassParameterTypes { get; }
        public required string TestFilePath { get; init; }
        public required string TestId { get; init; }
        public required int TestLineNumber { get; init; }
        public required .TestMethod TestMethod { get; init; }
        public required object?[] TestMethodArguments { get; init; }
        public [] TestMethodParameterTypes { get; }
        public required string TestName { get; init; }
        public ? Timeout { get; }
    }
    public class TestDetails<TClassType> : .TestDetails, <.TestDetails<TClassType>>
        where TClassType :  class
    {
        public TestDetails() { }
        public override object ClassInstance { get; }
        [..JsonIgnore]
        public required .ResettableLazy<TClassType> LazyClassInstance { get; init; }
    }
    public class TestDiscoveryContext : .Context
    {
        public .<.TestContext> AllTests { get; }
        public .<.AssemblyHookContext> Assemblies { get; }
        public .BeforeTestDiscoveryContext BeforeTestDiscoveryContext { get; }
        public .<.ClassHookContext> TestClasses { get; }
        public required string? TestFilter { get; init; }
        public new static .TestDiscoveryContext? Current { get; }
        public void AddTests(.<.TestContext> tests) { }
    }
    public abstract class TestMember : <.TestMember>
    {
        protected TestMember() { }
        public required [] Attributes { get; init; }
        public required string Name { get; init; }
        public abstract  Type { get; init; }
        public virtual bool Equals(.TestMember? other) { }
        public override int GetHashCode() { }
        protected virtual bool PrintMembers(.StringBuilder stringBuilder) { }
    }
    public abstract class TestMetadata : <.TestMetadata>
    {
        protected TestMetadata() { }
        public required int CurrentRepeatAttempt { get; init; }
        public ? DiscoveryException { get; init; }
        public [] DynamicAttributes { get; init; }
        public required int RepeatLimit { get; init; }
        public required .TestBuilderContext TestBuilderContext { get; init; }
        public required object?[] TestClassArguments { get; init; }
        public required .<string, object?> TestClassProperties { get; init; }
        public abstract  TestClassType { get; }
        public required string TestFilePath { get; init; }
        public required string TestId { get; init; }
        public required int TestLineNumber { get; init; }
        public required .TestMethod TestMethod { get; init; }
        public required object?[] TestMethodArguments { get; init; }
        public abstract .TestDetails BuildTestDetails();
        public abstract .TestMetadata CloneWithNewMethodFactory(<object, .CancellationToken, .> testMethodFactory);
    }
    public class TestMetadata<TClassType> : .TestMetadata, <.TestMetadata<TClassType>>
        where TClassType :  class
    {
        public TestMetadata() { }
        public required .ResettableLazy<TClassType> ResettableClassFactory { get; init; }
        public override  TestClassType { get; }
        public required <TClassType, .CancellationToken, .> TestMethodFactory { get; init; }
        public override .TestDetails BuildTestDetails() { }
        public override .TestMetadata CloneWithNewMethodFactory(<object, .CancellationToken, .> testMethodFactory) { }
    }
    [.DebuggerDisplay("{Type}.{Name}")]
    public class TestMethod : .TestMember, <.TestMethod>
    {
        public TestMethod() { }
        public required .TestClass Class { get; init; }
        public required int GenericTypeCount { get; init; }
        public required .TestParameter[] Parameters { get; init; }
        [..JsonIgnore]
        public .MethodInfo ReflectionInformation { get; set; }
        public required  ReturnType { get; init; }
        public override required  Type { get; init; }
        public virtual bool Equals(.TestMethod? other) { }
        public override int GetHashCode() { }
        protected override bool PrintMembers(.StringBuilder stringBuilder) { }
    }
    [.DebuggerDisplay("{Type} {Name})")]
    public class TestParameter : .TestMember, <.TestParameter>
    {
        public TestParameter( Type) { }
        public object? DefaultValue { get; }
        public bool IsOptional { get; }
        public bool IsParams { get; }
        public required .ParameterInfo ReflectionInfo { get; set; }
        public override  Type { get; init; }
    }
    [.DebuggerDisplay("{Type} {Name})")]
    public class TestParameter<T> : .TestParameter, <.TestParameter<T>>
    {
        public TestParameter() { }
    }
    [.DebuggerDisplay("{Type} {Name})")]
    public class TestProperty : .TestMember, <.TestProperty>
    {
        public TestProperty() { }
        public required <object?, object?> Getter { get; init; }
        public required bool IsStatic { get; init; }
        public string? Key { get; init; }
        public required .PropertyInfo ReflectionInfo { get; init; }
        public .SharedType Shared { get; init; }
        public override required  Type { get; init; }
    }
    public class TestRegisteredContext : .BeforeTestContext
    {
        public void SetParallelLimiter(. parallelLimit) { }
        public void SkipTest(string reason) { }
    }
    public class TestResult : <.TestResult>
    {
        public TestResult() { }
        public required string ComputerName { get; init; }
        public required ? Duration { get; init; }
        public required ? End { get; init; }
        public required ? Exception { get; init; }
        public bool IsOverridden { get; set; }
        public string? Output { get; }
        public string? OverrideReason { get; set; }
        public required ? Start { get; init; }
        public required . Status { get; init; }
    }
    public class TestSessionContext : .Context
    {
        public .<.TestContext> AllTests { get; }
        public .<.AssemblyHookContext> Assemblies { get; }
        public required string Id { get; init; }
        public .<.ClassHookContext> TestClasses { get; }
        public .BeforeTestDiscoveryContext TestDiscoveryContext { get; }
        public required string? TestFilter { get; init; }
        public new static .TestSessionContext? Current { get; }
        public void AddArtifact(.Artifact artifact) { }
        public void AddAssembly(.AssemblyHookContext assemblyHookContext) { }
    }
    [(.Assembly | .Class | .Method)]
    public class TimeoutAttribute : .TUnitAttribute, ., .
    {
        public TimeoutAttribute(int timeoutInMilliseconds) { }
        public int Order { get; }
        public  Timeout { get; }
        public void OnTestDiscovery(.DiscoveredTestContext discoveredTestContext) { }
    }
    public class Timing : <.Timing>
    {
        public Timing(string StepName,  Start,  End) { }
        public  Duration { get; }
        public  End { get; init; }
        public  Start { get; init; }
        public string StepName { get; init; }
    }
    [(.Class | .Method | .Property, AllowMultiple=true)]
    public abstract class UntypedDataSourceGeneratorAttribute : .AsyncUntypedDataSourceGeneratorAttribute
    {
        protected UntypedDataSourceGeneratorAttribute() { }
        protected abstract .<<object?[]?>> GenerateDataSources(.DataGeneratorMetadata dataGeneratorMetadata);
        [.(typeof(.UntypedDataSourceGeneratorAttribute.<GenerateDataSourcesAsync>d__1))]
        protected override .<<.<object?[]?>>> GenerateDataSourcesAsync(.DataGeneratorMetadata dataGeneratorMetadata) { }
    }
    public class UntypedDynamicTest : .DynamicTest, <.UntypedDynamicTest>
    {
        public UntypedDynamicTest(.MethodInfo testBody) { }
        public UntypedDynamicTest( testClassType, .MethodInfo testBody) { }
        public .TestBuilderContext TestBuilderContext { get; set; }
        public override  TestClassType { get; }
        public override string TestId { get; }
        public override .<.TestMetadata> BuildTestMetadatas() { }
    }
    public class UntypedFailedDynamicTest : <.UntypedFailedDynamicTest>
    {
        public UntypedFailedDynamicTest(.MethodInfo TestMethod) { }
        public required  Exception { get; init; }
        public required string MethodName { get; init; }
        public required  TestClassType { get; init; }
        public required string TestFilePath { get; init; }
        public required int TestLineNumber { get; init; }
        public .MethodInfo TestMethod { get; init; }
        public static .DynamicTest op_Implicit(.UntypedFailedDynamicTest failedTestMetadata) { }
    }
    public class UntypedTestDetails : .TestDetails, <.UntypedTestDetails>
    {
        public UntypedTestDetails(.ResettableLazy<object> ResettableLazy) { }
        public override object ClassInstance { get; }
        public .ResettableLazy<object> ResettableLazy { get; init; }
    }
    public class UntypedTestMetadata : .TestMetadata, <.UntypedTestMetadata>
    {
        public UntypedTestMetadata( TestClassType) { }
        public override  TestClassType { get; }
        public override .TestDetails BuildTestDetails() { }
        public override .TestMetadata CloneWithNewMethodFactory(<object, .CancellationToken, .> testMethodFactory) { }
    }
}
namespace .Data
{
    public class GetOnlyDictionary<TKey, TValue>
        where TKey :  notnull
    {
        public GetOnlyDictionary() { }
        public TValue this[TKey key] { get; }
        public .<TKey> Keys { get; }
        public .<TValue> Values { get; }
        public TValue GetOrAdd(TKey key, <TKey, TValue> func) { }
        public TValue GetOrAdd(TKey key, <TKey, TValue> func, out bool previouslyExisted) { }
        public TValue? Remove(TKey key) { }
        public bool TryGetValue(TKey key, [.(true)] out TValue? value) { }
    }
}
namespace .Enums
{
    public enum DataGeneratorType
    {
        ClassParameters = 0,
        TestParameters = 1,
        Property = 2,
    }
    public enum LogLevel
    {
        None = -1,
        Trace = 0,
        Debug = 1,
        Information = 2,
        Warning = 3,
        Error = 4,
        Critical = 5,
    }
    []
    public enum OS
    {
        Linux = 1,
        Windows = 2,
        MacOs = 4,
    }
    public enum Status
    {
        None = 0,
        Passed = 1,
        Failed = 2,
        Skipped = 3,
        Cancelled = 4,
    }
}
namespace .Events
{
    []
    public enum EventType
    {
        Initialize = 1,
        Dispose = 2,
        TestRegistered = 4,
        TestStart = 8,
        TestEnd = 16,
        TestSkipped = 32,
        FirstTestInClass = 64,
        FirstTestInAssembly = 128,
        FirstTestInTestSession = 256,
        LastTestInClass = 512,
        LastTestInAssembly = 1024,
        LastTestInTestSession = 2048,
        TestRetry = 2049,
        All = 4095,
    }
    public class FirstTestInAssemblyEventWrapper : ., .
    {
        public FirstTestInAssemblyEventWrapper(.AsyncEvent<<.AssemblyHookContext, .TestContext>>.Invocation invocation) { }
        public int Order { get; }
        public . OnFirstTestInAssembly(.AssemblyHookContext context, .TestContext testContext) { }
    }
    public class FirstTestInClassEventWrapper : ., .
    {
        public FirstTestInClassEventWrapper(.AsyncEvent<<.ClassHookContext, .TestContext>>.Invocation invocation) { }
        public int Order { get; }
        public . OnFirstTestInClass(.ClassHookContext context, .TestContext testContext) { }
    }
    public class FirstTestInTestSessionEventWrapper : ., .
    {
        public FirstTestInTestSessionEventWrapper(.AsyncEvent<<.TestSessionContext, .TestContext>>.Invocation invocation) { }
        public int Order { get; }
        public . OnFirstTestInTestSession(.TestSessionContext context, .TestContext testContext) { }
    }
    public class LastTestInAssemblyEventWrapper : ., .
    {
        public LastTestInAssemblyEventWrapper(.AsyncEvent<<.AssemblyHookContext, .TestContext>>.Invocation invocation) { }
        public int Order { get; }
        public . OnLastTestInAssembly(.AssemblyHookContext context, .TestContext testContext) { }
    }
    public class LastTestInClassEventWrapper : ., .
    {
        public LastTestInClassEventWrapper(.AsyncEvent<<.ClassHookContext, .TestContext>>.Invocation invocation) { }
        public int Order { get; }
        public . OnLastTestInClass(.ClassHookContext context, .TestContext testContext) { }
    }
    public class LastTestInTestSessionEventWrapper : ., .
    {
        public LastTestInTestSessionEventWrapper(.AsyncEvent<<.TestSessionContext, .TestContext>>.Invocation invocation) { }
        public int Order { get; }
        public . OnLastTestInTestSession(.TestSessionContext context, .TestContext testContext) { }
    }
    public class TestDisposeEventWrapper : , .
    {
        public TestDisposeEventWrapper(.AsyncEvent<.TestContext>.Invocation invocation) { }
        public int Order { get; }
        public . DisposeAsync() { }
    }
    public class TestEndEventWrapper : ., .
    {
        public TestEndEventWrapper(.AsyncEvent<.AfterTestContext>.Invocation invocation) { }
        public int Order { get; }
        public . OnTestEnd(.AfterTestContext testContext) { }
    }
    public class TestInitializeEventWrapper : ., .
    {
        public TestInitializeEventWrapper(.AsyncEvent<.TestContext>.Invocation invocation) { }
        public int Order { get; }
        public . InitializeAsync() { }
    }
    public class TestRegisteredEventWrapper : ., .
    {
        public TestRegisteredEventWrapper(.AsyncEvent<.TestRegisteredContext>.Invocation invocation) { }
        public int Order { get; }
        public . OnTestRegistered(.TestRegisteredContext context) { }
    }
    public class TestRetryEventWrapper : ., .
    {
        public TestRetryEventWrapper([.(new string[] {
                null,
                "RetryAttempt"})] .AsyncEvent<<.TestContext, int>>.Invocation invocation) { }
        public int Order { get; }
        public . OnTestRetry(.TestContext testContext, int retryAttempt) { }
    }
    public class TestSkippedEventWrapper : ., .
    {
        public TestSkippedEventWrapper(.AsyncEvent<.TestContext>.Invocation invocation) { }
        public int Order { get; }
        public . OnTestSkipped(.TestContext testContext) { }
    }
    public class TestStartEventWrapper : ., .
    {
        public TestStartEventWrapper(.AsyncEvent<.BeforeTestContext>.Invocation invocation) { }
        public int Order { get; }
        public . OnTestStart(.BeforeTestContext beforeTestContext) { }
    }
}
namespace .Exceptions
{
    public class AfterAssemblyException : .
    {
        public AfterAssemblyException(string message,  innerException) { }
    }
    public class AfterClassException : .
    {
        public AfterClassException(string message,  innerException) { }
    }
    public class AfterTestDiscoveryException : .
    {
        public AfterTestDiscoveryException(string message,  innerException) { }
    }
    public class AfterTestException : .
    {
        public AfterTestException(string message,  innerException) { }
    }
    public class AfterTestSessionException : .
    {
        public AfterTestSessionException(string message,  innerException) { }
    }
    public class BeforeAssemblyException : .
    {
        public BeforeAssemblyException(string message,  innerException) { }
    }
    public class BeforeClassException : .
    {
        public BeforeClassException(string message,  innerException) { }
    }
    public class BeforeTestDiscoveryException : .
    {
        public BeforeTestDiscoveryException(string message,  innerException) { }
    }
    public class BeforeTestException : .
    {
        public BeforeTestException(string message,  innerException) { }
    }
    public class BeforeTestSessionException : .
    {
        public BeforeTestSessionException(string message,  innerException) { }
    }
    public class DependencyConflictException : . { }
    public class FailTestException : .
    {
        public FailTestException(string reason) { }
        public string Reason { get; }
    }
    public class InconclusiveTestException : .
    {
        public InconclusiveTestException(string message,  exception) { }
    }
    public class SkipTestException : .
    {
        public SkipTestException(string reason) { }
        public string Reason { get; }
    }
    public class TUnitException : 
    {
        public TUnitException() { }
        public TUnitException(string? message) { }
        public TUnitException(string? message, ? innerException) { }
    }
    public class TestFailedInitializationException : 
    {
        public TestFailedInitializationException(string? message, ? innerException) { }
    }
    public class TestNotExecutedException : . { }
    public class TestRunCanceledException : .
    {
        public TestRunCanceledException() { }
    }
    public class TimeoutException : . { }
}
namespace .Executors
{
    [(.Assembly | .Class | .Method)]
    public class CultureAttribute : .TUnitAttribute, ., .
    {
        public CultureAttribute(.CultureInfo cultureInfo) { }
        public CultureAttribute(string cultureName) { }
        public int Order { get; }
        public . OnTestRegistered(.TestRegisteredContext context) { }
    }
    public class HookExecutorAttribute : .TUnitAttribute
    {
        public HookExecutorAttribute( type) { }
        public  HookExecutorType { get; }
    }
    [(.Assembly | .Class | .Method)]
    public sealed class HookExecutorAttribute<T> : .
        where T : ., new ()
    {
        public HookExecutorAttribute() { }
    }
    [(.Assembly | .Class | .Method)]
    public class InvariantCultureAttribute : .
    {
        public InvariantCultureAttribute() { }
    }
    [(.Assembly | .Class | .Method)]
    public class STAThreadExecutorAttribute : .TUnitAttribute, ., .
    {
        public STAThreadExecutorAttribute() { }
        public int Order { get; }
        public . OnTestRegistered(.TestRegisteredContext context) { }
    }
    [(.Assembly | .Class | .Method)]
    public sealed class TestExecutorAttribute : .TUnitAttribute, ., .
    {
        public TestExecutorAttribute( type) { }
        public int Order { get; }
        public . OnTestRegistered(.TestRegisteredContext context) { }
    }
    [(.Assembly | .Class | .Method)]
    public sealed class TestExecutorAttribute<T> : .TUnitAttribute, ., .
        where T : ., new ()
    {
        public TestExecutorAttribute() { }
        public int Order { get; }
        public . OnTestRegistered(.TestRegisteredContext context) { }
    }
}
namespace .Extensions
{
    public static class ClassConstructorExtensions
    {
        public static T Create<T>(this . classConstructor, .ClassConstructorMetadata classConstructorMetadata)
            where T :  class { }
    }
    public static class TestContextExtensions
    {
        public static . AddDynamicTest<T>(this .TestContext testContext, .DynamicTest<T> dynamicTest)
            where T :  class { }
        public static string GetClassTypeName(this .TestContext testContext) { }
        public static string GetTestDisplayName(this .TestContext testContext) { }
        public static .TestContext[] GetTests(this .TestContext context, string testName) { }
        public static .TestContext[] GetTests(this .TestContext context, string testName, [] parameterTypes) { }
    }
}
namespace .Helpers
{
    public static class AsyncDataSourceHelper
    {
        public static .<object?> GetFirstValueAsync(.<<.<object?[]?>>> asyncEnumerable, .CancellationToken cancellationToken = default) { }
        public static .<.<<.<object?[]?>>>> ToListAsync(.<<.<object?[]?>>> asyncEnumerable, .CancellationToken cancellationToken = default) { }
        [.(typeof(..<WrapAsyncEnumerable>d__0))]
        public static .<<.<object?[]?>>> WrapAsyncEnumerable(.IAsyncDataSourceGeneratorAttribute asyncDataSourceGenerator, .DataGeneratorMetadata dataGeneratorMetadata, [.] .CancellationToken cancellationToken = default) { }
    }
    public static class CastHelper
    {
        public static object? Cast( type, object? value) { }
        public static T? Cast<T>(object? value) { }
        public static .MethodInfo? GetConversionMethod( baseType,  targetType) { }
    }
    [.DebuggerDisplay("Count = {CurrentCount}")]
    public class Counter
    {
        public <int>? OnCountChanged;
        public Counter() { }
        public int CurrentCount { get; }
        public int Decrement() { }
        public int Increment() { }
    }
    public class MethodInfoRetriever
    {
        public MethodInfoRetriever() { }
        public static .MethodInfo GetMethodInfo( type, string methodName, int genericParameterCount, [] parameterTypes) { }
    }
    public class ProcessorCountParallelLimit : .
    {
        public ProcessorCountParallelLimit() { }
        public int Limit { get; }
    }
    public class ReferenceEqualityComparer : .<object>
    {
        public ReferenceEqualityComparer() { }
        public bool Equals(object? x, object? y) { }
        public int GetHashCode(object obj) { }
    }
    public static class RobustParameterInfoRetriever
    {
        public static .ParameterInfo GetConstructorParameterInfo( type, [] parameterTypes, int parameterIndex,  expectedType, string parameterName) { }
        public static .ParameterInfo GetMethodParameterInfo( type, string methodName, int parameterIndex, [] parameterTypes, bool isStatic, int genericParameterCount) { }
    }
}
namespace .Hooks
{
    public class AfterAssemblyHookMethod : .<.AssemblyHookContext>, <.>
    {
        public AfterAssemblyHookMethod() { }
        public override . ExecuteAsync(.AssemblyHookContext context, .CancellationToken cancellationToken) { }
    }
    public class AfterClassHookMethod : .<.ClassHookContext>, <.>
    {
        public AfterClassHookMethod() { }
        public override . ExecuteAsync(.ClassHookContext context, .CancellationToken cancellationToken) { }
    }
    public class AfterTestDiscoveryHookMethod : .<.TestDiscoveryContext>, <.>
    {
        public AfterTestDiscoveryHookMethod() { }
        public override . ExecuteAsync(.TestDiscoveryContext context, .CancellationToken cancellationToken) { }
    }
    public class AfterTestHookMethod : .<.TestContext>, <.>
    {
        public AfterTestHookMethod() { }
        public override . ExecuteAsync(.TestContext context, .CancellationToken cancellationToken) { }
    }
    public class AfterTestSessionHookMethod : .<.TestSessionContext>, <.>
    {
        public AfterTestSessionHookMethod() { }
        public override . ExecuteAsync(.TestSessionContext context, .CancellationToken cancellationToken) { }
    }
    public class BeforeAssemblyHookMethod : .<.AssemblyHookContext>, <.>
    {
        public BeforeAssemblyHookMethod() { }
        public override . ExecuteAsync(.AssemblyHookContext context, .CancellationToken cancellationToken) { }
    }
    public class BeforeClassHookMethod : .<.ClassHookContext>, <.>
    {
        public BeforeClassHookMethod() { }
        public override . ExecuteAsync(.ClassHookContext context, .CancellationToken cancellationToken) { }
    }
    public class BeforeTestDiscoveryHookMethod : .<.BeforeTestDiscoveryContext>, <.>
    {
        public BeforeTestDiscoveryHookMethod() { }
        public override . ExecuteAsync(.BeforeTestDiscoveryContext context, .CancellationToken cancellationToken) { }
    }
    public class BeforeTestHookMethod : .<.TestContext>, <.>
    {
        public BeforeTestHookMethod() { }
        public override . ExecuteAsync(.TestContext context, .CancellationToken cancellationToken) { }
    }
    public class BeforeTestSessionHookMethod : .<.TestSessionContext>, <.>
    {
        public BeforeTestSessionHookMethod() { }
        public override . ExecuteAsync(.TestSessionContext context, .CancellationToken cancellationToken) { }
    }
    public class HookMethod
    {
        public HookMethod(. instanceHookMethod) { }
        public HookMethod(. staticHookMethod) { }
        public .? InstanceHookMethod { get; }
        public .? StaticHookMethod { get; }
        public static . op_Implicit(. instanceHookMethod) { }
        public static . op_Implicit(. staticHookMethod) { }
    }
    public interface IExecutableHook<in T>
    {
        .TestMethod MethodInfo { get; }
        string Name { get; }
        int Order { get; }
        . ExecuteAsync(T context, .CancellationToken cancellationToken);
    }
    public interface IHookMessagePublisher
    {
        . Discover(string sessionId, string displayName, . hookMethod);
        . Push(string sessionId, string displayName, . hookMethod, <.> func);
    }
    public class InstanceHookMethod : <.>, .<.TestContext>
    {
        public InstanceHookMethod() { }
        public .Assembly Assembly { get; }
        public [] AssemblyAttributes { get; }
        public .<> Attributes { get; }
        public <object, .TestContext, .CancellationToken, .>? Body { get; init; }
        public [] ClassAttributes { get; }
        public required  ClassType { get; init; }
        public required . HookExecutor { get; init; }
        public [] MethodAttributes { get; }
        public required .TestMethod MethodInfo { get; init; }
        public string Name { get; }
        public required int Order { get; init; }
        public ? Timeout { get; }
        public . ExecuteAsync(.TestContext context, .CancellationToken cancellationToken) { }
        public TAttribute? GetAttribute<TAttribute>()
            where TAttribute :  { }
    }
    public class LastTestInAssemblyAdapter : .<.AssemblyHookContext>
    {
        public LastTestInAssemblyAdapter(. lastTestInAssemblyEventReceiver, .TestContext testContext) { }
        public .TestMethod MethodInfo { get; }
        public string Name { get; }
        public int Order { get; }
        public bool Execute(.AssemblyHookContext context, .CancellationToken cancellationToken) { }
        public . ExecuteAsync(.AssemblyHookContext context, .CancellationToken cancellationToken) { }
    }
    public class LastTestInClassAdapter : .<.ClassHookContext>
    {
        public LastTestInClassAdapter(. lastTestInClassEventReceiver, .TestContext testContext) { }
        public .TestMethod MethodInfo { get; }
        public string Name { get; }
        public int Order { get; }
        public bool Execute(.ClassHookContext context, .CancellationToken cancellationToken) { }
        public . ExecuteAsync(.ClassHookContext context, .CancellationToken cancellationToken) { }
    }
    public abstract class StaticHookMethod : <.>
    {
        protected StaticHookMethod() { }
        public .Assembly Assembly { get; }
        public [] AssemblyAttributes { get; }
        public .<> Attributes { get; }
        public [] ClassAttributes { get; }
        public  ClassType { get; }
        public required string FilePath { get; init; }
        public required . HookExecutor { get; init; }
        public required int LineNumber { get; init; }
        public [] MethodAttributes { get; }
        public required .TestMethod MethodInfo { get; init; }
        public string Name { get; }
        public required int Order { get; init; }
        public ? Timeout { get; }
        public TAttribute? GetAttribute<TAttribute>()
            where TAttribute :  { }
    }
    public abstract class StaticHookMethod<T> : ., <.<T>>, .<T>
    {
        protected StaticHookMethod() { }
        public <T, .CancellationToken, .>? Body { get; init; }
        public abstract . ExecuteAsync(T context, .CancellationToken cancellationToken);
    }
}
namespace .Interfaces
{
    public interface IAsyncInitializer
    {
        . InitializeAsync();
    }
    public interface IClassConstructor
    {
        object Create( type, .ClassConstructorMetadata classConstructorMetadata);
    }
    public interface IConfiguration
    {
        string? Get(string key);
    }
    public interface IContext
    {
        .TextWriter ErrorOutputWriter { get; }
        .TextWriter OutputWriter { get; }
        . GetDefaultLogger();
    }
    public interface IEventReceiver
    {
        int Order { get; }
    }
    public interface IFirstTestInAssemblyEventReceiver : .
    {
        . OnFirstTestInAssembly(.AssemblyHookContext context, .TestContext testContext);
    }
    public interface IFirstTestInClassEventReceiver : .
    {
        . OnFirstTestInClass(.ClassHookContext context, .TestContext testContext);
    }
    public interface IFirstTestInTestSessionEventReceiver : .
    {
        . OnFirstTestInTestSession(.TestSessionContext current, .TestContext testContext);
    }
    public interface IHasLoggers
    {
        .<.> Loggers { get; }
    }
    public interface IHookExecutor
    {
        . ExecuteAfterAssemblyHook(.TestMethod hookMethodInfo, .AssemblyHookContext context, <.> action);
        . ExecuteAfterClassHook(.TestMethod hookMethodInfo, .ClassHookContext context, <.> action);
        . ExecuteAfterTestDiscoveryHook(.TestMethod hookMethodInfo, .TestDiscoveryContext context, <.> action);
        . ExecuteAfterTestHook(.TestMethod hookMethodInfo, .TestContext context, <.> action);
        . ExecuteAfterTestSessionHook(.TestMethod hookMethodInfo, .TestSessionContext context, <.> action);
        . ExecuteBeforeAssemblyHook(.TestMethod hookMethodInfo, .AssemblyHookContext context, <.> action);
        . ExecuteBeforeClassHook(.TestMethod hookMethodInfo, .ClassHookContext context, <.> action);
        . ExecuteBeforeTestDiscoveryHook(.TestMethod hookMethodInfo, .BeforeTestDiscoveryContext context, <.> action);
        . ExecuteBeforeTestHook(.TestMethod hookMethodInfo, .TestContext context, <.> action);
        . ExecuteBeforeTestSessionHook(.TestMethod hookMethodInfo, .TestSessionContext context, <.> action);
    }
    public interface ILastTestInAssemblyEventReceiver : .
    {
        . OnLastTestInAssembly(.AssemblyHookContext context, .TestContext testContext);
    }
    public interface ILastTestInClassEventReceiver : .
    {
        . OnLastTestInClass(.ClassHookContext context, .TestContext testContext);
    }
    public interface ILastTestInTestSessionEventReceiver : .
    {
        . OnLastTestInTestSession(.TestSessionContext current, .TestContext testContext);
    }
    public interface IParallelConstraint { }
    public interface IParallelLimit
    {
        int Limit { get; }
    }
    public interface ITestDiscoveryEventReceiver : .
    {
        void OnTestDiscovery(.DiscoveredTestContext discoveredTestContext);
    }
    public interface ITestEndEventReceiver : .
    {
        . OnTestEnd(.AfterTestContext afterTestContext);
    }
    public interface ITestExecutor
    {
        . ExecuteTest(.TestContext context, <.> action);
    }
    public interface ITestFinder
    {
        .<.TestContext> GetTests( classType);
        .TestContext[] GetTestsByNameAndParameters(string testName, .<> methodParameterTypes,  classType, .<> classParameterTypes, .<object?> classArguments);
    }
    public interface ITestRegisteredEventReceiver : .
    {
        . OnTestRegistered(.TestRegisteredContext context);
    }
    public interface ITestRetryEventReceiver : .
    {
        . OnTestRetry(.TestContext testContext, int retryAttempt);
    }
    public interface ITestSkippedEventReceiver : .
    {
        . OnTestSkipped(.TestContext testContext);
    }
    public interface ITestStartEventReceiver : .
    {
        . OnTestStart(.BeforeTestContext beforeTestContext);
    }
}
namespace .
{
    public interface IAssemblyHookSource
    {
        .<.<.AssemblyHookContext>> CollectAfterAssemblyHooks(string sessionId);
        .<.<.AssemblyHookContext>> CollectAfterEveryAssemblyHooks(string sessionId);
        .<.<.AssemblyHookContext>> CollectBeforeAssemblyHooks(string sessionId);
        .<.<.AssemblyHookContext>> CollectBeforeEveryAssemblyHooks(string sessionId);
    }
    public interface IClassHookSource
    {
        .<.<.ClassHookContext>> CollectAfterClassHooks(string sessionId);
        .<.<.ClassHookContext>> CollectAfterEveryClassHooks(string sessionId);
        .<.<.ClassHookContext>> CollectBeforeClassHooks(string sessionId);
        .<.<.ClassHookContext>> CollectBeforeEveryClassHooks(string sessionId);
    }
    public interface IDynamicTestSource
    {
        .<.DynamicTest> CollectDynamicTests(string sessionId);
    }
    public interface ITestDiscoveryHookSource
    {
        .<.<.TestDiscoveryContext>> CollectAfterTestDiscoveryHooks(string sessionId);
        .<.<.BeforeTestDiscoveryContext>> CollectBeforeTestDiscoveryHooks(string sessionId);
    }
    public interface ITestHookSource
    {
        .<.<.TestContext>> CollectAfterEveryTestHooks(string sessionId);
        .<.> CollectAfterTestHooks(string sessionId);
        .<.<.TestContext>> CollectBeforeEveryTestHooks(string sessionId);
        .<.> CollectBeforeTestHooks(string sessionId);
    }
    public interface ITestSessionHookSource
    {
        .<.<.TestSessionContext>> CollectAfterTestSessionHooks(string sessionId);
        .<.<.TestSessionContext>> CollectBeforeTestSessionHooks(string sessionId);
    }
    public interface ITestSource
    {
        .<.<.TestMetadata>> CollectTestsAsync(string sessionId);
    }
}
namespace .Logging
{
    public class DefaultLogger : .
    {
        public DefaultLogger(.Context context) { }
        public override void Log<TState>(. logLevel, TState state, ? exception, <TState, ?, string> formatter) { }
        public override . LogAsync<TState>(. logLevel, TState state, ? exception, <TState, ?, string> formatter) { }
        public void PushProperties(.<string, .<object>> dictionary) { }
        public void PushProperty(string name, object? value) { }
    }
    public interface ILogger
    {
        bool IsEnabled(. logLevel);
        void Log<TState>(. logLevel, TState state, ? exception, <TState, ?, string> formatter);
        . LogAsync<TState>(. logLevel, TState state, ? exception, <TState, ?, string> formatter);
    }
    public interface ILogger<out TCategoryName> : . { }
    public enum LogLevel
    {
        Trace = 0,
        Debug = 1,
        Information = 2,
        Warning = 3,
        Error = 4,
        Critical = 5,
        None = 6,
    }
    public static class LoggingExtensions
    {
        public static void LogCritical(this . logger, string message) { }
        public static . LogCriticalAsync(this . logger, string message) { }
        public static void LogDebug(this . logger, string message) { }
        public static . LogDebugAsync(this . logger, string message) { }
        public static void LogError(this . logger,  ex) { }
        public static void LogError(this . logger, string message) { }
        public static void LogError(this . logger, string message,  ex) { }
        public static . LogErrorAsync(this . logger,  ex) { }
        public static . LogErrorAsync(this . logger, string message) { }
        public static . LogErrorAsync(this . logger, string message,  ex) { }
        public static void LogInformation(this . logger, string message) { }
        public static . LogInformationAsync(this . logger, string message) { }
        public static void LogTrace(this . logger, string message) { }
        public static . LogTraceAsync(this . logger, string message) { }
        public static void LogWarning(this . logger, string message) { }
        public static . LogWarningAsync(this . logger, string message) { }
    }
    public abstract class TUnitLogger : .
    {
        protected TUnitLogger() { }
        public virtual bool IsEnabled(. logLevel) { }
        public abstract void Log<TState>(. logLevel, TState state, ? exception, <TState, ?, string> formatter);
        public abstract . LogAsync<TState>(. logLevel, TState state, ? exception, <TState, ?, string> formatter);
    }
}