[assembly: .(".NETCoreApp,Version=v8.0", FrameworkDisplayName=".NET 8.0")]
namespace 
{
    public static class Assert
    {
        public static void Fail(string reason) { }
        public static  Multiple() { }
        public static . That( action, [.("action")] string? expression = null) { }
        public static .<object?> That(.IEnumerable value, [.("value")] string? expression = null) { }
        public static . That(<.> action, [.("action")] string? expression = null) { }
        public static . That(. task, [.("task")] string? expression = null) { }
        public static .<string> That(string? value, [.("value")] string? expression = null) { }
        public static .<TItem> That<TItem>(.<TItem>? value, [.("value")] string? expression = null) { }
        public static .<TValue> That<TValue>(<.<TValue?>> func, [.("func")] string? expression = null) { }
        public static .<TValue> That<TValue>(<TValue?> func, [.("func")] string? expression = null) { }
        public static .<TValue> That<TValue>(.<TValue?> task, [.("task")] string? expression = null) { }
        public static .<TValue> That<TValue>(TValue? value, [.("value")] string? expression = null) { }
        public static .<TKey, TValue> That<TKey, TValue>(.<TKey, TValue> value, [.("value")] string? expression = null) { }
        public static  Throws( exceptionType,  action) { }
        public static TException Throws<TException>( action)
            where TException :  { }
        public static TException Throws<TException>(string parameterName,  action)
            where TException :  { }
        public static .<> ThrowsAsync(<.> action) { }
        public static .<> ThrowsAsync(. task) { }
        public static .<> ThrowsAsync(. task) { }
        public static .<?> ThrowsAsync( exceptionType, <.> action) { }
        public static .<TException> ThrowsAsync<TException>(<.> action)
            where TException :  { }
        public static .<TException> ThrowsAsync<TException>(string parameterName, <.> action)
            where TException :  { }
        public static TException ThrowsExactly<TException>( action)
            where TException :  { }
        public static TException ThrowsExactly<TException>(string parameterName,  action)
            where TException :  { }
        public static .<TException> ThrowsExactlyAsync<TException>(<.> action)
            where TException :  { }
        public static .<TException> ThrowsExactlyAsync<TException>(string parameterName, <.> action)
            where TException :  { }
    }
    public static class Fail
    {
        public static void Test(string reason) { }
        public static void Unless([.(false)] bool condition, string reason) { }
        public static void When([.(true)] bool condition, string reason) { }
    }
    public static class IntAssertions
    {
        [.]
        public static bool IsEven(this int value) { }
        [.]
        public static bool IsOdd(this int value) { }
    }
    public class StringMatcher
    {
        public .StringMatcher IgnoringCase() { }
        public bool IsMatch(string? input) { }
        public override string ToString() { }
        public static .StringMatcher AsRegex(string pattern) { }
        public static .StringMatcher AsWildcard(string pattern) { }
    }
}
namespace .
{
    public class DoesNotHaveFlagAssertion<TEnum> : .<TEnum>
        where TEnum :  struct, 
    {
        public DoesNotHaveFlagAssertion(.<TEnum> context, TEnum unexpectedFlag) { }
        protected override .<.> CheckAsync(.<TEnum> metadata) { }
        protected override string GetExpectation() { }
    }
    public class DoesNotHaveSameNameAsAssertion<TEnum> : .<TEnum>
        where TEnum :  struct, 
    {
        public DoesNotHaveSameNameAsAssertion(.<TEnum> context,  otherEnumValue) { }
        protected override .<.> CheckAsync(.<TEnum> metadata) { }
        protected override string GetExpectation() { }
    }
    public class DoesNotHaveSameValueAsAssertion<TEnum> : .<TEnum>
        where TEnum :  struct, 
    {
        public DoesNotHaveSameValueAsAssertion(.<TEnum> context,  otherEnumValue) { }
        protected override .<.> CheckAsync(.<TEnum> metadata) { }
        protected override string GetExpectation() { }
    }
    public class HasFlagAssertion<TEnum> : .<TEnum>
        where TEnum :  struct, 
    {
        public HasFlagAssertion(.<TEnum> context, TEnum expectedFlag) { }
        protected override .<.> CheckAsync(.<TEnum> metadata) { }
        protected override string GetExpectation() { }
    }
    public class HasSameNameAsAssertion<TEnum> : .<TEnum>
        where TEnum :  struct, 
    {
        public HasSameNameAsAssertion(.<TEnum> context,  otherEnumValue) { }
        protected override .<.> CheckAsync(.<TEnum> metadata) { }
        protected override string GetExpectation() { }
    }
    public class HasSameValueAsAssertion<TEnum> : .<TEnum>
        where TEnum :  struct, 
    {
        public HasSameValueAsAssertion(.<TEnum> context,  otherEnumValue) { }
        protected override .<.> CheckAsync(.<TEnum> metadata) { }
        protected override string GetExpectation() { }
    }
    public class IsDefinedAssertion<TEnum> : .<TEnum>
        where TEnum :  struct, 
    {
        public IsDefinedAssertion(.<TEnum> context) { }
        protected override .<.> CheckAsync(.<TEnum> metadata) { }
        protected override string GetExpectation() { }
    }
    public class IsNotDefinedAssertion<TEnum> : .<TEnum>
        where TEnum :  struct, 
    {
        public IsNotDefinedAssertion(.<TEnum> context) { }
        protected override .<.> CheckAsync(.<TEnum> metadata) { }
        protected override string GetExpectation() { }
    }
}
namespace .Assertions
{
    public class PropertyAssertionResult<TObject> : ., .<TObject>
    {
        public .<TObject> Context { get; }
        public .<TObject?> GetAwaiter() { }
    }
    public class PropertyAssertion<TObject, TProperty>
    {
        public .<TObject> IsEqualTo(TProperty expected) { }
        public .<TObject> IsNotEqualTo(TProperty expected) { }
        public .<TObject> IsNotNull() { }
        public .<TObject> IsNull() { }
    }
}
namespace .
{
    public class IsNotParsableIntoAssertion<[.(..None | ..PublicMethods | ..Interfaces)]  T> : .<string>
    {
        public IsNotParsableIntoAssertion(.<string> context) { }
        protected override .<.> CheckAsync(.<string> metadata) { }
        protected override string GetExpectation() { }
        public ..IsNotParsableIntoAssertion<T> WithFormatProvider( formatProvider) { }
    }
    public class IsParsableIntoAssertion<[.(..None | ..PublicMethods | ..Interfaces)]  T> : .<string>
    {
        public IsParsableIntoAssertion(.<string> context) { }
        protected override .<.> CheckAsync(.<string> metadata) { }
        protected override string GetExpectation() { }
        public ..IsParsableIntoAssertion<T> WithFormatProvider( formatProvider) { }
    }
    public class WhenParsedIntoAssertion<[.(..None | ..PublicMethods | ..Interfaces)]  T> : .<T>, ., .<T>
    {
        public WhenParsedIntoAssertion(.<string> stringContext, ? formatProvider = null) { }
        protected override .<.> CheckAsync(.<T> metadata) { }
        protected override string GetExpectation() { }
        public ..WhenParsedIntoAssertion<T> WithFormatProvider( formatProvider) { }
    }
}
namespace .Attributes
{
    [(.Class, AllowMultiple=false)]
    public class AssertionExtensionAttribute : 
    {
        public AssertionExtensionAttribute(string methodName) { }
        public string MethodName { get; }
        public string? NegatedMethodName { get; set; }
        public int OverloadResolutionPriority { get; set; }
    }
    [(.Class, AllowMultiple=true, Inherited=false)]
    public class AssertionFromAttribute : 
    {
        public AssertionFromAttribute( targetType, string methodName) { }
        public AssertionFromAttribute( targetType,  containingType, string methodName) { }
        public ? ContainingType { get; }
        public string? CustomName { get; set; }
        public string MethodName { get; }
        public bool NegateLogic { get; set; }
        public bool RequiresGenericTypeParameter { get; set; }
        public  TargetType { get; }
        public bool TreatAsInstance { get; set; }
    }
    [(.Class, AllowMultiple=true, Inherited=false)]
    public sealed class AssertionFromAttribute<TTarget> : 
    {
        public AssertionFromAttribute(string methodName) { }
        public AssertionFromAttribute( containingType, string methodName) { }
        public ? ContainingType { get; }
        public string? CustomName { get; set; }
        public string? ExpectationMessage { get; set; }
        public string MethodName { get; }
        public bool NegateLogic { get; set; }
        public bool RequiresGenericTypeParameter { get; set; }
        public  TargetType { get; }
        public bool TreatAsInstance { get; set; }
    }
    [(.Class, AllowMultiple=true)]
    [("Use AssertionFromAttribute instead. This attribute will be removed in a future ve" +
        "rsion.")]
    public class CreateAssertionAttribute : 
    {
        public CreateAssertionAttribute( targetType, string methodName) { }
        public CreateAssertionAttribute( targetType,  containingType, string methodName) { }
        public ? ContainingType { get; }
        public string? CustomName { get; set; }
        public string MethodName { get; }
        public bool NegateLogic { get; set; }
        public bool RequiresGenericTypeParameter { get; set; }
        public  TargetType { get; }
        public bool TreatAsInstance { get; set; }
    }
    [(.Class, AllowMultiple=true)]
    [("Use AssertionFromAttribute<T> instead. This attribute will be removed in a future" +
        " version.")]
    public class CreateAssertionAttribute<TTarget> : 
    {
        public CreateAssertionAttribute(string methodName) { }
        public CreateAssertionAttribute( containingType, string methodName) { }
        public ? ContainingType { get; }
        public string? CustomName { get; set; }
        public string MethodName { get; }
        public bool NegateLogic { get; set; }
        public bool RequiresGenericTypeParameter { get; set; }
        public  TargetType { get; }
        public bool TreatAsInstance { get; set; }
    }
    [(.Method, AllowMultiple=false, Inherited=false)]
    public sealed class GenerateAssertionAttribute : 
    {
        public GenerateAssertionAttribute() { }
        public string? ExpectationMessage { get; set; }
    }
}
namespace .Chaining
{
    public class AndAssertion<TValue> : .<TValue>
    {
        public AndAssertion(.<TValue> first, .<TValue> second) { }
        public new .<TValue> Or { get; }
        public override .<TValue?> AssertAsync() { }
        protected override string GetExpectation() { }
    }
    public class OrAssertion<TValue> : .<TValue>
    {
        public OrAssertion(.<TValue> first, .<TValue> second) { }
        public new .<TValue> And { get; }
        public override .<TValue?> AssertAsync() { }
        protected override string GetExpectation() { }
    }
}
namespace .Conditions
{
    public static class ArrayAssertionExtensions
    {
        [.(ExpectationMessage="to be an empty array")]
        public static bool IsEmpty<T>(this T[] value) { }
        [.(ExpectationMessage="to not be an empty array")]
        public static bool IsNotEmpty<T>(this T[] value) { }
        [.(ExpectationMessage="to not be a single-element collection")]
        public static bool IsNotSingleElement<T>(this .<T> value) { }
        [.(ExpectationMessage="to not be a single-element array")]
        public static bool IsNotSingleElement<T>(this T[] value) { }
        [.(ExpectationMessage="to be a single-element collection")]
        public static bool IsSingleElement<T>(this .<T> value) { }
        [.(ExpectationMessage="to be a single-element array")]
        public static bool IsSingleElement<T>(this T[] value) { }
    }
    [.<.Assembly>("IsCollectible", CustomName="IsNotCollectible", ExpectationMessage="be collectible", NegateLogic=true)]
    [.<.Assembly>("IsCollectible", ExpectationMessage="be collectible")]
    [.<.Assembly>("IsDynamic", CustomName="IsNotDynamic", ExpectationMessage="be dynamic", NegateLogic=true)]
    [.<.Assembly>("IsDynamic", ExpectationMessage="be dynamic")]
    [.<.Assembly>("IsFullyTrusted", CustomName="IsNotFullyTrusted", ExpectationMessage="be fully trusted", NegateLogic=true)]
    [.<.Assembly>("IsFullyTrusted", ExpectationMessage="be fully trusted")]
    public static class AssemblyAssertionExtensions
    {
        [.(ExpectationMessage="to be a debug build")]
        public static bool IsDebugBuild(this .Assembly value) { }
        [.(ExpectationMessage="to not be signed")]
        public static bool IsNotSigned(this .Assembly value) { }
        [.(ExpectationMessage="to be a release build")]
        public static bool IsReleaseBuild(this .Assembly value) { }
        [.(ExpectationMessage="to be signed")]
        public static bool IsSigned(this .Assembly value) { }
    }
    public class AssertionSourceAdapter<T> : ., .<T>
    {
        public AssertionSourceAdapter(.<T> context) { }
        public .<T> Context { get; }
    }
    public class AsyncMappedSatisfiesAssertion<TValue, TMapped> : .<TValue>
    {
        public AsyncMappedSatisfiesAssertion(.<TValue> context, <TValue?, .<TMapped>> selector, <.<TMapped>, .<TMapped>?> assertions, string selectorDescription) { }
        protected override .<.> CheckAsync(.<TValue> metadata) { }
        protected override string GetExpectation() { }
    }
    public abstract class BaseThrowsAssertion<TException, TSelf> : .<TException>
        where TException : 
        where TSelf : .<TException, TSelf>
    {
        protected BaseThrowsAssertion(.<TException> context, bool allowSubclasses) { }
        protected abstract bool IsExactTypeMatch { get; }
        protected override sealed .<.> CheckAsync(.<TException> metadata) { }
        protected abstract bool CheckExceptionType( actualException, out string? errorMessage);
        protected override string GetExpectation() { }
    }
    [.("IsBetween")]
    public class BetweenAssertion<TValue> : .<TValue>
        where TValue : <TValue>
    {
        public BetweenAssertion(.<TValue> context, TValue minimum, TValue maximum) { }
        protected override .<.> CheckAsync(.<TValue> metadata) { }
        public .<TValue> Exclusive() { }
        protected override string GetExpectation() { }
        public .<TValue> Inclusive() { }
        public .<TValue> InclusiveMaximum() { }
        public .<TValue> InclusiveMinimum() { }
    }
    public static class BooleanAssertionExtensions
    {
        [.(ExpectationMessage="to be false")]
        public static bool IsFalse(this bool value) { }
        [.(ExpectationMessage="to be false")]
        public static bool IsFalse(this bool? value) { }
        [.(ExpectationMessage="to be true")]
        public static bool IsTrue(this bool value) { }
        [.(ExpectationMessage="to be true")]
        public static bool IsTrue(this bool? value) { }
    }
    [.<.CancellationToken>("CanBeCanceled", CustomName="CannotBeCanceled", ExpectationMessage="be cancellable", NegateLogic=true)]
    [.<.CancellationToken>("CanBeCanceled", ExpectationMessage="be cancellable")]
    [.<.CancellationToken>("IsCancellationRequested", CustomName="IsNotCancellationRequested", ExpectationMessage="have cancellation requested", NegateLogic=true)]
    [.<.CancellationToken>("IsCancellationRequested", ExpectationMessage="have cancellation requested")]
    public static class CancellationTokenAssertionExtensions
    {
        [.(ExpectationMessage="to be ")]
        public static bool IsNone(this .CancellationToken value) { }
        [.(ExpectationMessage="to not be ")]
        public static bool IsNotNone(this .CancellationToken value) { }
    }
    [.<char>("IsControl", CustomName="IsNotControl", ExpectationMessage="be a control character", NegateLogic=true)]
    [.<char>("IsControl", ExpectationMessage="be a control character")]
    [.<char>("IsDigit", CustomName="IsNotDigit", ExpectationMessage="be a digit", NegateLogic=true)]
    [.<char>("IsDigit", ExpectationMessage="be a digit")]
    [.<char>("IsHighSurrogate", CustomName="IsNotHighSurrogate", ExpectationMessage="be a high surrogate", NegateLogic=true)]
    [.<char>("IsHighSurrogate", ExpectationMessage="be a high surrogate")]
    [.<char>("IsLetter", CustomName="IsNotLetter", ExpectationMessage="be a letter", NegateLogic=true)]
    [.<char>("IsLetter", ExpectationMessage="be a letter")]
    [.<char>("IsLetterOrDigit", CustomName="IsNotLetterOrDigit", ExpectationMessage="be a letter or digit", NegateLogic=true)]
    [.<char>("IsLetterOrDigit", ExpectationMessage="be a letter or digit")]
    [.<char>("IsLowSurrogate", CustomName="IsNotLowSurrogate", ExpectationMessage="be a low surrogate", NegateLogic=true)]
    [.<char>("IsLowSurrogate", ExpectationMessage="be a low surrogate")]
    [.<char>("IsLower", CustomName="IsNotLower", ExpectationMessage="be lowercase", NegateLogic=true)]
    [.<char>("IsLower", ExpectationMessage="be lowercase")]
    [.<char>("IsNumber", CustomName="IsNotNumber", ExpectationMessage="be a number", NegateLogic=true)]
    [.<char>("IsNumber", ExpectationMessage="be a number")]
    [.<char>("IsPunctuation", CustomName="IsNotPunctuation", ExpectationMessage="be punctuation", NegateLogic=true)]
    [.<char>("IsPunctuation", ExpectationMessage="be punctuation")]
    [.<char>("IsSeparator", CustomName="IsNotSeparator", ExpectationMessage="be a separator", NegateLogic=true)]
    [.<char>("IsSeparator", ExpectationMessage="be a separator")]
    [.<char>("IsSurrogate", CustomName="IsNotSurrogate", ExpectationMessage="be a surrogate", NegateLogic=true)]
    [.<char>("IsSurrogate", ExpectationMessage="be a surrogate")]
    [.<char>("IsSymbol", CustomName="IsNotSymbol", ExpectationMessage="be a symbol", NegateLogic=true)]
    [.<char>("IsSymbol", ExpectationMessage="be a symbol")]
    [.<char>("IsUpper", CustomName="IsNotUpper", ExpectationMessage="be uppercase", NegateLogic=true)]
    [.<char>("IsUpper", ExpectationMessage="be uppercase")]
    [.<char>("IsWhiteSpace", CustomName="IsNotWhiteSpace", ExpectationMessage="be whitespace", NegateLogic=true)]
    [.<char>("IsWhiteSpace", ExpectationMessage="be whitespace")]
    public static class CharAssertionExtensions { }
    [.("All")]
    public class CollectionAllAssertion<TCollection, TItem> : .<TCollection, TItem>
        where TCollection : .<TItem>
    {
        public CollectionAllAssertion(.<TCollection> context, <TItem, bool> predicate, string predicateDescription) { }
        protected override .<.> CheckAsync(.<TCollection> metadata) { }
        protected override string GetExpectation() { }
    }
    public class CollectionAllSatisfyAssertion<TCollection, TItem> : .<TCollection, TItem>
        where TCollection : .<TItem>
    {
        public CollectionAllSatisfyAssertion(.<TCollection> context, <.<TItem>, .<TItem>?> assertion, string assertionDescription) { }
        protected override .<.> CheckAsync(.<TCollection> metadata) { }
        protected override string GetExpectation() { }
    }
    public class CollectionAllSatisfyHelper<TCollection, TItem>
        where TCollection : .<TItem>
    {
        public CollectionAllSatisfyHelper(.<TCollection> context) { }
        public .<TCollection, TItem> Satisfy(<.<TItem>, .<TItem>?> assertion, [.("assertion")] string? expression = null) { }
        public .<TCollection, TItem, TMapped> Satisfy<TMapped>(<TItem, TMapped> mapper, <.<TMapped>, .<TMapped>?> assertion, [.("mapper")] string? mapperExpression = null, [.("assertion")] string? assertionExpression = null) { }
    }
    public class CollectionAllSatisfyMappedAssertion<TCollection, TItem, TMapped> : .<TCollection, TItem>
        where TCollection : .<TItem>
    {
        public CollectionAllSatisfyMappedAssertion(.<TCollection> context, <TItem, TMapped> mapper, <.<TMapped>, .<TMapped>?> assertion, string mapperDescription, string assertionDescription) { }
        protected override .<.> CheckAsync(.<TCollection> metadata) { }
        protected override string GetExpectation() { }
    }
    [.("Any")]
    public class CollectionAnyAssertion<TCollection, TItem> : .<TCollection, TItem>
        where TCollection : .<TItem>
    {
        public CollectionAnyAssertion(.<TCollection> context, <TItem, bool> predicate, string predicateDescription) { }
        protected override .<.> CheckAsync(.<TCollection> metadata) { }
        protected override string GetExpectation() { }
    }
    public abstract class CollectionComparerBasedAssertion<TCollection, TItem> : .<TCollection, TItem>
        where TCollection : .<TItem>
    {
        protected CollectionComparerBasedAssertion(.<TCollection> context) { }
        protected .<TItem> GetComparer() { }
        protected bool HasCustomComparer() { }
        protected void SetComparer(.<TItem> comparer) { }
    }
    [.("Contains")]
    public class CollectionContainsAssertion<TCollection, TItem> : .<TCollection, TItem>
        where TCollection : .<TItem>
    {
        public CollectionContainsAssertion(.<TCollection> context, TItem expected, .<TItem>? comparer = null) { }
        protected override .<.> CheckAsync(.<TCollection> metadata) { }
        protected override string GetExpectation() { }
    }
    [.("Contains")]
    public class CollectionContainsPredicateAssertion<TCollection, TItem> : .<TCollection, TItem>
        where TCollection : .<TItem>
    {
        public CollectionContainsPredicateAssertion(.<TCollection> context, <TItem, bool> predicate) { }
        protected override .<.> CheckAsync(.<TCollection> metadata) { }
        public .<TItem> GetAwaiter() { }
        protected override string GetExpectation() { }
    }
    public class CollectionCountAssertion<TCollection, TItem> : .<TCollection, TItem>
        where TCollection : .<TItem>
    {
        public CollectionCountAssertion(.<TCollection> context, int expectedCount) { }
        protected override .<.> CheckAsync(.<TCollection> metadata) { }
        protected override string GetExpectation() { }
    }
    public class CollectionCountValueAssertion<TCollection, TItem> : .<int>
        where TCollection : .<TItem>
    {
        public CollectionCountValueAssertion(.<TCollection> collectionContext, <TItem, bool>? predicate) { }
    }
    [.("DoesNotContain")]
    public class CollectionDoesNotContainAssertion<TCollection, TItem> : .<TCollection, TItem>
        where TCollection : .<TItem>
    {
        public CollectionDoesNotContainAssertion(.<TCollection> context, TItem expected, .<TItem>? comparer = null) { }
        protected override .<.> CheckAsync(.<TCollection> metadata) { }
        protected override string GetExpectation() { }
    }
    [.("DoesNotContain")]
    public class CollectionDoesNotContainPredicateAssertion<TCollection, TItem> : .<TCollection, TItem>
        where TCollection : .<TItem>
    {
        public CollectionDoesNotContainPredicateAssertion(.<TCollection> context, <TItem, bool> predicate, string predicateDescription) { }
        protected override .<.> CheckAsync(.<TCollection> metadata) { }
        protected override string GetExpectation() { }
    }
    public class CollectionIsEmptyAssertion<TCollection, TItem> : .<TCollection, TItem>
        where TCollection : .<TItem>
    {
        public CollectionIsEmptyAssertion(.<TCollection> context) { }
        protected override .<.> CheckAsync(.<TCollection> metadata) { }
        protected override string GetExpectation() { }
    }
    [.("IsInDescendingOrder")]
    public class CollectionIsInDescendingOrderAssertion<TCollection, TItem> : .<TCollection, TItem>
        where TCollection : .<TItem>
    {
        public CollectionIsInDescendingOrderAssertion(.<TCollection> context) { }
        protected override .<.> CheckAsync(.<TCollection> metadata) { }
        protected override string GetExpectation() { }
    }
    [.("IsInOrder")]
    public class CollectionIsInOrderAssertion<TCollection, TItem> : .<TCollection, TItem>
        where TCollection : .<TItem>
    {
        public CollectionIsInOrderAssertion(.<TCollection> context) { }
        protected override .<.> CheckAsync(.<TCollection> metadata) { }
        protected override string GetExpectation() { }
    }
    public class CollectionIsNotEmptyAssertion<TCollection, TItem> : .<TCollection, TItem>
        where TCollection : .<TItem>
    {
        public CollectionIsNotEmptyAssertion(.<TCollection> context) { }
        protected override .<.> CheckAsync(.<TCollection> metadata) { }
        protected override string GetExpectation() { }
    }
    public class CollectionIsOrderedByAssertion<TCollection, TItem, TKey> : .<TCollection, TItem>
        where TCollection : .<TItem>
    {
        public CollectionIsOrderedByAssertion(.<TCollection> context, <TItem, TKey> keySelector, .<TKey>? comparer = null) { }
        protected override .<.> CheckAsync(.<TCollection> metadata) { }
        protected override string GetExpectation() { }
    }
    public class CollectionIsOrderedByDescendingAssertion<TCollection, TItem, TKey> : .<TCollection, TItem>
        where TCollection : .<TItem>
    {
        public CollectionIsOrderedByDescendingAssertion(.<TCollection> context, <TItem, TKey> keySelector, .<TKey>? comparer = null) { }
        protected override .<.> CheckAsync(.<TCollection> metadata) { }
        protected override string GetExpectation() { }
    }
    public class CollectionNotNullAssertion<TCollection, TItem> : .<TCollection, TItem>
        where TCollection : .<TItem>
    {
        public CollectionNotNullAssertion(.<TCollection> context) { }
        protected override .<.> CheckAsync(.<TCollection> metadata) { }
        protected override string GetExpectation() { }
    }
    public abstract class ComparerBasedAssertion<TValue, TItem> : .<TValue>
    {
        protected ComparerBasedAssertion(.<TValue> context) { }
        protected .<TItem> GetComparer() { }
        protected bool HasCustomComparer() { }
        protected void SetComparer(.<TItem> comparer) { }
    }
    public class CompletesWithinActionAssertion : .<object?>
    {
        public CompletesWithinActionAssertion( action,  timeout, .<object?>? context = null) { }
        protected override .<.> CheckAsync(.<object?> metadata) { }
        protected override string GetExpectation() { }
    }
    public class CompletesWithinAsyncAssertion : .<object?>
    {
        public CompletesWithinAsyncAssertion(<.> asyncAction,  timeout, .<object?>? context = null) { }
        protected override .<.> CheckAsync(.<object?> metadata) { }
        protected override string GetExpectation() { }
    }
    [.<.CultureInfo>("IsNeutralCulture", CustomName="IsNotNeutralCulture", ExpectationMessage="be a neutral culture", NegateLogic=true)]
    [.<.CultureInfo>("IsNeutralCulture", ExpectationMessage="be a neutral culture")]
    [.<.CultureInfo>("IsReadOnly", ExpectationMessage="be read-only culture")]
    public static class CultureInfoAssertionExtensions
    {
        [.(ExpectationMessage="to be English culture")]
        public static bool IsEnglish(this .CultureInfo value) { }
        [.(ExpectationMessage="to be invariant culture")]
        public static bool IsInvariant(this .CultureInfo value) { }
        [.(ExpectationMessage="to be left-to-right culture")]
        public static bool IsLeftToRight(this .CultureInfo value) { }
        [.(ExpectationMessage="to not be English culture")]
        public static bool IsNotEnglish(this .CultureInfo value) { }
        [.(ExpectationMessage="to not be invariant culture")]
        public static bool IsNotInvariant(this .CultureInfo value) { }
        [.(ExpectationMessage="to be right-to-left culture")]
        public static bool IsRightToLeft(this .CultureInfo value) { }
    }
    public static class DateOnlyAssertionExtensions
    {
        [.(ExpectationMessage="to be the first day of the month")]
        public static bool IsFirstDayOfMonth(this  value) { }
        [.(ExpectationMessage="to be in the future")]
        public static bool IsInFuture(this  value) { }
        [.(ExpectationMessage="to be in the past")]
        public static bool IsInPast(this  value) { }
        [.(ExpectationMessage="to be the last day of the month")]
        public static bool IsLastDayOfMonth(this  value) { }
        [.(ExpectationMessage="to be in a leap year")]
        public static bool IsLeapYear(this  value) { }
        [.(ExpectationMessage="to not be in a leap year")]
        public static bool IsNotLeapYear(this  value) { }
        [.(ExpectationMessage="to not be today")]
        public static bool IsNotToday(this  value) { }
        [.(ExpectationMessage="to be on a weekday")]
        public static bool IsOnWeekday(this  value) { }
        [.(ExpectationMessage="to be on a weekend")]
        public static bool IsOnWeekend(this  value) { }
        [.(ExpectationMessage="to be today")]
        public static bool IsToday(this  value) { }
    }
    [.("IsEqualTo", OverloadResolutionPriority=2)]
    public class DateOnlyEqualsAssertion : .<, int>
    {
        public DateOnlyEqualsAssertion(.<> context,  expected) { }
        protected override bool AreExactlyEqual( actual,  expected) { }
        protected override object CalculateDifference( actual,  expected) { }
        protected override string FormatDifferenceMessage( actual, object difference) { }
        protected override string GetExpectation() { }
        protected override bool HasToleranceValue() { }
        protected override bool IsWithinTolerance( actual,  expected, int toleranceDays) { }
        public . WithinDays(int days) { }
    }
    [.<>("IsDaylightSavingTime", CustomName="IsNotDaylightSavingTime", ExpectationMessage="be during daylight saving time", NegateLogic=true)]
    [.<>("IsDaylightSavingTime", ExpectationMessage="be during daylight saving time")]
    public static class DateTimeAssertionExtensions
    {
        [.(ExpectationMessage="to be in the future")]
        public static bool IsInFuture(this  value) { }
        [.(ExpectationMessage="to be in the future (UTC)")]
        public static bool IsInFutureUtc(this  value) { }
        [.(ExpectationMessage="to be in the past")]
        public static bool IsInPast(this  value) { }
        [.(ExpectationMessage="to be in the past (UTC)")]
        public static bool IsInPastUtc(this  value) { }
        [.(ExpectationMessage="to be in a leap year")]
        public static bool IsLeapYear(this  value) { }
        [.(ExpectationMessage="to not be in a leap year")]
        public static bool IsNotLeapYear(this  value) { }
        [.(ExpectationMessage="to not be today")]
        public static bool IsNotToday(this  value) { }
        [.(ExpectationMessage="to not be UTC")]
        public static bool IsNotUtc(this  value) { }
        [.(ExpectationMessage="to be on a weekday")]
        public static bool IsOnWeekday(this  value) { }
        [.(ExpectationMessage="to be on a weekend")]
        public static bool IsOnWeekend(this  value) { }
        [.(ExpectationMessage="to be today")]
        public static bool IsToday(this  value) { }
        [.(ExpectationMessage="to be UTC")]
        public static bool IsUtc(this  value) { }
    }
    [.("IsEqualTo", OverloadResolutionPriority=2)]
    public class DateTimeEqualsAssertion : .<, >
    {
        public DateTimeEqualsAssertion(.<> context,  expected) { }
        protected override bool AreExactlyEqual( actual,  expected) { }
        protected override object CalculateDifference( actual,  expected) { }
        protected override string FormatDifferenceMessage( actual, object difference) { }
        protected override string GetExpectation() { }
        protected override bool HasToleranceValue() { }
        protected override bool IsWithinTolerance( actual,  expected,  tolerance) { }
    }
    [.("EqualsExact")]
    public class DateTimeEqualsExactAssertion : .<>
    {
        public DateTimeEqualsExactAssertion(.<> context,  expected) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public static class DateTimeOffsetAssertionExtensions
    {
        [.(ExpectationMessage="to be in the future")]
        public static bool IsInFuture(this  value) { }
        [.(ExpectationMessage="to be in the future (UTC)")]
        public static bool IsInFutureUtc(this  value) { }
        [.(ExpectationMessage="to be in the past")]
        public static bool IsInPast(this  value) { }
        [.(ExpectationMessage="to be in the past (UTC)")]
        public static bool IsInPastUtc(this  value) { }
        [.(ExpectationMessage="to be in a leap year")]
        public static bool IsLeapYear(this  value) { }
        [.(ExpectationMessage="to not be in a leap year")]
        public static bool IsNotLeapYear(this  value) { }
        [.(ExpectationMessage="to not be today")]
        public static bool IsNotToday(this  value) { }
        [.(ExpectationMessage="to not be UTC")]
        public static bool IsNotUtc(this  value) { }
        [.(ExpectationMessage="to be on a weekday")]
        public static bool IsOnWeekday(this  value) { }
        [.(ExpectationMessage="to be on a weekend")]
        public static bool IsOnWeekend(this  value) { }
        [.(ExpectationMessage="to be today")]
        public static bool IsToday(this  value) { }
        [.(ExpectationMessage="to be UTC")]
        public static bool IsUtc(this  value) { }
    }
    [.("IsEqualTo", OverloadResolutionPriority=2)]
    public class DateTimeOffsetEqualsAssertion : .<, >
    {
        public DateTimeOffsetEqualsAssertion(.<> context,  expected) { }
        protected override bool AreExactlyEqual( actual,  expected) { }
        protected override object CalculateDifference( actual,  expected) { }
        protected override bool HasToleranceValue() { }
        protected override bool IsWithinTolerance( actual,  expected,  tolerance) { }
    }
    public static class DayOfWeekAssertionExtensions
    {
        [.(ExpectationMessage="to be Friday")]
        public static bool IsFriday(this  value) { }
        [.(ExpectationMessage="to be Monday")]
        public static bool IsMonday(this  value) { }
        [.(ExpectationMessage="to be a weekday")]
        public static bool IsWeekday(this  value) { }
        [.(ExpectationMessage="to be a weekend day")]
        public static bool IsWeekend(this  value) { }
    }
    [.("IsEqualTo", OverloadResolutionPriority=2)]
    public class DecimalEqualsAssertion : .<decimal, decimal>
    {
        public DecimalEqualsAssertion(.<decimal> context, decimal expected) { }
        protected override bool AreExactlyEqual(decimal actual, decimal expected) { }
        protected override object CalculateDifference(decimal actual, decimal expected) { }
        protected override bool HasToleranceValue() { }
        protected override bool IsWithinTolerance(decimal actual, decimal expected, decimal tolerance) { }
    }
    public class DictionaryContainsKeyAssertion<TDictionary, TKey, TValue> : .<TDictionary, TKey, TValue>
        where TDictionary : .<TKey, TValue>
    {
        public DictionaryContainsKeyAssertion(.<TDictionary> context, TKey expectedKey, .<TKey>? comparer = null) { }
        protected override .<.> CheckAsync(.<TDictionary> metadata) { }
        protected override string GetExpectation() { }
        public .<TDictionary, TKey, TValue> Using(.<TKey> comparer) { }
    }
    public class DictionaryDoesNotContainKeyAssertion<TDictionary, TKey, TValue> : .<TDictionary, TKey, TValue>
        where TDictionary : .<TKey, TValue>
    {
        public DictionaryDoesNotContainKeyAssertion(.<TDictionary> context, TKey expectedKey) { }
        protected override .<.> CheckAsync(.<TDictionary> metadata) { }
        protected override string GetExpectation() { }
    }
    [.("HasFiles")]
    public class DirectoryHasFilesAssertion : .<.DirectoryInfo>
    {
        public DirectoryHasFilesAssertion(.<.DirectoryInfo> context) { }
        protected override .<.> CheckAsync(.<.DirectoryInfo> metadata) { }
        protected override string GetExpectation() { }
    }
    [.("HasNoSubdirectories")]
    public class DirectoryHasNoSubdirectoriesAssertion : .<.DirectoryInfo>
    {
        public DirectoryHasNoSubdirectoriesAssertion(.<.DirectoryInfo> context) { }
        protected override .<.> CheckAsync(.<.DirectoryInfo> metadata) { }
        protected override string GetExpectation() { }
    }
    [.<.DirectoryInfo>("Exists", CustomName="DoesNotExist", ExpectationMessage="exist", NegateLogic=true)]
    [.<.DirectoryInfo>("Exists", ExpectationMessage="exist")]
    public static class DirectoryInfoAssertionExtensions
    {
        [.(ExpectationMessage="to be empty")]
        public static bool IsEmpty(this .DirectoryInfo value) { }
        [.(ExpectationMessage="to be hidden")]
        public static bool IsHidden(this .DirectoryInfo value) { }
        [.(ExpectationMessage="to not be empty")]
        public static bool IsNotEmpty(this .DirectoryInfo value) { }
        [.(ExpectationMessage="to not be hidden")]
        public static bool IsNotHidden(this .DirectoryInfo value) { }
        [.(ExpectationMessage="to not be a root directory")]
        public static bool IsNotRoot(this .DirectoryInfo value) { }
        [.(ExpectationMessage="to be a root directory")]
        public static bool IsRoot(this .DirectoryInfo value) { }
        [.(ExpectationMessage="to be a system directory")]
        public static bool IsSystemDirectory(this .DirectoryInfo value) { }
    }
    [.("IsEqualTo", OverloadResolutionPriority=2)]
    public class DoubleEqualsAssertion : .<double, double>
    {
        public DoubleEqualsAssertion(.<double> context, double expected) { }
        protected override bool AreExactlyEqual(double actual, double expected) { }
        protected override object CalculateDifference(double actual, double expected) { }
        protected override bool HasToleranceValue() { }
        protected override bool IsWithinTolerance(double actual, double expected, double tolerance) { }
    }
    [.<.Encoding>("IsSingleByte", CustomName="IsNotSingleByte", ExpectationMessage="be single-byte encoding", NegateLogic=true)]
    [.<.Encoding>("IsSingleByte", ExpectationMessage="be single-byte encoding")]
    public static class EncodingAssertionExtensions
    {
        [.(ExpectationMessage="to be ASCII encoding")]
        public static bool IsASCII(this .Encoding value) { }
        [.(ExpectationMessage="to be big-endian Unicode encoding")]
        public static bool IsBigEndianUnicode(this .Encoding value) { }
        [.(ExpectationMessage="to not be UTF-8 encoding")]
        public static bool IsNotUTF8(this .Encoding value) { }
        [.(ExpectationMessage="to be UTF-32 encoding")]
        public static bool IsUTF32(this .Encoding value) { }
        [.(ExpectationMessage="to be UTF-8 encoding")]
        public static bool IsUTF8(this .Encoding value) { }
        [.(ExpectationMessage="to be Unicode encoding")]
        public static bool IsUnicode(this .Encoding value) { }
    }
    [.("IsEqualTo")]
    public class EqualsAssertion<TValue> : .<TValue>
    {
        public EqualsAssertion(.<TValue> context, TValue? expected) { }
        public EqualsAssertion(.<TValue> context, TValue? expected, .<TValue> comparer) { }
        public TValue Expected { get; }
        protected override .<.> CheckAsync(.<TValue> metadata) { }
        protected override string GetExpectation() { }
        public .<TValue> IgnoringType( type) { }
        public .<TValue> IgnoringType<TIgnore>() { }
    }
    [.("IsEquatableTo")]
    public class EquatableAssertion<TActual, TExpected> : .<TActual>
        where TActual : <TExpected>
    {
        public EquatableAssertion(.<TActual> context, TExpected expected) { }
        protected override .<.> CheckAsync(.<TActual> metadata) { }
        protected override string GetExpectation() { }
    }
    public static class ExceptionAssertionExtensions
    {
        [.(ExpectationMessage="to have a help link")]
        public static bool HasHelpLink(this  value) { }
        [.(ExpectationMessage="to have an inner exception")]
        public static bool HasInnerException(this  value) { }
        [.(ExpectationMessage="to have no data")]
        public static bool HasNoData(this  value) { }
        [.(ExpectationMessage="to have no help link")]
        public static bool HasNoHelpLink(this  value) { }
        [.(ExpectationMessage="to have no inner exception")]
        public static bool HasNoInnerException(this  value) { }
        [.(ExpectationMessage="to have no source")]
        public static bool HasNoSource(this  value) { }
        [.("Trimming", "IL2026", Justification="TargetSite is used for assertion purposes only, not for reflection-based operatio" +
            "ns")]
        [.(ExpectationMessage="to have no target site")]
        public static bool HasNoTargetSite(this  value) { }
        [.(ExpectationMessage="to have a source")]
        public static bool HasSource(this  value) { }
        [.(ExpectationMessage="to have a stack trace")]
        public static bool HasStackTrace(this  value) { }
        [.("Trimming", "IL2026", Justification="TargetSite is used for assertion purposes only, not for reflection-based operatio" +
            "ns")]
        [.(ExpectationMessage="to have a target site")]
        public static bool HasTargetSite(this  value) { }
    }
    public class ExceptionMessageContainsAssertion<TException> : .<TException>
        where TException : 
    {
        public ExceptionMessageContainsAssertion(.<TException> context, string expectedSubstring,  comparison = 4) { }
        protected override .<.> CheckAsync(.<TException> metadata) { }
        protected override string GetExpectation() { }
    }
    public class ExceptionMessageEqualsAssertion<TException> : .<TException>
        where TException : 
    {
        public ExceptionMessageEqualsAssertion(.<TException> context, string expectedMessage,  comparison = 4) { }
        protected override .<.> CheckAsync(.<TException> metadata) { }
        protected override string GetExpectation() { }
    }
    public class ExceptionMessageMatchesAssertion<TException> : .<TException>
        where TException : 
    {
        public ExceptionMessageMatchesAssertion(.<TException> context, .StringMatcher matcher) { }
        protected override .<.> CheckAsync(.<TException> metadata) { }
        protected override string GetExpectation() { }
    }
    public class ExceptionMessageMatchesPatternAssertion<TException> : .<TException>
        where TException : 
    {
        public ExceptionMessageMatchesPatternAssertion(.<TException> context, string pattern) { }
        protected override .<.> CheckAsync(.<TException> metadata) { }
        protected override string GetExpectation() { }
    }
    public class ExceptionMessageNotContainsAssertion<TException> : .<TException>
        where TException : 
    {
        public ExceptionMessageNotContainsAssertion(.<TException> context, string notExpectedSubstring,  comparison = 4) { }
        protected override .<.> CheckAsync(.<TException> metadata) { }
        protected override string GetExpectation() { }
    }
    public class ExceptionParameterNameAssertion<TException> : .<TException>
        where TException : 
    {
        public ExceptionParameterNameAssertion(.<TException> context, string expectedParameterName) { }
        protected override .<.> CheckAsync(.<TException> metadata) { }
        protected override string GetExpectation() { }
    }
    [.<.FileInfo>("Exists", CustomName="DoesNotExist", ExpectationMessage="exist", NegateLogic=true)]
    [.<.FileInfo>("Exists", ExpectationMessage="exist")]
    [.<.FileInfo>("IsReadOnly", CustomName="IsNotReadOnly", ExpectationMessage="be read-only", NegateLogic=true)]
    [.<.FileInfo>("IsReadOnly", ExpectationMessage="be read-only")]
    public static class FileInfoAssertionExtensions
    {
        [.(ExpectationMessage="to have an extension")]
        public static bool HasExtension(this .FileInfo value) { }
        [.(ExpectationMessage="to not have an extension")]
        public static bool HasNoExtension(this .FileInfo value) { }
        [.(ExpectationMessage="to be archived")]
        public static bool IsArchived(this .FileInfo value) { }
        [.(ExpectationMessage="to be empty")]
        public static bool IsEmpty(this .FileInfo value) { }
        [.(ExpectationMessage="to be hidden")]
        public static bool IsHidden(this .FileInfo value) { }
        [.(ExpectationMessage="to not be empty")]
        public static bool IsNotEmpty(this .FileInfo value) { }
        [.(ExpectationMessage="to not be hidden")]
        public static bool IsNotHidden(this .FileInfo value) { }
        [.(ExpectationMessage="to be a system file")]
        public static bool IsSystemFile(this .FileInfo value) { }
    }
    [.("IsNotExecutable")]
    public class FileIsNotExecutableAssertion : .<.FileInfo>
    {
        public FileIsNotExecutableAssertion(.<.FileInfo> context) { }
        protected override .<.> CheckAsync(.<.FileInfo> metadata) { }
        protected override string GetExpectation() { }
    }
    [.("IsNotSystem")]
    public class FileIsNotSystemAssertion : .<.FileInfo>
    {
        public FileIsNotSystemAssertion(.<.FileInfo> context) { }
        protected override .<.> CheckAsync(.<.FileInfo> metadata) { }
        protected override string GetExpectation() { }
    }
    [.("IsEqualTo", OverloadResolutionPriority=2)]
    public class FloatEqualsAssertion : .<float, float>
    {
        public FloatEqualsAssertion(.<float> context, float expected) { }
        protected override bool AreExactlyEqual(float actual, float expected) { }
        protected override object CalculateDifference(float actual, float expected) { }
        protected override bool HasToleranceValue() { }
        protected override bool IsWithinTolerance(float actual, float expected, float tolerance) { }
    }
    [.("IsGreaterThan")]
    public class GreaterThanAssertion<TValue> : .<TValue>
        where TValue : <TValue>
    {
        public GreaterThanAssertion(.<TValue> context, TValue minimum) { }
        protected override .<.> CheckAsync(.<TValue> metadata) { }
        protected override string GetExpectation() { }
    }
    [.("IsGreaterThanOrEqualTo")]
    public class GreaterThanOrEqualAssertion<TValue> : .<TValue>
        where TValue : <TValue>
    {
        public GreaterThanOrEqualAssertion(.<TValue> context, TValue minimum) { }
        protected override .<.> CheckAsync(.<TValue> metadata) { }
        protected override string GetExpectation() { }
    }
    public static class GuidAssertionExtensions
    {
        [.(ExpectationMessage="to be an empty GUID")]
        public static bool IsEmptyGuid(this  value) { }
        [.(ExpectationMessage="to not be an empty GUID")]
        public static bool IsNotEmptyGuid(this  value) { }
    }
    public class HasDistinctItemsAssertion<TCollection, TItem> : .<TCollection, TItem>
        where TCollection : .<TItem>
    {
        public HasDistinctItemsAssertion(.<TCollection> context) { }
        protected override .<.> CheckAsync(.<TCollection> metadata) { }
        protected override string GetExpectation() { }
    }
    public class HasMessageContainingAssertion<TValue> : .<TValue>
    {
        public HasMessageContainingAssertion(.<TValue> context, string expectedSubstring,  comparison = 4) { }
        protected override .<.> CheckAsync(.<TValue> metadata) { }
        protected override string GetExpectation() { }
    }
    public class HasMessageEqualToAssertion<TValue> : .<TValue>
    {
        public HasMessageEqualToAssertion(.<TValue> context, string expectedMessage,  comparison = 4) { }
        protected override .<.> CheckAsync(.<TValue> metadata) { }
        protected override string GetExpectation() { }
    }
    public class HasMessageStartingWithAssertion<TValue> : .<TValue>
    {
        public HasMessageStartingWithAssertion(.<TValue> context, string expectedPrefix,  comparison = 4) { }
        protected override .<.> CheckAsync(.<TValue> metadata) { }
        protected override string GetExpectation() { }
    }
    [.("HasSingleItem")]
    public class HasSingleItemAssertion<TCollection, TItem> : .<TCollection, TItem>
        where TCollection : .<TItem>
    {
        public HasSingleItemAssertion(.<TCollection> context) { }
        protected override .<.> CheckAsync(.<TCollection> metadata) { }
        public .<TItem> GetAwaiter() { }
        protected override string GetExpectation() { }
    }
    public static class HttpStatusCodeAssertionExtensions
    {
        [.(ExpectationMessage="to be a client error status code (4xx)")]
        public static bool IsClientError(this .HttpStatusCode value) { }
        [.(ExpectationMessage="to be an error status code (4xx or 5xx)")]
        public static bool IsError(this .HttpStatusCode value) { }
        [.(ExpectationMessage="to be an informational status code (1xx)")]
        public static bool IsInformational(this .HttpStatusCode value) { }
        [.(ExpectationMessage="to not be a success status code")]
        public static bool IsNotSuccess(this .HttpStatusCode value) { }
        [.(ExpectationMessage="to be a redirection status code (3xx)")]
        public static bool IsRedirection(this .HttpStatusCode value) { }
        [.(ExpectationMessage="to be a server error status code (5xx)")]
        public static bool IsServerError(this .HttpStatusCode value) { }
        [.(ExpectationMessage="to be a success status code (2xx)")]
        public static bool IsSuccess(this .HttpStatusCode value) { }
    }
    [.<.IPAddress>("IsIPv4MappedToIPv6", CustomName="IsNotIPv4MappedToIPv6", ExpectationMessage="be an IPv4-mapped IPv6 address", NegateLogic=true)]
    [.<.IPAddress>("IsIPv4MappedToIPv6", ExpectationMessage="be an IPv4-mapped IPv6 address")]
    [.<.IPAddress>("IsIPv6LinkLocal", CustomName="IsNotIPv6LinkLocal", ExpectationMessage="be an IPv6 link-local address", NegateLogic=true)]
    [.<.IPAddress>("IsIPv6LinkLocal", ExpectationMessage="be an IPv6 link-local address")]
    [.<.IPAddress>("IsIPv6Multicast", CustomName="IsNotIPv6Multicast", ExpectationMessage="be an IPv6 multicast address", NegateLogic=true)]
    [.<.IPAddress>("IsIPv6Multicast", ExpectationMessage="be an IPv6 multicast address")]
    [.<.IPAddress>("IsIPv6SiteLocal", CustomName="IsNotIPv6SiteLocal", ExpectationMessage="be an IPv6 site-local address", NegateLogic=true)]
    [.<.IPAddress>("IsIPv6SiteLocal", ExpectationMessage="be an IPv6 site-local address")]
    [.<.IPAddress>("IsIPv6Teredo", CustomName="IsNotIPv6Teredo", ExpectationMessage="be an IPv6 Teredo address", NegateLogic=true)]
    [.<.IPAddress>("IsIPv6Teredo", ExpectationMessage="be an IPv6 Teredo address")]
    public static class IPAddressAssertionExtensions { }
    [.<>("IsFromEnd", CustomName="IsNotFromEnd", ExpectationMessage="be from the end", NegateLogic=true)]
    [.<>("IsFromEnd", ExpectationMessage="be from the end")]
    public static class IndexAssertionExtensions { }
    [.("IsEqualTo", OverloadResolutionPriority=2)]
    public class IntEqualsAssertion : .<int>
    {
        public IntEqualsAssertion(.<int> context, int expected) { }
        protected override .<.> CheckAsync(.<int> metadata) { }
        protected override string GetExpectation() { }
        public . Within(int tolerance) { }
    }
    [.("IsAssignableTo")]
    public class IsAssignableToAssertion<TTarget, TValue> : .<TValue>
    {
        public IsAssignableToAssertion(.<TValue> context) { }
        protected override .<.> CheckAsync(.<TValue> metadata) { }
        protected override string GetExpectation() { }
    }
    [.("IsDefault")]
    public class IsDefaultAssertion<TValue> : .<TValue>
        where TValue :  struct
    {
        public IsDefaultAssertion(.<TValue> context) { }
        protected override .<.> CheckAsync(.<TValue> metadata) { }
        protected override string GetExpectation() { }
    }
    [.("IsDefault")]
    public class IsDefaultNullableAssertion<TValue> : .<TValue?>
        where TValue :  struct
    {
        public IsDefaultNullableAssertion(.<TValue?> context) { }
        protected override .<.> CheckAsync(.<TValue?> metadata) { }
        protected override string GetExpectation() { }
    }
    [.("IsDefault")]
    public class IsDefaultReferenceAssertion<TValue> : .<TValue>
        where TValue :  class
    {
        public IsDefaultReferenceAssertion(.<TValue> context) { }
        protected override .<.> CheckAsync(.<TValue> metadata) { }
        protected override string GetExpectation() { }
    }
    [.("IsEquatableOrEqualTo")]
    public class IsEquatableOrEqualToAssertion<TValue> : .<TValue, TValue>
    {
        public IsEquatableOrEqualToAssertion(.<TValue> context, TValue expected) { }
        protected override .<.> CheckAsync(.<TValue> metadata) { }
        protected override string GetExpectation() { }
        public .<TValue> Using(.<TValue> comparer) { }
    }
    [.("Collection equivalency uses structural comparison for complex objects, which requ" +
        "ires reflection and is not compatible with AOT")]
    [.("IsEquivalentTo")]
    public class IsEquivalentToAssertion<TCollection, TItem> : .<TCollection, TItem>
        where TCollection : .<TItem>
    {
        public IsEquivalentToAssertion(.<TCollection> context, .<TItem> expected, . ordering = 0) { }
        public IsEquivalentToAssertion(.<TCollection> context, .<TItem> expected, .<TItem> comparer, . ordering = 0) { }
        [.("AOT", "IL3050", Justification="Collection equivalency uses structural comparison which requires reflection")]
        protected override .<.> CheckAsync(.<TCollection> metadata) { }
        protected override string GetExpectation() { }
        public .<TCollection, TItem> Using(.<TItem> comparer) { }
    }
    [.("IsIn")]
    public class IsInAssertion<TValue> : .<TValue, TValue>
    {
        public IsInAssertion(.<TValue> context, .<TValue> collection) { }
        protected override .<.> CheckAsync(.<TValue> metadata) { }
        protected override string GetExpectation() { }
        public .<TValue> Using(.<TValue> comparer) { }
    }
    [.("IsNotAssignableTo")]
    public class IsNotAssignableToAssertion<TTarget, TValue> : .<TValue>
    {
        public IsNotAssignableToAssertion(.<TValue> context) { }
        protected override .<.> CheckAsync(.<TValue> metadata) { }
        protected override string GetExpectation() { }
    }
    [.("IsNotDefault")]
    public class IsNotDefaultAssertion<TValue> : .<TValue>
        where TValue :  struct
    {
        public IsNotDefaultAssertion(.<TValue> context) { }
        protected override .<.> CheckAsync(.<TValue> metadata) { }
        protected override string GetExpectation() { }
    }
    [.("IsNotDefault")]
    public class IsNotDefaultNullableAssertion<TValue> : .<TValue?>
        where TValue :  struct
    {
        public IsNotDefaultNullableAssertion(.<TValue?> context) { }
        protected override .<.> CheckAsync(.<TValue?> metadata) { }
        protected override string GetExpectation() { }
    }
    [.("IsNotDefault")]
    public class IsNotDefaultReferenceAssertion<TValue> : .<TValue>
        where TValue :  class
    {
        public IsNotDefaultReferenceAssertion(.<TValue> context) { }
        protected override .<.> CheckAsync(.<TValue> metadata) { }
        protected override string GetExpectation() { }
    }
    [.("IsNotIn")]
    public class IsNotInAssertion<TValue> : .<TValue, TValue>
    {
        public IsNotInAssertion(.<TValue> context, .<TValue> collection) { }
        protected override .<.> CheckAsync(.<TValue> metadata) { }
        protected override string GetExpectation() { }
        public .<TValue> Using(.<TValue> comparer) { }
    }
    public class IsTypeOfRuntimeAssertion<TValue> : .<TValue>
    {
        public IsTypeOfRuntimeAssertion(.<TValue> context,  expectedType) { }
        protected override .<.> CheckAsync(.<TValue> metadata) { }
        protected override string GetExpectation() { }
    }
    public static class LazyAssertionExtensions
    {
        [.("Trimming", "IL2091", Justification="Only checking IsValueCreated property, not creating instances")]
        [.(ExpectationMessage="to have its value created")]
        public static bool IsValueCreated<T>(this <T> value) { }
        [.("Trimming", "IL2091", Justification="Only checking IsValueCreated property, not creating instances")]
        [.(ExpectationMessage="to not have its value created")]
        public static bool IsValueNotCreated<T>(this <T> value) { }
    }
    [.("IsLessThan")]
    public class LessThanAssertion<TValue> : .<TValue>
        where TValue : <TValue>
    {
        public LessThanAssertion(.<TValue> context, TValue maximum) { }
        protected override .<.> CheckAsync(.<TValue> metadata) { }
        protected override string GetExpectation() { }
    }
    [.("IsLessThanOrEqualTo")]
    public class LessThanOrEqualAssertion<TValue> : .<TValue>
        where TValue : <TValue>
    {
        public LessThanOrEqualAssertion(.<TValue> context, TValue maximum) { }
        protected override .<.> CheckAsync(.<TValue> metadata) { }
        protected override string GetExpectation() { }
    }
    [.("IsEqualTo", OverloadResolutionPriority=2)]
    public class LongEqualsAssertion : .<long, long>
    {
        public LongEqualsAssertion(.<long> context, long expected) { }
        protected override bool AreExactlyEqual(long actual, long expected) { }
        protected override object CalculateDifference(long actual, long expected) { }
        protected override bool HasToleranceValue() { }
        protected override bool IsWithinTolerance(long actual, long expected, long tolerance) { }
    }
    public class MappedSatisfiesAssertion<TValue, TMapped> : .<TValue>
    {
        public MappedSatisfiesAssertion(.<TValue> context, <TValue?, TMapped> selector, <.<TMapped>, .<TMapped>?> assertions, string selectorDescription) { }
        protected override .<.> CheckAsync(.<TValue> metadata) { }
        protected override string GetExpectation() { }
    }
    public class MemberAssertionResult<TObject>
    {
        public .<TObject> And { get; }
        public .<TObject> Or { get; }
        public .<TObject?> GetAwaiter() { }
        public static .<TObject> op_Implicit(.<TObject> result) { }
    }
    [.("IsNotEqualTo")]
    public class NotEqualsAssertion<TValue> : .<TValue>
    {
        public NotEqualsAssertion(.<TValue> context, TValue notExpected, .<TValue>? comparer = null) { }
        protected override .<.> CheckAsync(.<TValue> metadata) { }
        protected override string GetExpectation() { }
        public .<TValue> IgnoringType( type) { }
        public .<TValue> IgnoringType<TIgnore>() { }
    }
    [.("Collection equivalency uses structural comparison for complex objects, which requ" +
        "ires reflection and is not compatible with AOT")]
    [.("IsNotEquivalentTo")]
    public class NotEquivalentToAssertion<TCollection, TItem> : .<TCollection, TItem>
        where TCollection : .<TItem>
    {
        public NotEquivalentToAssertion(.<TCollection> context, .<TItem> notExpected, . ordering = 0) { }
        [.("AOT", "IL3050", Justification="Collection equivalency uses structural comparison which requires reflection")]
        protected override .<.> CheckAsync(.<TCollection> metadata) { }
        protected override string GetExpectation() { }
        public .<TCollection, TItem> Using(.<TItem> comparer) { }
    }
    public class NotNullAssertion<TValue> : .<TValue>
    {
        public NotNullAssertion(.<TValue> context) { }
        protected override .<.> CheckAsync(.<TValue> metadata) { }
        public new .<TValue> GetAwaiter() { }
        protected override string GetExpectation() { }
    }
    [.("IsNotSameReferenceAs")]
    public class NotSameReferenceAssertion<TValue> : .<TValue>
    {
        public NotSameReferenceAssertion(.<TValue> context, object? expected) { }
        protected override .<.> CheckAsync(.<TValue> metadata) { }
        protected override string GetExpectation() { }
    }
    public class NotStructuralEquivalencyAssertion<TValue> : .<TValue>
    {
        public NotStructuralEquivalencyAssertion(.<TValue> context, object? notExpected, string? notExpectedExpression = null) { }
        protected override .<.> CheckAsync(.<TValue> metadata) { }
        protected override string GetExpectation() { }
        public .<TValue> IgnoringMember(string memberPath) { }
        public .<TValue> IgnoringType( type) { }
        public .<TValue> IgnoringType<T>() { }
        public .<TValue> WithPartialEquivalency() { }
    }
    [.("IsNull")]
    public class NullAssertion<TValue> : .<TValue>
    {
        public NullAssertion(.<TValue> context) { }
        protected override .<.> CheckAsync(.<TValue> metadata) { }
        protected override string GetExpectation() { }
    }
    [.("IsEquatableTo")]
    public class NullableEquatableAssertion<TActual, TExpected> : .<TActual?>
        where TActual :  struct, <TExpected>
    {
        public NullableEquatableAssertion(.<TActual?> context, TExpected expected) { }
        protected override .<.> CheckAsync(.<TActual?> metadata) { }
        protected override string GetExpectation() { }
    }
    [.<.Process>("EnableRaisingEvents", CustomName="DoesNotHaveEventRaisingEnabled", ExpectationMessage="have event raising enabled", NegateLogic=true)]
    [.<.Process>("EnableRaisingEvents", ExpectationMessage="have event raising enabled")]
    [.<.Process>("HasExited", CustomName="HasNotExited", ExpectationMessage="have exited", NegateLogic=true)]
    [.<.Process>("HasExited", ExpectationMessage="have exited")]
    [.<.Process>("Responding", CustomName="IsNotResponding", ExpectationMessage="be responding", NegateLogic=true)]
    [.<.Process>("Responding", ExpectationMessage="be responding")]
    public static class ProcessAssertionExtensions { }
    public static class RangeAssertionExtensions
    {
        [.(ExpectationMessage="to have both indices from the end")]
        public static bool HasBothIndicesFromEnd(this  value) { }
        [.(ExpectationMessage="to have end index from beginning")]
        public static bool HasEndFromBeginning(this  value) { }
        [.(ExpectationMessage="to have start index from beginning")]
        public static bool HasStartFromBeginning(this  value) { }
        [.(ExpectationMessage="to be the all range")]
        public static bool IsAll(this  value) { }
    }
    [.("IsSameReferenceAs")]
    public class SameReferenceAssertion<TValue> : .<TValue>
    {
        public SameReferenceAssertion(.<TValue> context, object? expected) { }
        protected override .<.> CheckAsync(.<TValue> metadata) { }
        protected override string GetExpectation() { }
    }
    public class SatisfiesAssertion<TValue> : .<TValue>
    {
        public SatisfiesAssertion(.<TValue> context, <TValue?, bool> predicate, string predicateDescription) { }
        protected override .<.> CheckAsync(.<TValue> metadata) { }
        protected override string GetExpectation() { }
    }
    [.<.Stream>("CanRead", CustomName="CannotRead", ExpectationMessage="be readable", NegateLogic=true)]
    [.<.Stream>("CanRead", ExpectationMessage="be readable")]
    [.<.Stream>("CanSeek", CustomName="CannotSeek", ExpectationMessage="be seekable", NegateLogic=true)]
    [.<.Stream>("CanSeek", ExpectationMessage="be seekable")]
    [.<.Stream>("CanTimeout", CustomName="CannotTimeout", ExpectationMessage="support timeout", NegateLogic=true)]
    [.<.Stream>("CanTimeout", ExpectationMessage="support timeout")]
    [.<.Stream>("CanWrite", CustomName="CannotWrite", ExpectationMessage="be writable", NegateLogic=true)]
    [.<.Stream>("CanWrite", ExpectationMessage="be writable")]
    public static class StreamAssertionExtensions
    {
        [.(ExpectationMessage="to be at the end")]
        public static bool IsAtEnd(this .Stream value) { }
        [.(ExpectationMessage="to be at the start")]
        public static bool IsAtStart(this .Stream value) { }
        [.(ExpectationMessage="to be empty")]
        public static bool IsEmpty(this .Stream value) { }
        [.(ExpectationMessage="to not be empty")]
        public static bool IsNotEmpty(this .Stream value) { }
    }
    public static class StringBuilderAssertionExtensions
    {
        [.(ExpectationMessage="to have excess capacity")]
        public static bool HasExcessCapacity(this .StringBuilder value) { }
        [.(ExpectationMessage="to be empty")]
        public static bool IsEmpty(this .StringBuilder value) { }
        [.(ExpectationMessage="to not be empty")]
        public static bool IsNotEmpty(this .StringBuilder value) { }
    }
    [.("Contains")]
    public class StringContainsAssertion : .<string>
    {
        public StringContainsAssertion(.<string> context, string expected) { }
        public StringContainsAssertion(.<string> context, string expected,  comparison) { }
        protected override .<.> CheckAsync(.<string> metadata) { }
        protected override string GetExpectation() { }
        public . IgnoringCase() { }
        public . IgnoringWhitespace() { }
        public . WithComparison( comparison) { }
        public . WithTrimming() { }
    }
    [.("DoesNotContain")]
    public class StringDoesNotContainAssertion : .<string>
    {
        public StringDoesNotContainAssertion(.<string> context, string expected) { }
        public StringDoesNotContainAssertion(.<string> context, string expected,  comparison) { }
        protected override .<.> CheckAsync(.<string> metadata) { }
        protected override string GetExpectation() { }
        public . IgnoringCase() { }
        public . WithComparison( comparison) { }
    }
    [.("DoesNotMatch")]
    public class StringDoesNotMatchAssertion : .<string>
    {
        public StringDoesNotMatchAssertion(.<string> context, . regex) { }
        public StringDoesNotMatchAssertion(.<string> context, string pattern) { }
        protected override .<.> CheckAsync(.<string> metadata) { }
        protected override string GetExpectation() { }
        public . IgnoringCase() { }
        public . WithOptions(. options) { }
    }
    [.("EndsWith")]
    public class StringEndsWithAssertion : .<string>
    {
        public StringEndsWithAssertion(.<string> context, string expected) { }
        public StringEndsWithAssertion(.<string> context, string expected,  comparison) { }
        protected override .<.> CheckAsync(.<string> metadata) { }
        protected override string GetExpectation() { }
        public . IgnoringCase() { }
        public . WithComparison( comparison) { }
    }
    [.("IsEqualTo", OverloadResolutionPriority=2)]
    public class StringEqualsAssertion : .<string>
    {
        public StringEqualsAssertion(.<string> context, string? expected) { }
        protected override .<.> CheckAsync(.<string> metadata) { }
        protected override string GetExpectation() { }
        public . IgnoringCase() { }
        public . IgnoringWhitespace() { }
        public . WithComparison( comparison) { }
        public . WithNullAndEmptyEquality() { }
        public . WithTrimming() { }
    }
    [.("IsEmpty")]
    public class StringIsEmptyAssertion : .<string>
    {
        public StringIsEmptyAssertion(.<string> context) { }
        protected override .<.> CheckAsync(.<string> metadata) { }
        protected override string GetExpectation() { }
    }
    [.("IsNotEmpty")]
    public class StringIsNotEmptyAssertion : .<string>
    {
        public StringIsNotEmptyAssertion(.<string> context) { }
        protected override .<.> CheckAsync(.<string> metadata) { }
        protected override string GetExpectation() { }
    }
    public class StringLengthAssertion : .<string>
    {
        public StringLengthAssertion(.<string> context, int expectedLength) { }
        protected override .<.> CheckAsync(.<string> metadata) { }
        protected override string GetExpectation() { }
    }
    [.("Matches")]
    public class StringMatchesAssertion : .<string>
    {
        public StringMatchesAssertion(.<string> context, . regex) { }
        public StringMatchesAssertion(.<string> context, string pattern) { }
        protected override .<.> CheckAsync(.<string> metadata) { }
        protected override string GetExpectation() { }
        public . IgnoringCase() { }
        public . WithOptions(. options) { }
    }
    [.("StartsWith")]
    public class StringStartsWithAssertion : .<string>
    {
        public StringStartsWithAssertion(.<string> context, string expected) { }
        public StringStartsWithAssertion(.<string> context, string expected,  comparison) { }
        protected override .<.> CheckAsync(.<string> metadata) { }
        protected override string GetExpectation() { }
        public . IgnoringCase() { }
        public . WithComparison( comparison) { }
    }
    [.<string>("IsNullOrEmpty", CustomName="IsNotNullOrEmpty", ExpectationMessage="be null or empty", NegateLogic=true)]
    [.<string>("IsNullOrEmpty", ExpectationMessage="be null or empty")]
    [.<string>("IsNullOrWhiteSpace", CustomName="IsNotNullOrWhiteSpace", ExpectationMessage="be null, empty, or whitespace", NegateLogic=true)]
    [.<string>("IsNullOrWhiteSpace", ExpectationMessage="be null, empty, or whitespace")]
    public static class StringStaticMethodAssertions { }
    public class StructuralEquivalencyAssertion<TValue> : .<TValue>
    {
        public StructuralEquivalencyAssertion(.<TValue> context, object? expected, string? expectedExpression = null) { }
        protected override .<.> CheckAsync(.<TValue> metadata) { }
        protected override string GetExpectation() { }
        public .<TValue> IgnoringMember(string memberPath) { }
        public .<TValue> IgnoringType( type) { }
        public .<TValue> IgnoringType<T>() { }
        public .<TValue> WithPartialEquivalency() { }
    }
    [.<.>("IsCanceled", CustomName="IsNotCanceled", ExpectationMessage="be canceled", NegateLogic=true)]
    [.<.>("IsCanceled", ExpectationMessage="be canceled")]
    [.<.>("IsCompleted", CustomName="IsNotCompleted", ExpectationMessage="be completed", NegateLogic=true)]
    [.<.>("IsCompleted", ExpectationMessage="be completed")]
    [.<.>("IsCompletedSuccessfully", CustomName="IsNotCompletedSuccessfully", ExpectationMessage="be completed successfully", NegateLogic=true)]
    [.<.>("IsCompletedSuccessfully", ExpectationMessage="be completed successfully")]
    [.<.>("IsFaulted", CustomName="IsNotFaulted", ExpectationMessage="be faulted", NegateLogic=true)]
    [.<.>("IsFaulted", ExpectationMessage="be faulted")]
    public static class TaskAssertionExtensions { }
    [.<.Thread>("IsAlive", CustomName="IsNotAlive", ExpectationMessage="be alive", NegateLogic=true)]
    [.<.Thread>("IsAlive", ExpectationMessage="be alive")]
    [.<.Thread>("IsBackground", CustomName="IsNotBackground", ExpectationMessage="be a background thread", NegateLogic=true)]
    [.<.Thread>("IsBackground", ExpectationMessage="be a background thread")]
    [.<.Thread>("IsThreadPoolThread", CustomName="IsNotThreadPoolThread", ExpectationMessage="be a thread pool thread", NegateLogic=true)]
    [.<.Thread>("IsThreadPoolThread", ExpectationMessage="be a thread pool thread")]
    public static class ThreadAssertionExtensions { }
    public class ThrowsAssertion<TException> : .<TException, .<TException>>
        where TException : 
    {
        public ThrowsAssertion(.<TException> context) { }
        protected override bool IsExactTypeMatch { get; }
        protected override bool CheckExceptionType( actualException, out string? errorMessage) { }
        public .<> WithInnerException() { }
        public .<TException> WithMessage(string expectedMessage) { }
        public .<TException> WithMessage(string expectedMessage,  comparison) { }
        public .<TException> WithMessageContaining(string expectedSubstring) { }
        public .<TException> WithMessageContaining(string expectedSubstring,  comparison) { }
        public .<TException> WithMessageMatching(.StringMatcher matcher) { }
        public .<TException> WithMessageMatching(string pattern) { }
        public .<TException> WithMessageNotContaining(string notExpectedSubstring) { }
        public .<TException> WithMessageNotContaining(string notExpectedSubstring,  comparison) { }
        public .<TException> WithParameterName(string expectedParameterName) { }
    }
    public class ThrowsExactlyAssertion<TException> : .<TException, .<TException>>
        where TException : 
    {
        public ThrowsExactlyAssertion(.<TException> context) { }
        protected override bool IsExactTypeMatch { get; }
        protected override bool CheckExceptionType( actualException, out string? errorMessage) { }
        public .<TException> WithMessage(string expectedMessage) { }
        public .<TException> WithMessage(string expectedMessage,  comparison) { }
        public .<TException> WithMessageContaining(string expectedSubstring) { }
        public .<TException> WithMessageContaining(string expectedSubstring,  comparison) { }
        public .<TException> WithMessageMatching(.StringMatcher matcher) { }
        public .<TException> WithMessageMatching(string pattern) { }
        public .<TException> WithMessageNotContaining(string notExpectedSubstring) { }
        public .<TException> WithMessageNotContaining(string notExpectedSubstring,  comparison) { }
        public .<TException> WithParameterName(string expectedParameterName) { }
    }
    public class ThrowsNothingAssertion<TValue> : .<TValue>
    {
        public ThrowsNothingAssertion(.<TValue> context) { }
        protected override .<.> CheckAsync(.<TValue> metadata) { }
        protected override string GetExpectation() { }
    }
    public static class TimeOnlyAssertionExtensions
    {
        [.(ExpectationMessage="to be in the AM")]
        public static bool IsAM(this  value) { }
        [.(ExpectationMessage="to be at the end of the hour")]
        public static bool IsEndOfHour(this  value) { }
        [.(ExpectationMessage="to be midnight")]
        public static bool IsMidnight(this  value) { }
        [.(ExpectationMessage="to be noon")]
        public static bool IsNoon(this  value) { }
        [.(ExpectationMessage="to not be midnight")]
        public static bool IsNotMidnight(this  value) { }
        [.(ExpectationMessage="to be in the PM")]
        public static bool IsPM(this  value) { }
        [.(ExpectationMessage="to be at the start of the hour")]
        public static bool IsStartOfHour(this  value) { }
    }
    [.("IsEqualTo", OverloadResolutionPriority=2)]
    public class TimeOnlyEqualsAssertion : .<, >
    {
        public TimeOnlyEqualsAssertion(.<> context,  expected) { }
        protected override bool AreExactlyEqual( actual,  expected) { }
        protected override object CalculateDifference( actual,  expected) { }
        protected override string FormatDifferenceMessage( actual, object difference) { }
        protected override bool HasToleranceValue() { }
        protected override bool IsWithinTolerance( actual,  expected,  tolerance) { }
    }
    public static class TimeSpanAssertionExtensions
    {
        [.(ExpectationMessage="to be negative")]
        public static bool IsNegative(this  value) { }
        [.(ExpectationMessage="to be non-negative")]
        public static bool IsNonNegative(this  value) { }
        [.(ExpectationMessage="to be non-positive")]
        public static bool IsNonPositive(this  value) { }
        [.(ExpectationMessage="to not be zero")]
        public static bool IsNotZero(this  value) { }
        [.(ExpectationMessage="to be positive")]
        public static bool IsPositive(this  value) { }
        [.(ExpectationMessage="to be zero")]
        public static bool IsZero(this  value) { }
    }
    [.("IsEqualTo", OverloadResolutionPriority=2)]
    public class TimeSpanEqualsAssertion : .<>
    {
        public TimeSpanEqualsAssertion(.<> context,  expected) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
        public . Within( tolerance) { }
    }
    [.<>("HasIanaId", CustomName="DoesNotHaveIanaId", ExpectationMessage="have an IANA ID", NegateLogic=true)]
    [.<>("HasIanaId", ExpectationMessage="have an IANA ID")]
    [.<>("SupportsDaylightSavingTime", CustomName="DoesNotSupportDaylightSavingTime", ExpectationMessage="support daylight saving time", NegateLogic=true)]
    [.<>("SupportsDaylightSavingTime", ExpectationMessage="support daylight saving time")]
    public static class TimeZoneInfoAssertionExtensions { }
    public abstract class ToleranceBasedEqualsAssertion<TValue, TTolerance> : .<TValue>
    {
        protected ToleranceBasedEqualsAssertion(.<TValue> context, TValue expected) { }
        protected abstract bool AreExactlyEqual(TValue actual, TValue expected);
        protected abstract object CalculateDifference(TValue actual, TValue expected);
        protected override .<.> CheckAsync(.<TValue> metadata) { }
        protected virtual string FormatDifferenceMessage(TValue actual, object difference) { }
        protected override string GetExpectation() { }
        protected abstract bool HasToleranceValue();
        protected abstract bool IsWithinTolerance(TValue actual, TValue expected, TTolerance tolerance);
        public .<TValue, TTolerance> Within(TTolerance tolerance) { }
    }
    [.<>("ContainsGenericParameters", CustomName="DoesNotContainGenericParameters", ExpectationMessage="contain generic parameters", NegateLogic=true)]
    [.<>("ContainsGenericParameters", ExpectationMessage="contain generic parameters")]
    [.<>("IsAbstract", CustomName="IsNotAbstract", ExpectationMessage="be abstract", NegateLogic=true)]
    [.<>("IsAbstract", ExpectationMessage="be abstract")]
    [.<>("IsArray", CustomName="IsNotArray", ExpectationMessage="be an array", NegateLogic=true)]
    [.<>("IsArray", ExpectationMessage="be an array")]
    [.<>("IsByRef", CustomName="IsNotByRef", ExpectationMessage="be a by-ref type", NegateLogic=true)]
    [.<>("IsByRef", ExpectationMessage="be a by-ref type")]
    [.<>("IsByRefLike", CustomName="IsNotByRefLike", ExpectationMessage="be a by-ref-like type", NegateLogic=true)]
    [.<>("IsByRefLike", ExpectationMessage="be a by-ref-like type")]
    [.<>("IsCOMObject", CustomName="IsNotCOMObject", ExpectationMessage="be a COM object", NegateLogic=true)]
    [.<>("IsCOMObject", ExpectationMessage="be a COM object")]
    [.<>("IsClass", CustomName="IsNotClass", ExpectationMessage="be a class", NegateLogic=true)]
    [.<>("IsClass", ExpectationMessage="be a class")]
    [.<>("IsConstructedGenericType", CustomName="IsNotConstructedGenericType", ExpectationMessage="be a constructed generic type", NegateLogic=true)]
    [.<>("IsConstructedGenericType", ExpectationMessage="be a constructed generic type")]
    [.<>("IsEnum", CustomName="IsNotEnum", ExpectationMessage="be an enum", NegateLogic=true)]
    [.<>("IsEnum", ExpectationMessage="be an enum")]
    [.<>("IsGenericType", CustomName="IsNotGenericType", ExpectationMessage="be a generic type", NegateLogic=true)]
    [.<>("IsGenericType", ExpectationMessage="be a generic type")]
    [.<>("IsGenericTypeDefinition", CustomName="IsNotGenericTypeDefinition", ExpectationMessage="be a generic type definition", NegateLogic=true)]
    [.<>("IsGenericTypeDefinition", ExpectationMessage="be a generic type definition")]
    [.<>("IsInterface", CustomName="IsNotInterface", ExpectationMessage="be an interface", NegateLogic=true)]
    [.<>("IsInterface", ExpectationMessage="be an interface")]
    [.<>("IsNested", CustomName="IsNotNested", ExpectationMessage="be a nested type", NegateLogic=true)]
    [.<>("IsNested", ExpectationMessage="be a nested type")]
    [.<>("IsNestedAssembly", CustomName="IsNotNestedAssembly", ExpectationMessage="be a nested assembly type", NegateLogic=true)]
    [.<>("IsNestedAssembly", ExpectationMessage="be a nested assembly type")]
    [.<>("IsNestedFamily", CustomName="IsNotNestedFamily", ExpectationMessage="be a nested family type", NegateLogic=true)]
    [.<>("IsNestedFamily", ExpectationMessage="be a nested family type")]
    [.<>("IsNestedPrivate", CustomName="IsNotNestedPrivate", ExpectationMessage="be a nested private type", NegateLogic=true)]
    [.<>("IsNestedPrivate", ExpectationMessage="be a nested private type")]
    [.<>("IsNestedPublic", CustomName="IsNotNestedPublic", ExpectationMessage="be a nested public type", NegateLogic=true)]
    [.<>("IsNestedPublic", ExpectationMessage="be a nested public type")]
    [.<>("IsPointer", CustomName="IsNotPointer", ExpectationMessage="be a pointer type", NegateLogic=true)]
    [.<>("IsPointer", ExpectationMessage="be a pointer type")]
    [.<>("IsPrimitive", CustomName="IsNotPrimitive", ExpectationMessage="be a primitive type", NegateLogic=true)]
    [.<>("IsPrimitive", ExpectationMessage="be a primitive type")]
    [.<>("IsPublic", CustomName="IsNotPublic", ExpectationMessage="be public", NegateLogic=true)]
    [.<>("IsPublic", ExpectationMessage="be public")]
    [.<>("IsSealed", CustomName="IsNotSealed", ExpectationMessage="be sealed", NegateLogic=true)]
    [.<>("IsSealed", ExpectationMessage="be sealed")]
    [.<>("IsValueType", CustomName="IsNotValueType", ExpectationMessage="be a value type", NegateLogic=true)]
    [.<>("IsValueType", ExpectationMessage="be a value type")]
    [.<>("IsVisible", CustomName="IsNotVisible", ExpectationMessage="be visible", NegateLogic=true)]
    [.<>("IsVisible", ExpectationMessage="be visible")]
    public static class TypeAssertionExtensions { }
    public class TypeOfAssertion<TFrom, TTo> : .<TTo>
    {
        public TypeOfAssertion(.<TFrom> parentContext) { }
        protected override .<.> CheckAsync(.<TTo> metadata) { }
        protected override string GetExpectation() { }
    }
    [.<>("IsAbsoluteUri", CustomName="IsNotAbsoluteUri", ExpectationMessage="be an absolute URI", NegateLogic=true)]
    [.<>("IsAbsoluteUri", ExpectationMessage="be an absolute URI")]
    [.<>("IsDefaultPort", CustomName="IsNotDefaultPort", ExpectationMessage="use the default port", NegateLogic=true)]
    [.<>("IsDefaultPort", ExpectationMessage="use the default port")]
    [.<>("IsFile", CustomName="IsNotFile", ExpectationMessage="be a file URI", NegateLogic=true)]
    [.<>("IsFile", ExpectationMessage="be a file URI")]
    [.<>("IsLoopback", CustomName="IsNotLoopback", ExpectationMessage="be a loopback URI", NegateLogic=true)]
    [.<>("IsLoopback", ExpectationMessage="be a loopback URI")]
    [.<>("IsUnc", CustomName="IsNotUnc", ExpectationMessage="be a UNC URI", NegateLogic=true)]
    [.<>("IsUnc", ExpectationMessage="be a UNC URI")]
    [.<>("UserEscaped", CustomName="IsNotUserEscaped", ExpectationMessage="be user-escaped", NegateLogic=true)]
    [.<>("UserEscaped", ExpectationMessage="be user-escaped")]
    public static class UriAssertionExtensions { }
    public static class VersionAssertionExtensions
    {
        [.(ExpectationMessage="to have a build number")]
        public static bool HasBuildNumber(this  value) { }
        [.(ExpectationMessage="to not have a build number")]
        public static bool HasNoBuildNumber(this  value) { }
        [.(ExpectationMessage="to not have a revision number")]
        public static bool HasNoRevisionNumber(this  value) { }
        [.(ExpectationMessage="to have a revision number")]
        public static bool HasRevisionNumber(this  value) { }
        [.(ExpectationMessage="to be a major version (x.0.0.0)")]
        public static bool IsMajorVersion(this  value) { }
        [.(ExpectationMessage="to not be a major version")]
        public static bool IsNotMajorVersion(this  value) { }
    }
    [.<>("IsAlive", CustomName="IsNotAlive", ExpectationMessage="be alive", NegateLogic=true)]
    [.<>("IsAlive", ExpectationMessage="be alive")]
    [.<>("TrackResurrection", CustomName="DoesNotTrackResurrection", ExpectationMessage="track resurrection", NegateLogic=true)]
    [.<>("TrackResurrection", ExpectationMessage="track resurrection")]
    public static class WeakReferenceAssertionExtensions { }
}
namespace .
{
    public sealed class ReferenceEqualityComparer<T> : .<T>
        where T :  class
    {
        public static readonly ..ReferenceEqualityComparer<T> Instance;
        public bool Equals(T? x, T? y) { }
        public int GetHashCode(T obj) { }
    }
    [.("Structural equality comparison uses reflection to access object members and is no" +
        "t compatible with AOT")]
    public sealed class StructuralEqualityComparer<T> : .<T>
    {
        public static readonly ..StructuralEqualityComparer<T> Instance;
        public bool Equals(T? x, T? y) { }
        public int GetHashCode(T obj) { }
    }
}
namespace .
{
    public class CountWrapper<TCollection, TItem> : ., .<TCollection>
        where TCollection : .<TItem>
    {
        public CountWrapper(.<TCollection> context) { }
        public .<int> Between(int minimum, int maximum, [.("minimum")] string? minExpression = null, [.("maximum")] string? maxExpression = null) { }
        public .<TCollection, TItem> EqualTo(int expectedCount, [.("expectedCount")] string? expression = null) { }
        public .<int> GreaterThan(int expected, [.("expected")] string? expression = null) { }
        public .<int> GreaterThanOrEqualTo(int expected, [.("expected")] string? expression = null) { }
        public .<int> LessThan(int expected, [.("expected")] string? expression = null) { }
        public .<int> LessThanOrEqualTo(int expected, [.("expected")] string? expression = null) { }
        public .<int> NotEqualTo(int expected, [.("expected")] string? expression = null) { }
        public .<int> Positive() { }
        public .<TCollection, TItem> Zero() { }
    }
    public class LengthWrapper : ., .<string>
    {
        public LengthWrapper(.<string> context) { }
        public . EqualTo(int expectedLength, [.("expectedLength")] string? expression = null) { }
    }
}
namespace .Core
{
    public class AndContinuation<TValue> : .<TValue> { }
    public sealed class AssertionContext<TValue>
    {
        public AssertionContext(.<TValue> evaluation, .StringBuilder expressionBuilder) { }
        public AssertionContext(TValue? value, .StringBuilder expressionBuilder) { }
        public .<TValue> Evaluation { get; }
        public .StringBuilder ExpressionBuilder { get; }
        [return: .(new string[] {
                "Value",
                "Exception"})]
        public .<<TValue?, ?>> GetAsync() { }
        [return: .(new string[] {
                "Start",
                "End"})]
        public <, > GetTiming() { }
        public .<TNew> Map<TNew>(<.<TValue>, .<TNew>> evaluationFactory) { }
        public .<TNew> Map<TNew>(<TValue?, TNew?> mapper) { }
        public .<.<TNew?>> MapAsync<TNew>(<TValue?, .<TNew?>> mapper) { }
        public .<TException> MapException<TException>()
            where TException :  { }
    }
    public readonly struct AssertionResult
    {
        public bool IsPassed { get; }
        public string Message { get; }
        public static . Passed { get; }
        public static . FailIf(bool condition, string message) { }
        public static . Failed(string message) { }
    }
    public abstract class Assertion<TValue>
    {
        protected readonly .<TValue> Context;
        protected Assertion(.<TValue> context) { }
        public .<TValue> And { get; }
        protected .<TValue>? InternalWrappedExecution { get; }
        public .<TValue> Or { get; }
        protected void AppendExpression(string expression) { }
        public virtual .<TValue?> AssertAsync() { }
        public .<TValue> Because(string message) { }
        protected virtual .<.> CheckAsync(.<TValue> metadata) { }
        protected  CreateException(. result) { }
        public .<TValue?> GetAwaiter() { }
        protected abstract string GetExpectation();
        protected void ThrowIfMixingCombiner<TCombinerToAvoid>()
            where TCombinerToAvoid : .<TValue> { }
    }
    public enum ChainType
    {
        None = 0,
        And = 1,
        Or = 2,
    }
    public class CollectionAndContinuation<TCollection, TItem> : .<TCollection, TItem>
        where TCollection : .<TItem> { }
    public class CollectionOrContinuation<TCollection, TItem> : .<TCollection, TItem>
        where TCollection : .<TItem> { }
    public class DictionaryAndContinuation<TDictionary, TKey, TValue> : .<TDictionary, TKey, TValue>
        where TDictionary : .<TKey, TValue> { }
    public class DictionaryOrContinuation<TDictionary, TKey, TValue> : .<TDictionary, TKey, TValue>
        where TDictionary : .<TKey, TValue> { }
    public sealed class EvaluationContext<TValue>
    {
        public EvaluationContext(<.<<TValue?, ?>>> evaluator) { }
        public EvaluationContext(TValue? value) { }
        [return: .(new string?[]?[] {
                "Value",
                "Exception"})]
        public .<<TValue?, ?>> GetAsync() { }
        [return: .(new string[] {
                "Start",
                "End"})]
        public <, > GetTiming() { }
        public .<TNew> Map<TNew>(<TValue?, TNew?> mapper) { }
        public .<TException> MapException<TException>()
            where TException :  { }
    }
    public readonly struct EvaluationMetadata<TValue>
    {
        public EvaluationMetadata(TValue? value, ? exception,  startTime,  endTime) { }
        public  Duration { get; }
        public  EndTime { get; }
        public ? Exception { get; }
        public  StartTime { get; }
        public TValue Value { get; }
    }
    public interface IAssertionSource { }
    public interface IAssertionSource<TValue> : .
    {
        .<TValue> Context { get; }
    }
    public interface IDelegateAssertionSource<TValue> : ., .<TValue> { }
    public class OrContinuation<TValue> : .<TValue> { }
}
namespace .Enums
{
    public enum CollectionOrdering
    {
        Any = 0,
        Matching = 1,
    }
}
namespace .Exceptions
{
    public class AssertionException : .
    {
        public AssertionException(string? message) { }
        public AssertionException(string? message,  innerException) { }
    }
    public class BaseAssertionException : 
    {
        public BaseAssertionException() { }
        public BaseAssertionException(string? message) { }
        public BaseAssertionException(string? message, ? innerException) { }
    }
    public class MaybeCaughtException : 
    {
        public MaybeCaughtException( exception) { }
    }
    public class MixedAndOrAssertionsException : .
    {
        public MixedAndOrAssertionsException() { }
    }
}
namespace .Extensions
{
    public static class ArrayAssertionExtensions
    {
        [.("Trimming", "IL2091", Justification="Generic type parameter is only used for property access, not instantiation")]
        public static .Extensions._IsEmpty_Assertion<T> IsEmpty<T>(this .<T[]> source) { }
        [.("Trimming", "IL2091", Justification="Generic type parameter is only used for property access, not instantiation")]
        public static .Extensions._IsNotEmpty_Assertion<T> IsNotEmpty<T>(this .<T[]> source) { }
        [.("Trimming", "IL2091", Justification="Generic type parameter is only used for property access, not instantiation")]
        public static ._IsNotSingleElement_Assertion<T> IsNotSingleElement<T>(this .<.<T>> source) { }
        [.("Trimming", "IL2091", Justification="Generic type parameter is only used for property access, not instantiation")]
        public static .Extensions._IsNotSingleElement_Assertion<T> IsNotSingleElement<T>(this .<T[]> source) { }
        [.("Trimming", "IL2091", Justification="Generic type parameter is only used for property access, not instantiation")]
        public static ._IsSingleElement_Assertion<T> IsSingleElement<T>(this .<.<T>> source) { }
        [.("Trimming", "IL2091", Justification="Generic type parameter is only used for property access, not instantiation")]
        public static .Extensions._IsSingleElement_Assertion<T> IsSingleElement<T>(this .<T[]> source) { }
    }
    public static class AssemblyAssertionExtensions
    {
        public static . IsCollectible(this .<.Assembly> source) { }
        public static ._IsDebugBuild_Assertion IsDebugBuild(this .<.Assembly> source) { }
        public static . IsDynamic(this .<.Assembly> source) { }
        public static . IsFullyTrusted(this .<.Assembly> source) { }
        public static . IsNotCollectible(this .<.Assembly> source) { }
        public static . IsNotDynamic(this .<.Assembly> source) { }
        public static . IsNotFullyTrusted(this .<.Assembly> source) { }
        public static ._IsNotSigned_Assertion IsNotSigned(this .<.Assembly> source) { }
        public static ._IsReleaseBuild_Assertion IsReleaseBuild(this .<.Assembly> source) { }
        public static ._IsSigned_Assertion IsSigned(this .<.Assembly> source) { }
    }
    public class AssemblyIsCollectibleAssertion : .<.Assembly>
    {
        public AssemblyIsCollectibleAssertion(.<.Assembly> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<.Assembly> metadata) { }
        protected override string GetExpectation() { }
    }
    public class AssemblyIsDynamicAssertion : .<.Assembly>
    {
        public AssemblyIsDynamicAssertion(.<.Assembly> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<.Assembly> metadata) { }
        protected override string GetExpectation() { }
    }
    public class AssemblyIsFullyTrustedAssertion : .<.Assembly>
    {
        public AssemblyIsFullyTrustedAssertion(.<.Assembly> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<.Assembly> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class Assembly_IsDebugBuild_Assertion : .<.Assembly>
    {
        public Assembly_IsDebugBuild_Assertion(.<.Assembly> context) { }
        protected override .<.> CheckAsync(.<.Assembly> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class Assembly_IsNotSigned_Assertion : .<.Assembly>
    {
        public Assembly_IsNotSigned_Assertion(.<.Assembly> context) { }
        protected override .<.> CheckAsync(.<.Assembly> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class Assembly_IsReleaseBuild_Assertion : .<.Assembly>
    {
        public Assembly_IsReleaseBuild_Assertion(.<.Assembly> context) { }
        protected override .<.> CheckAsync(.<.Assembly> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class Assembly_IsSigned_Assertion : .<.Assembly>
    {
        public Assembly_IsSigned_Assertion(.<.Assembly> context) { }
        protected override .<.> CheckAsync(.<.Assembly> metadata) { }
        protected override string GetExpectation() { }
    }
    public static class AssertionExtensions
    {
        public static . CompletesWithin(this . source,  timeout, [.("timeout")] string? expression = null) { }
        public static . CompletesWithin(this . source,  timeout, [.("timeout")] string? expression = null) { }
        public static ..DoesNotHaveFlagAssertion<TEnum> DoesNotHaveFlag<TEnum>(this .<TEnum> source, TEnum unexpectedFlag, [.("unexpectedFlag")] string? expression = null)
            where TEnum :  struct,  { }
        public static ..DoesNotHaveSameNameAsAssertion<TEnum> DoesNotHaveSameNameAs<TEnum>(this .<TEnum> source,  otherEnumValue, [.("otherEnumValue")] string? expression = null)
            where TEnum :  struct,  { }
        public static ..DoesNotHaveSameValueAsAssertion<TEnum> DoesNotHaveSameValueAs<TEnum>(this .<TEnum> source,  otherEnumValue, [.("otherEnumValue")] string? expression = null)
            where TEnum :  struct,  { }
        public static .<TValue> EqualTo<TValue>(this .<TValue> source, TValue? expected, [.("expected")] string? expression = null) { }
        public static ..HasFlagAssertion<TEnum> HasFlag<TEnum>(this .<TEnum> source, TEnum expectedFlag, [.("expectedFlag")] string? expression = null)
            where TEnum :  struct,  { }
        public static ..LengthWrapper HasLength(this .<string> source) { }
        public static . HasLength(this .<string> source, int expectedLength, [.("expectedLength")] string? expression = null) { }
        public static .<TException> HasMessageContaining<TException>(this .<TException> source, string expectedSubstring, [.("expectedSubstring")] string? expression = null)
            where TException :  { }
        public static .<TException> HasMessageContaining<TException>(this .<TException> source, string expectedSubstring,  comparison, [.("expectedSubstring")] string? expression = null)
            where TException :  { }
        public static .<TValue> HasMessageEqualTo<TValue>(this .<TValue> source, string expectedMessage) { }
        public static .<TValue> HasMessageEqualTo<TValue>(this .<TValue> source, string expectedMessage,  comparison) { }
        public static .<TValue> HasMessageStartingWith<TValue>(this .<TValue> source, string expectedPrefix) { }
        public static .<TValue> HasMessageStartingWith<TValue>(this .<TValue> source, string expectedPrefix,  comparison) { }
        public static ..HasSameNameAsAssertion<TEnum> HasSameNameAs<TEnum>(this .<TEnum> source,  otherEnumValue, [.("otherEnumValue")] string? expression = null)
            where TEnum :  struct,  { }
        public static ..HasSameValueAsAssertion<TEnum> HasSameValueAs<TEnum>(this .<TEnum> source,  otherEnumValue, [.("otherEnumValue")] string? expression = null)
            where TEnum :  struct,  { }
        public static .<> IsAfter(this .<> source,  expected, [.("expected")] string? expression = null) { }
        public static .<> IsAfter(this .<> source,  expected, [.("expected")] string? expression = null) { }
        public static .<> IsAfter(this .<> source,  expected, [.("expected")] string? expression = null) { }
        public static .<> IsAfter(this .<> source,  expected, [.("expected")] string? expression = null) { }
        public static .<> IsAfterOrEqualTo(this .<> source,  expected, [.("expected")] string? expression = null) { }
        public static .<> IsAfterOrEqualTo(this .<> source,  expected, [.("expected")] string? expression = null) { }
        public static .<> IsAfterOrEqualTo(this .<> source,  expected, [.("expected")] string? expression = null) { }
        public static .<> IsAfterOrEqualTo(this .<> source,  expected, [.("expected")] string? expression = null) { }
        public static .<TTarget, object> IsAssignableTo<TTarget>(this .<object> source) { }
        public static .<TTarget, TValue> IsAssignableTo<TTarget, TValue>(this .<TValue> source) { }
        public static .<> IsBefore(this .<> source,  expected, [.("expected")] string? expression = null) { }
        public static .<> IsBefore(this .<> source,  expected, [.("expected")] string? expression = null) { }
        public static .<> IsBefore(this .<> source,  expected, [.("expected")] string? expression = null) { }
        public static .<> IsBefore(this .<> source,  expected, [.("expected")] string? expression = null) { }
        public static .<> IsBeforeOrEqualTo(this .<> source,  expected, [.("expected")] string? expression = null) { }
        public static .<> IsBeforeOrEqualTo(this .<> source,  expected, [.("expected")] string? expression = null) { }
        public static .<> IsBeforeOrEqualTo(this .<> source,  expected, [.("expected")] string? expression = null) { }
        public static .<> IsBeforeOrEqualTo(this .<> source,  expected, [.("expected")] string? expression = null) { }
        public static ..IsDefinedAssertion<TEnum> IsDefined<TEnum>(this .<TEnum> source)
            where TEnum :  struct,  { }
        public static . IsEqualTo(this .<string> source, string? expected,  comparison, [.("expected")] string? expression = null) { }
        public static .<TValue> IsEquivalentTo<TValue>(this .<TValue> source, object? expected, [.("expected")] string? expression = null) { }
        public static .<TValue> IsIn<TValue>(this .<TValue> source, params TValue[] collection) { }
        public static .<TValue> IsNegative<TValue>(this .<TValue> source)
            where TValue : <TValue> { }
        public static .<TValue> IsNegative<TValue>(this .<TValue?> source)
            where TValue :  struct, <TValue> { }
        public static .<TTarget, TValue> IsNotAssignableTo<TTarget, TValue>(this .<TValue> source) { }
        public static ..IsNotDefinedAssertion<TEnum> IsNotDefined<TEnum>(this .<TEnum> source)
            where TEnum :  struct,  { }
        public static .<TValue> IsNotEquivalentTo<TValue>(this .<TValue> source, object? expected, [.("expected")] string? expression = null) { }
        public static .<TValue> IsNotIn<TValue>(this .<TValue> source, params TValue[] collection) { }
        public static .<TValue> IsNotNull<TValue>(this .<TValue> source)
            where TValue :  class { }
        public static .<TValue> IsNotNull<TValue>(this .<TValue?> source)
            where TValue :  struct { }
        public static .<TCollection, TItem> IsNotNull<TCollection, TItem>(this .<TCollection, TItem> source)
            where TCollection :  class, .<TItem> { }
        public static ..IsNotParsableIntoAssertion<T> IsNotParsableInto<[.(..None | ..PublicMethods | ..Interfaces)]  T>(this .<string> source) { }
        public static .<TValue> IsOfType<TValue>(this .<TValue> source,  expectedType, [.("expectedType")] string? expression = null) { }
        public static ..IsParsableIntoAssertion<T> IsParsableInto<[.(..None | ..PublicMethods | ..Interfaces)]  T>(this .<string> source) { }
        public static .<TValue> IsPositive<TValue>(this .<TValue> source)
            where TValue : <TValue> { }
        public static .<TValue> IsPositive<TValue>(this .<TValue?> source)
            where TValue :  struct, <TValue> { }
        public static .<TValue, TExpected> IsTypeOf<TExpected, TValue>(this .<TValue> source) { }
        public static .<TObject> Member<TObject, TMember>(this .<TObject> source, .<<TObject, TMember>> memberSelector, <.<TMember>, .<TMember>> assertions) { }
        public static .<TObject> Member<TObject, TMember>(this .<TObject> source, .<<TObject, TMember>> memberSelector, <.<TMember>, object> assertions) { }
        public static .<TValue> Satisfies<TValue>(this .<TValue> source, <TValue?, bool> predicate, [.("predicate")] string? expression = null) { }
        public static .<TValue, TMapped> Satisfies<TValue, TMapped>(this .<TValue> source, <TValue?, .<TMapped>> selector, <.<TMapped>, .<TMapped>?> assertions, [.("selector")] string? selectorExpression = null) { }
        public static .<TValue, TMapped> Satisfies<TValue, TMapped>(this .<TValue> source, <TValue?, TMapped> selector, <.<TMapped>, .<TMapped>?> assertions, [.("selector")] string? selectorExpression = null) { }
        public static .<TException> Throws<TException>(this . source)
            where TException :  { }
        public static .<TException> Throws<TException>(this . source)
            where TException :  { }
        public static .<TException> Throws<TException, TValue>(this .<TValue> source)
            where TException :  { }
        public static .<TException> ThrowsAsync<TValue, TException>(this .<TValue> source)
            where TException :  { }
        public static .<TException> ThrowsExactly<TException>(this . source)
            where TException :  { }
        public static .<TException> ThrowsExactly<TException>(this . source)
            where TException :  { }
        public static .<TException> ThrowsExactly<TException, TValue>(this .<TValue> source)
            where TException :  { }
        public static .<> ThrowsException<TValue>(this .<TValue> source) { }
        public static .<TException> ThrowsException<TException, TValue>(this .<TValue> source)
            where TException :  { }
        public static .<TValue> ThrowsNothing<TValue>(this .<TValue> source) { }
        public static ..WhenParsedIntoAssertion<T> WhenParsedInto<[.(..None | ..PublicMethods | ..Interfaces)]  T>(this .<string> source) { }
        public static .<TException> WithMessage<TException>(this .<TException> source, string expectedMessage, [.("expectedMessage")] string? expression = null)
            where TException :  { }
        public static .<TException> WithMessage<TException>(this .<TException> source, string expectedMessage,  comparison, [.("expectedMessage")] string? expression = null)
            where TException :  { }
        public static .<TException> WithMessageContaining<TException>(this .<TException> source, string expectedSubstring, [.("expectedSubstring")] string? expression = null)
            where TException :  { }
        public static .<TException> WithMessageContaining<TException>(this .<TException> source, string expectedSubstring,  comparison, [.("expectedSubstring")] string? expression = null)
            where TException :  { }
        public static .<TException> WithMessageMatching<TException>(this .<TException> source, .StringMatcher matcher, [.("matcher")] string? expression = null)
            where TException :  { }
        public static .<TException> WithMessageMatching<TException>(this .<TException> source, string pattern, [.("pattern")] string? expression = null)
            where TException :  { }
        public static .<TException> WithMessageNotContaining<TException>(this .<TException> source, string notExpectedSubstring, [.("notExpectedSubstring")] string? expression = null)
            where TException :  { }
        public static .<TException> WithMessageNotContaining<TException>(this .<TException> source, string notExpectedSubstring,  comparison, [.("notExpectedSubstring")] string? expression = null)
            where TException :  { }
        public static .<TException> WithParameterName<TException>(this .<TException> source, string expectedParameterName, [.("expectedParameterName")] string? expression = null)
            where TException :  { }
    }
    public static class BetweenAssertionExtensions
    {
        public static .<TValue> IsBetween<TValue>(this .<TValue> source, TValue minimum, TValue maximum, [.("minimum")] string? minimumExpression = null, [.("maximum")] string? maximumExpression = null)
            where TValue : <TValue> { }
    }
    public sealed class Bool_IsFalse_Assertion : .<bool>
    {
        public Bool_IsFalse_Assertion(.<bool> context) { }
        protected override .<.> CheckAsync(.<bool> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class Bool_IsTrue_Assertion : .<bool>
    {
        public Bool_IsTrue_Assertion(.<bool> context) { }
        protected override .<.> CheckAsync(.<bool> metadata) { }
        protected override string GetExpectation() { }
    }
    public static class BooleanAssertionExtensions
    {
        public static ._IsFalse_Assertion IsFalse(this .<bool> source) { }
        public static ._IsFalse_Assertion IsFalse(this .<bool?> source) { }
        public static ._IsTrue_Assertion IsTrue(this .<bool> source) { }
        public static ._IsTrue_Assertion IsTrue(this .<bool?> source) { }
    }
    public static class CancellationTokenAssertionExtensions
    {
        public static . CanBeCanceled(this .<.CancellationToken> source) { }
        public static . CannotBeCanceled(this .<.CancellationToken> source) { }
        public static . IsCancellationRequested(this .<.CancellationToken> source) { }
        public static ._IsNone_Assertion IsNone(this .<.CancellationToken> source) { }
        public static . IsNotCancellationRequested(this .<.CancellationToken> source) { }
        public static ._IsNotNone_Assertion IsNotNone(this .<.CancellationToken> source) { }
    }
    public class CancellationTokenCanBeCanceledAssertion : .<.CancellationToken>
    {
        public CancellationTokenCanBeCanceledAssertion(.<.CancellationToken> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<.CancellationToken> metadata) { }
        protected override string GetExpectation() { }
    }
    public class CancellationTokenIsCancellationRequestedAssertion : .<.CancellationToken>
    {
        public CancellationTokenIsCancellationRequestedAssertion(.<.CancellationToken> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<.CancellationToken> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class CancellationToken_IsNone_Assertion : .<.CancellationToken>
    {
        public CancellationToken_IsNone_Assertion(.<.CancellationToken> context) { }
        protected override .<.> CheckAsync(.<.CancellationToken> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class CancellationToken_IsNotNone_Assertion : .<.CancellationToken>
    {
        public CancellationToken_IsNotNone_Assertion(.<.CancellationToken> context) { }
        protected override .<.> CheckAsync(.<.CancellationToken> metadata) { }
        protected override string GetExpectation() { }
    }
    public static class CharAssertionExtensions
    {
        public static . IsControl(this .<char> source) { }
        public static . IsDigit(this .<char> source) { }
        public static . IsHighSurrogate(this .<char> source) { }
        public static . IsLetter(this .<char> source) { }
        public static . IsLetterOrDigit(this .<char> source) { }
        public static . IsLowSurrogate(this .<char> source) { }
        public static . IsLower(this .<char> source) { }
        public static . IsNotControl(this .<char> source) { }
        public static . IsNotDigit(this .<char> source) { }
        public static . IsNotHighSurrogate(this .<char> source) { }
        public static . IsNotLetter(this .<char> source) { }
        public static . IsNotLetterOrDigit(this .<char> source) { }
        public static . IsNotLowSurrogate(this .<char> source) { }
        public static . IsNotLower(this .<char> source) { }
        public static . IsNotNumber(this .<char> source) { }
        public static . IsNotPunctuation(this .<char> source) { }
        public static . IsNotSeparator(this .<char> source) { }
        public static . IsNotSurrogate(this .<char> source) { }
        public static . IsNotSymbol(this .<char> source) { }
        public static . IsNotUpper(this .<char> source) { }
        public static . IsNotWhiteSpace(this .<char> source) { }
        public static . IsNumber(this .<char> source) { }
        public static . IsPunctuation(this .<char> source) { }
        public static . IsSeparator(this .<char> source) { }
        public static . IsSurrogate(this .<char> source) { }
        public static . IsSymbol(this .<char> source) { }
        public static . IsUpper(this .<char> source) { }
        public static . IsWhiteSpace(this .<char> source) { }
    }
    public class CharIsControlWithCharAssertion : .<char>
    {
        public CharIsControlWithCharAssertion(.<char> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<char> metadata) { }
        protected override string GetExpectation() { }
    }
    public class CharIsDigitWithCharAssertion : .<char>
    {
        public CharIsDigitWithCharAssertion(.<char> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<char> metadata) { }
        protected override string GetExpectation() { }
    }
    public class CharIsHighSurrogateWithCharAssertion : .<char>
    {
        public CharIsHighSurrogateWithCharAssertion(.<char> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<char> metadata) { }
        protected override string GetExpectation() { }
    }
    public class CharIsLetterOrDigitWithCharAssertion : .<char>
    {
        public CharIsLetterOrDigitWithCharAssertion(.<char> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<char> metadata) { }
        protected override string GetExpectation() { }
    }
    public class CharIsLetterWithCharAssertion : .<char>
    {
        public CharIsLetterWithCharAssertion(.<char> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<char> metadata) { }
        protected override string GetExpectation() { }
    }
    public class CharIsLowSurrogateWithCharAssertion : .<char>
    {
        public CharIsLowSurrogateWithCharAssertion(.<char> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<char> metadata) { }
        protected override string GetExpectation() { }
    }
    public class CharIsLowerWithCharAssertion : .<char>
    {
        public CharIsLowerWithCharAssertion(.<char> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<char> metadata) { }
        protected override string GetExpectation() { }
    }
    public class CharIsNumberWithCharAssertion : .<char>
    {
        public CharIsNumberWithCharAssertion(.<char> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<char> metadata) { }
        protected override string GetExpectation() { }
    }
    public class CharIsPunctuationWithCharAssertion : .<char>
    {
        public CharIsPunctuationWithCharAssertion(.<char> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<char> metadata) { }
        protected override string GetExpectation() { }
    }
    public class CharIsSeparatorWithCharAssertion : .<char>
    {
        public CharIsSeparatorWithCharAssertion(.<char> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<char> metadata) { }
        protected override string GetExpectation() { }
    }
    public class CharIsSurrogateWithCharAssertion : .<char>
    {
        public CharIsSurrogateWithCharAssertion(.<char> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<char> metadata) { }
        protected override string GetExpectation() { }
    }
    public class CharIsSymbolWithCharAssertion : .<char>
    {
        public CharIsSymbolWithCharAssertion(.<char> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<char> metadata) { }
        protected override string GetExpectation() { }
    }
    public class CharIsUpperWithCharAssertion : .<char>
    {
        public CharIsUpperWithCharAssertion(.<char> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<char> metadata) { }
        protected override string GetExpectation() { }
    }
    public class CharIsWhiteSpaceWithCharAssertion : .<char>
    {
        public CharIsWhiteSpaceWithCharAssertion(.<char> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<char> metadata) { }
        protected override string GetExpectation() { }
    }
    public static class CollectionAllAssertionExtensions
    {
        public static .<TCollection, TItem> All<TCollection, TItem>(this .<TCollection> source, <TItem, bool> predicate, string predicateDescription, [.("predicate")] string? predicateExpression = null, [.("predicateDescription")] string? predicateDescriptionExpression = null)
            where TCollection : .<TItem> { }
    }
    public static class CollectionAnyAssertionExtensions
    {
        public static .<TCollection, TItem> Any<TCollection, TItem>(this .<TCollection> source, <TItem, bool> predicate, string predicateDescription, [.("predicate")] string? predicateExpression = null, [.("predicateDescription")] string? predicateDescriptionExpression = null)
            where TCollection : .<TItem> { }
    }
    public static class CollectionContainsAssertionExtensions
    {
        public static .<TCollection, TItem> Contains<TCollection, TItem>(this .<TCollection> source, TItem expected, .<TItem>? comparer = null, [.("expected")] string? expectedExpression = null, [.("comparer")] string? comparerExpression = null)
            where TCollection : .<TItem> { }
    }
    public static class CollectionContainsPredicateAssertionExtensions
    {
        public static .<TCollection, TItem> Contains<TCollection, TItem>(this .<TCollection> source, <TItem, bool> predicate, [.("predicate")] string? predicateExpression = null)
            where TCollection : .<TItem> { }
    }
    public static class CollectionDoesNotContainAssertionExtensions
    {
        public static .<TCollection, TItem> DoesNotContain<TCollection, TItem>(this .<TCollection> source, TItem expected, .<TItem>? comparer = null, [.("expected")] string? expectedExpression = null, [.("comparer")] string? comparerExpression = null)
            where TCollection : .<TItem> { }
    }
    public static class CollectionDoesNotContainPredicateAssertionExtensions
    {
        public static .<TCollection, TItem> DoesNotContain<TCollection, TItem>(this .<TCollection> source, <TItem, bool> predicate, string predicateDescription, [.("predicate")] string? predicateExpression = null, [.("predicateDescription")] string? predicateDescriptionExpression = null)
            where TCollection : .<TItem> { }
    }
    public static class CollectionIsInDescendingOrderAssertionExtensions
    {
        public static .<TCollection, TItem> IsInDescendingOrder<TCollection, TItem>(this .<TCollection> source)
            where TCollection : .<TItem> { }
    }
    public static class CollectionIsInOrderAssertionExtensions
    {
        public static .<TCollection, TItem> IsInOrder<TCollection, TItem>(this .<TCollection> source)
            where TCollection : .<TItem> { }
    }
    public static class CultureInfoAssertionExtensions
    {
        public static ._IsEnglish_Assertion IsEnglish(this .<.CultureInfo> source) { }
        public static ._IsInvariant_Assertion IsInvariant(this .<.CultureInfo> source) { }
        public static ._IsLeftToRight_Assertion IsLeftToRight(this .<.CultureInfo> source) { }
        public static . IsNeutralCulture(this .<.CultureInfo> source) { }
        public static ._IsNotEnglish_Assertion IsNotEnglish(this .<.CultureInfo> source) { }
        public static ._IsNotInvariant_Assertion IsNotInvariant(this .<.CultureInfo> source) { }
        public static . IsNotNeutralCulture(this .<.CultureInfo> source) { }
        public static . IsReadOnly(this .<.CultureInfo> source) { }
        public static ._IsRightToLeft_Assertion IsRightToLeft(this .<.CultureInfo> source) { }
    }
    public class CultureInfoIsNeutralCultureAssertion : .<.CultureInfo>
    {
        public CultureInfoIsNeutralCultureAssertion(.<.CultureInfo> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<.CultureInfo> metadata) { }
        protected override string GetExpectation() { }
    }
    public class CultureInfoIsReadOnlyAssertion : .<.CultureInfo>
    {
        public CultureInfoIsReadOnlyAssertion(.<.CultureInfo> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<.CultureInfo> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class CultureInfo_IsEnglish_Assertion : .<.CultureInfo>
    {
        public CultureInfo_IsEnglish_Assertion(.<.CultureInfo> context) { }
        protected override .<.> CheckAsync(.<.CultureInfo> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class CultureInfo_IsInvariant_Assertion : .<.CultureInfo>
    {
        public CultureInfo_IsInvariant_Assertion(.<.CultureInfo> context) { }
        protected override .<.> CheckAsync(.<.CultureInfo> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class CultureInfo_IsLeftToRight_Assertion : .<.CultureInfo>
    {
        public CultureInfo_IsLeftToRight_Assertion(.<.CultureInfo> context) { }
        protected override .<.> CheckAsync(.<.CultureInfo> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class CultureInfo_IsNotEnglish_Assertion : .<.CultureInfo>
    {
        public CultureInfo_IsNotEnglish_Assertion(.<.CultureInfo> context) { }
        protected override .<.> CheckAsync(.<.CultureInfo> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class CultureInfo_IsNotInvariant_Assertion : .<.CultureInfo>
    {
        public CultureInfo_IsNotInvariant_Assertion(.<.CultureInfo> context) { }
        protected override .<.> CheckAsync(.<.CultureInfo> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class CultureInfo_IsRightToLeft_Assertion : .<.CultureInfo>
    {
        public CultureInfo_IsRightToLeft_Assertion(.<.CultureInfo> context) { }
        protected override .<.> CheckAsync(.<.CultureInfo> metadata) { }
        protected override string GetExpectation() { }
    }
    public static class DateOnlyAssertionExtensions
    {
        public static ._IsFirstDayOfMonth_Assertion IsFirstDayOfMonth(this .<> source) { }
        public static ._IsInFuture_Assertion IsInFuture(this .<> source) { }
        public static ._IsInPast_Assertion IsInPast(this .<> source) { }
        public static ._IsLastDayOfMonth_Assertion IsLastDayOfMonth(this .<> source) { }
        public static ._IsLeapYear_Assertion IsLeapYear(this .<> source) { }
        public static ._IsNotLeapYear_Assertion IsNotLeapYear(this .<> source) { }
        public static ._IsNotToday_Assertion IsNotToday(this .<> source) { }
        public static ._IsOnWeekday_Assertion IsOnWeekday(this .<> source) { }
        public static ._IsOnWeekend_Assertion IsOnWeekend(this .<> source) { }
        public static ._IsToday_Assertion IsToday(this .<> source) { }
    }
    public static class DateOnlyEqualsAssertionExtensions
    {
        public static . IsEqualTo(this .<> source,  expected, [.("expected")] string? expectedExpression = null) { }
    }
    public sealed class DateOnly_IsFirstDayOfMonth_Assertion : .<>
    {
        public DateOnly_IsFirstDayOfMonth_Assertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class DateOnly_IsInFuture_Assertion : .<>
    {
        public DateOnly_IsInFuture_Assertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class DateOnly_IsInPast_Assertion : .<>
    {
        public DateOnly_IsInPast_Assertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class DateOnly_IsLastDayOfMonth_Assertion : .<>
    {
        public DateOnly_IsLastDayOfMonth_Assertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class DateOnly_IsLeapYear_Assertion : .<>
    {
        public DateOnly_IsLeapYear_Assertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class DateOnly_IsNotLeapYear_Assertion : .<>
    {
        public DateOnly_IsNotLeapYear_Assertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class DateOnly_IsNotToday_Assertion : .<>
    {
        public DateOnly_IsNotToday_Assertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class DateOnly_IsOnWeekday_Assertion : .<>
    {
        public DateOnly_IsOnWeekday_Assertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class DateOnly_IsOnWeekend_Assertion : .<>
    {
        public DateOnly_IsOnWeekend_Assertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class DateOnly_IsToday_Assertion : .<>
    {
        public DateOnly_IsToday_Assertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public static class DateTimeAssertionExtensions
    {
        public static . IsDaylightSavingTime(this .<> source) { }
        public static ._IsInFuture_Assertion IsInFuture(this .<> source) { }
        public static ._IsInFutureUtc_Assertion IsInFutureUtc(this .<> source) { }
        public static ._IsInPast_Assertion IsInPast(this .<> source) { }
        public static ._IsInPastUtc_Assertion IsInPastUtc(this .<> source) { }
        public static ._IsLeapYear_Assertion IsLeapYear(this .<> source) { }
        public static . IsNotDaylightSavingTime(this .<> source) { }
        public static ._IsNotLeapYear_Assertion IsNotLeapYear(this .<> source) { }
        public static ._IsNotToday_Assertion IsNotToday(this .<> source) { }
        public static ._IsNotUtc_Assertion IsNotUtc(this .<> source) { }
        public static ._IsOnWeekday_Assertion IsOnWeekday(this .<> source) { }
        public static ._IsOnWeekend_Assertion IsOnWeekend(this .<> source) { }
        public static ._IsToday_Assertion IsToday(this .<> source) { }
        public static ._IsUtc_Assertion IsUtc(this .<> source) { }
    }
    public static class DateTimeEqualsAssertionExtensions
    {
        public static . IsEqualTo(this .<> source,  expected, [.("expected")] string? expectedExpression = null) { }
    }
    public static class DateTimeEqualsExactAssertionExtensions
    {
        public static . EqualsExact(this .<> source,  expected, [.("expected")] string? expectedExpression = null) { }
    }
    public class DateTimeIsDaylightSavingTimeAssertion : .<>
    {
        public DateTimeIsDaylightSavingTimeAssertion(.<> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public static class DateTimeOffsetAssertionExtensions
    {
        public static ._IsInFuture_Assertion IsInFuture(this .<> source) { }
        public static ._IsInFutureUtc_Assertion IsInFutureUtc(this .<> source) { }
        public static ._IsInPast_Assertion IsInPast(this .<> source) { }
        public static ._IsInPastUtc_Assertion IsInPastUtc(this .<> source) { }
        public static ._IsLeapYear_Assertion IsLeapYear(this .<> source) { }
        public static ._IsNotLeapYear_Assertion IsNotLeapYear(this .<> source) { }
        public static ._IsNotToday_Assertion IsNotToday(this .<> source) { }
        public static ._IsNotUtc_Assertion IsNotUtc(this .<> source) { }
        public static ._IsOnWeekday_Assertion IsOnWeekday(this .<> source) { }
        public static ._IsOnWeekend_Assertion IsOnWeekend(this .<> source) { }
        public static ._IsToday_Assertion IsToday(this .<> source) { }
        public static ._IsUtc_Assertion IsUtc(this .<> source) { }
    }
    public static class DateTimeOffsetEqualsAssertionExtensions
    {
        public static . IsEqualTo(this .<> source,  expected, [.("expected")] string? expectedExpression = null) { }
    }
    public sealed class DateTimeOffset_IsInFutureUtc_Assertion : .<>
    {
        public DateTimeOffset_IsInFutureUtc_Assertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class DateTimeOffset_IsInFuture_Assertion : .<>
    {
        public DateTimeOffset_IsInFuture_Assertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class DateTimeOffset_IsInPastUtc_Assertion : .<>
    {
        public DateTimeOffset_IsInPastUtc_Assertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class DateTimeOffset_IsInPast_Assertion : .<>
    {
        public DateTimeOffset_IsInPast_Assertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class DateTimeOffset_IsLeapYear_Assertion : .<>
    {
        public DateTimeOffset_IsLeapYear_Assertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class DateTimeOffset_IsNotLeapYear_Assertion : .<>
    {
        public DateTimeOffset_IsNotLeapYear_Assertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class DateTimeOffset_IsNotToday_Assertion : .<>
    {
        public DateTimeOffset_IsNotToday_Assertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class DateTimeOffset_IsNotUtc_Assertion : .<>
    {
        public DateTimeOffset_IsNotUtc_Assertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class DateTimeOffset_IsOnWeekday_Assertion : .<>
    {
        public DateTimeOffset_IsOnWeekday_Assertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class DateTimeOffset_IsOnWeekend_Assertion : .<>
    {
        public DateTimeOffset_IsOnWeekend_Assertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class DateTimeOffset_IsToday_Assertion : .<>
    {
        public DateTimeOffset_IsToday_Assertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class DateTimeOffset_IsUtc_Assertion : .<>
    {
        public DateTimeOffset_IsUtc_Assertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class DateTime_IsInFutureUtc_Assertion : .<>
    {
        public DateTime_IsInFutureUtc_Assertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class DateTime_IsInFuture_Assertion : .<>
    {
        public DateTime_IsInFuture_Assertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class DateTime_IsInPastUtc_Assertion : .<>
    {
        public DateTime_IsInPastUtc_Assertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class DateTime_IsInPast_Assertion : .<>
    {
        public DateTime_IsInPast_Assertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class DateTime_IsLeapYear_Assertion : .<>
    {
        public DateTime_IsLeapYear_Assertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class DateTime_IsNotLeapYear_Assertion : .<>
    {
        public DateTime_IsNotLeapYear_Assertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class DateTime_IsNotToday_Assertion : .<>
    {
        public DateTime_IsNotToday_Assertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class DateTime_IsNotUtc_Assertion : .<>
    {
        public DateTime_IsNotUtc_Assertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class DateTime_IsOnWeekday_Assertion : .<>
    {
        public DateTime_IsOnWeekday_Assertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class DateTime_IsOnWeekend_Assertion : .<>
    {
        public DateTime_IsOnWeekend_Assertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class DateTime_IsToday_Assertion : .<>
    {
        public DateTime_IsToday_Assertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class DateTime_IsUtc_Assertion : .<>
    {
        public DateTime_IsUtc_Assertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public static class DayOfWeekAssertionExtensions
    {
        public static ._IsFriday_Assertion IsFriday(this .<> source) { }
        public static ._IsMonday_Assertion IsMonday(this .<> source) { }
        public static ._IsWeekday_Assertion IsWeekday(this .<> source) { }
        public static ._IsWeekend_Assertion IsWeekend(this .<> source) { }
    }
    public sealed class DayOfWeek_IsFriday_Assertion : .<>
    {
        public DayOfWeek_IsFriday_Assertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class DayOfWeek_IsMonday_Assertion : .<>
    {
        public DayOfWeek_IsMonday_Assertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class DayOfWeek_IsWeekday_Assertion : .<>
    {
        public DayOfWeek_IsWeekday_Assertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class DayOfWeek_IsWeekend_Assertion : .<>
    {
        public DayOfWeek_IsWeekend_Assertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public static class DecimalEqualsAssertionExtensions
    {
        public static . IsEqualTo(this .<decimal> source, decimal expected, [.("expected")] string? expectedExpression = null) { }
    }
    public static class DirectoryHasFilesAssertionExtensions
    {
        public static . HasFiles(this .<.DirectoryInfo> source) { }
    }
    public static class DirectoryHasNoSubdirectoriesAssertionExtensions
    {
        public static . HasNoSubdirectories(this .<.DirectoryInfo> source) { }
    }
    public static class DirectoryInfoAssertionExtensions
    {
        public static . DoesNotExist(this .<.DirectoryInfo> source) { }
        public static . Exists(this .<.DirectoryInfo> source) { }
        public static ._IsEmpty_Assertion IsEmpty(this .<.DirectoryInfo> source) { }
        public static ._IsHidden_Assertion IsHidden(this .<.DirectoryInfo> source) { }
        public static ._IsNotEmpty_Assertion IsNotEmpty(this .<.DirectoryInfo> source) { }
        public static ._IsNotHidden_Assertion IsNotHidden(this .<.DirectoryInfo> source) { }
        public static ._IsNotRoot_Assertion IsNotRoot(this .<.DirectoryInfo> source) { }
        public static ._IsRoot_Assertion IsRoot(this .<.DirectoryInfo> source) { }
        public static ._IsSystemDirectory_Assertion IsSystemDirectory(this .<.DirectoryInfo> source) { }
    }
    public class DirectoryInfoExistsAssertion : .<.DirectoryInfo>
    {
        public DirectoryInfoExistsAssertion(.<.DirectoryInfo> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<.DirectoryInfo> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class DirectoryInfo_IsEmpty_Assertion : .<.DirectoryInfo>
    {
        public DirectoryInfo_IsEmpty_Assertion(.<.DirectoryInfo> context) { }
        protected override .<.> CheckAsync(.<.DirectoryInfo> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class DirectoryInfo_IsHidden_Assertion : .<.DirectoryInfo>
    {
        public DirectoryInfo_IsHidden_Assertion(.<.DirectoryInfo> context) { }
        protected override .<.> CheckAsync(.<.DirectoryInfo> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class DirectoryInfo_IsNotEmpty_Assertion : .<.DirectoryInfo>
    {
        public DirectoryInfo_IsNotEmpty_Assertion(.<.DirectoryInfo> context) { }
        protected override .<.> CheckAsync(.<.DirectoryInfo> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class DirectoryInfo_IsNotHidden_Assertion : .<.DirectoryInfo>
    {
        public DirectoryInfo_IsNotHidden_Assertion(.<.DirectoryInfo> context) { }
        protected override .<.> CheckAsync(.<.DirectoryInfo> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class DirectoryInfo_IsNotRoot_Assertion : .<.DirectoryInfo>
    {
        public DirectoryInfo_IsNotRoot_Assertion(.<.DirectoryInfo> context) { }
        protected override .<.> CheckAsync(.<.DirectoryInfo> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class DirectoryInfo_IsRoot_Assertion : .<.DirectoryInfo>
    {
        public DirectoryInfo_IsRoot_Assertion(.<.DirectoryInfo> context) { }
        protected override .<.> CheckAsync(.<.DirectoryInfo> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class DirectoryInfo_IsSystemDirectory_Assertion : .<.DirectoryInfo>
    {
        public DirectoryInfo_IsSystemDirectory_Assertion(.<.DirectoryInfo> context) { }
        protected override .<.> CheckAsync(.<.DirectoryInfo> metadata) { }
        protected override string GetExpectation() { }
    }
    public static class DoubleEqualsAssertionExtensions
    {
        public static . IsEqualTo(this .<double> source, double expected, [.("expected")] string? expectedExpression = null) { }
    }
    public static class EncodingAssertionExtensions
    {
        public static ._IsASCII_Assertion IsASCII(this .<.Encoding> source) { }
        public static ._IsBigEndianUnicode_Assertion IsBigEndianUnicode(this .<.Encoding> source) { }
        public static . IsNotSingleByte(this .<.Encoding> source) { }
        public static ._IsNotUTF8_Assertion IsNotUTF8(this .<.Encoding> source) { }
        public static . IsSingleByte(this .<.Encoding> source) { }
        public static ._IsUTF32_Assertion IsUTF32(this .<.Encoding> source) { }
        public static ._IsUTF8_Assertion IsUTF8(this .<.Encoding> source) { }
        public static ._IsUnicode_Assertion IsUnicode(this .<.Encoding> source) { }
    }
    public class EncodingIsSingleByteAssertion : .<.Encoding>
    {
        public EncodingIsSingleByteAssertion(.<.Encoding> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<.Encoding> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class Encoding_IsASCII_Assertion : .<.Encoding>
    {
        public Encoding_IsASCII_Assertion(.<.Encoding> context) { }
        protected override .<.> CheckAsync(.<.Encoding> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class Encoding_IsBigEndianUnicode_Assertion : .<.Encoding>
    {
        public Encoding_IsBigEndianUnicode_Assertion(.<.Encoding> context) { }
        protected override .<.> CheckAsync(.<.Encoding> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class Encoding_IsNotUTF8_Assertion : .<.Encoding>
    {
        public Encoding_IsNotUTF8_Assertion(.<.Encoding> context) { }
        protected override .<.> CheckAsync(.<.Encoding> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class Encoding_IsUTF32_Assertion : .<.Encoding>
    {
        public Encoding_IsUTF32_Assertion(.<.Encoding> context) { }
        protected override .<.> CheckAsync(.<.Encoding> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class Encoding_IsUTF8_Assertion : .<.Encoding>
    {
        public Encoding_IsUTF8_Assertion(.<.Encoding> context) { }
        protected override .<.> CheckAsync(.<.Encoding> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class Encoding_IsUnicode_Assertion : .<.Encoding>
    {
        public Encoding_IsUnicode_Assertion(.<.Encoding> context) { }
        protected override .<.> CheckAsync(.<.Encoding> metadata) { }
        protected override string GetExpectation() { }
    }
    public static class EqualsAssertionExtensions
    {
        public static .<TValue> IsEqualTo<TValue>(this .<TValue> source, TValue? expected, [.("expected")] string? expectedExpression = null) { }
        public static .<TValue> IsEqualTo<TValue>(this .<TValue> source, TValue? expected, .<TValue> comparer, [.("expected")] string? expectedExpression = null, [.("comparer")] string? comparerExpression = null) { }
    }
    public static class EquatableAssertionExtensions
    {
        public static .<TActual, TExpected> IsEquatableTo<TActual, TExpected>(this .<TActual> source, TExpected expected, [.("expected")] string? expectedExpression = null)
            where TActual : <TExpected> { }
    }
    public static class ExceptionAssertionExtensions
    {
        public static ._HasHelpLink_Assertion HasHelpLink(this .<> source) { }
        public static ._HasInnerException_Assertion HasInnerException(this .<> source) { }
        public static ._HasNoData_Assertion HasNoData(this .<> source) { }
        public static ._HasNoHelpLink_Assertion HasNoHelpLink(this .<> source) { }
        public static ._HasNoInnerException_Assertion HasNoInnerException(this .<> source) { }
        public static ._HasNoSource_Assertion HasNoSource(this .<> source) { }
        public static ._HasNoTargetSite_Assertion HasNoTargetSite(this .<> source) { }
        public static ._HasSource_Assertion HasSource(this .<> source) { }
        public static ._HasStackTrace_Assertion HasStackTrace(this .<> source) { }
        public static ._HasTargetSite_Assertion HasTargetSite(this .<> source) { }
    }
    public sealed class Exception_HasHelpLink_Assertion : .<>
    {
        public Exception_HasHelpLink_Assertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class Exception_HasInnerException_Assertion : .<>
    {
        public Exception_HasInnerException_Assertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class Exception_HasNoData_Assertion : .<>
    {
        public Exception_HasNoData_Assertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class Exception_HasNoHelpLink_Assertion : .<>
    {
        public Exception_HasNoHelpLink_Assertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class Exception_HasNoInnerException_Assertion : .<>
    {
        public Exception_HasNoInnerException_Assertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class Exception_HasNoSource_Assertion : .<>
    {
        public Exception_HasNoSource_Assertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class Exception_HasNoTargetSite_Assertion : .<>
    {
        public Exception_HasNoTargetSite_Assertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class Exception_HasSource_Assertion : .<>
    {
        public Exception_HasSource_Assertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class Exception_HasStackTrace_Assertion : .<>
    {
        public Exception_HasStackTrace_Assertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class Exception_HasTargetSite_Assertion : .<>
    {
        public Exception_HasTargetSite_Assertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public static class FileInfoAssertionExtensions
    {
        public static . DoesNotExist(this .<.FileInfo> source) { }
        public static . Exists(this .<.FileInfo> source) { }
        public static ._HasExtension_Assertion HasExtension(this .<.FileInfo> source) { }
        public static ._HasNoExtension_Assertion HasNoExtension(this .<.FileInfo> source) { }
        public static ._IsArchived_Assertion IsArchived(this .<.FileInfo> source) { }
        public static ._IsEmpty_Assertion IsEmpty(this .<.FileInfo> source) { }
        public static ._IsHidden_Assertion IsHidden(this .<.FileInfo> source) { }
        public static ._IsNotEmpty_Assertion IsNotEmpty(this .<.FileInfo> source) { }
        public static ._IsNotHidden_Assertion IsNotHidden(this .<.FileInfo> source) { }
        public static . IsNotReadOnly(this .<.FileInfo> source) { }
        public static . IsReadOnly(this .<.FileInfo> source) { }
        public static ._IsSystemFile_Assertion IsSystemFile(this .<.FileInfo> source) { }
    }
    public class FileInfoExistsAssertion : .<.FileInfo>
    {
        public FileInfoExistsAssertion(.<.FileInfo> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<.FileInfo> metadata) { }
        protected override string GetExpectation() { }
    }
    public class FileInfoIsReadOnlyAssertion : .<.FileInfo>
    {
        public FileInfoIsReadOnlyAssertion(.<.FileInfo> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<.FileInfo> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class FileInfo_HasExtension_Assertion : .<.FileInfo>
    {
        public FileInfo_HasExtension_Assertion(.<.FileInfo> context) { }
        protected override .<.> CheckAsync(.<.FileInfo> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class FileInfo_HasNoExtension_Assertion : .<.FileInfo>
    {
        public FileInfo_HasNoExtension_Assertion(.<.FileInfo> context) { }
        protected override .<.> CheckAsync(.<.FileInfo> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class FileInfo_IsArchived_Assertion : .<.FileInfo>
    {
        public FileInfo_IsArchived_Assertion(.<.FileInfo> context) { }
        protected override .<.> CheckAsync(.<.FileInfo> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class FileInfo_IsEmpty_Assertion : .<.FileInfo>
    {
        public FileInfo_IsEmpty_Assertion(.<.FileInfo> context) { }
        protected override .<.> CheckAsync(.<.FileInfo> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class FileInfo_IsHidden_Assertion : .<.FileInfo>
    {
        public FileInfo_IsHidden_Assertion(.<.FileInfo> context) { }
        protected override .<.> CheckAsync(.<.FileInfo> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class FileInfo_IsNotEmpty_Assertion : .<.FileInfo>
    {
        public FileInfo_IsNotEmpty_Assertion(.<.FileInfo> context) { }
        protected override .<.> CheckAsync(.<.FileInfo> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class FileInfo_IsNotHidden_Assertion : .<.FileInfo>
    {
        public FileInfo_IsNotHidden_Assertion(.<.FileInfo> context) { }
        protected override .<.> CheckAsync(.<.FileInfo> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class FileInfo_IsSystemFile_Assertion : .<.FileInfo>
    {
        public FileInfo_IsSystemFile_Assertion(.<.FileInfo> context) { }
        protected override .<.> CheckAsync(.<.FileInfo> metadata) { }
        protected override string GetExpectation() { }
    }
    public static class FileIsNotExecutableAssertionExtensions
    {
        public static . IsNotExecutable(this .<.FileInfo> source) { }
    }
    public static class FileIsNotSystemAssertionExtensions
    {
        public static . IsNotSystem(this .<.FileInfo> source) { }
    }
    public static class FloatEqualsAssertionExtensions
    {
        public static . IsEqualTo(this .<float> source, float expected, [.("expected")] string? expectedExpression = null) { }
    }
    public static class GreaterThanAssertionExtensions
    {
        public static .<TValue> IsGreaterThan<TValue>(this .<TValue> source, TValue minimum, [.("minimum")] string? minimumExpression = null)
            where TValue : <TValue> { }
    }
    public static class GreaterThanOrEqualAssertionExtensions
    {
        public static .<TValue> IsGreaterThanOrEqualTo<TValue>(this .<TValue> source, TValue minimum, [.("minimum")] string? minimumExpression = null)
            where TValue : <TValue> { }
    }
    public static class GuidAssertionExtensions
    {
        public static ._IsEmptyGuid_Assertion IsEmptyGuid(this .<> source) { }
        public static ._IsNotEmptyGuid_Assertion IsNotEmptyGuid(this .<> source) { }
    }
    public sealed class Guid_IsEmptyGuid_Assertion : .<>
    {
        public Guid_IsEmptyGuid_Assertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class Guid_IsNotEmptyGuid_Assertion : .<>
    {
        public Guid_IsNotEmptyGuid_Assertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public static class HasSingleItemAssertionExtensions
    {
        public static .<TCollection, TItem> HasSingleItem<TCollection, TItem>(this .<TCollection> source)
            where TCollection : .<TItem> { }
    }
    public static class HttpStatusCodeAssertionExtensions
    {
        public static ._IsClientError_Assertion IsClientError(this .<.HttpStatusCode> source) { }
        public static ._IsError_Assertion IsError(this .<.HttpStatusCode> source) { }
        public static ._IsInformational_Assertion IsInformational(this .<.HttpStatusCode> source) { }
        public static ._IsNotSuccess_Assertion IsNotSuccess(this .<.HttpStatusCode> source) { }
        public static ._IsRedirection_Assertion IsRedirection(this .<.HttpStatusCode> source) { }
        public static ._IsServerError_Assertion IsServerError(this .<.HttpStatusCode> source) { }
        public static ._IsSuccess_Assertion IsSuccess(this .<.HttpStatusCode> source) { }
    }
    public sealed class HttpStatusCode_IsClientError_Assertion : .<.HttpStatusCode>
    {
        public HttpStatusCode_IsClientError_Assertion(.<.HttpStatusCode> context) { }
        protected override .<.> CheckAsync(.<.HttpStatusCode> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class HttpStatusCode_IsError_Assertion : .<.HttpStatusCode>
    {
        public HttpStatusCode_IsError_Assertion(.<.HttpStatusCode> context) { }
        protected override .<.> CheckAsync(.<.HttpStatusCode> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class HttpStatusCode_IsInformational_Assertion : .<.HttpStatusCode>
    {
        public HttpStatusCode_IsInformational_Assertion(.<.HttpStatusCode> context) { }
        protected override .<.> CheckAsync(.<.HttpStatusCode> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class HttpStatusCode_IsNotSuccess_Assertion : .<.HttpStatusCode>
    {
        public HttpStatusCode_IsNotSuccess_Assertion(.<.HttpStatusCode> context) { }
        protected override .<.> CheckAsync(.<.HttpStatusCode> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class HttpStatusCode_IsRedirection_Assertion : .<.HttpStatusCode>
    {
        public HttpStatusCode_IsRedirection_Assertion(.<.HttpStatusCode> context) { }
        protected override .<.> CheckAsync(.<.HttpStatusCode> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class HttpStatusCode_IsServerError_Assertion : .<.HttpStatusCode>
    {
        public HttpStatusCode_IsServerError_Assertion(.<.HttpStatusCode> context) { }
        protected override .<.> CheckAsync(.<.HttpStatusCode> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class HttpStatusCode_IsSuccess_Assertion : .<.HttpStatusCode>
    {
        public HttpStatusCode_IsSuccess_Assertion(.<.HttpStatusCode> context) { }
        protected override .<.> CheckAsync(.<.HttpStatusCode> metadata) { }
        protected override string GetExpectation() { }
    }
    [.("Trimming", "IL2091", Justification="Generic type parameter is only used for property access, not instantiation")]
    public sealed class IEnumerableT_IsNotSingleElement_Assertion<T> : .<.<T>>
    {
        public IEnumerableT_IsNotSingleElement_Assertion(.<.<T>> context) { }
        protected override .<.> CheckAsync(.<.<T>> metadata) { }
        protected override string GetExpectation() { }
    }
    [.("Trimming", "IL2091", Justification="Generic type parameter is only used for property access, not instantiation")]
    public sealed class IEnumerableT_IsSingleElement_Assertion<T> : .<.<T>>
    {
        public IEnumerableT_IsSingleElement_Assertion(.<.<T>> context) { }
        protected override .<.> CheckAsync(.<.<T>> metadata) { }
        protected override string GetExpectation() { }
    }
    public static class IPAddressAssertionExtensions
    {
        public static .4MappedToIPv6Assertion IsIPv4MappedToIPv6(this .<.IPAddress> source) { }
        public static .6LinkLocalAssertion IsIPv6LinkLocal(this .<.IPAddress> source) { }
        public static .6MulticastAssertion IsIPv6Multicast(this .<.IPAddress> source) { }
        public static .6SiteLocalAssertion IsIPv6SiteLocal(this .<.IPAddress> source) { }
        public static .6TeredoAssertion IsIPv6Teredo(this .<.IPAddress> source) { }
        public static .4MappedToIPv6Assertion IsNotIPv4MappedToIPv6(this .<.IPAddress> source) { }
        public static .6LinkLocalAssertion IsNotIPv6LinkLocal(this .<.IPAddress> source) { }
        public static .6MulticastAssertion IsNotIPv6Multicast(this .<.IPAddress> source) { }
        public static .6SiteLocalAssertion IsNotIPv6SiteLocal(this .<.IPAddress> source) { }
        public static .6TeredoAssertion IsNotIPv6Teredo(this .<.IPAddress> source) { }
    }
    public class IPAddressIsIPv4MappedToIPv6Assertion : .<.IPAddress>
    {
        public IPAddressIsIPv4MappedToIPv6Assertion(.<.IPAddress> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<.IPAddress> metadata) { }
        protected override string GetExpectation() { }
    }
    public class IPAddressIsIPv6LinkLocalAssertion : .<.IPAddress>
    {
        public IPAddressIsIPv6LinkLocalAssertion(.<.IPAddress> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<.IPAddress> metadata) { }
        protected override string GetExpectation() { }
    }
    public class IPAddressIsIPv6MulticastAssertion : .<.IPAddress>
    {
        public IPAddressIsIPv6MulticastAssertion(.<.IPAddress> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<.IPAddress> metadata) { }
        protected override string GetExpectation() { }
    }
    public class IPAddressIsIPv6SiteLocalAssertion : .<.IPAddress>
    {
        public IPAddressIsIPv6SiteLocalAssertion(.<.IPAddress> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<.IPAddress> metadata) { }
        protected override string GetExpectation() { }
    }
    public class IPAddressIsIPv6TeredoAssertion : .<.IPAddress>
    {
        public IPAddressIsIPv6TeredoAssertion(.<.IPAddress> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<.IPAddress> metadata) { }
        protected override string GetExpectation() { }
    }
    public static class IndexAssertionExtensions
    {
        public static . IsFromEnd(this .<> source) { }
        public static . IsNotFromEnd(this .<> source) { }
    }
    public class IndexIsFromEndAssertion : .<>
    {
        public IndexIsFromEndAssertion(.<> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public static class IntAssertions
    {
        public static ._IsEven_Assertion IsEven(this .<int> source) { }
        public static ._IsOdd_Assertion IsOdd(this .<int> source) { }
    }
    public static class IntEqualsAssertionExtensions
    {
        public static . IsEqualTo(this .<int> source, int expected, [.("expected")] string? expectedExpression = null) { }
    }
    public sealed class Int_IsEven_Assertion : .<int>
    {
        public Int_IsEven_Assertion(.<int> context) { }
        protected override .<.> CheckAsync(.<int> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class Int_IsOdd_Assertion : .<int>
    {
        public Int_IsOdd_Assertion(.<int> context) { }
        protected override .<.> CheckAsync(.<int> metadata) { }
        protected override string GetExpectation() { }
    }
    public static class IsAssignableToAssertionExtensions
    {
        public static .<TTarget, TValue> IsAssignableTo<TTarget, TValue>(this .<TValue> source) { }
    }
    public static class IsDefaultAssertionExtensions
    {
        public static .<TValue> IsDefault<TValue>(this .<TValue> source)
            where TValue :  struct { }
    }
    public static class IsDefaultNullableAssertionExtensions
    {
        public static .<TValue> IsDefault<TValue>(this .<TValue?> source)
            where TValue :  struct { }
    }
    public static class IsDefaultReferenceAssertionExtensions
    {
        public static .<TValue> IsDefault<TValue>(this .<TValue> source)
            where TValue :  class { }
    }
    public static class IsEquatableOrEqualToAssertionExtensions
    {
        public static .<TValue> IsEquatableOrEqualTo<TValue>(this .<TValue> source, TValue expected, [.("expected")] string? expectedExpression = null) { }
    }
    public static class IsEquivalentToAssertionExtensions
    {
        [.("Collection equivalency uses structural comparison for complex objects, which requ" +
            "ires reflection and is not compatible with AOT")]
        public static .<TCollection, TItem> IsEquivalentTo<TCollection, TItem>(this .<TCollection> source, .<TItem> expected, . ordering = 0, [.("expected")] string? expectedExpression = null, [.("ordering")] string? orderingExpression = null)
            where TCollection : .<TItem> { }
        [.("Collection equivalency uses structural comparison for complex objects, which requ" +
            "ires reflection and is not compatible with AOT")]
        public static .<TCollection, TItem> IsEquivalentTo<TCollection, TItem>(this .<TCollection> source, .<TItem> expected, .<TItem> comparer, . ordering = 0, [.("expected")] string? expectedExpression = null, [.("comparer")] string? comparerExpression = null, [.("ordering")] string? orderingExpression = null)
            where TCollection : .<TItem> { }
    }
    public static class IsInAssertionExtensions
    {
        public static .<TValue> IsIn<TValue>(this .<TValue> source, .<TValue> collection, [.("collection")] string? collectionExpression = null) { }
    }
    public static class IsNotAssignableToAssertionExtensions
    {
        public static .<TTarget, TValue> IsNotAssignableTo<TTarget, TValue>(this .<TValue> source) { }
    }
    public static class IsNotDefaultAssertionExtensions
    {
        public static .<TValue> IsNotDefault<TValue>(this .<TValue> source)
            where TValue :  struct { }
    }
    public static class IsNotDefaultNullableAssertionExtensions
    {
        public static .<TValue> IsNotDefault<TValue>(this .<TValue?> source)
            where TValue :  struct { }
    }
    public static class IsNotDefaultReferenceAssertionExtensions
    {
        public static .<TValue> IsNotDefault<TValue>(this .<TValue> source)
            where TValue :  class { }
    }
    public static class IsNotInAssertionExtensions
    {
        public static .<TValue> IsNotIn<TValue>(this .<TValue> source, .<TValue> collection, [.("collection")] string? collectionExpression = null) { }
    }
    public static class LazyAssertionExtensions
    {
        [.("Trimming", "IL2091", Justification="Generic type parameter is only used for property access, not instantiation")]
        public static ._IsValueCreated_Assertion<T> IsValueCreated<T>(this .<<T>> source) { }
        [.("Trimming", "IL2091", Justification="Generic type parameter is only used for property access, not instantiation")]
        public static ._IsValueNotCreated_Assertion<T> IsValueNotCreated<T>(this .<<T>> source) { }
    }
    [.("Trimming", "IL2091", Justification="Generic type parameter is only used for property access, not instantiation")]
    public sealed class LazyT_IsValueCreated_Assertion<T> : .<<T>>
    {
        public LazyT_IsValueCreated_Assertion(.<<T>> context) { }
        protected override .<.> CheckAsync(.<<T>> metadata) { }
        protected override string GetExpectation() { }
    }
    [.("Trimming", "IL2091", Justification="Generic type parameter is only used for property access, not instantiation")]
    public sealed class LazyT_IsValueNotCreated_Assertion<T> : .<<T>>
    {
        public LazyT_IsValueNotCreated_Assertion(.<<T>> context) { }
        protected override .<.> CheckAsync(.<<T>> metadata) { }
        protected override string GetExpectation() { }
    }
    public static class LessThanAssertionExtensions
    {
        public static .<TValue> IsLessThan<TValue>(this .<TValue> source, TValue maximum, [.("maximum")] string? maximumExpression = null)
            where TValue : <TValue> { }
    }
    public static class LessThanOrEqualAssertionExtensions
    {
        public static .<TValue> IsLessThanOrEqualTo<TValue>(this .<TValue> source, TValue maximum, [.("maximum")] string? maximumExpression = null)
            where TValue : <TValue> { }
    }
    public static class LongEqualsAssertionExtensions
    {
        public static . IsEqualTo(this .<long> source, long expected, [.("expected")] string? expectedExpression = null) { }
    }
    public static class NotEqualsAssertionExtensions
    {
        public static .<TValue> IsNotEqualTo<TValue>(this .<TValue> source, TValue notExpected, .<TValue>? comparer = null, [.("notExpected")] string? notExpectedExpression = null, [.("comparer")] string? comparerExpression = null) { }
    }
    public static class NotEquivalentToAssertionExtensions
    {
        [.("Collection equivalency uses structural comparison for complex objects, which requ" +
            "ires reflection and is not compatible with AOT")]
        public static .<TCollection, TItem> IsNotEquivalentTo<TCollection, TItem>(this .<TCollection> source, .<TItem> notExpected, . ordering = 0, [.("notExpected")] string? notExpectedExpression = null, [.("ordering")] string? orderingExpression = null)
            where TCollection : .<TItem> { }
    }
    public static class NotSameReferenceAssertionExtensions
    {
        public static .<TValue> IsNotSameReferenceAs<TValue>(this .<TValue> source, object? expected, [.("expected")] string? expectedExpression = null) { }
    }
    public static class NullAssertionExtensions
    {
        public static .<TValue> IsNull<TValue>(this .<TValue> source) { }
    }
    public sealed class NullableBool_IsFalse_Assertion : .<bool?>
    {
        public NullableBool_IsFalse_Assertion(.<bool?> context) { }
        protected override .<.> CheckAsync(.<bool?> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class NullableBool_IsTrue_Assertion : .<bool?>
    {
        public NullableBool_IsTrue_Assertion(.<bool?> context) { }
        protected override .<.> CheckAsync(.<bool?> metadata) { }
        protected override string GetExpectation() { }
    }
    public static class NullableEquatableAssertionExtensions
    {
        public static .<TActual, TExpected> IsEquatableTo<TActual, TExpected>(this .<TActual?> source, TExpected expected, [.("expected")] string? expectedExpression = null)
            where TActual :  struct, <TExpected> { }
    }
    public static class ProcessAssertionExtensions
    {
        public static . DoesNotHaveEventRaisingEnabled(this .<.Process> source) { }
        public static . EnableRaisingEvents(this .<.Process> source) { }
        public static . HasExited(this .<.Process> source) { }
        public static . HasNotExited(this .<.Process> source) { }
        public static . IsNotResponding(this .<.Process> source) { }
        public static . Responding(this .<.Process> source) { }
    }
    public class ProcessEnableRaisingEventsAssertion : .<.Process>
    {
        public ProcessEnableRaisingEventsAssertion(.<.Process> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<.Process> metadata) { }
        protected override string GetExpectation() { }
    }
    public class ProcessHasExitedAssertion : .<.Process>
    {
        public ProcessHasExitedAssertion(.<.Process> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<.Process> metadata) { }
        protected override string GetExpectation() { }
    }
    public class ProcessRespondingAssertion : .<.Process>
    {
        public ProcessRespondingAssertion(.<.Process> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<.Process> metadata) { }
        protected override string GetExpectation() { }
    }
    public static class PropertyAssertionExtensions
    {
        public static .<TObject, TProperty> HasProperty<TObject, TProperty>(this .<TObject> source, .<<TObject, TProperty>> propertySelector) { }
        public static .<TObject> HasProperty<TObject, TProperty>(this .<TObject> source, .<<TObject, TProperty>> propertySelector, TProperty expectedValue, [.("expectedValue")] string? expression = null) { }
    }
    public static class RangeAssertionExtensions
    {
        public static ._HasBothIndicesFromEnd_Assertion HasBothIndicesFromEnd(this .<> source) { }
        public static ._HasEndFromBeginning_Assertion HasEndFromBeginning(this .<> source) { }
        public static ._HasStartFromBeginning_Assertion HasStartFromBeginning(this .<> source) { }
        public static ._IsAll_Assertion IsAll(this .<> source) { }
    }
    public sealed class Range_HasBothIndicesFromEnd_Assertion : .<>
    {
        public Range_HasBothIndicesFromEnd_Assertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class Range_HasEndFromBeginning_Assertion : .<>
    {
        public Range_HasEndFromBeginning_Assertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class Range_HasStartFromBeginning_Assertion : .<>
    {
        public Range_HasStartFromBeginning_Assertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class Range_IsAll_Assertion : .<>
    {
        public Range_IsAll_Assertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public static class SameReferenceAssertionExtensions
    {
        public static .<TValue> IsSameReferenceAs<TValue>(this .<TValue> source, object? expected, [.("expected")] string? expectedExpression = null) { }
    }
    public static class StreamAssertionExtensions
    {
        public static . CanRead(this .<.Stream> source) { }
        public static . CanSeek(this .<.Stream> source) { }
        public static . CanTimeout(this .<.Stream> source) { }
        public static . CanWrite(this .<.Stream> source) { }
        public static . CannotRead(this .<.Stream> source) { }
        public static . CannotSeek(this .<.Stream> source) { }
        public static . CannotTimeout(this .<.Stream> source) { }
        public static . CannotWrite(this .<.Stream> source) { }
        public static ._IsAtEnd_Assertion IsAtEnd(this .<.Stream> source) { }
        public static ._IsAtStart_Assertion IsAtStart(this .<.Stream> source) { }
        public static ._IsEmpty_Assertion IsEmpty(this .<.Stream> source) { }
        public static ._IsNotEmpty_Assertion IsNotEmpty(this .<.Stream> source) { }
    }
    public class StreamCanReadAssertion : .<.Stream>
    {
        public StreamCanReadAssertion(.<.Stream> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<.Stream> metadata) { }
        protected override string GetExpectation() { }
    }
    public class StreamCanSeekAssertion : .<.Stream>
    {
        public StreamCanSeekAssertion(.<.Stream> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<.Stream> metadata) { }
        protected override string GetExpectation() { }
    }
    public class StreamCanTimeoutAssertion : .<.Stream>
    {
        public StreamCanTimeoutAssertion(.<.Stream> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<.Stream> metadata) { }
        protected override string GetExpectation() { }
    }
    public class StreamCanWriteAssertion : .<.Stream>
    {
        public StreamCanWriteAssertion(.<.Stream> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<.Stream> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class Stream_IsAtEnd_Assertion : .<.Stream>
    {
        public Stream_IsAtEnd_Assertion(.<.Stream> context) { }
        protected override .<.> CheckAsync(.<.Stream> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class Stream_IsAtStart_Assertion : .<.Stream>
    {
        public Stream_IsAtStart_Assertion(.<.Stream> context) { }
        protected override .<.> CheckAsync(.<.Stream> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class Stream_IsEmpty_Assertion : .<.Stream>
    {
        public Stream_IsEmpty_Assertion(.<.Stream> context) { }
        protected override .<.> CheckAsync(.<.Stream> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class Stream_IsNotEmpty_Assertion : .<.Stream>
    {
        public Stream_IsNotEmpty_Assertion(.<.Stream> context) { }
        protected override .<.> CheckAsync(.<.Stream> metadata) { }
        protected override string GetExpectation() { }
    }
    public static class StringBuilderAssertionExtensions
    {
        public static ._HasExcessCapacity_Assertion HasExcessCapacity(this .<.StringBuilder> source) { }
        public static ._IsEmpty_Assertion IsEmpty(this .<.StringBuilder> source) { }
        public static ._IsNotEmpty_Assertion IsNotEmpty(this .<.StringBuilder> source) { }
    }
    public sealed class StringBuilder_HasExcessCapacity_Assertion : .<.StringBuilder>
    {
        public StringBuilder_HasExcessCapacity_Assertion(.<.StringBuilder> context) { }
        protected override .<.> CheckAsync(.<.StringBuilder> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class StringBuilder_IsEmpty_Assertion : .<.StringBuilder>
    {
        public StringBuilder_IsEmpty_Assertion(.<.StringBuilder> context) { }
        protected override .<.> CheckAsync(.<.StringBuilder> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class StringBuilder_IsNotEmpty_Assertion : .<.StringBuilder>
    {
        public StringBuilder_IsNotEmpty_Assertion(.<.StringBuilder> context) { }
        protected override .<.> CheckAsync(.<.StringBuilder> metadata) { }
        protected override string GetExpectation() { }
    }
    public static class StringContainsAssertionExtensions
    {
        public static . Contains(this .<string> source, string expected, [.("expected")] string? expectedExpression = null) { }
        public static . Contains(this .<string> source, string expected,  comparison, [.("expected")] string? expectedExpression = null, [.("comparison")] string? comparisonExpression = null) { }
    }
    public static class StringDoesNotContainAssertionExtensions
    {
        public static . DoesNotContain(this .<string> source, string expected, [.("expected")] string? expectedExpression = null) { }
        public static . DoesNotContain(this .<string> source, string expected,  comparison, [.("expected")] string? expectedExpression = null, [.("comparison")] string? comparisonExpression = null) { }
    }
    public static class StringDoesNotMatchAssertionExtensions
    {
        public static . DoesNotMatch(this .<string> source, . regex, [.("regex")] string? regexExpression = null) { }
        public static . DoesNotMatch(this .<string> source, string pattern, [.("pattern")] string? patternExpression = null) { }
    }
    public static class StringEndsWithAssertionExtensions
    {
        public static . EndsWith(this .<string> source, string expected, [.("expected")] string? expectedExpression = null) { }
        public static . EndsWith(this .<string> source, string expected,  comparison, [.("expected")] string? expectedExpression = null, [.("comparison")] string? comparisonExpression = null) { }
    }
    public static class StringEqualsAssertionExtensions
    {
        public static . IsEqualTo(this .<string> source, string? expected, [.("expected")] string? expectedExpression = null) { }
    }
    public static class StringIsEmptyAssertionExtensions
    {
        public static . IsEmpty(this .<string> source) { }
    }
    public static class StringIsNotEmptyAssertionExtensions
    {
        public static . IsNotEmpty(this .<string> source) { }
    }
    public class StringIsNullOrEmptyWithStringAssertion : .<string>
    {
        public StringIsNullOrEmptyWithStringAssertion(.<string> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<string> metadata) { }
        protected override string GetExpectation() { }
    }
    public class StringIsNullOrWhiteSpaceWithStringAssertion : .<string>
    {
        public StringIsNullOrWhiteSpaceWithStringAssertion(.<string> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<string> metadata) { }
        protected override string GetExpectation() { }
    }
    public static class StringMatchesAssertionExtensions
    {
        public static . Matches(this .<string> source, . regex, [.("regex")] string? regexExpression = null) { }
        public static . Matches(this .<string> source, string pattern, [.("pattern")] string? patternExpression = null) { }
    }
    public static class StringStartsWithAssertionExtensions
    {
        public static . StartsWith(this .<string> source, string expected, [.("expected")] string? expectedExpression = null) { }
        public static . StartsWith(this .<string> source, string expected,  comparison, [.("expected")] string? expectedExpression = null, [.("comparison")] string? comparisonExpression = null) { }
    }
    public static class StringStaticMethodAssertions
    {
        public static . IsNotNullOrEmpty(this .<string> source) { }
        public static . IsNotNullOrWhiteSpace(this .<string> source) { }
        public static . IsNullOrEmpty(this .<string> source) { }
        public static . IsNullOrWhiteSpace(this .<string> source) { }
    }
    public static class TaskAssertionExtensions
    {
        public static .<TTask> IsCanceled<TTask>(this .<TTask> source)
            where TTask : . { }
        public static .<TTask> IsCompleted<TTask>(this .<TTask> source)
            where TTask : . { }
        public static .<TTask> IsCompletedSuccessfully<TTask>(this .<TTask> source)
            where TTask : . { }
        public static .<TTask> IsFaulted<TTask>(this .<TTask> source)
            where TTask : . { }
        public static .<TTask> IsNotCanceled<TTask>(this .<TTask> source)
            where TTask : . { }
        public static .<TTask> IsNotCompleted<TTask>(this .<TTask> source)
            where TTask : . { }
        public static .<TTask> IsNotCompletedSuccessfully<TTask>(this .<TTask> source)
            where TTask : . { }
        public static .<TTask> IsNotFaulted<TTask>(this .<TTask> source)
            where TTask : . { }
    }
    public class TaskIsCanceledAssertion<TTask> : .<TTask>
        where TTask : .
    {
        public TaskIsCanceledAssertion(.<TTask> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<TTask> metadata) { }
        protected override string GetExpectation() { }
    }
    public class TaskIsCompletedAssertion<TTask> : .<TTask>
        where TTask : .
    {
        public TaskIsCompletedAssertion(.<TTask> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<TTask> metadata) { }
        protected override string GetExpectation() { }
    }
    public class TaskIsCompletedSuccessfullyAssertion<TTask> : .<TTask>
        where TTask : .
    {
        public TaskIsCompletedSuccessfullyAssertion(.<TTask> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<TTask> metadata) { }
        protected override string GetExpectation() { }
    }
    public class TaskIsFaultedAssertion<TTask> : .<TTask>
        where TTask : .
    {
        public TaskIsFaultedAssertion(.<TTask> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<TTask> metadata) { }
        protected override string GetExpectation() { }
    }
    public static class ThreadAssertionExtensions
    {
        public static . IsAlive(this .<.Thread> source) { }
        public static . IsBackground(this .<.Thread> source) { }
        public static . IsNotAlive(this .<.Thread> source) { }
        public static . IsNotBackground(this .<.Thread> source) { }
        public static . IsNotThreadPoolThread(this .<.Thread> source) { }
        public static . IsThreadPoolThread(this .<.Thread> source) { }
    }
    public class ThreadIsAliveAssertion : .<.Thread>
    {
        public ThreadIsAliveAssertion(.<.Thread> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<.Thread> metadata) { }
        protected override string GetExpectation() { }
    }
    public class ThreadIsBackgroundAssertion : .<.Thread>
    {
        public ThreadIsBackgroundAssertion(.<.Thread> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<.Thread> metadata) { }
        protected override string GetExpectation() { }
    }
    public class ThreadIsThreadPoolThreadAssertion : .<.Thread>
    {
        public ThreadIsThreadPoolThreadAssertion(.<.Thread> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<.Thread> metadata) { }
        protected override string GetExpectation() { }
    }
    public static class TimeOnlyAssertionExtensions
    {
        public static ._IsAM_Assertion IsAM(this .<> source) { }
        public static ._IsEndOfHour_Assertion IsEndOfHour(this .<> source) { }
        public static ._IsMidnight_Assertion IsMidnight(this .<> source) { }
        public static ._IsNoon_Assertion IsNoon(this .<> source) { }
        public static ._IsNotMidnight_Assertion IsNotMidnight(this .<> source) { }
        public static ._IsPM_Assertion IsPM(this .<> source) { }
        public static ._IsStartOfHour_Assertion IsStartOfHour(this .<> source) { }
    }
    public static class TimeOnlyEqualsAssertionExtensions
    {
        public static . IsEqualTo(this .<> source,  expected, [.("expected")] string? expectedExpression = null) { }
    }
    public sealed class TimeOnly_IsAM_Assertion : .<>
    {
        public TimeOnly_IsAM_Assertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class TimeOnly_IsEndOfHour_Assertion : .<>
    {
        public TimeOnly_IsEndOfHour_Assertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class TimeOnly_IsMidnight_Assertion : .<>
    {
        public TimeOnly_IsMidnight_Assertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class TimeOnly_IsNoon_Assertion : .<>
    {
        public TimeOnly_IsNoon_Assertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class TimeOnly_IsNotMidnight_Assertion : .<>
    {
        public TimeOnly_IsNotMidnight_Assertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class TimeOnly_IsPM_Assertion : .<>
    {
        public TimeOnly_IsPM_Assertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class TimeOnly_IsStartOfHour_Assertion : .<>
    {
        public TimeOnly_IsStartOfHour_Assertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public static class TimeSpanAssertionExtensions
    {
        public static ._IsNegative_Assertion IsNegative(this .<> source) { }
        public static ._IsNonNegative_Assertion IsNonNegative(this .<> source) { }
        public static ._IsNonPositive_Assertion IsNonPositive(this .<> source) { }
        public static ._IsNotZero_Assertion IsNotZero(this .<> source) { }
        public static ._IsPositive_Assertion IsPositive(this .<> source) { }
        public static ._IsZero_Assertion IsZero(this .<> source) { }
    }
    public static class TimeSpanEqualsAssertionExtensions
    {
        public static . IsEqualTo(this .<> source,  expected, [.("expected")] string? expectedExpression = null) { }
    }
    public sealed class TimeSpan_IsNegative_Assertion : .<>
    {
        public TimeSpan_IsNegative_Assertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class TimeSpan_IsNonNegative_Assertion : .<>
    {
        public TimeSpan_IsNonNegative_Assertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class TimeSpan_IsNonPositive_Assertion : .<>
    {
        public TimeSpan_IsNonPositive_Assertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class TimeSpan_IsNotZero_Assertion : .<>
    {
        public TimeSpan_IsNotZero_Assertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class TimeSpan_IsPositive_Assertion : .<>
    {
        public TimeSpan_IsPositive_Assertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class TimeSpan_IsZero_Assertion : .<>
    {
        public TimeSpan_IsZero_Assertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public static class TimeZoneInfoAssertionExtensions
    {
        public static . DoesNotHaveIanaId(this .<> source) { }
        public static . DoesNotSupportDaylightSavingTime(this .<> source) { }
        public static . HasIanaId(this .<> source) { }
        public static . SupportsDaylightSavingTime(this .<> source) { }
    }
    public class TimeZoneInfoHasIanaIdAssertion : .<>
    {
        public TimeZoneInfoHasIanaIdAssertion(.<> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public class TimeZoneInfoSupportsDaylightSavingTimeAssertion : .<>
    {
        public TimeZoneInfoSupportsDaylightSavingTimeAssertion(.<> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public static class TypeAssertionExtensions
    {
        public static . ContainsGenericParameters(this .<> source) { }
        public static . DoesNotContainGenericParameters(this .<> source) { }
        public static . IsAbstract(this .<> source) { }
        public static . IsArray(this .<> source) { }
        public static . IsByRef(this .<> source) { }
        public static . IsByRefLike(this .<> source) { }
        public static . IsCOMObject(this .<> source) { }
        public static . IsClass(this .<> source) { }
        public static . IsConstructedGenericType(this .<> source) { }
        public static . IsEnum(this .<> source) { }
        public static . IsGenericType(this .<> source) { }
        public static . IsGenericTypeDefinition(this .<> source) { }
        public static . IsInterface(this .<> source) { }
        public static . IsNested(this .<> source) { }
        public static . IsNestedAssembly(this .<> source) { }
        public static . IsNestedFamily(this .<> source) { }
        public static . IsNestedPrivate(this .<> source) { }
        public static . IsNestedPublic(this .<> source) { }
        public static . IsNotAbstract(this .<> source) { }
        public static . IsNotArray(this .<> source) { }
        public static . IsNotByRef(this .<> source) { }
        public static . IsNotByRefLike(this .<> source) { }
        public static . IsNotCOMObject(this .<> source) { }
        public static . IsNotClass(this .<> source) { }
        public static . IsNotConstructedGenericType(this .<> source) { }
        public static . IsNotEnum(this .<> source) { }
        public static . IsNotGenericType(this .<> source) { }
        public static . IsNotGenericTypeDefinition(this .<> source) { }
        public static . IsNotInterface(this .<> source) { }
        public static . IsNotNested(this .<> source) { }
        public static . IsNotNestedAssembly(this .<> source) { }
        public static . IsNotNestedFamily(this .<> source) { }
        public static . IsNotNestedPrivate(this .<> source) { }
        public static . IsNotNestedPublic(this .<> source) { }
        public static . IsNotPointer(this .<> source) { }
        public static . IsNotPrimitive(this .<> source) { }
        public static . IsNotPublic(this .<> source) { }
        public static . IsNotSealed(this .<> source) { }
        public static . IsNotValueType(this .<> source) { }
        public static . IsNotVisible(this .<> source) { }
        public static . IsPointer(this .<> source) { }
        public static . IsPrimitive(this .<> source) { }
        public static . IsPublic(this .<> source) { }
        public static . IsSealed(this .<> source) { }
        public static . IsValueType(this .<> source) { }
        public static . IsVisible(this .<> source) { }
    }
    public class TypeContainsGenericParametersAssertion : .<>
    {
        public TypeContainsGenericParametersAssertion(.<> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public class TypeIsAbstractAssertion : .<>
    {
        public TypeIsAbstractAssertion(.<> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public class TypeIsArrayAssertion : .<>
    {
        public TypeIsArrayAssertion(.<> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public class TypeIsByRefAssertion : .<>
    {
        public TypeIsByRefAssertion(.<> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public class TypeIsByRefLikeAssertion : .<>
    {
        public TypeIsByRefLikeAssertion(.<> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public class TypeIsCOMObjectAssertion : .<>
    {
        public TypeIsCOMObjectAssertion(.<> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public class TypeIsClassAssertion : .<>
    {
        public TypeIsClassAssertion(.<> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public class TypeIsConstructedGenericTypeAssertion : .<>
    {
        public TypeIsConstructedGenericTypeAssertion(.<> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public class TypeIsEnumAssertion : .<>
    {
        public TypeIsEnumAssertion(.<> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public class TypeIsGenericTypeAssertion : .<>
    {
        public TypeIsGenericTypeAssertion(.<> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public class TypeIsGenericTypeDefinitionAssertion : .<>
    {
        public TypeIsGenericTypeDefinitionAssertion(.<> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public class TypeIsInterfaceAssertion : .<>
    {
        public TypeIsInterfaceAssertion(.<> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public class TypeIsNestedAssemblyAssertion : .<>
    {
        public TypeIsNestedAssemblyAssertion(.<> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public class TypeIsNestedAssertion : .<>
    {
        public TypeIsNestedAssertion(.<> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public class TypeIsNestedFamilyAssertion : .<>
    {
        public TypeIsNestedFamilyAssertion(.<> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public class TypeIsNestedPrivateAssertion : .<>
    {
        public TypeIsNestedPrivateAssertion(.<> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public class TypeIsNestedPublicAssertion : .<>
    {
        public TypeIsNestedPublicAssertion(.<> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public class TypeIsPointerAssertion : .<>
    {
        public TypeIsPointerAssertion(.<> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public class TypeIsPrimitiveAssertion : .<>
    {
        public TypeIsPrimitiveAssertion(.<> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public class TypeIsPublicAssertion : .<>
    {
        public TypeIsPublicAssertion(.<> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public class TypeIsSealedAssertion : .<>
    {
        public TypeIsSealedAssertion(.<> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public class TypeIsValueTypeAssertion : .<>
    {
        public TypeIsValueTypeAssertion(.<> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public class TypeIsVisibleAssertion : .<>
    {
        public TypeIsVisibleAssertion(.<> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public static class UriAssertionExtensions
    {
        public static . IsAbsoluteUri(this .<> source) { }
        public static . IsDefaultPort(this .<> source) { }
        public static . IsFile(this .<> source) { }
        public static . IsLoopback(this .<> source) { }
        public static . IsNotAbsoluteUri(this .<> source) { }
        public static . IsNotDefaultPort(this .<> source) { }
        public static . IsNotFile(this .<> source) { }
        public static . IsNotLoopback(this .<> source) { }
        public static . IsNotUnc(this .<> source) { }
        public static . IsNotUserEscaped(this .<> source) { }
        public static . IsUnc(this .<> source) { }
        public static . UserEscaped(this .<> source) { }
    }
    public class UriIsAbsoluteUriAssertion : .<>
    {
        public UriIsAbsoluteUriAssertion(.<> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public class UriIsDefaultPortAssertion : .<>
    {
        public UriIsDefaultPortAssertion(.<> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public class UriIsFileAssertion : .<>
    {
        public UriIsFileAssertion(.<> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public class UriIsLoopbackAssertion : .<>
    {
        public UriIsLoopbackAssertion(.<> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public class UriIsUncAssertion : .<>
    {
        public UriIsUncAssertion(.<> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public class UriUserEscapedAssertion : .<>
    {
        public UriUserEscapedAssertion(.<> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public static class VersionAssertionExtensions
    {
        public static ._HasBuildNumber_Assertion HasBuildNumber(this .<> source) { }
        public static ._HasNoBuildNumber_Assertion HasNoBuildNumber(this .<> source) { }
        public static ._HasNoRevisionNumber_Assertion HasNoRevisionNumber(this .<> source) { }
        public static ._HasRevisionNumber_Assertion HasRevisionNumber(this .<> source) { }
        public static ._IsMajorVersion_Assertion IsMajorVersion(this .<> source) { }
        public static ._IsNotMajorVersion_Assertion IsNotMajorVersion(this .<> source) { }
    }
    public sealed class Version_HasBuildNumber_Assertion : .<>
    {
        public Version_HasBuildNumber_Assertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class Version_HasNoBuildNumber_Assertion : .<>
    {
        public Version_HasNoBuildNumber_Assertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class Version_HasNoRevisionNumber_Assertion : .<>
    {
        public Version_HasNoRevisionNumber_Assertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class Version_HasRevisionNumber_Assertion : .<>
    {
        public Version_HasRevisionNumber_Assertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class Version_IsMajorVersion_Assertion : .<>
    {
        public Version_IsMajorVersion_Assertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public sealed class Version_IsNotMajorVersion_Assertion : .<>
    {
        public Version_IsNotMajorVersion_Assertion(.<> context) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public static class WeakReferenceAssertionExtensions
    {
        public static . DoesNotTrackResurrection(this .<> source) { }
        public static . IsAlive(this .<> source) { }
        public static . IsNotAlive(this .<> source) { }
        public static . TrackResurrection(this .<> source) { }
    }
    public class WeakReferenceIsAliveAssertion : .<>
    {
        public WeakReferenceIsAliveAssertion(.<> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    public class WeakReferenceTrackResurrectionAssertion : .<>
    {
        public WeakReferenceTrackResurrectionAssertion(.<> context, bool negated = false) { }
        protected override .<.> CheckAsync(.<> metadata) { }
        protected override string GetExpectation() { }
    }
    [.("Trimming", "IL2091", Justification="Generic type parameter is only used for property access, not instantiation")]
    public sealed class _IsEmpty_Assertion<T> : .<T[]>
    {
        public _IsEmpty_Assertion(.<T[]> context) { }
        protected override .<.> CheckAsync(.<T[]> metadata) { }
        protected override string GetExpectation() { }
    }
    [.("Trimming", "IL2091", Justification="Generic type parameter is only used for property access, not instantiation")]
    public sealed class _IsNotEmpty_Assertion<T> : .<T[]>
    {
        public _IsNotEmpty_Assertion(.<T[]> context) { }
        protected override .<.> CheckAsync(.<T[]> metadata) { }
        protected override string GetExpectation() { }
    }
    [.("Trimming", "IL2091", Justification="Generic type parameter is only used for property access, not instantiation")]
    public sealed class _IsNotSingleElement_Assertion<T> : .<T[]>
    {
        public _IsNotSingleElement_Assertion(.<T[]> context) { }
        protected override .<.> CheckAsync(.<T[]> metadata) { }
        protected override string GetExpectation() { }
    }
    [.("Trimming", "IL2091", Justification="Generic type parameter is only used for property access, not instantiation")]
    public sealed class _IsSingleElement_Assertion<T> : .<T[]>
    {
        public _IsSingleElement_Assertion(.<T[]> context) { }
        protected override .<.> CheckAsync(.<T[]> metadata) { }
        protected override string GetExpectation() { }
    }
}
namespace .Sources
{
    public class AsyncDelegateAssertion : ., .<object?>, .<.>, .<object?>
    {
        public AsyncDelegateAssertion(<.> action, string? expression) { }
        public .<object?> Context { get; }
        public .<.> IsCanceled() { }
        public .<.> IsCompleted() { }
        public .<.> IsCompletedSuccessfully() { }
        public .<.> IsFaulted() { }
        public .<.> IsNotCanceled() { }
        public .<.> IsNotCompleted() { }
        public .<.> IsNotCompletedSuccessfully() { }
        public .<.> IsNotFaulted() { }
        public .<TException> Throws<TException>()
            where TException :  { }
        public .<TException> ThrowsExactly<TException>()
            where TException :  { }
    }
    public class AsyncFuncAssertion<TValue> : ., .<TValue>, .<TValue>
    {
        public AsyncFuncAssertion(<.<TValue?>> func, string? expression) { }
        public .<TValue> Context { get; }
        public .<TException> Throws<TException>()
            where TException :  { }
        public .<TException> ThrowsExactly<TException>()
            where TException :  { }
    }
    public abstract class CollectionAssertionBase<TCollection, TItem> : .<TCollection>, ., .<TCollection>
        where TCollection : .<TItem>
    {
        protected CollectionAssertionBase(.<TCollection> context) { }
        public new .<TCollection, TItem> And { get; }
        public new .<TCollection, TItem> Or { get; }
        public .<TCollection, TItem> All() { }
        public .<TCollection, TItem> All(<TItem, bool> predicate, [.("predicate")] string? expression = null) { }
        public .<TCollection, TItem> Any(<TItem, bool> predicate, [.("predicate")] string? expression = null) { }
        public .<TCollection, TItem> Contains(<TItem, bool> predicate, [.("predicate")] string? expression = null) { }
        public .<TCollection, TItem> Contains(TItem expected, [.("expected")] string? expression = null) { }
        public .<TCollection, TItem> ContainsOnly(<TItem, bool> predicate, [.("predicate")] string? expression = null) { }
        public .<TCollection, TItem> Count() { }
        public .<TCollection, TItem> Count(<TItem, bool> predicate, [.("predicate")] string? expression = null) { }
        public .<TCollection, TItem> DoesNotContain(<TItem, bool> predicate, [.("predicate")] string? expression = null) { }
        public .<TCollection, TItem> DoesNotContain(TItem expected, [.("expected")] string? expression = null) { }
        protected override string GetExpectation() { }
        public ..CountWrapper<TCollection, TItem> HasCount() { }
        public .<TCollection, TItem> HasCount(int expectedCount, [.("expectedCount")] string? expression = null) { }
        public .<TCollection, TItem> HasDistinctItems() { }
        public .<TCollection, TItem> HasSingleItem() { }
        public .<TCollection, TItem> IsEmpty() { }
        public .<TCollection, TItem> IsInDescendingOrder() { }
        public .<TCollection, TItem> IsInOrder() { }
        public .<TCollection, TItem> IsNotEmpty() { }
        public .<TCollection, TItem, TKey> IsOrderedBy<TKey>(<TItem, TKey> keySelector, [.("keySelector")] string? expression = null) { }
        public .<TCollection, TItem, TKey> IsOrderedBy<TKey>(<TItem, TKey> keySelector, .<TKey>? comparer, [.("keySelector")] string? selectorExpression = null, [.("comparer")] string? comparerExpression = null) { }
        public .<TCollection, TItem, TKey> IsOrderedByDescending<TKey>(<TItem, TKey> keySelector, [.("keySelector")] string? expression = null) { }
        public .<TCollection, TItem, TKey> IsOrderedByDescending<TKey>(<TItem, TKey> keySelector, .<TKey>? comparer, [.("keySelector")] string? selectorExpression = null, [.("comparer")] string? comparerExpression = null) { }
        public .<TCollection, TExpected> IsTypeOf<TExpected>() { }
    }
    public class CollectionAssertion<TItem> : .<.<TItem>, TItem>
    {
        public CollectionAssertion(.<TItem> value, string? expression) { }
    }
    public class DelegateAssertion : ., .<object?>, .<object?>
    {
        public DelegateAssertion( action, string? expression) { }
        public .<object?> Context { get; }
        public .<TException> Throws<TException>()
            where TException :  { }
        public .<TException> ThrowsExactly<TException>()
            where TException :  { }
    }
    public abstract class DictionaryAssertionBase<TDictionary, TKey, TValue> : .<TDictionary, .<TKey, TValue>>
        where TDictionary : .<TKey, TValue>
    {
        protected DictionaryAssertionBase(.<TDictionary> context) { }
        public new .<TDictionary, TKey, TValue> And { get; }
        public new .<TDictionary, TKey, TValue> Or { get; }
        public .<TDictionary, TKey, TValue> ContainsKey(TKey expectedKey, [.("expectedKey")] string? expression = null) { }
        public .<TDictionary, TKey, TValue> ContainsKey(TKey expectedKey, .<TKey>? comparer, [.("expectedKey")] string? keyExpression = null, [.("comparer")] string? comparerExpression = null) { }
        public .<TDictionary, TKey, TValue> DoesNotContainKey(TKey expectedKey, [.("expectedKey")] string? expression = null) { }
        protected override string GetExpectation() { }
    }
    public class DictionaryAssertion<TKey, TValue> : .<.<TKey, TValue>, TKey, TValue>
    {
        public DictionaryAssertion(.<TKey, TValue> value, string? expression) { }
    }
    public class FuncAssertion<TValue> : ., .<TValue>, .<TValue>
    {
        public FuncAssertion(<TValue?> func, string? expression) { }
        public .<TValue> Context { get; }
        public .<TException> Throws<TException>()
            where TException :  { }
        public .<TException> ThrowsExactly<TException>()
            where TException :  { }
    }
    public class TaskAssertion<TValue> : ., .<.<TValue?>>, .<TValue>, .<TValue>
    {
        public TaskAssertion(.<TValue?> task, string? expression) { }
        public .<TValue> Context { get; }
        public .<.<TValue>> IsCanceled() { }
        public .<.<TValue>> IsCompleted() { }
        public .<.<TValue>> IsCompletedSuccessfully() { }
        public .<.<TValue>> IsFaulted() { }
        public .<.<TValue>> IsNotCanceled() { }
        public .<.<TValue>> IsNotCompleted() { }
        public .<.<TValue>> IsNotCompletedSuccessfully() { }
        public .<.<TValue>> IsNotFaulted() { }
        public .<TException> Throws<TException>()
            where TException :  { }
        public .<TException> ThrowsExactly<TException>()
            where TException :  { }
    }
    public class ValueAssertion<TValue> : ., .<TValue>
    {
        protected ValueAssertion(.<TValue> context) { }
        public ValueAssertion(TValue? value, string? expression) { }
        public .<TValue> Context { get; }
        public .<TTarget, TValue> IsAssignableTo<TTarget>() { }
        public .<TTarget, TValue> IsNotAssignableTo<TTarget>() { }
        public .<TValue, TExpected> IsTypeOf<TExpected>() { }
    }
}