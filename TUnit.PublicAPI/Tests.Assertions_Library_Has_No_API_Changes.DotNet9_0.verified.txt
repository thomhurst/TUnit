[assembly: .(".NETCoreApp,Version=v9.0", FrameworkDisplayName=".NET 9.0")]
namespace 
{
    [.("Usage", "TUnitAssertions0002:Assert statements must be awaited")]
    public static class Assert
    {
        public static void Fail(string reason) { }
        public static  Multiple() { }
        public static .<object?> That( value, [.("value")] string? doNotPopulateThisValue = null) { }
        public static .<.<object>> That(.IEnumerable enumerable, [.("enumerable")] string? doNotPopulateThisValue = null) { }
        public static .<object?> That(<.> value, [.("value")] string? doNotPopulateThisValue = null) { }
        public static .<object?> That(. value, [.("value")] string? doNotPopulateThisValue = null) { }
        public static .<object?> That(. value, [.("value")] string? doNotPopulateThisValue = null) { }
        public static .<TActual> That<TActual>(<.<TActual>> value, [.("value")] string? doNotPopulateThisValue = null) { }
        public static .<TActual> That<TActual>(<TActual> value, [.("value")] string? doNotPopulateThisValue = null) { }
        public static .<TActual> That<TActual>(.<TActual> value, [.("value")] string? doNotPopulateThisValue = null) { }
        public static .<TActual> That<TActual>(.<TActual> value, [.("value")] string? doNotPopulateThisValue = null) { }
        public static .<TActual> That<TActual>(TActual value, [.("value")] string? doNotPopulateThisValue = null) { }
        public static .<object?> ThatAction<TActual>(<TActual> value, [.("value")] string? doNotPopulateThisValue = null) { }
        public static . Throws( @delegate, [.("delegate")] string? doNotPopulateThisValue = null) { }
        public static . Throws( exceptionType,  @delegate, [.("delegate")] string? doNotPopulateThisValue = null) { }
        public static .<TException> Throws<TException>( @delegate, [.("delegate")] string? doNotPopulateThisValue = null)
            where TException :  { }
        public static . ThrowsAsync(<.> @delegate, [.("delegate")] string? doNotPopulateThisValue = null) { }
        public static . ThrowsAsync(. task, [.("task")] string? doNotPopulateThisValue = null) { }
        public static . ThrowsAsync(. valueTask, [.("valueTask")] string? doNotPopulateThisValue = null) { }
        public static . ThrowsAsync( exceptionType, <.> @delegate, [.("delegate")] string? doNotPopulateThisValue = null) { }
        public static .<TException> ThrowsAsync<TException>(<.> @delegate, [.("delegate")] string? doNotPopulateThisValue = null)
            where TException :  { }
    }
    public readonly struct AssertionData : <.AssertionData>
    {
        public AssertionData(object? Result, ? Exception, string? ActualExpression,  Start,  End) { }
        public string? ActualExpression { get; init; }
        public  End { get; init; }
        public ? Exception { get; init; }
        public object? Result { get; init; }
        public  Start { get; init; }
        public static .AssertionData op_Implicit(<object?, ?, string?, , > tuple) { }
    }
    public class AssertionDecision : <.AssertionDecision>
    {
        public static .AssertionDecision Continue { get; }
        public static .AssertionDecision Pass { get; }
        public static .AssertionDecision Fail(string message) { }
    }
    public class AssertionMetadata
    {
        public AssertionMetadata() { }
        public  Duration { get; }
        public required  EndTime { get; init; }
        public required  StartTime { get; init; }
    }
    public static class Compare
    {
        public static .<.ComparisonFailure> CheckEquivalent<[.(..None | ..PublicFields | ..NonPublicFields | ..PublicProperties | ..NonPublicProperties)]  TActual, [.(..None | ..PublicFields | ..NonPublicFields | ..PublicProperties | ..NonPublicProperties)]  TExpected>(TActual actual, TExpected expected, .CompareOptions options, int? index) { }
    }
    public class CompareOptions : <.CompareOptions>
    {
        public CompareOptions() { }
        public . EquivalencyKind { get; set; }
        public string[] MembersToIgnore { get; init; }
        public [] TypesToIgnore { get; init; }
    }
    public class ComparisonFailure : <.ComparisonFailure>
    {
        public ComparisonFailure() { }
        public required object? Actual { get; init; }
        public required object? Expected { get; init; }
        public required string[] NestedMemberNames { get; init; }
        public required .MemberType Type { get; init; }
    }
    public static class Fail
    {
        [.]
        public static void Test(string reason) { }
        public static void Unless([.(false)] bool condition, string reason) { }
        public static void When([.(true)] bool condition, string reason) { }
    }
    public enum MemberType
    {
        Property = 0,
        Field = 1,
        Value = 2,
        EnumerableItem = 3,
        DictionaryItem = 4,
    }
}
namespace .AssertConditions
{
    public class AssertionResult
    {
        public bool IsPassed { get; }
        public string Message { get; }
        public static . Passed { get; }
        public . And(. other) { }
        public .<.> OrAsync(<.<.>> otherResult) { }
        public . OrFailIf(bool isFailed, [.("isFailed")] ..InterpolatedStringHandler stringHandler) { }
        public . OrFailIf(bool isFailed, string message) { }
        public static . Fail(string message) { }
        public static . FailIf(bool isFailed, [.("isFailed")] ..InterpolatedStringHandler stringHandler) { }
        public static . FailIf(bool isFailed, string message) { }
        public static .<.> op_Implicit(. result) { }
        public static .<.> op_Implicit(. result) { }
        [.]
        public readonly struct InterpolatedStringHandler
        {
            public InterpolatedStringHandler(int literalLength, int formattedCount, bool isFailed, out bool enabled) { }
            public void AppendFormatted<T>(T? t) { }
            public void AppendFormatted<T>(T? t, string format)
                where T :  { }
            public void AppendLiteral(string s) { }
        }
    }
    public abstract class BaseAssertCondition
    {
        protected BaseAssertCondition() { }
        public string? OverriddenMessage { get; }
        public string? Subject { get; }
        public virtual ? WaitFor { get; protected set; }
        public . FailWithMessage(string message) { }
        protected abstract string GetExpectation();
    }
    public abstract class BaseAssertCondition<TActual> : .
    {
        protected BaseAssertCondition() { }
        public string? ActualExpression { get; }
        public .<.> GetAssertionResult(TActual? actualValue, ? exception, .AssertionMetadata assertionMetadata, string? actualExpression = null) { }
        protected abstract .<.> GetResult(TActual? actualValue, ? exception, .AssertionMetadata assertionMetadata);
    }
    public enum ChainType
    {
        None = 0,
        And = 1,
        Or = 2,
    }
    public abstract class ConvertToAssertCondition<TFromType, TToType> : .<TFromType>
    {
        protected ConvertToAssertCondition() { }
        public TToType ConvertedValue { get; }
        public abstract .<<., TToType?>> ConvertValue(TFromType? value);
        protected override sealed .<.> GetResult(TFromType? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public abstract class DelegateAssertCondition : .<object?, >
    {
        protected DelegateAssertCondition() { }
    }
    public abstract class DelegateAssertCondition<TActual> : .<TActual, >
    {
        protected DelegateAssertCondition() { }
    }
    public abstract class DelegateAssertCondition<TActual, TException> : .<TActual>
        where TException : 
    {
        protected DelegateAssertCondition() { }
        protected override string GetExpectation() { }
        protected virtual string GetFailureMessage(TException? exception) { }
        protected override .<.> GetResult(TActual? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
        public void WithComparer(<TException?, .AssertionDecision> comparer) { }
    }
    public abstract class ExpectedExceptionDelegateAssertCondition<TException> : .<object?, >
    {
        protected ExpectedExceptionDelegateAssertCondition() { }
    }
    public abstract class ExpectedValueAssertCondition<TActual, TExpected> : .<TActual>
    {
        protected ExpectedValueAssertCondition(TExpected? expected) { }
        public TExpected ExpectedValue { get; }
        protected abstract .<.> GetResult(TActual? actualValue, TExpected? expectedValue);
        protected override .<.> GetResult(TActual? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
        public void WithComparer(<TActual?, TExpected?, .AssertionDecision> comparer) { }
        public void WithTransform(<TActual?, TActual?> actualTransformation, <TExpected?, TExpected?> expectedTransformation) { }
    }
    public class FailureLocation : <.>
    {
        public FailureLocation() { }
        public object? ActualValue { get; }
        public object? ExpectedValue { get; }
        public long Position { get; }
    }
    public class FuncValueAssertCondition<TActual, TExpected> : .<TActual, TExpected>
    {
        public FuncValueAssertCondition(TExpected? expected, <TActual?, TExpected?, .<TActual, TExpected>, bool> condition, <TActual?, ?, string?, string> defaultMessageFactory, string expectation) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(TActual? actualValue, TExpected? expectedValue) { }
    }
    public class NotNullExpectedValueAssertCondition<TActual> : .<TActual?, TActual>
        where TActual :  class?
    {
        public NotNullExpectedValueAssertCondition() { }
        public override .<<., TActual?>> ConvertValue(TActual? value) { }
        protected override string GetExpectation() { }
    }
    public class NotNullStructExpectedValueAssertCondition<TActual> : .<TActual?, TActual>
        where TActual :  struct
    {
        public NotNullStructExpectedValueAssertCondition() { }
        public override .<<., TActual>> ConvertValue(TActual? value) { }
        protected override string GetExpectation() { }
    }
    public class NullExpectedValueAssertCondition<TActual> : .<TActual>
    {
        public NullExpectedValueAssertCondition() { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(TActual? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public class StaticMethodAssertCondition<T> : .<T>
    {
        public StaticMethodAssertCondition(<T, bool> predicate, string methodName, bool negated = false) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(T? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
    }
    public abstract class StringMatcher
    {
        protected StringMatcher() { }
        public static ..RegexMatch AsRegex([.("regex")] string pattern) { }
        public static ..WildcardMatch AsWildcard(string pattern) { }
        public static . op_Implicit(. pattern) { }
        public static . op_Implicit(string pattern) { }
        public sealed class RegexMatch : .
        {
            public ..RegexMatch IgnoringCase(bool ignoreCase = true) { }
            public override string ToString() { }
        }
        public sealed class WildcardMatch : .
        {
            public ..WildcardMatch IgnoringCase(bool ignoreCase = true) { }
            public override string ToString() { }
        }
    }
    public abstract class ValueAssertCondition<TActual> : .<TActual>
    {
        protected ValueAssertCondition() { }
        protected override string GetExpectation() { }
        protected abstract string GetFailureMessage(TActual? actualValue);
        protected override .<.> GetResult(TActual? actualValue, ? exception, .AssertionMetadata assertionMetadata) { }
        protected abstract . Passes(TActual? actualValue);
        public void WithComparer(<TActual?, .AssertionDecision> comparer) { }
        public void WithTransform(<TActual?, TActual?> actualTransformation) { }
    }
}
namespace .
{
    public class ExceptionMessageContainingExpectedValueAssertCondition<TException> : .<TException, string>
        where TException : 
    {
        public ExceptionMessageContainingExpectedValueAssertCondition(string expected,  stringComparison) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(TException? actualValue, string? expectedValue) { }
    }
    public class ExceptionMessageEndingWithExpectedValueAssertCondition<TException> : .<TException, string>
        where TException : 
    {
        public ExceptionMessageEndingWithExpectedValueAssertCondition(string expected,  stringComparison) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(TException? actualValue, string? expectedValue) { }
    }
    public class ExceptionMessageEqualsExpectedValueAssertCondition<TException> : .<TException, string>
        where TException : 
    {
        public ExceptionMessageEqualsExpectedValueAssertCondition(string expected,  stringComparison) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(TException? actualValue, string? expectedValue) { }
    }
    public class ExceptionMessageMatchingExpectedAssertCondition<TException> : .<TException, .>
        where TException : 
    {
        public ExceptionMessageMatchingExpectedAssertCondition(. match) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(TException? actualValue, .? expectedValue) { }
    }
    public class ExceptionMessageStartingWithExpectedValueAssertCondition<TException> : .<TException, string>
        where TException : 
    {
        public ExceptionMessageStartingWithExpectedValueAssertCondition(string expected,  stringComparison) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(TException? actualValue, string? expectedValue) { }
    }
    public class ExceptionTypeAssertCondition : .<, >
    {
        public ExceptionTypeAssertCondition( expectedType) { }
        protected override string GetExpectation() { }
        protected override .<.> GetResult(? actualValue, ? expectedValue) { }
    }
}
namespace .
{
    public interface IDelegateSource : ..ISource { }
    public interface ISource
    {
        string? ActualExpression { get; }
        ..ISource AppendExpression(string expression);
        ..ISource WithAssertion(. assertCondition);
    }
    public interface IValueDelegateSource<out TActual> : ..IDelegateSource, ..ISource, ..IValueSource<TActual> { }
    public interface IValueSource<out TActual> : ..ISource { }
}
namespace .
{
    []
    public enum AssertionType
    {
        Value = 1,
        Delegate = 2,
    }
    public class DelegateAnd<TActual> : ..IDelegateSource, ..ISource
    {
        public DelegateAnd(. assertionBuilder) { }
        public static ..DelegateAnd<TActual> Create(. assertionBuilder) { }
    }
    public class DelegateOr<TActual> : ..IDelegateSource, ..ISource
    {
        public DelegateOr(. assertionBuilder) { }
        public static ..DelegateOr<TActual> Create(. assertionBuilder) { }
    }
    public class ValueAnd<TActual> : ..ISource, ..IValueSource<TActual>
    {
        public ValueAnd(. assertionBuilder) { }
        public static ..ValueAnd<TActual> Create(. assertionBuilder) { }
    }
    public class ValueDelegateAnd<TActual> : ..IDelegateSource, ..ISource, ..IValueDelegateSource<TActual>, ..IValueSource<TActual>
    {
        public ValueDelegateAnd(. assertionBuilder) { }
        public static ..ValueDelegateAnd<TActual> Create(. assertionBuilder) { }
    }
    public class ValueDelegateOr<TActual> : ..IDelegateSource, ..ISource, ..IValueDelegateSource<TActual>, ..IValueSource<TActual>
    {
        public ValueDelegateOr(. assertionBuilder) { }
        public static ..ValueDelegateOr<TActual> Create(. assertionBuilder) { }
    }
    public class ValueOr<TActual> : ..ISource, ..IValueSource<TActual>
    {
        public ValueOr(. assertionBuilder) { }
    }
}
namespace .AssertionBuilders
{
    public abstract class AssertionBase
    {
        protected AssertionBase() { }
        public abstract . ExecuteAsync();
        public abstract . GetAwaiter();
    }
    public abstract class AssertionBase<T>
    {
        protected AssertionBase(<.<T>> actualValueProvider) { }
        protected AssertionBase(<T> actualValueProvider) { }
        protected AssertionBase(.<T> actualValueTask) { }
        protected AssertionBase(T actualValue) { }
        public .<T> And { get; }
        public .<T> Or { get; }
        protected abstract .<.> AssertAsync();
        public virtual .<T> Because(string reason, [.("reason")] string? expression = null) { }
        public . ExecuteAsync() { }
        protected .<T> GetActualValueAsync() { }
        public . GetAwaiter() { }
    }
    public abstract class AssertionBuilder : .
    {
        protected AssertionBuilder() { }
        public virtual string? ActualExpression { get; protected set; }
        public virtual void AppendExpression(string expression) { }
        [.DebuggerHidden]
        [("This is a base `object` method that should not be called.", true)]
        public new void Equals(object? obj) { }
        public abstract .<.AssertionData> GetAssertionData();
        public virtual .<.> GetAssertions() { }
        public abstract . GetAwaiter();
        public virtual .? GetLastAssertion() { }
        public abstract . ProcessAssertionsAsync(.AssertionData data);
        [.DebuggerHidden]
        [("This is a base `object` method that should not be called.", true)]
        public void ReferenceEquals(object a, object b) { }
        public virtual void SetBecause(string reason, string? expression) { }
        public virtual void WithAssertion(. assertion) { }
    }
    public class AssertionBuilder<TActual>
    {
        public AssertionBuilder(<.<TActual>> asyncValueProvider, string? expression = null) { }
        public AssertionBuilder(<TActual> valueProvider, string? expression = null) { }
        public AssertionBuilder(.<TActual> task, string? expression = null) { }
        public AssertionBuilder(.<TActual> valueTask, string? expression = null) { }
        public AssertionBuilder(TActual value, string? expression = null) { }
        public .<TActual> Contains(object? item) { }
        public .<TActual> DoesNotContain(object? item) { }
        public .<TActual> EqualTo(TActual expected) { }
        public .<int> HasCount() { }
        public .<TActual> HasCount(int expectedCount) { }
        public .<TActual> HasDistinctItems() { }
        public .<TActual> HasSingleItem() { }
        public .<TActual> IsAssignableTo( expectedType) { }
        public .<TActual> IsAssignableTo<TExpected>() { }
        public .<TActual> IsEmpty() { }
        public .<TActual> IsEqualTo(TActual expected) { }
        public .<TActual> IsEquatableOrEqualTo(TActual expected) { }
        public .<TActual> IsEquivalentTo(.<object?> expected) { }
        public .<TActual> IsEquivalentTo(TActual expected) { }
        public . IsFalse() { }
        public .<TActual> IsGreaterThan(TActual value) { }
        public .<TActual> IsGreaterThanOrEqualTo(TActual value) { }
        public .<TActual> IsIn(.<TActual> values) { }
        public .<TActual> IsIn(params TActual[] values) { }
        public .<TActual> IsLessThan(TActual value) { }
        public .<TActual> IsLessThanOrEqualTo(TActual value) { }
        public .<TActual> IsNotEmpty() { }
        public .<TActual> IsNotEqualTo(TActual expected) { }
        public .<TActual> IsNotEquivalentTo(TActual expected) { }
        public .<TActual> IsNotIn(params TActual[] values) { }
        public .<TActual> IsNotNull() { }
        public .<TActual> IsNull() { }
        public . IsTrue() { }
        public .<TActual> IsTypeOf( expectedType) { }
        public .<TActual> IsTypeOf<TExpected>() { }
        public .<TActual> Satisfies(<TActual, bool> predicate, string? failureMessage = null) { }
        public . Throws( exceptionType) { }
        public .<TException> Throws<TException>()
            where TException :  { }
        public .<TException> ThrowsExactly<TException>()
            where TException :  { }
        public . ThrowsException() { }
        public .<TException> ThrowsException<TException>()
            where TException :  { }
        public .<TActual> ThrowsNothing() { }
    }
    public class AssertionEvaluator
    {
        public AssertionEvaluator() { }
        public . EvaluateAsync(..IAssertionChain chain) { }
        public .<.AssertionData> EvaluateAsync(.<.AssertionData> assertionDataTask, .<.> assertions, . expressionFormatter) { }
        public .<.> GetResults() { }
    }
    public static class BetweenAssertionExtensions
    {
        public static .<TActual> IsBetween<TActual>(this .<TActual> builder, TActual min, TActual max, bool inclusive = true)
            where TActual : <TActual> { }
        public static .<TActual> IsNotBetween<TActual>(this .<TActual> builder, TActual min, TActual max, bool inclusive = true)
            where TActual : <TActual> { }
    }
    public class BetweenAssertion<TActual> : .<TActual>
        where TActual : <TActual>
    {
        public BetweenAssertion(<.<TActual>> actualValueProvider, TActual min, TActual max, bool inclusive = true, bool shouldBeInRange = true) { }
        public BetweenAssertion(<TActual> actualValueProvider, TActual min, TActual max, bool inclusive = true, bool shouldBeInRange = true) { }
        public BetweenAssertion(TActual actualValue, TActual min, TActual max, bool inclusive = true, bool shouldBeInRange = true) { }
        protected override .<.> AssertAsync() { }
    }
    public class BooleanAssertion : .<bool>
    {
        public BooleanAssertion(<.<bool>> actualValueProvider, bool expectedValue) { }
        public BooleanAssertion(<bool> actualValueProvider, bool expectedValue) { }
        public BooleanAssertion(bool actualValue, bool expectedValue) { }
        protected override .<.> AssertAsync() { }
    }
    public static class ChainingExtensions
    {
        public static .<T> CompletesWithin<T>(this .<T> builder,  timeout) { }
        [.("Trimming", "IL2073", Justification="HasMember is for testing scenarios where reflection is acceptable")]
        [.("Trimming", "IL2075", Justification="HasMember is for testing scenarios where reflection is acceptable")]
        public static .<T> HasMember<T>(this .<T> builder, string memberName) { }
        public static .<T> IgnoringType<T>(this .<T> assertion,  typeToIgnore) { }
        public static .<string> IgnoringWhitespace(this .<string> assertion) { }
        public static . IgnoringWhitespace(this .<string> assertion) { }
        public static .<T> IsAssignableTo<T, TTarget>(this .<T> builder) { }
        public static .<T> IsAssignableTo<T, TTarget>(this .<T> assertion) { }
        public static .<TException> IsAssignableTo<TException, TTarget>(this .<TException> assertion)
            where TException :  { }
        public static .<T> IsDefault<T>(this .<T> builder) { }
        public static .<T> IsNotDefault<T>(this .<T> builder) { }
        public static . WithNullAndEmptyEquality(this .<string> assertion) { }
        public static .<string> WithTrimming(this .<string> assertion) { }
        public static . WithTrimming(this .<string> assertion) { }
    }
    public enum CollectionAssertType
    {
        Empty = 0,
        NotEmpty = 1,
        Count = 2,
        Contains = 3,
        DoesNotContain = 4,
        HasSingleItem = 5,
        HasDistinctItems = 6,
    }
    public class CollectionAssertion<TActual> : .<TActual>
    {
        public CollectionAssertion(<.<TActual>> actualValueProvider, . assertType, int? expectedCount = default, object? expectedItem = null) { }
        public CollectionAssertion(<TActual> actualValueProvider, . assertType, int? expectedCount = default, object? expectedItem = null) { }
        public CollectionAssertion(TActual actualValue, . assertType, int? expectedCount = default, object? expectedItem = null) { }
        protected override .<.> AssertAsync() { }
    }
    public static class CollectionContainsOnlyExtensions
    {
        public static .<.<T>> ContainsOnly<T>(this .<.<T>> builder, params T[] expected) { }
        public static .<.<T>> ContainsOnly<T>(this .<.<T>> builder, params T[] expected) { }
        public static .<.<T>> ContainsOnly<T>(this .<.<T>> builder, params T[] expected) { }
        public static .<T[]> ContainsOnly<T>(this .<T[]> builder, params T[] expected) { }
    }
    public static class CollectionExtensions
    {
        public static .<T> HasSingleItem<T>(this .<.<T>> builder) { }
        public static .<T> HasSingleItem<T>(this .<.<T>> builder) { }
        public static .<T> HasSingleItem<T>(this .<.<T>> builder) { }
        public static .<T> HasSingleItem<T>(this .<.<T>> builder) { }
        public static .<T> HasSingleItem<T>(this .<T[]> builder) { }
    }
    public static class CollectionOrderingExtensions
    {
        public static .<.<T>> IsInDescendingOrder<T>(this .<.<T>> builder)
            where T : <T> { }
        public static .<T[]> IsInDescendingOrder<T>(this .<T[]> builder)
            where T : <T> { }
        public static .<.<object>> IsInOrder(this .<.<object>> builder) { }
        public static .<.<T>> IsInOrder<T>(this .<.<T>> builder)
            where T : <T> { }
        public static .<T[]> IsInOrder<T>(this .<T[]> builder)
            where T : <T> { }
    }
    public class ComparisonAndChain<TActual>
    {
        public ComparisonAndChain(.<TActual> previousAssertion, <.<TActual>> valueProvider) { }
        public . IsGreaterThan(TActual value) { }
        public . IsGreaterThanOrEqualTo(TActual value) { }
        public . IsLessThan(TActual value) { }
        public . IsLessThanOrEqualTo(TActual value) { }
    }
    public class ComparisonAssertion<TActual> : .<TActual>
    {
        public ComparisonAssertion(<.<TActual>> actualValueProvider, TActual comparisonValue, . comparisonType) { }
        public ComparisonAssertion(<TActual> actualValueProvider, TActual comparisonValue, . comparisonType) { }
        public ComparisonAssertion(TActual actualValue, TActual comparisonValue, . comparisonType) { }
        protected override .<.> AssertAsync() { }
    }
    public enum ComparisonType
    {
        GreaterThan = 0,
        GreaterThanOrEqual = 1,
        LessThan = 2,
        LessThanOrEqual = 3,
    }
    public static class CultureInfoAssertionExtensions
    {
        public static .<.CultureInfo> IsEnglish(this .<.CultureInfo> builder) { }
        public static .<.CultureInfo> IsInvariant(this .<.CultureInfo> builder) { }
        public static .<.CultureInfo> IsLeftToRight(this .<.CultureInfo> builder) { }
        public static .<.CultureInfo> IsNeutralCulture(this .<.CultureInfo> builder) { }
        public static .<.CultureInfo> IsNotEnglish(this .<.CultureInfo> builder) { }
        public static .<.CultureInfo> IsNotInvariant(this .<.CultureInfo> builder) { }
        public static .<.CultureInfo> IsNotNeutralCulture(this .<.CultureInfo> builder) { }
        public static .<.CultureInfo> IsReadOnly(this .<.CultureInfo> builder) { }
        public static .<.CultureInfo> IsRightToLeft(this .<.CultureInfo> builder) { }
    }
    public class CustomAssertion<TActual> : .<TActual>
    {
        public CustomAssertion(<.<TActual>> actualValueProvider, <TActual, bool> predicate, string? failureMessage) { }
        public CustomAssertion(<TActual> actualValueProvider, <TActual, bool> predicate, string? failureMessage) { }
        public CustomAssertion(TActual actualValue, <TActual, bool> predicate, string? failureMessage) { }
        protected override .<.> AssertAsync() { }
    }
    public class DateOnlyAssertion : .<>
    {
        public DateOnlyAssertion( actualValue,  expected) { }
        public DateOnlyAssertion(<> actualValueProvider,  expected) { }
        public DateOnlyAssertion(<.<>> actualValueProvider,  expected) { }
        protected override .<.> AssertAsync() { }
        public . WithinDays(int days) { }
    }
    public static class DateOnlyGenericAssertionExtensions
    {
        public static .<> WithinDays(this .<> assertion, int days) { }
    }
    public class DateTimeAssertion : .<>
    {
        public DateTimeAssertion( actualValue,  expected) { }
        public DateTimeAssertion(<> actualValueProvider,  expected) { }
        public DateTimeAssertion(<.<>> actualValueProvider,  expected) { }
        protected override .<.> AssertAsync() { }
        public .<> IsAfterOrEqualTo( other) { }
        public .<> IsBeforeOrEqualTo( other) { }
        public . Within( tolerance) { }
    }
    public static class DateTimeAssertionBuilderExtensions
    {
        public static .<> IsAfterOrEqualTo(this .<> builder,  other) { }
        public static .<> IsBeforeOrEqualTo(this .<> builder,  other) { }
        public static . IsEqualTo(this .<> builder,  expected) { }
        public static . IsEqualTo(this .<> builder,  expected) { }
        public static . IsEqualTo(this .<> builder,  expected) { }
        public static . IsEqualTo(this .<> builder,  expected) { }
        public static . IsEqualTo(this .<> builder,  expected) { }
    }
    public class DateTimeOffsetAssertion : .<>
    {
        public DateTimeOffsetAssertion( actualValue,  expected) { }
        public DateTimeOffsetAssertion(<> actualValueProvider,  expected) { }
        public DateTimeOffsetAssertion(<.<>> actualValueProvider,  expected) { }
        protected override .<.> AssertAsync() { }
        public . Within( tolerance) { }
    }
    public static class DayOfWeekAssertionExtensions
    {
        public static .<> IsFriday(this .<> builder) { }
        public static .<> IsMonday(this .<> builder) { }
        public static .<> IsSaturday(this .<> builder) { }
        public static .<> IsSunday(this .<> builder) { }
        public static .<> IsThursday(this .<> builder) { }
        public static .<> IsTuesday(this .<> builder) { }
        public static .<> IsWednesday(this .<> builder) { }
        public static .<> IsWeekday(this .<> builder) { }
        public static .<> IsWeekend(this .<> builder) { }
    }
    public static class DictionaryAssertionExtensions
    {
        public static .<T> ContainsKey<T>(this .<T> builder, object key)
            where T : .IDictionary { }
        public static .<TKey, TValue> ContainsKey<TKey, TValue>(this .<.<TKey, TValue>> builder, TKey key)
            where TKey :  notnull { }
        public static .<TKey, TValue> ContainsKey<TKey, TValue>(this .<.<TKey, TValue>> builder, TKey key) { }
        public static .<.<TKey, TValue>> ContainsKey<TKey, TValue>(this .<.<TKey, TValue>> builder, TKey key) { }
        public static .<TKey, TValue> DoesNotContainKey<TKey, TValue>(this .<.<TKey, TValue>> builder, TKey key)
            where TKey :  notnull { }
        public static .<TKey, TValue> DoesNotContainKey<TKey, TValue>(this .<.<TKey, TValue>> builder, TKey key) { }
        public static .<.<TKey, TValue>> DoesNotContainKey<TKey, TValue>(this .<.<TKey, TValue>> builder, TKey key) { }
    }
    public class DictionaryAssertion<TKey, TValue> : .<.<TKey, TValue>>
    {
        public DictionaryAssertion(.<TKey, TValue> actualValue, TKey? key, bool shouldContain) { }
        public DictionaryAssertion(<.<TKey, TValue>> actualValueProvider, TKey? key, bool shouldContain) { }
        public DictionaryAssertion(<.<.<TKey, TValue>>> actualValueProvider, TKey? key, bool shouldContain) { }
        protected override .<.> AssertAsync() { }
    }
    public static class DirectoryInfoAssertionExtensions
    {
        public static .<.DirectoryInfo> DoesNotExist(this .<.DirectoryInfo> builder) { }
        public static .<.DirectoryInfo> Exists(this .<.DirectoryInfo> builder) { }
        public static .<.DirectoryInfo> HasFiles(this .<.DirectoryInfo> builder) { }
        public static .<.DirectoryInfo> HasNoFiles(this .<.DirectoryInfo> builder) { }
        public static .<.DirectoryInfo> HasNoSubdirectories(this .<.DirectoryInfo> builder) { }
        public static .<.DirectoryInfo> HasSubdirectories(this .<.DirectoryInfo> builder) { }
    }
    public static class EncodingAssertionExtensions
    {
        public static .<.Encoding> IsASCII(this .<.Encoding> builder) { }
        public static .<.Encoding> IsBigEndianUnicode(this .<.Encoding> builder) { }
        public static .<.Encoding> IsNotSingleByte(this .<.Encoding> builder) { }
        public static .<.Encoding> IsNotUTF8(this .<.Encoding> builder) { }
        public static .<.Encoding> IsSingleByte(this .<.Encoding> builder) { }
        public static .<.Encoding> IsUTF32(this .<.Encoding> builder) { }
        public static .<.Encoding> IsUTF8(this .<.Encoding> builder) { }
        public static .<.Encoding> IsUnicode(this .<.Encoding> builder) { }
    }
    public static class EnumAssertionExtensions
    {
        public static .<TEnum> DoesNotHaveFlag<TEnum>(this .<TEnum> builder, TEnum flag)
            where TEnum :  struct,  { }
        public static .<TEnum> DoesNotHaveSameNameAs<TEnum>(this .<TEnum> builder, TEnum other)
            where TEnum :  struct,  { }
        public static .<TEnum> DoesNotHaveSameValueAs<TEnum>(this .<TEnum> builder, TEnum other)
            where TEnum :  struct,  { }
        public static .<TEnum> HasFlag<TEnum>(this .<TEnum> builder, TEnum flag)
            where TEnum :  struct,  { }
        public static .<TEnum> HasSameNameAs<TEnum>(this .<TEnum> builder, TEnum other)
            where TEnum :  struct,  { }
        public static .<TEnum> HasSameValueAs<TEnum>(this .<TEnum> builder, TEnum other)
            where TEnum :  struct,  { }
        public static .<TEnum> IsDefined<TEnum>(this .<TEnum> builder)
            where TEnum :  struct,  { }
        public static .<TEnum> IsNotDefined<TEnum>(this .<TEnum> builder)
            where TEnum :  struct,  { }
    }
    public class ExceptionAssertion : .<>
    {
        public ExceptionAssertion( syncDelegate) { }
        public ExceptionAssertion(<.> asyncDelegate) { }
        public ExceptionAssertion( syncDelegate,  expectedType) { }
        public ExceptionAssertion(<.> asyncDelegate,  expectedType) { }
        public new . WithInnerException() { }
    }
    public static class ExceptionAssertionExtensions
    {
        public static .<> HasInnerException(this .<> builder) { }
        public static .<> HasNoData(this .<> builder) { }
        public static .<> HasNoInnerException(this .<> builder) { }
        public static .<> HasStackTrace(this .<> builder) { }
    }
    public class ExceptionAssertion<TException> : .<TException>
        where TException : 
    {
        public ExceptionAssertion( syncDelegate) { }
        public ExceptionAssertion(<.> asyncDelegate) { }
        public ExceptionAssertion( syncDelegate,  expectedType) { }
        public ExceptionAssertion(<.> asyncDelegate,  expectedType) { }
        public new .<TException> And { get; }
        protected override .<.> AssertAsync() { }
        public .<TException> HasInnerException() { }
        public .<TException> HasMessageContaining(string substring) { }
        public .<TException> HasMessageEqualTo(string expectedMessage) { }
        public .<TException> HasNoInnerException() { }
        public .<TException> HasStackTrace() { }
        public .<TException> Matching(<TException, bool> predicate) { }
        public .<TException> WithInnerException() { }
        public .<TException> WithInnerException<TInner>()
            where TInner :  { }
        public .<TException> WithMessage(string expectedMessage) { }
        public .<TException> WithMessageContaining(string substring) { }
        public .<TException> WithMessageMatching(string pattern) { }
        public .<TException> WithMessageNotContaining(string substring) { }
        public .<TException> WithParameterName(string parameterName) { }
    }
    public class ExecutionTimeAssertion<T> : .<T>
    {
        public ExecutionTimeAssertion(<.<T>> actualValueProvider,  timeout) { }
        protected override .<.> AssertAsync() { }
    }
    public class ExpressionFormatter
    {
        public ExpressionFormatter(string? actualExpression) { }
        public string? ActualExpression { get; }
        public void AppendConnector(string connector) { }
        public void AppendMethod(string methodName, params string?[] arguments) { }
        public string GetExpression() { }
    }
    public static class FileInfoAssertionExtensions
    {
        public static .<.FileInfo> DoesNotExist(this .<.FileInfo> builder) { }
        public static .<.FileInfo> Exists(this .<.FileInfo> builder) { }
        public static .<.FileInfo> IsExecutable(this .<.FileInfo> builder) { }
        public static .<.FileInfo> IsHidden(this .<.FileInfo> builder) { }
        public static .<.FileInfo> IsNotExecutable(this .<.FileInfo> builder) { }
        public static .<.FileInfo> IsNotHidden(this .<.FileInfo> builder) { }
        public static .<.FileInfo> IsNotReadOnly(this .<.FileInfo> builder) { }
        public static .<.FileInfo> IsNotSystem(this .<.FileInfo> builder) { }
        public static .<.FileInfo> IsReadOnly(this .<.FileInfo> builder) { }
        public static .<.FileInfo> IsSystem(this .<.FileInfo> builder) { }
    }
    public enum FileSystemAssertType
    {
        FileExists = 0,
        FileDoesNotExist = 1,
        DirectoryExists = 2,
        DirectoryDoesNotExist = 3,
        HasFiles = 4,
        HasNoFiles = 5,
        HasSubdirectories = 6,
        HasNoSubdirectories = 7,
    }
    public class FileSystemAssertion : .<string>
    {
        public FileSystemAssertion(<.<string>> pathProvider, . assertType) { }
        public FileSystemAssertion(<string> pathProvider, . assertType) { }
        public FileSystemAssertion(string path, . assertType) { }
        protected override .<.> AssertAsync() { }
    }
    public static class FileSystemAssertionExtensions
    {
        public static . DirectoryDoesNotExist(this .<string> builder) { }
        public static . DirectoryExists(this .<string> builder) { }
        public static . DoesNotExist(this .<string> builder) { }
        public static . Exists(this .<string> builder) { }
        public static . HasFiles(this .<string> builder) { }
        public static . HasNoFiles(this .<string> builder) { }
        public static . HasNoSubdirectories(this .<string> builder) { }
        public static . HasSubdirectories(this .<string> builder) { }
    }
    public static class GenericAssertionExtensions
    {
        public static .<T> IsEqualTo<T>(this <.<T>> actualProvider, T expected) { }
        public static .<T> IsEqualTo<T>(this <T> actualProvider, T expected) { }
        public static .<T> IsEqualTo<T>(this .<T> actualTask, T expected) { }
        public static .<T> IsEqualTo<T>(this T actual, T expected) { }
    }
    public class GenericEqualToAssertion<TActual> : .<TActual>
    {
        public GenericEqualToAssertion(<.<TActual>> actualValueProvider, TActual expected) { }
        public GenericEqualToAssertion(<TActual> actualValueProvider, TActual expected) { }
        public GenericEqualToAssertion(TActual actualValue, TActual expected) { }
        protected override .<.> AssertAsync() { }
        public .<TActual> WithComparer(.<TActual> comparer) { }
        public .<TActual> WithComparison(<TActual?, TActual?, bool> comparison) { }
        public .<TActual> Within<T>(T tolerance)
            where T : <T> { }
    }
    public class GenericNotEqualToAssertion<TActual> : .<TActual>
    {
        public GenericNotEqualToAssertion(<.<TActual>> actualValueProvider, TActual expected) { }
        public GenericNotEqualToAssertion(<TActual> actualValueProvider, TActual expected) { }
        public GenericNotEqualToAssertion(TActual actualValue, TActual expected) { }
        protected override .<.> AssertAsync() { }
        public .<TActual> WithComparer(.<TActual> comparer) { }
    }
    public static class HttpStatusCodeAssertionExtensions
    {
        public static .<.HttpStatusCode> IsClientError(this .<.HttpStatusCode> builder) { }
        public static .<.HttpStatusCode> IsError(this .<.HttpStatusCode> builder) { }
        public static .<.HttpStatusCode> IsInformational(this .<.HttpStatusCode> builder) { }
        public static .<.HttpStatusCode> IsNotSuccess(this .<.HttpStatusCode> builder) { }
        public static .<.HttpStatusCode> IsRedirection(this .<.HttpStatusCode> builder) { }
        public static .<.HttpStatusCode> IsServerError(this .<.HttpStatusCode> builder) { }
        public static .<.HttpStatusCode> IsSuccess(this .<.HttpStatusCode> builder) { }
    }
    public interface IInvokableAssertionBuilder
    {
        .<.AssertionData> GetAssertionData();
        .<.> GetAssertions();
        . GetAwaiter();
        .? GetLastAssertion();
        . ProcessAssertionsAsync(.AssertionData data);
    }
    public class NullAssertion<TActual> : .<TActual>
    {
        public NullAssertion(<.<TActual>> actualValueProvider, bool shouldBeNull) { }
        public NullAssertion(<TActual> actualValueProvider, bool shouldBeNull) { }
        public NullAssertion(TActual actualValue, bool shouldBeNull) { }
        protected override .<.> AssertAsync() { }
    }
    public static class NullableStringAssertionBuilderExtensions
    {
        public static . Contains(this .<string?> builder, string substring) { }
        public static .<string?> DoesNotContain(this .<string?> builder, string substring) { }
        public static . EndsWith(this .<string?> builder, string suffix) { }
        public static .<string?> HasLength(this .<string?> builder, int expectedLength) { }
        public static .<string?> IsEmpty(this .<string?> builder) { }
        public static .<string?> IsNotEmpty(this .<string?> builder) { }
        public static .<T> IsNotParsableInto<T>(this .<string?> builder)
            where T : <T> { }
        public static .<T> IsParsableInto<T>(this .<string?> builder)
            where T : <T> { }
        public static . StartsWith(this .<string?> builder, string prefix) { }
        public static .<T> WhenParsedInto<T>(this .<string?> builder)
            where T : <T> { }
    }
    public static class NumericAssertionExtensions
    {
        public static .<double> IsInfinity(this .<double> builder) { }
        public static .<double> IsNaN(this .<double> builder) { }
        public static .<decimal> IsNegative(this .<decimal> builder) { }
        public static .<double> IsNegative(this .<double> builder) { }
        public static .<float> IsNegative(this .<float> builder) { }
        public static .<int> IsNegative(this .<int> builder) { }
        public static .<long> IsNegative(this .<long> builder) { }
        public static .<short> IsNegative(this .<short> builder) { }
        public static .<T> IsNegative<T>(this .<T> builder)
            where T : .INumber<T> { }
        public static .<byte> IsPositive(this .<byte> builder) { }
        public static .<decimal> IsPositive(this .<decimal> builder) { }
        public static .<double> IsPositive(this .<double> builder) { }
        public static .<float> IsPositive(this .<float> builder) { }
        public static .<int> IsPositive(this .<int> builder) { }
        public static .<long> IsPositive(this .<long> builder) { }
        public static .<short> IsPositive(this .<short> builder) { }
        public static .<T> IsPositive<T>(this .<T> builder)
            where T : .INumber<T> { }
        public static .<int> IsZero(this .<int> builder) { }
        public static .<T> IsZero<T>(this .<T> builder)
            where T : .INumber<T> { }
    }
    public static class NumericRangeAssertionExtensions
    {
        public static .<decimal> IsBetween(this .<decimal> builder, decimal min, decimal max) { }
        public static .<double> IsBetween(this .<double> builder, double min, double max) { }
        public static .<int> IsBetween(this .<int> builder, int min, int max) { }
        public static .<long> IsBetween(this .<long> builder, long min, long max) { }
        public static .<decimal> IsNotBetween(this .<decimal> builder, decimal min, decimal max) { }
        public static .<double> IsNotBetween(this .<double> builder, double min, double max) { }
        public static .<int> IsNotBetween(this .<int> builder, int min, int max) { }
        public static .<long> IsNotBetween(this .<long> builder, long min, long max) { }
    }
    public static class ObjectReferenceAssertionExtensions
    {
        public static .<TActual> IsNotSameReferenceAs<TActual>(this .<TActual> builder, object? expected) { }
        public static .<TActual> IsSameReferenceAs<TActual>(this .<TActual> builder, object? expected) { }
    }
    public class ParseAssertion<T> : .<string?>
        where T : <T>
    {
        public ParseAssertion(<.<string?>> actualValueProvider, bool shouldBeParsable) { }
        public ParseAssertion(<string?> actualValueProvider, bool shouldBeParsable) { }
        public ParseAssertion(string? actualValue, bool shouldBeParsable) { }
        protected override .<.> AssertAsync() { }
        public .<T> WithFormatProvider( formatProvider) { }
    }
    public static class RangeExtensions
    {
        public static .<TActual> WithExclusiveBounds<TActual>(this .<TActual> assertion)
            where TActual : <TActual> { }
        public static .<TActual> WithExclusiveBounds<TActual>(this .<TActual> assertion)
            where TActual : <TActual> { }
        public static .<TActual> WithInclusiveBounds<TActual>(this .<TActual> assertion)
            where TActual : <TActual> { }
        public static .<TActual> WithInclusiveBounds<TActual>(this .<TActual> assertion)
            where TActual : <TActual> { }
    }
    public static class ReferenceAssertionBuilderExtensions
    {
        public static .<TActual> IsNotSameReferenceAs<TActual>(this .<TActual> builder, TActual? expected)
            where TActual :  class { }
        public static .<TActual> IsSameReferenceAs<TActual>(this .<TActual> builder, TActual? expected)
            where TActual :  class { }
    }
    public class ReferenceAssertion<TActual> : .<TActual>
        where TActual :  class
    {
        public ReferenceAssertion(<.<TActual>> actualValueProvider, TActual? expected, bool shouldBeSame) { }
        public ReferenceAssertion(<TActual> actualValueProvider, TActual? expected, bool shouldBeSame) { }
        public ReferenceAssertion(TActual actualValue, TActual? expected, bool shouldBeSame) { }
        protected override .<.> AssertAsync() { }
    }
    public class SingleItemAssertion<TElement> : .<TElement>
    {
        public SingleItemAssertion(<.<.IEnumerable>> collectionProvider) { }
    }
    public static class StringAssertionBuilderExtensions
    {
        public static . Contains(this .<string> builder, string substring) { }
        public static .<string> DoesNotContain(this .<string> builder, string substring) { }
        public static .<string> DoesNotExist(this .<string> builder) { }
        public static .<string> DoesNotMatch(this .<string> builder, string pattern) { }
        public static . EndsWith(this .<string> builder, string suffix) { }
        public static .<string> Exists(this .<string> builder) { }
        public static .<string> HasFiles(this .<string> builder) { }
        public static .<int> HasLength(this .<string> builder) { }
        public static .<string> HasLength(this .<string> builder, int expectedLength) { }
        public static .<string> HasNoSubdirectories(this .<string> builder) { }
        public static .<string> IsDefault(this .<string> builder) { }
        public static .<string> IsEmpty(this .<string> builder) { }
        public static . IsEqualTo(this .<string> builder, string? expected) { }
        public static . IsEqualTo(this .<string> builder, string? expected,  comparison) { }
        public static .<string> IsNotDefault(this .<string> builder) { }
        public static .<string> IsNotEmpty(this .<string> builder) { }
        public static .<string> IsNotNullOrEmpty(this .<string> builder) { }
        public static .<T> IsNotParsableInto<T>(this .<string> builder)
            where T : <T> { }
        public static .<string> IsNullOrEmpty(this .<string> builder) { }
        public static .<string> IsNullOrWhitespace(this .<string> builder) { }
        public static .<T> IsParsableInto<T>(this .<string> builder)
            where T : <T> { }
        public static .<string> Matches(this .<string> builder, string pattern) { }
        public static . StartsWith(this .<string> builder, string prefix) { }
        public static .<T> WhenParsedInto<T>(this .<string> builder)
            where T : <T> { }
    }
    public static class StringAssertionExtensions
    {
        public static . IsEqualToSimplified(this <string?> actualProvider, string? expected) { }
        public static . IsEqualToSimplified(this .<string?> actualTask, string? expected) { }
        public static . IsEqualToSimplified(this string? actual, string? expected) { }
    }
    public static class StringBuilderAssertionExtensions
    {
        public static .<.StringBuilder> HasExcessCapacity(this .<.StringBuilder> builder) { }
        public static .<.StringBuilder> HasNoExcessCapacity(this .<.StringBuilder> builder) { }
    }
    public class StringContainsAssertion : .<string?>
    {
        public StringContainsAssertion(<.<string?>> actualValueProvider, string substring) { }
        public StringContainsAssertion(<string?> actualValueProvider, string substring) { }
        public StringContainsAssertion(string? actualValue, string substring) { }
        protected override .<.> AssertAsync() { }
        public . IgnoringCase() { }
        public . WithComparison( comparison) { }
    }
    public class StringEndsWithAssertion : .<string?>
    {
        public StringEndsWithAssertion(<.<string?>> actualValueProvider, string suffix) { }
        public StringEndsWithAssertion(<string?> actualValueProvider, string suffix) { }
        public StringEndsWithAssertion(string? actualValue, string suffix) { }
        protected override .<.> AssertAsync() { }
        public . IgnoringCase() { }
        public . WithComparison( comparison) { }
    }
    public class StringEqualToAssertion : .<string?>
    {
        public StringEqualToAssertion(<.<string?>> actualValueProvider, string? expected) { }
        public StringEqualToAssertion(<string?> actualValueProvider, string? expected) { }
        public StringEqualToAssertion(string? actualValue, string? expected) { }
        protected override .<.> AssertAsync() { }
        public . IgnoringCase() { }
        public . IgnoringWhitespace() { }
        public . WithNullAndEmptyEquality() { }
        public . WithStringComparison( comparison) { }
        public . WithTrimming() { }
    }
    public class StringStartsWithAssertion : .<string?>
    {
        public StringStartsWithAssertion(<.<string?>> actualValueProvider, string prefix) { }
        public StringStartsWithAssertion(<string?> actualValueProvider, string prefix) { }
        public StringStartsWithAssertion(string? actualValue, string prefix) { }
        protected override .<.> AssertAsync() { }
        public . IgnoringCase() { }
        public . WithComparison( comparison) { }
    }
    public class TimeOnlyAssertion : .<>
    {
        public TimeOnlyAssertion(<.<>> actualValueProvider,  expected) { }
        public TimeOnlyAssertion(<> actualValueProvider,  expected) { }
        public TimeOnlyAssertion( actualValue,  expected) { }
        protected override .<.> AssertAsync() { }
        public . Within( tolerance) { }
    }
    public class TimeSpanAssertion : .<>
    {
        public TimeSpanAssertion(<.<>> actualValueProvider,  expected) { }
        public TimeSpanAssertion(<> actualValueProvider,  expected) { }
        public TimeSpanAssertion( actualValue,  expected) { }
        protected override .<.> AssertAsync() { }
        public . Within( tolerance) { }
    }
    public class TypeAssertion<TActual> : .<TActual>
    {
        public TypeAssertion(<.<TActual>> actualValueProvider,  expectedType, bool exact) { }
        public TypeAssertion(<TActual> actualValueProvider,  expectedType, bool exact) { }
        public TypeAssertion(TActual actualValue,  expectedType, bool exact) { }
        protected override .<.> AssertAsync() { }
    }
    public static class WeakReferenceAssertionExtensions
    {
        public static .<> IsAlive(this .<> builder) { }
        public static .<> IsDead(this .<> builder) { }
    }
    public class WhenParsedAssertion<T> : .<T>
        where T : <T>
    {
        public WhenParsedAssertion(<.<string?>> stringValueProvider, ? formatProvider = null) { }
    }
}
namespace .
{
    public class ChainedAssertion
    {
        public ChainedAssertion(. assertion, . chainType = 0) { }
        public . Assertion { get; }
        public . ChainType { get; }
    }
}
namespace .
{
    public interface IAssertionChain
    {
        void AddAndAssertion(. assertion);
        void AddAssertion(. assertion, . chainType = 0);
        void AddOrAssertion(. assertion);
        .<..ChainedAssertion> GetAssertions();
        .<.> GetBaseAssertions();
        .? GetLastAssertion();
    }
}
namespace .Attributes
{
    [(.Method)]
    public sealed class AssertionAttribute : 
    {
        public AssertionAttribute(string expectation, string? but = null) { }
        public string? But { get; }
        public string Expectation { get; }
    }
    [(.Class, AllowMultiple=true)]
    public class CreateAssertionAttribute : 
    {
        public CreateAssertionAttribute( targetType, string methodName) { }
        public CreateAssertionAttribute( targetType,  containingType, string methodName) { }
        public ? ContainingType { get; }
        public string? CustomName { get; set; }
        public string MethodName { get; }
        public bool NegateLogic { get; set; }
        public bool RequiresGenericTypeParameter { get; set; }
        public  TargetType { get; }
        public bool TreatAsInstance { get; set; }
    }
    [(.Class, AllowMultiple=true)]
    public class CreateAssertionAttribute<TTarget> : 
    {
        public CreateAssertionAttribute(string methodName) { }
        public CreateAssertionAttribute( containingType, string methodName) { }
        public ? ContainingType { get; }
        public string? CustomName { get; set; }
        public string MethodName { get; }
        public bool NegateLogic { get; set; }
        public bool RequiresGenericTypeParameter { get; set; }
        public  TargetType { get; }
        public bool TreatAsInstance { get; set; }
    }
}
namespace .Enums
{
    public enum CollectionOrdering
    {
        Matching = 0,
        Any = 1,
    }
    public enum EquivalencyKind
    {
        Full = 0,
        Partial = 1,
    }
    public enum Order
    {
        Ascending = 0,
        Descending = 1,
    }
}
namespace .Equality
{
    public class CollectionEquivalentToEqualityComparer<[.(..None | ..PublicFields | ..NonPublicFields | ..PublicProperties | ..NonPublicProperties)]  T> : .<T>
    {
        public CollectionEquivalentToEqualityComparer() { }
        public CollectionEquivalentToEqualityComparer(.CompareOptions compareOptions) { }
        public override int? EnumerableIndex { get; protected set; }
        public override bool Equals(T? x, T? y) { }
    }
    public class EquivalentToEqualityComparer<[.(..None | ..PublicFields | ..NonPublicFields | ..PublicProperties | ..NonPublicProperties)]  T> : .<T>
    {
        public EquivalentToEqualityComparer() { }
        public EquivalentToEqualityComparer(.CompareOptions compareOptions) { }
        public .ComparisonFailure[]? ComparisonFailures { get; }
        public virtual int? EnumerableIndex { get; protected set; }
        public virtual bool Equals(T? x, T? y) { }
        public string GetFailureMessages() { }
        public int GetHashCode([.] T obj) { }
    }
}
namespace .Exceptions
{
    public class AssertionException : .
    {
        public AssertionException(string? message) { }
        public AssertionException(string? message,  innerException) { }
    }
    public class BaseAssertionException : 
    {
        public BaseAssertionException() { }
        public BaseAssertionException(string? message) { }
        public BaseAssertionException(string? message, ? innerException) { }
    }
    public class MaybeCaughtException : 
    {
        public MaybeCaughtException( exception) { }
    }
    public class MixedAndOrAssertionsException : .
    {
        public MixedAndOrAssertionsException() { }
    }
}
namespace .Extensions
{
    public static class BecauseExtensions
    {
        public static TAssertionBuilder Because<TAssertionBuilder>(this TAssertionBuilder assertionBuilder, string reason, [.("reason")] string? reasonExpression = null)
            where TAssertionBuilder : . { }
    }
    public static class StringExtensions
    {
        public static string GetStringOr(this string? value, string defaultValue) { }
        public static string GetStringOrEmpty(this string? value) { }
        public static string PrependAOrAn(this string value) { }
        public static string ReplaceNewLines(this string value) { }
        public static string ShowNewLines(this string value) { }
        public static string TruncateWithEllipsis(this string value, int maxLength) { }
    }
    public static class TimeSpanExtensions
    {
        public static  Days(this int days) { }
        public static  Hours(this int hours) { }
        public static  Milliseconds(this int milliseconds) { }
        public static  Minutes(this int minutes) { }
        public static  Seconds(this int seconds) { }
    }
}
namespace .Helpers
{
    public static class ExpressionHelpers
    {
        public static string GetName<T1, T2>(.<<T1, T2>> exp) { }
    }
    public abstract class Formatter
    {
        protected Formatter() { }
        public abstract bool CanHandle(object? value);
        public abstract string FormatValue(object? value);
        public static string Format(object? value) { }
    }
    public class StringDifference
    {
        public StringDifference(string? actualValue, string? expectedValue, .<string>? comparer = null) { }
        public int IgnoreWhiteSpace { get; set; }
        public int? OverriddenIndex { get; set; }
        public int IndexOfFirstMismatch() { }
        public override string ToString() { }
        public string ToString(string prefix) { }
    }
    public static class TimeSpanFormatter
    {
        public static string PrettyPrint(this  timeSpan) { }
    }
}