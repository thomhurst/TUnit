[assembly: System.Runtime.Versioning.TargetFramework(".NETCoreApp,Version=v9.0", FrameworkDisplayName=".NET 9.0")]
namespace TUnit.Assertions
{
    public static class Assert
    {
        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void Fail(string reason) { }
        public static System.IDisposable Multiple() { }
        public static TUnit.Assertions.AssertionBuilders.DelegateAssertionBuilder That(System.Action value, [System.Runtime.CompilerServices.CallerArgumentExpression("value")] string? doNotPopulateThisValue = null) { }
        public static TUnit.Assertions.AssertionBuilders.ValueAssertionBuilder<System.Collections.Generic.IEnumerable<object>> That(System.Collections.IEnumerable enumerable, [System.Runtime.CompilerServices.CallerArgumentExpression("enumerable")] string? doNotPopulateThisValue = null) { }
        public static TUnit.Assertions.AssertionBuilders.AsyncDelegateAssertionBuilder That(System.Func<System.Threading.Tasks.Task> value, [System.Runtime.CompilerServices.CallerArgumentExpression("value")] string? doNotPopulateThisValue = null) { }
        public static TUnit.Assertions.AssertionBuilders.AsyncDelegateAssertionBuilder That(System.Threading.Tasks.Task value, [System.Runtime.CompilerServices.CallerArgumentExpression("value")] string? doNotPopulateThisValue = null) { }
        public static TUnit.Assertions.AssertionBuilders.AsyncDelegateAssertionBuilder That(System.Threading.Tasks.ValueTask value, [System.Runtime.CompilerServices.CallerArgumentExpression("value")] string? doNotPopulateThisValue = null) { }
        public static TUnit.Assertions.AssertionBuilders.AsyncValueDelegateAssertionBuilder<TActual> That<TActual>(System.Func<System.Threading.Tasks.Task<TActual>> value, [System.Runtime.CompilerServices.CallerArgumentExpression("value")] string? doNotPopulateThisValue = null) { }
        public static TUnit.Assertions.AssertionBuilders.ValueDelegateAssertionBuilder<TActual> That<TActual>(System.Func<TActual> value, [System.Runtime.CompilerServices.CallerArgumentExpression("value")] string? doNotPopulateThisValue = null) { }
        public static TUnit.Assertions.AssertionBuilders.AsyncValueDelegateAssertionBuilder<TActual> That<TActual>(System.Threading.Tasks.Task<TActual> value, [System.Runtime.CompilerServices.CallerArgumentExpression("value")] string? doNotPopulateThisValue = null) { }
        public static TUnit.Assertions.AssertionBuilders.AsyncValueDelegateAssertionBuilder<TActual> That<TActual>(System.Threading.Tasks.ValueTask<TActual> value, [System.Runtime.CompilerServices.CallerArgumentExpression("value")] string? doNotPopulateThisValue = null) { }
        public static TUnit.Assertions.AssertionBuilders.ValueAssertionBuilder<TActual> That<TActual>(TActual value, [System.Runtime.CompilerServices.CallerArgumentExpression("value")] string? doNotPopulateThisValue = null) { }
        public static System.Exception Throws(System.Action @delegate, [System.Runtime.CompilerServices.CallerArgumentExpression("delegate")] string? doNotPopulateThisValue = null) { }
        public static System.Exception Throws(System.Type type, System.Action @delegate, [System.Runtime.CompilerServices.CallerArgumentExpression("delegate")] string? doNotPopulateThisValue = null) { }
        public static TException Throws<TException>(System.Action @delegate, [System.Runtime.CompilerServices.CallerArgumentExpression("delegate")] string? doNotPopulateThisValue = null)
            where TException : System.Exception { }
        public static System.Threading.Tasks.Task<System.Exception> ThrowsAsync(System.Func<System.Threading.Tasks.Task> @delegate, [System.Runtime.CompilerServices.CallerArgumentExpression("delegate")] string? doNotPopulateThisValue = null) { }
        public static System.Threading.Tasks.Task<System.Exception> ThrowsAsync(System.Threading.Tasks.Task @delegate, [System.Runtime.CompilerServices.CallerArgumentExpression("delegate")] string? doNotPopulateThisValue = null) { }
        public static System.Threading.Tasks.Task<System.Exception> ThrowsAsync(System.Threading.Tasks.ValueTask @delegate, [System.Runtime.CompilerServices.CallerArgumentExpression("delegate")] string? doNotPopulateThisValue = null) { }
        public static System.Threading.Tasks.Task<System.Exception> ThrowsAsync(System.Type type, System.Func<System.Threading.Tasks.Task> @delegate, [System.Runtime.CompilerServices.CallerArgumentExpression("delegate")] string? doNotPopulateThisValue = null) { }
        public static System.Threading.Tasks.Task<System.Exception> ThrowsAsync(System.Type type, System.Threading.Tasks.Task @delegate, [System.Runtime.CompilerServices.CallerArgumentExpression("delegate")] string? doNotPopulateThisValue = null) { }
        public static System.Threading.Tasks.Task<System.Exception> ThrowsAsync(System.Type type, System.Threading.Tasks.ValueTask @delegate, [System.Runtime.CompilerServices.CallerArgumentExpression("delegate")] string? doNotPopulateThisValue = null) { }
        public static System.Threading.Tasks.Task<TException> ThrowsAsync<TException>(System.Func<System.Threading.Tasks.Task> @delegate, [System.Runtime.CompilerServices.CallerArgumentExpression("delegate")] string? doNotPopulateThisValue = null)
            where TException : System.Exception { }
        public static System.Threading.Tasks.Task<TException> ThrowsAsync<TException>(System.Threading.Tasks.Task @delegate, [System.Runtime.CompilerServices.CallerArgumentExpression("delegate")] string? doNotPopulateThisValue = null)
            where TException : System.Exception { }
        public static System.Threading.Tasks.Task<TException> ThrowsAsync<TException>(System.Threading.Tasks.ValueTask @delegate, [System.Runtime.CompilerServices.CallerArgumentExpression("delegate")] string? doNotPopulateThisValue = null)
            where TException : System.Exception { }
    }
    public readonly struct AssertionData : System.IEquatable<TUnit.Assertions.AssertionData>
    {
        public AssertionData(object? Result, System.Exception? Exception, string? ActualExpression, System.DateTimeOffset Start, System.DateTimeOffset End) { }
        public string? ActualExpression { get; init; }
        public System.DateTimeOffset End { get; init; }
        public System.Exception? Exception { get; init; }
        public object? Result { get; init; }
        public System.DateTimeOffset Start { get; init; }
        public static TUnit.Assertions.AssertionData op_Implicit(System.ValueTuple<object?, System.Exception?, string?, System.DateTimeOffset, System.DateTimeOffset> tuple) { }
    }
    public class AssertionDecision : System.IEquatable<TUnit.Assertions.AssertionDecision>
    {
        public static TUnit.Assertions.AssertionDecision Continue { get; }
        public static TUnit.Assertions.AssertionDecision Pass { get; }
        public static TUnit.Assertions.AssertionDecision Fail(string message) { }
    }
    public class AssertionMetadata
    {
        public AssertionMetadata() { }
        public System.TimeSpan Duration { get; }
        public required System.DateTimeOffset EndTime { get; init; }
        public required System.DateTimeOffset StartTime { get; init; }
    }
    public class CollectionWrapper<TInner>
    {
        public CollectionWrapper(TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.Collections.Generic.IEnumerable<TInner>> valueSource) { }
        public TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.Collections.Generic.IEnumerable<TInner>> Satisfy(System.Func<TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TInner?>, TUnit.Assertions.AssertionBuilders.IInvokableAssertionBuilder> assert, [System.Runtime.CompilerServices.CallerArgumentExpression("assert")] string assertionBuilderExpression = "") { }
        public TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.Collections.Generic.IEnumerable<TInner>> Satisfy<TExpected>(System.Func<TInner?, System.Threading.Tasks.Task<TExpected>?> asyncMapper, System.Func<TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TExpected?>, TUnit.Assertions.AssertionBuilders.IInvokableAssertionBuilder> assert, [System.Runtime.CompilerServices.CallerArgumentExpression("asyncMapper")] string mapperExpression = "", [System.Runtime.CompilerServices.CallerArgumentExpression("assert")] string assertionBuilderExpression = "") { }
        public TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.Collections.Generic.IEnumerable<TInner>> Satisfy<TExpected>(System.Func<TInner?, TExpected> mapper, System.Func<TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TExpected?>, TUnit.Assertions.AssertionBuilders.IInvokableAssertionBuilder> assert, [System.Runtime.CompilerServices.CallerArgumentExpression("mapper")] string mapperExpression = "", [System.Runtime.CompilerServices.CallerArgumentExpression("assert")] string assertionBuilderExpression = "") { }
    }
    public static class Compare
    {
        public static System.Collections.Generic.IEnumerable<TUnit.Assertions.ComparisonFailure> CheckEquivalent<[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.None | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicProperties | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicProperties)]  TActual, [System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.None | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicProperties | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicProperties)]  TExpected>(TActual actual, TExpected expected, TUnit.Assertions.CompareOptions options, int? index) { }
    }
    public class CompareOptions : System.IEquatable<TUnit.Assertions.CompareOptions>
    {
        public CompareOptions() { }
        public TUnit.Assertions.Enums.EquivalencyKind EquivalencyKind { get; set; }
        public string[] MembersToIgnore { get; init; }
    }
    public class ComparisonFailure : System.IEquatable<TUnit.Assertions.ComparisonFailure>
    {
        public ComparisonFailure() { }
        public required object? Actual { get; init; }
        public required object? Expected { get; init; }
        public required string[] NestedMemberNames { get; init; }
        public required TUnit.Assertions.MemberType Type { get; init; }
    }
    public static class Fail
    {
        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void Test(string reason) { }
        public static void Unless([System.Diagnostics.CodeAnalysis.DoesNotReturnIf(false)] bool condition, string reason) { }
        public static void When([System.Diagnostics.CodeAnalysis.DoesNotReturnIf(true)] bool condition, string reason) { }
    }
    public enum MemberType
    {
        Property = 0,
        Field = 1,
        Value = 2,
        EnumerableItem = 3,
        DictionaryItem = 4,
    }
}
namespace TUnit.Assertions.AssertConditions
{
    public class AssertionResult
    {
        public bool IsPassed { get; }
        public string Message { get; }
        public static TUnit.Assertions.AssertConditions.AssertionResult Passed { get; }
        public TUnit.Assertions.AssertConditions.AssertionResult And(TUnit.Assertions.AssertConditions.AssertionResult other) { }
        public System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> OrAsync(System.Func<System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult>> otherResult) { }
        public TUnit.Assertions.AssertConditions.AssertionResult OrFailIf(bool isFailed, [System.Runtime.CompilerServices.InterpolatedStringHandlerArgument("isFailed")] TUnit.Assertions.AssertConditions.AssertionResult.InterpolatedStringHandler stringHandler) { }
        public TUnit.Assertions.AssertConditions.AssertionResult OrFailIf(bool isFailed, string message) { }
        public static TUnit.Assertions.AssertConditions.AssertionResult Fail(string message) { }
        public static TUnit.Assertions.AssertConditions.AssertionResult FailIf(bool isFailed, [System.Runtime.CompilerServices.InterpolatedStringHandlerArgument("isFailed")] TUnit.Assertions.AssertConditions.AssertionResult.InterpolatedStringHandler stringHandler) { }
        public static TUnit.Assertions.AssertConditions.AssertionResult FailIf(bool isFailed, string message) { }
        public static System.Threading.Tasks.Task<TUnit.Assertions.AssertConditions.AssertionResult> op_Implicit(TUnit.Assertions.AssertConditions.AssertionResult result) { }
        public static System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> op_Implicit(TUnit.Assertions.AssertConditions.AssertionResult result) { }
        [System.Runtime.CompilerServices.InterpolatedStringHandler]
        public readonly struct InterpolatedStringHandler
        {
            public InterpolatedStringHandler(int literalLength, int formattedCount, bool isFailed, out bool enabled) { }
            public void AppendFormatted<T>(T? t) { }
            public void AppendFormatted<T>(T? t, string format)
                where T : System.IFormattable { }
            public void AppendLiteral(string s) { }
        }
    }
    public abstract class BaseAssertCondition
    {
        protected BaseAssertCondition() { }
        public string? OverriddenMessage { get; }
        public string? Subject { get; }
        public virtual System.TimeSpan? WaitFor { get; protected set; }
        public TUnit.Assertions.AssertConditions.AssertionResult FailWithMessage(string message) { }
        protected abstract string GetExpectation();
    }
    public abstract class BaseAssertCondition<TActual> : TUnit.Assertions.AssertConditions.BaseAssertCondition
    {
        protected BaseAssertCondition() { }
        public string? ActualExpression { get; }
        public System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetAssertionResult(TActual? actualValue, System.Exception? exception, TUnit.Assertions.AssertionMetadata assertionMetadata, string? actualExpression = null) { }
        protected abstract System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TActual? actualValue, System.Exception? exception, TUnit.Assertions.AssertionMetadata assertionMetadata);
    }
    public enum ChainType
    {
        None = 0,
        And = 1,
        Or = 2,
    }
    public abstract class ConvertToAssertCondition<TFromType, TToType> : TUnit.Assertions.AssertConditions.BaseAssertCondition<TFromType>
    {
        protected ConvertToAssertCondition() { }
        public TToType ConvertedValue { get; }
        public abstract System.Threading.Tasks.ValueTask<System.ValueTuple<TUnit.Assertions.AssertConditions.AssertionResult, TToType?>> ConvertValue(TFromType? value);
        protected override sealed System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TFromType? actualValue, System.Exception? exception, TUnit.Assertions.AssertionMetadata assertionMetadata) { }
    }
    public abstract class DelegateAssertCondition : TUnit.Assertions.AssertConditions.DelegateAssertCondition<object?, System.Exception>
    {
        protected DelegateAssertCondition() { }
    }
    public abstract class DelegateAssertCondition<TActual> : TUnit.Assertions.AssertConditions.DelegateAssertCondition<TActual, System.Exception>
    {
        protected DelegateAssertCondition() { }
    }
    public abstract class DelegateAssertCondition<TActual, TException> : TUnit.Assertions.AssertConditions.BaseAssertCondition<TActual>
        where TException : System.Exception
    {
        protected DelegateAssertCondition() { }
        protected override string GetExpectation() { }
        protected virtual string GetFailureMessage(TException? exception) { }
        protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TActual? actualValue, System.Exception? exception, TUnit.Assertions.AssertionMetadata assertionMetadata) { }
        public void WithComparer(System.Func<TException?, TUnit.Assertions.AssertionDecision> comparer) { }
    }
    public class EnumerableSatisfiesAssertCondition<TActual, TInner, TExpected> : TUnit.Assertions.AssertConditions.BaseAssertCondition<TActual>
        where TActual : System.Collections.Generic.IEnumerable<TInner?>
    {
        public EnumerableSatisfiesAssertCondition(System.Func<TInner?, System.Threading.Tasks.Task<TExpected>?> mapper, System.Func<TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TExpected?>, TUnit.Assertions.AssertionBuilders.IInvokableAssertionBuilder> assertionBuilder, string mapperExpression, string assertionBuilderExpression) { }
        protected override string GetExpectation() { }
        protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TActual? actualValue, System.Exception? exception, TUnit.Assertions.AssertionMetadata assertionMetadata) { }
    }
    public abstract class ExpectedExceptionDelegateAssertCondition<TException> : TUnit.Assertions.AssertConditions.DelegateAssertCondition<object?, System.Exception>
    {
        protected ExpectedExceptionDelegateAssertCondition() { }
    }
    public abstract class ExpectedValueAssertCondition<TActual, TExpected> : TUnit.Assertions.AssertConditions.BaseAssertCondition<TActual>
    {
        protected ExpectedValueAssertCondition(TExpected? expected) { }
        public TExpected ExpectedValue { get; }
        protected abstract System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TActual? actualValue, TExpected? expectedValue);
        protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TActual? actualValue, System.Exception? exception, TUnit.Assertions.AssertionMetadata assertionMetadata) { }
        public void WithComparer(System.Func<TActual?, TExpected?, TUnit.Assertions.AssertionDecision> comparer) { }
        public void WithTransform(System.Func<TActual?, TActual?> actualTransformation, System.Func<TExpected?, TExpected?> expectedTransformation) { }
    }
    public class FailureLocation : System.IEquatable<TUnit.Assertions.AssertConditions.FailureLocation>
    {
        public FailureLocation() { }
        public object? ActualValue { get; }
        public object? ExpectedValue { get; }
        public long Position { get; }
    }
    public class FuncValueAssertCondition<TActual, TExpected> : TUnit.Assertions.AssertConditions.ExpectedValueAssertCondition<TActual, TExpected>
    {
        public FuncValueAssertCondition(TExpected? expected, System.Func<TActual?, TExpected?, TUnit.Assertions.AssertConditions.FuncValueAssertCondition<TActual, TExpected>, bool> condition, System.Func<TActual?, System.Exception?, string?, string> defaultMessageFactory, string expectation) { }
        protected override string GetExpectation() { }
        protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TActual? actualValue, TExpected? expectedValue) { }
    }
    public class NotNullExpectedValueAssertCondition<TActual> : TUnit.Assertions.AssertConditions.ConvertToAssertCondition<TActual?, TActual>
        where TActual :  class?
    {
        public NotNullExpectedValueAssertCondition() { }
        public override System.Threading.Tasks.ValueTask<System.ValueTuple<TUnit.Assertions.AssertConditions.AssertionResult, TActual?>> ConvertValue(TActual? value) { }
        protected override string GetExpectation() { }
    }
    public class NotNullStructExpectedValueAssertCondition<TActual> : TUnit.Assertions.AssertConditions.ConvertToAssertCondition<TActual?, TActual>
        where TActual :  struct
    {
        public NotNullStructExpectedValueAssertCondition() { }
        public override System.Threading.Tasks.ValueTask<System.ValueTuple<TUnit.Assertions.AssertConditions.AssertionResult, TActual>> ConvertValue(TActual? value) { }
        protected override string GetExpectation() { }
    }
    public class NullExpectedValueAssertCondition<TActual> : TUnit.Assertions.AssertConditions.BaseAssertCondition<TActual>
    {
        public NullExpectedValueAssertCondition() { }
        protected override string GetExpectation() { }
        protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TActual? actualValue, System.Exception? exception, TUnit.Assertions.AssertionMetadata assertionMetadata) { }
    }
    public class SatisfiesAssertCondition<TActual, TExpected> : TUnit.Assertions.AssertConditions.BaseAssertCondition<TActual>
    {
        public SatisfiesAssertCondition(System.Func<TActual, System.Threading.Tasks.Task<TExpected>?> mapper, System.Func<TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TExpected?>, TUnit.Assertions.AssertionBuilders.InvokableAssertionBuilder<TExpected?>> assertionBuilder, string mapperExpression, string assertionBuilderExpression) { }
        protected override string GetExpectation() { }
        protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TActual? actualValue, System.Exception? exception, TUnit.Assertions.AssertionMetadata assertionMetadata) { }
    }
    public abstract class StringMatcher
    {
        protected StringMatcher() { }
        public static TUnit.Assertions.AssertConditions.StringMatcher.RegexMatch AsRegex([System.Diagnostics.CodeAnalysis.StringSyntax("regex")] string pattern) { }
        public static TUnit.Assertions.AssertConditions.StringMatcher.WildcardMatch AsWildcard(string pattern) { }
        public static TUnit.Assertions.AssertConditions.StringMatcher op_Implicit(System.Text.RegularExpressions.Regex pattern) { }
        public static TUnit.Assertions.AssertConditions.StringMatcher op_Implicit(string pattern) { }
        public sealed class RegexMatch : TUnit.Assertions.AssertConditions.StringMatcher
        {
            public TUnit.Assertions.AssertConditions.StringMatcher.RegexMatch IgnoringCase(bool ignoreCase = true) { }
            public override string ToString() { }
        }
        public sealed class WildcardMatch : TUnit.Assertions.AssertConditions.StringMatcher
        {
            public TUnit.Assertions.AssertConditions.StringMatcher.WildcardMatch IgnoringCase(bool ignoreCase = true) { }
            public override string ToString() { }
        }
    }
    public abstract class ValueAssertCondition<TActual> : TUnit.Assertions.AssertConditions.BaseAssertCondition<TActual>
    {
        protected ValueAssertCondition() { }
        protected override string GetExpectation() { }
        protected abstract string GetFailureMessage(TActual? actualValue);
        protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TActual? actualValue, System.Exception? exception, TUnit.Assertions.AssertionMetadata assertionMetadata) { }
        protected abstract TUnit.Assertions.AssertConditions.AssertionResult Passes(TActual? actualValue);
        public void WithComparer(System.Func<TActual?, TUnit.Assertions.AssertionDecision> comparer) { }
        public void WithTransform(System.Func<TActual?, TActual?> actualTransformation) { }
    }
}
namespace TUnit.Assertions.AssertConditions.Chronology
{
    public class DateOnlyEqualsExpectedValueAssertCondition : TUnit.Assertions.AssertConditions.ExpectedValueAssertCondition<System.DateOnly, System.DateOnly>
    {
        public DateOnlyEqualsExpectedValueAssertCondition(System.DateOnly expected) { }
        protected override string GetExpectation() { }
        protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(System.DateOnly actualValue, System.DateOnly expectedValue) { }
        public void SetTolerance(int toleranceDays) { }
    }
    public class DateTimeEqualsExpectedValueAssertCondition : TUnit.Assertions.AssertConditions.ExpectedValueAssertCondition<System.DateTime, System.DateTime>
    {
        public DateTimeEqualsExpectedValueAssertCondition(System.DateTime expected) { }
        protected override string GetExpectation() { }
        protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(System.DateTime actualValue, System.DateTime expectedValue) { }
        public void SetTolerance(System.TimeSpan tolerance) { }
    }
    public class DateTimeOffsetEqualsExpectedValueAssertCondition : TUnit.Assertions.AssertConditions.ExpectedValueAssertCondition<System.DateTimeOffset, System.DateTimeOffset>
    {
        public DateTimeOffsetEqualsExpectedValueAssertCondition(System.DateTimeOffset expected) { }
        protected override string GetExpectation() { }
        protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(System.DateTimeOffset actualValue, System.DateTimeOffset expectedValue) { }
        public void SetTolerance(System.TimeSpan tolerance) { }
    }
    public class TimeOnlyEqualsExpectedValueAssertCondition : TUnit.Assertions.AssertConditions.ExpectedValueAssertCondition<System.TimeOnly, System.TimeOnly>
    {
        public TimeOnlyEqualsExpectedValueAssertCondition(System.TimeOnly expected) { }
        protected override string GetExpectation() { }
        protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(System.TimeOnly actualValue, System.TimeOnly expectedValue) { }
        public void SetTolerance(System.TimeSpan tolerance) { }
    }
    public class TimeSpanEqualsExpectedValueAssertCondition : TUnit.Assertions.AssertConditions.ExpectedValueAssertCondition<System.TimeSpan, System.TimeSpan>
    {
        public TimeSpanEqualsExpectedValueAssertCondition(System.TimeSpan expected) { }
        protected override string GetExpectation() { }
        protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(System.TimeSpan actualValue, System.TimeSpan expectedValue) { }
        public void SetTolerance(System.TimeSpan tolerance) { }
    }
}
namespace TUnit.Assertions.AssertConditions.ClassMember
{
    public class Member<TActualRootType, TPropertyType>
    {
        public Member(TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActualRootType> valueSource, System.Linq.Expressions.Expression<System.Func<TActualRootType, TPropertyType>> selector) { }
        public TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActualRootType> EqualTo(TPropertyType expected, [System.Runtime.CompilerServices.CallerArgumentExpression("expected")] string? doNotPopulateThisValue = null) { }
        public TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActualRootType> NotEqualTo(TPropertyType expected, [System.Runtime.CompilerServices.CallerArgumentExpression("expected")] string? doNotPopulateThisValue = null) { }
    }
    public class PropertyEqualsExpectedValueAssertCondition<TRootObjectType, TPropertyType> : TUnit.Assertions.AssertConditions.ExpectedValueAssertCondition<TRootObjectType, TPropertyType>
    {
        public PropertyEqualsExpectedValueAssertCondition(System.Linq.Expressions.Expression<System.Func<TRootObjectType, TPropertyType>> propertySelector, TPropertyType expected, bool isEqual) { }
        protected override string GetExpectation() { }
        protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TRootObjectType? actualValue, TPropertyType? expectedValue) { }
    }
}
namespace TUnit.Assertions.AssertConditions.Collections
{
    public class EnumerableAllExpectedFuncAssertCondition<TActual, TInner> : TUnit.Assertions.AssertConditions.BaseAssertCondition<TActual>
        where TActual : System.Collections.Generic.IEnumerable<TInner>
    {
        public EnumerableAllExpectedFuncAssertCondition(System.Func<TInner, bool> matcher, string? matcherString) { }
        protected override string GetExpectation() { }
        protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TActual? actualValue, System.Exception? exception, TUnit.Assertions.AssertionMetadata assertionMetadata) { }
    }
    public class EnumerableContainsExpectedFuncAssertCondition<TActual, TInner> : TUnit.Assertions.AssertConditions.BaseAssertCondition<TActual>
        where TActual : System.Collections.Generic.IEnumerable<TInner>
    {
        public EnumerableContainsExpectedFuncAssertCondition(System.Func<TInner, bool> matcher, string? matcherString) { }
        public TInner FoundItem { get; }
        protected override string GetExpectation() { }
        protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TActual? actualValue, System.Exception? exception, TUnit.Assertions.AssertionMetadata assertionMetadata) { }
    }
    public class EnumerableContainsExpectedValueAssertCondition<TActual, TInner> : TUnit.Assertions.AssertConditions.ExpectedValueAssertCondition<TActual, TInner>
        where TActual : System.Collections.Generic.IEnumerable<TInner>
    {
        public EnumerableContainsExpectedValueAssertCondition(TInner expected, System.Collections.Generic.IEqualityComparer<TInner?>? equalityComparer) { }
        protected override string GetExpectation() { }
        protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TActual? actualValue, TInner? inner) { }
    }
    public class EnumerableCountEqualToExpectedValueAssertCondition<TActual, TInner> : TUnit.Assertions.AssertConditions.ExpectedValueAssertCondition<TActual, int>
        where TActual : System.Collections.Generic.IEnumerable<TInner>
    {
        public EnumerableCountEqualToExpectedValueAssertCondition(int expected) { }
        protected override string GetExpectation() { }
        protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TActual? actualValue, int count) { }
    }
    public class EnumerableCountNotEqualToExpectedValueAssertCondition<TActual, TInner> : TUnit.Assertions.AssertConditions.ExpectedValueAssertCondition<TActual, int>
        where TActual : System.Collections.Generic.IEnumerable<TInner>
    {
        public EnumerableCountNotEqualToExpectedValueAssertCondition(int expected) { }
        protected override string GetExpectation() { }
        protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TActual? actualValue, int count) { }
    }
    public class EnumerableDistinctItemsExpectedValueAssertCondition<TActual, TInner> : TUnit.Assertions.AssertConditions.BaseAssertCondition<TActual>
        where TActual : System.Collections.Generic.IEnumerable<TInner>
    {
        public EnumerableDistinctItemsExpectedValueAssertCondition(System.Collections.Generic.IEqualityComparer<TInner?>? equalityComparer) { }
        protected override string GetExpectation() { }
        protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TActual? actualValue, System.Exception? exception, TUnit.Assertions.AssertionMetadata assertionMetadata) { }
    }
    public class EnumerableEquivalentToExpectedValueAssertCondition<TActual, TInner> : TUnit.Assertions.AssertConditions.ExpectedValueAssertCondition<TActual, System.Collections.Generic.IEnumerable<TInner>>
        where TActual : System.Collections.Generic.IEnumerable<TInner>?
    {
        public EnumerableEquivalentToExpectedValueAssertCondition(System.Collections.Generic.IEnumerable<TInner>? expected, System.Collections.Generic.IEqualityComparer<TInner?> equalityComparer, TUnit.Assertions.Enums.CollectionOrdering collectionOrdering) { }
        protected override string GetExpectation() { }
        protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TActual? actualValue, System.Collections.Generic.IEnumerable<TInner>? expectedValue) { }
    }
    public class EnumerableNotContainsExpectedFuncAssertCondition<TActual, TInner> : TUnit.Assertions.AssertConditions.BaseAssertCondition<TActual>
        where TActual : System.Collections.Generic.IEnumerable<TInner>
    {
        public EnumerableNotContainsExpectedFuncAssertCondition(System.Func<TInner, bool> matcher, string? matcherString) { }
        protected override string GetExpectation() { }
        protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TActual? actualValue, System.Exception? exception, TUnit.Assertions.AssertionMetadata assertionMetadata) { }
    }
    public class EnumerableNotContainsExpectedValueAssertCondition<TActual, TInner> : TUnit.Assertions.AssertConditions.ExpectedValueAssertCondition<TActual, TInner>
        where TActual : System.Collections.Generic.IEnumerable<TInner>
    {
        public EnumerableNotContainsExpectedValueAssertCondition(TInner expected, System.Collections.Generic.IEqualityComparer<TInner?>? equalityComparer) { }
        protected override string GetExpectation() { }
        protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TActual? actualValue, TInner? inner) { }
    }
    public class EnumerableNotEquivalentToExpectedValueAssertCondition<TActual, TInner> : TUnit.Assertions.AssertConditions.ExpectedValueAssertCondition<TActual, System.Collections.Generic.IEnumerable<TInner>>
        where TActual : System.Collections.Generic.IEnumerable<TInner>?
    {
        public EnumerableNotEquivalentToExpectedValueAssertCondition(System.Collections.Generic.IEnumerable<TInner>? expected, System.Collections.Generic.IEqualityComparer<TInner?> equalityComparer, TUnit.Assertions.Enums.CollectionOrdering collectionOrdering) { }
        protected override string GetExpectation() { }
        protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TActual? actualValue, System.Collections.Generic.IEnumerable<TInner>? expectedValue) { }
    }
    public class EnumerableOrderedByAssertCondition<TActual, TInner, TComparisonItem> : TUnit.Assertions.AssertConditions.BaseAssertCondition<TActual>
        where TActual : System.Collections.Generic.IEnumerable<TInner>
    {
        public EnumerableOrderedByAssertCondition(System.Collections.Generic.IComparer<TComparisonItem?> comparer, System.Func<TInner, TComparisonItem> comparisonItemSelector, TUnit.Assertions.Enums.Order order) { }
        protected override string GetExpectation() { }
        protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TActual? actualValue, System.Exception? exception, TUnit.Assertions.AssertionMetadata assertionMetadata) { }
    }
    public class PropertyOrMethodAccessor<TActual>
    {
        public PropertyOrMethodAccessor() { }
    }
}
namespace TUnit.Assertions.AssertConditions.Comparable
{
    public class BetweenAssertCondition<TActual> : TUnit.Assertions.AssertConditions.BaseAssertCondition<TActual>
        where TActual : System.IComparable<TActual>
    {
        public BetweenAssertCondition(TActual minimum, TActual maximum) { }
        public void Exclusive() { }
        protected override string GetExpectation() { }
        protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TActual? actualValue, System.Exception? exception, TUnit.Assertions.AssertionMetadata assertionMetadata) { }
        public void Inclusive() { }
    }
    public class NotBetweenAssertCondition<TActual> : TUnit.Assertions.AssertConditions.BaseAssertCondition<TActual>
        where TActual : System.IComparable<TActual>
    {
        public NotBetweenAssertCondition(TActual minimum, TActual maximum) { }
        public void Exclusive() { }
        protected override string GetExpectation() { }
        protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TActual? actualValue, System.Exception? exception, TUnit.Assertions.AssertionMetadata assertionMetadata) { }
        public void Inclusive() { }
    }
}
namespace TUnit.Assertions.AssertConditions.Exceptions
{
    public class ExceptionMessageContainingExpectedValueAssertCondition<TException> : TUnit.Assertions.AssertConditions.ExpectedValueAssertCondition<TException, string>
        where TException : System.Exception
    {
        public ExceptionMessageContainingExpectedValueAssertCondition(string expected, System.StringComparison stringComparison) { }
        protected override string GetExpectation() { }
        protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TException? actualValue, string? expectedValue) { }
    }
    public class ExceptionMessageEndingWithExpectedValueAssertCondition<TException> : TUnit.Assertions.AssertConditions.ExpectedValueAssertCondition<TException, string>
        where TException : System.Exception
    {
        public ExceptionMessageEndingWithExpectedValueAssertCondition(string expected, System.StringComparison stringComparison) { }
        protected override string GetExpectation() { }
        protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TException? actualValue, string? expectedValue) { }
    }
    public class ExceptionMessageEqualsExpectedValueAssertCondition<TException> : TUnit.Assertions.AssertConditions.ExpectedValueAssertCondition<TException, string>
        where TException : System.Exception
    {
        public ExceptionMessageEqualsExpectedValueAssertCondition(string expected, System.StringComparison stringComparison) { }
        protected override string GetExpectation() { }
        protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TException? actualValue, string? expectedValue) { }
    }
    public class ExceptionMessageMatchingExpectedAssertCondition<TException> : TUnit.Assertions.AssertConditions.ExpectedValueAssertCondition<TException, TUnit.Assertions.AssertConditions.StringMatcher>
        where TException : System.Exception
    {
        public ExceptionMessageMatchingExpectedAssertCondition(TUnit.Assertions.AssertConditions.StringMatcher match) { }
        protected override string GetExpectation() { }
        protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TException? actualValue, TUnit.Assertions.AssertConditions.StringMatcher? expectedValue) { }
    }
    public class ExceptionMessageStartingWithExpectedValueAssertCondition<TException> : TUnit.Assertions.AssertConditions.ExpectedValueAssertCondition<TException, string>
        where TException : System.Exception
    {
        public ExceptionMessageStartingWithExpectedValueAssertCondition(string expected, System.StringComparison stringComparison) { }
        protected override string GetExpectation() { }
        protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TException? actualValue, string? expectedValue) { }
    }
}
namespace TUnit.Assertions.AssertConditions.Interfaces
{
    public class ConvertedDelegateSource<TToType> : TUnit.Assertions.AssertConditions.Interfaces.ISource, TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TToType?>
        where TToType : System.Exception
    {
        public ConvertedDelegateSource(TUnit.Assertions.AssertConditions.Interfaces.IDelegateSource source) { }
        public string? ActualExpression { get; }
        public System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertionData> AssertionDataTask { get; }
        public System.Collections.Generic.Stack<TUnit.Assertions.AssertConditions.BaseAssertCondition> Assertions { get; }
        public System.Text.StringBuilder ExpressionBuilder { get; }
        public TUnit.Assertions.AssertConditions.Interfaces.ISource AppendExpression(string expression) { }
        public TUnit.Assertions.AssertConditions.Interfaces.ISource WithAssertion(TUnit.Assertions.AssertConditions.BaseAssertCondition assertCondition) { }
    }
    public class ConvertedValueSource<TFromType, TToType> : TUnit.Assertions.AssertConditions.Interfaces.ISource, TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TToType?>
    {
        public ConvertedValueSource(TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TFromType> source, TUnit.Assertions.AssertConditions.ConvertToAssertCondition<TFromType, TToType> convertToAssertCondition) { }
        public string? ActualExpression { get; }
        public System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertionData> AssertionDataTask { get; }
        public System.Collections.Generic.Stack<TUnit.Assertions.AssertConditions.BaseAssertCondition> Assertions { get; }
        public System.Text.StringBuilder ExpressionBuilder { get; }
        public TUnit.Assertions.AssertConditions.Interfaces.ISource AppendExpression(string expression) { }
        public TUnit.Assertions.AssertConditions.Interfaces.ISource WithAssertion(TUnit.Assertions.AssertConditions.BaseAssertCondition assertCondition) { }
    }
    public interface IDelegateSource : TUnit.Assertions.AssertConditions.Interfaces.ISource { }
    public interface ISource
    {
        string? ActualExpression { get; }
        TUnit.Assertions.AssertConditions.Interfaces.ISource AppendExpression(string expression);
        TUnit.Assertions.AssertConditions.Interfaces.ISource WithAssertion(TUnit.Assertions.AssertConditions.BaseAssertCondition assertCondition);
    }
    public interface IValueDelegateSource<out TActual> : TUnit.Assertions.AssertConditions.Interfaces.IDelegateSource, TUnit.Assertions.AssertConditions.Interfaces.ISource, TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> { }
    public interface IValueSource<out TActual> : TUnit.Assertions.AssertConditions.Interfaces.ISource { }
}
namespace TUnit.Assertions.AssertConditions.Operators
{
    [System.Flags]
    public enum AssertionType
    {
        Value = 1,
        Delegate = 2,
    }
    public class DelegateAnd<TActual> : TUnit.Assertions.AssertConditions.Interfaces.IDelegateSource, TUnit.Assertions.AssertConditions.Interfaces.ISource
    {
        public DelegateAnd(TUnit.Assertions.AssertionBuilders.AssertionBuilder assertionBuilder) { }
        public static TUnit.Assertions.AssertConditions.Operators.DelegateAnd<TActual> Create(TUnit.Assertions.AssertionBuilders.AssertionBuilder assertionBuilder) { }
    }
    public class DelegateOr<TActual> : TUnit.Assertions.AssertConditions.Interfaces.IDelegateSource, TUnit.Assertions.AssertConditions.Interfaces.ISource
    {
        public DelegateOr(TUnit.Assertions.AssertionBuilders.AssertionBuilder assertionBuilder) { }
        public static TUnit.Assertions.AssertConditions.Operators.DelegateOr<TActual> Create(TUnit.Assertions.AssertionBuilders.AssertionBuilder assertionBuilder) { }
    }
    public class ValueAnd<TActual> : TUnit.Assertions.AssertConditions.Interfaces.ISource, TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual>
    {
        public ValueAnd(TUnit.Assertions.AssertionBuilders.AssertionBuilder assertionBuilder) { }
        public static TUnit.Assertions.AssertConditions.Operators.ValueAnd<TActual> Create(TUnit.Assertions.AssertionBuilders.AssertionBuilder assertionBuilder) { }
    }
    public class ValueDelegateAnd<TActual> : TUnit.Assertions.AssertConditions.Interfaces.IDelegateSource, TUnit.Assertions.AssertConditions.Interfaces.ISource, TUnit.Assertions.AssertConditions.Interfaces.IValueDelegateSource<TActual>, TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual>
    {
        public ValueDelegateAnd(TUnit.Assertions.AssertionBuilders.AssertionBuilder assertionBuilder) { }
        public static TUnit.Assertions.AssertConditions.Operators.ValueDelegateAnd<TActual> Create(TUnit.Assertions.AssertionBuilders.AssertionBuilder assertionBuilder) { }
    }
    public class ValueDelegateOr<TActual> : TUnit.Assertions.AssertConditions.Interfaces.IDelegateSource, TUnit.Assertions.AssertConditions.Interfaces.ISource, TUnit.Assertions.AssertConditions.Interfaces.IValueDelegateSource<TActual>, TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual>
    {
        public ValueDelegateOr(TUnit.Assertions.AssertionBuilders.AssertionBuilder assertionBuilder) { }
        public static TUnit.Assertions.AssertConditions.Operators.ValueDelegateOr<TActual> Create(TUnit.Assertions.AssertionBuilders.AssertionBuilder assertionBuilder) { }
    }
    public class ValueOr<TActual> : TUnit.Assertions.AssertConditions.Interfaces.ISource, TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual>
    {
        public ValueOr(TUnit.Assertions.AssertionBuilders.AssertionBuilder assertionBuilder) { }
    }
}
namespace TUnit.Assertions.AssertConditions.String
{
    public class StringEqualsExpectedValueAssertCondition : TUnit.Assertions.AssertConditions.ExpectedValueAssertCondition<string, string>
    {
        public StringEqualsExpectedValueAssertCondition(string expected, System.StringComparison stringComparison) { }
        protected override string GetExpectation() { }
        protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(string? actualValue, string? expectedValue) { }
        public TUnit.Assertions.AssertConditions.String.StringEqualsExpectedValueAssertCondition IgnoringWhitespace() { }
        public TUnit.Assertions.AssertConditions.String.StringEqualsExpectedValueAssertCondition WithNullAndEmptyEquality() { }
        public TUnit.Assertions.AssertConditions.String.StringEqualsExpectedValueAssertCondition WithTrimming() { }
    }
    public class StringNotContainsExpectedValueAssertCondition : TUnit.Assertions.AssertConditions.ExpectedValueAssertCondition<string, string>
    {
        public StringNotContainsExpectedValueAssertCondition(string expected, System.StringComparison stringComparison) { }
        protected override string GetExpectation() { }
        protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(string? actualValue, string? expectedValue) { }
    }
    public class StringNotEqualsExpectedValueAssertCondition : TUnit.Assertions.AssertConditions.ExpectedValueAssertCondition<string, string>
    {
        public StringNotEqualsExpectedValueAssertCondition(string expected, System.StringComparison stringComparison) { }
        protected override string GetExpectation() { }
        protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(string? actualValue, string? expectedValue) { }
    }
}
namespace TUnit.Assertions.AssertConditions.Throws
{
    public class ThrowsAnyExceptionAssertCondition<TActual> : TUnit.Assertions.AssertConditions.DelegateAssertCondition<TActual, System.Exception>
    {
        public ThrowsAnyExceptionAssertCondition() { }
        protected override string GetExpectation() { }
        protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TActual? actualValue, System.Exception? exception, TUnit.Assertions.AssertionMetadata assertionMetadata) { }
    }
    public class ThrowsExactTypeOfDelegateAssertCondition<TActual, TExpectedException> : TUnit.Assertions.AssertConditions.DelegateAssertCondition<TActual, TExpectedException>
        where TExpectedException : System.Exception
    {
        public ThrowsExactTypeOfDelegateAssertCondition() { }
        protected override string GetExpectation() { }
        protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TActual? actualValue, System.Exception? exception, TUnit.Assertions.AssertionMetadata assertionMetadata) { }
    }
    public class ThrowsException<TActual, TException>
        where TException : System.Exception
    {
        public ThrowsException(TUnit.Assertions.AssertionBuilders.InvokableDelegateAssertionBuilder delegateAssertionBuilder, TUnit.Assertions.AssertConditions.Interfaces.IDelegateSource source, System.Func<System.Exception?, System.Exception?> selector) { }
        public TUnit.Assertions.AssertConditions.Operators.ValueAnd<TException> And { get; }
        public TUnit.Assertions.AssertConditions.Operators.DelegateOr<object?> Or { get; }
        public System.Runtime.CompilerServices.TaskAwaiter<TException?> GetAwaiter() { }
        public TUnit.Assertions.AssertConditions.Throws.ThrowsException<TActual, System.Exception> WithInnerException() { }
        public TUnit.Assertions.AssertConditions.Throws.ThrowsException<TActual, TException> WithMessage(string expected, [System.Runtime.CompilerServices.CallerArgumentExpression("expected")] string? doNotPopulateThisValue = null) { }
        public TUnit.Assertions.AssertConditions.Throws.ThrowsException<TActual, TException> WithMessageMatching(TUnit.Assertions.AssertConditions.StringMatcher match, [System.Runtime.CompilerServices.CallerArgumentExpression("match")] string? doNotPopulateThisValue = null) { }
    }
    public static class ThrowsExtensions
    {
        public static TUnit.Assertions.AssertConditions.Throws.ThrowsException<object?, TException> Throws<TException>(this TUnit.Assertions.AssertConditions.Interfaces.IDelegateSource delegateSource)
            where TException : System.Exception { }
        public static TUnit.Assertions.AssertConditions.Throws.ThrowsException<object?, TException> ThrowsExactly<TException>(this TUnit.Assertions.AssertConditions.Interfaces.IDelegateSource delegateSource)
            where TException : System.Exception { }
        public static TUnit.Assertions.AssertConditions.Throws.ThrowsException<object?, System.Exception> ThrowsException(this TUnit.Assertions.AssertConditions.Interfaces.IDelegateSource delegateSource) { }
        public static TUnit.Assertions.AssertionBuilders.CastableResultAssertionBuilder<object?, object?> ThrowsNothing(this TUnit.Assertions.AssertConditions.Interfaces.IDelegateSource delegateSource) { }
        public static TUnit.Assertions.AssertionBuilders.CastableResultAssertionBuilder<TActual, TActual> ThrowsNothing<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueDelegateSource<TActual> delegateSource) { }
        public static TUnit.Assertions.AssertionBuilders.InvokableDelegateAssertionBuilder ThrowsWithin(this TUnit.Assertions.AssertConditions.Interfaces.IDelegateSource delegateSource, System.TimeSpan timeSpan, [System.Runtime.CompilerServices.CallerArgumentExpression("timeSpan")] string? doNotPopulateThisValue = null) { }
        public static TUnit.Assertions.AssertionBuilders.InvokableDelegateAssertionBuilder ThrowsWithin<TException>(this TUnit.Assertions.AssertConditions.Interfaces.IDelegateSource delegateSource, System.TimeSpan timeSpan, [System.Runtime.CompilerServices.CallerArgumentExpression("timeSpan")] string? doNotPopulateThisValue = null)
            where TException : System.Exception { }
        public static TUnit.Assertions.AssertConditions.Throws.ThrowsException<TActual, TException> WithParameterName<TActual, TException>(this TUnit.Assertions.AssertConditions.Throws.ThrowsException<TActual, TException> throwsException, string expected, [System.Runtime.CompilerServices.CallerArgumentExpression("expected")] string? doNotPopulateThisValue = null)
            where TException : System.ArgumentException { }
    }
    public class ThrowsNothingAssertCondition<TActual> : TUnit.Assertions.AssertConditions.DelegateAssertCondition<TActual, System.Exception>
    {
        public ThrowsNothingAssertCondition() { }
        protected override string GetExpectation() { }
        protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TActual? actualValue, System.Exception? exception, TUnit.Assertions.AssertionMetadata assertionMetadata) { }
    }
    public class ThrowsOfTypeAssertCondition<TActual, TExpectedException> : TUnit.Assertions.AssertConditions.DelegateAssertCondition<TActual, System.Exception>
    {
        public ThrowsOfTypeAssertCondition() { }
        protected override string GetExpectation() { }
        protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TActual? actualValue, System.Exception? exception, TUnit.Assertions.AssertionMetadata assertionMetadata) { }
    }
    public class ThrowsWithMessageAssertCondition<TActual, TException> : TUnit.Assertions.AssertConditions.DelegateAssertCondition<TActual, System.Exception>
        where TException : System.Exception
    {
        public ThrowsWithMessageAssertCondition(string expectedMessage, System.StringComparison stringComparison, System.Func<System.Exception?, System.Exception?> exceptionSelector) { }
        protected override string GetExpectation() { }
        protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TActual? actualValue, System.Exception? exception, TUnit.Assertions.AssertionMetadata assertionMetadata) { }
    }
    public class ThrowsWithMessageMatchingAssertCondition<TActual, TException> : TUnit.Assertions.AssertConditions.DelegateAssertCondition<TActual, System.Exception>
        where TException : System.Exception
    {
        public ThrowsWithMessageMatchingAssertCondition(TUnit.Assertions.AssertConditions.StringMatcher match, System.Func<System.Exception?, System.Exception?> exceptionSelector) { }
        protected override string GetExpectation() { }
        protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TActual? actualValue, System.Exception? exception, TUnit.Assertions.AssertionMetadata assertionMetadata) { }
    }
    public class ThrowsWithParamNameAssertCondition<TActual, TException> : TUnit.Assertions.AssertConditions.DelegateAssertCondition<TActual, System.ArgumentException>
        where TException : System.ArgumentException
    {
        public ThrowsWithParamNameAssertCondition(string expectedParamName, System.StringComparison stringComparison, System.Func<System.Exception?, System.ArgumentException?> exceptionSelector) { }
        protected override string GetExpectation() { }
        protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TActual? actualValue, System.Exception? exception, TUnit.Assertions.AssertionMetadata assertionMetadata) { }
    }
}
namespace TUnit.Assertions.AssertionBuilders
{
    public class AndAssertionBuilder : TUnit.Assertions.AssertionBuilders.AssertionBuilder, TUnit.Assertions.AssertionBuilders.IAndAssertionBuilder { }
    public abstract class AssertionBuilder : TUnit.Assertions.AssertConditions.Interfaces.ISource
    {
        protected TUnit.Assertions.AssertionData? AwaitedAssertionData;
        protected TUnit.Assertions.AssertionBuilders.IInvokableAssertionBuilder? OtherTypeAssertionBuilder;
        protected readonly System.Collections.Generic.List<TUnit.Assertions.AssertConditions.AssertionResult> Results;
        public AssertionBuilder(TUnit.Assertions.AssertConditions.Interfaces.ISource source) { }
        public AssertionBuilder(System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertionData> assertionDataTask, string? actualExpression) { }
        public AssertionBuilder(System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertionData> assertionDataTask, string actualExpression, System.Text.StringBuilder expressionBuilder, System.Collections.Generic.Stack<TUnit.Assertions.AssertConditions.BaseAssertCondition> assertions) { }
        protected void AppendCallerMethod(string?[] expressions, [System.Runtime.CompilerServices.CallerMemberName] string methodName = "") { }
        [System.Diagnostics.DebuggerHidden]
        [System.Obsolete("This is a base `object` method that should not be called.", true)]
        public new void Equals(object? obj) { }
        [System.Diagnostics.DebuggerHidden]
        [System.Obsolete("This is a base `object` method that should not be called.", true)]
        public void ReferenceEquals(object a, object b) { }
    }
    public class AsyncDelegateAssertionBuilder : TUnit.Assertions.AssertionBuilders.AssertionBuilder, TUnit.Assertions.AssertConditions.Interfaces.IDelegateSource, TUnit.Assertions.AssertConditions.Interfaces.ISource { }
    public class AsyncValueDelegateAssertionBuilder<TActual> : TUnit.Assertions.AssertionBuilders.AssertionBuilder, TUnit.Assertions.AssertConditions.Interfaces.IDelegateSource, TUnit.Assertions.AssertConditions.Interfaces.ISource, TUnit.Assertions.AssertConditions.Interfaces.IValueDelegateSource<TActual>, TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> { }
    public class CastableResultAssertionBuilder<TActual, TExpected> : TUnit.Assertions.AssertionBuilders.MappableResultAssertionBuilder<TActual, TExpected> { }
    public class CastedAssertionBuilder<TActual, TExpected> : TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TExpected> { }
    public class ConvertedDelegateAssertionBuilder<TException> : TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TException>
        where TException : System.Exception
    {
        public ConvertedDelegateAssertionBuilder(TUnit.Assertions.AssertConditions.Interfaces.IDelegateSource source) { }
    }
    public class ConvertedValueAssertionBuilder<TFromType, TToType> : TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TToType>
    {
        public ConvertedValueAssertionBuilder(TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TFromType> source, TUnit.Assertions.AssertConditions.ConvertToAssertCondition<TFromType, TToType> convertToAssertCondition) { }
    }
    public class DelegateAssertionBuilder : TUnit.Assertions.AssertionBuilders.AssertionBuilder, TUnit.Assertions.AssertConditions.Interfaces.IDelegateSource, TUnit.Assertions.AssertConditions.Interfaces.ISource { }
    public interface IAndAssertionBuilder { }
    public interface IInvokableAssertionBuilder : TUnit.Assertions.AssertConditions.Interfaces.ISource
    {
        System.Runtime.CompilerServices.TaskAwaiter GetAwaiter();
        string? GetExpression();
    }
    public interface IOrAssertionBuilder { }
    public class InvokableAssertionBuilder<TActual> : TUnit.Assertions.AssertionBuilders.AssertionBuilder, TUnit.Assertions.AssertConditions.Interfaces.ISource, TUnit.Assertions.AssertionBuilders.IInvokableAssertionBuilder
    {
        protected System.Collections.Generic.Stack<TUnit.Assertions.AssertConditions.BaseAssertCondition> Assertions { get; }
        public System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<TUnit.Assertions.AssertConditions.AssertionResult>> GetAssertionResults() { }
        public System.Runtime.CompilerServices.TaskAwaiter GetAwaiter() { }
    }
    public class InvokableDelegateAssertionBuilder : TUnit.Assertions.AssertionBuilders.InvokableAssertionBuilder<object?>, TUnit.Assertions.AssertConditions.Interfaces.IDelegateSource, TUnit.Assertions.AssertConditions.Interfaces.ISource
    {
        public TUnit.Assertions.AssertConditions.Operators.DelegateAnd<object?> And { get; }
        public TUnit.Assertions.AssertionBuilders.AssertionBuilder AssertionBuilder { get; }
        public TUnit.Assertions.AssertConditions.Operators.DelegateOr<object?> Or { get; }
    }
    public class InvokableValueAssertionBuilder<TActual> : TUnit.Assertions.AssertionBuilders.InvokableAssertionBuilder<TActual>, TUnit.Assertions.AssertConditions.Interfaces.ISource, TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual>
    {
        public InvokableValueAssertionBuilder(TUnit.Assertions.AssertConditions.Interfaces.ISource source) { }
        public TUnit.Assertions.AssertConditions.Operators.ValueAnd<TActual> And { get; }
        public TUnit.Assertions.AssertConditions.Operators.ValueOr<TActual> Or { get; }
        public TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> Because(string reason) { }
        public new System.Runtime.CompilerServices.TaskAwaiter<TActual?> GetAwaiter() { }
    }
    public class InvokableValueDelegateAssertionBuilder<TActual> : TUnit.Assertions.AssertionBuilders.InvokableAssertionBuilder<TActual>
    {
        public TUnit.Assertions.AssertConditions.Operators.ValueDelegateAnd<TActual> And { get; }
        public TUnit.Assertions.AssertionBuilders.AssertionBuilder AssertionBuilder { get; }
        public TUnit.Assertions.AssertConditions.Operators.ValueDelegateOr<TActual> Or { get; }
    }
    public class MappableResultAssertionBuilder<TActual, TExpected> : TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual>
    {
        public new System.Runtime.CompilerServices.TaskAwaiter<TExpected?> GetAwaiter() { }
    }
    public class MappableResultAssertionBuilder<TActual, TAssertCondition, TExpected> : TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual>
        where TAssertCondition : TUnit.Assertions.AssertConditions.BaseAssertCondition<TActual>
    {
        public new System.Runtime.CompilerServices.TaskAwaiter<TExpected?> GetAwaiter() { }
    }
    public class OrAssertionBuilder : TUnit.Assertions.AssertionBuilders.AssertionBuilder, TUnit.Assertions.AssertionBuilders.IOrAssertionBuilder { }
    public class ValueAssertionBuilder<TActual> : TUnit.Assertions.AssertionBuilders.AssertionBuilder, TUnit.Assertions.AssertConditions.Interfaces.ISource, TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual>
    {
        public ValueAssertionBuilder(TUnit.Assertions.AssertConditions.Interfaces.ISource source) { }
    }
    public class ValueDelegateAssertionBuilder<TActual> : TUnit.Assertions.AssertionBuilders.AssertionBuilder, TUnit.Assertions.AssertConditions.Interfaces.IDelegateSource, TUnit.Assertions.AssertConditions.Interfaces.ISource, TUnit.Assertions.AssertConditions.Interfaces.IValueDelegateSource<TActual>, TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> { }
}
namespace TUnit.Assertions.AssertionBuilders.Groups
{
    public class AndAssertionGroupInvoker<TActual, TAssertionBuilder>
        where TAssertionBuilder : TUnit.Assertions.AssertionBuilders.AssertionBuilder
    {
        public AndAssertionGroupInvoker(TUnit.Assertions.AssertionBuilders.Groups.AssertionGroup<TActual, TAssertionBuilder> group1, TUnit.Assertions.AssertionBuilders.Groups.AssertionGroup<TActual, TAssertionBuilder> group2) { }
        public TUnit.Assertions.AssertionBuilders.Groups.AndAssertionGroupInvoker<TActual, TAssertionBuilder> And(TUnit.Assertions.AssertionBuilders.Groups.AssertionGroup<TActual, TAssertionBuilder> group) { }
        public System.Runtime.CompilerServices.TaskAwaiter<TActual?> GetAwaiter() { }
    }
    public class AndAssertionGroup<TActual, TAssertionBuilder> : TUnit.Assertions.AssertionBuilders.Groups.AssertionGroup<TActual, TAssertionBuilder>
        where TAssertionBuilder : TUnit.Assertions.AssertionBuilders.AssertionBuilder
    {
        public TUnit.Assertions.AssertionBuilders.Groups.AndAssertionGroup<TActual, TAssertionBuilder> And(System.Func<TAssertionBuilder, TUnit.Assertions.AssertionBuilders.InvokableAssertionBuilder<TActual>> assert) { }
        public override System.Runtime.CompilerServices.TaskAwaiter<TActual?> GetAwaiter() { }
    }
    public static class AssertionGroup
    {
        public static TUnit.Assertions.AssertionBuilders.Groups.AndAssertionGroupInvoker<TActual, TAssertionBuilder> And<TActual, TAssertionBuilder>(TUnit.Assertions.AssertionBuilders.Groups.AssertionGroup<TActual, TAssertionBuilder> group1, TUnit.Assertions.AssertionBuilders.Groups.AssertionGroup<TActual, TAssertionBuilder> group2)
            where TAssertionBuilder : TUnit.Assertions.AssertionBuilders.AssertionBuilder { }
        public static TUnit.Assertions.AssertionBuilders.Groups.UnknownAssertionGroupInvoker<TActual, TAssertionBuilder> Assert<TActual, TAssertionBuilder>(TUnit.Assertions.AssertionBuilders.Groups.AssertionGroup<TActual, TAssertionBuilder> group)
            where TAssertionBuilder : TUnit.Assertions.AssertionBuilders.AssertionBuilder { }
        public static TUnit.Assertions.AssertionBuilders.Groups.AssertionGroupBuilder<object?, TUnit.Assertions.AssertionBuilders.DelegateAssertionBuilder> For(System.Action value) { }
        public static TUnit.Assertions.AssertionBuilders.Groups.AssertionGroupBuilder<object?, TUnit.Assertions.AssertionBuilders.AsyncDelegateAssertionBuilder> For(System.Func<System.Threading.Tasks.Task> value) { }
        public static TUnit.Assertions.AssertionBuilders.Groups.AssertionGroupBuilder<object?, TUnit.Assertions.AssertionBuilders.AsyncDelegateAssertionBuilder> For(System.Threading.Tasks.Task value) { }
        public static TUnit.Assertions.AssertionBuilders.Groups.AssertionGroupBuilder<object?, TUnit.Assertions.AssertionBuilders.AsyncDelegateAssertionBuilder> For(System.Threading.Tasks.ValueTask value) { }
        public static TUnit.Assertions.AssertionBuilders.Groups.AssertionGroupBuilder<TActual, TUnit.Assertions.AssertionBuilders.AsyncValueDelegateAssertionBuilder<TActual>> For<TActual>(System.Func<System.Threading.Tasks.Task<TActual>> value) { }
        public static TUnit.Assertions.AssertionBuilders.Groups.AssertionGroupBuilder<TActual, TUnit.Assertions.AssertionBuilders.ValueDelegateAssertionBuilder<TActual>> For<TActual>(System.Func<TActual> value) { }
        public static TUnit.Assertions.AssertionBuilders.Groups.AssertionGroupBuilder<TActual, TUnit.Assertions.AssertionBuilders.AsyncValueDelegateAssertionBuilder<TActual>> For<TActual>(System.Threading.Tasks.Task<TActual> value) { }
        public static TUnit.Assertions.AssertionBuilders.Groups.AssertionGroupBuilder<TActual, TUnit.Assertions.AssertionBuilders.AsyncValueDelegateAssertionBuilder<TActual>> For<TActual>(System.Threading.Tasks.ValueTask<TActual> value) { }
        public static TUnit.Assertions.AssertionBuilders.Groups.AssertionGroupBuilder<TActual, TUnit.Assertions.AssertionBuilders.ValueAssertionBuilder<TActual>> For<TActual>(TActual value) { }
        public static TUnit.Assertions.AssertionBuilders.Groups.AssertionGroupBuilder<object?, TUnit.Assertions.AssertionBuilders.AsyncDelegateAssertionBuilder> ForSameValueAs(TUnit.Assertions.AssertionBuilders.Groups.AssertionGroup<object?, TUnit.Assertions.AssertionBuilders.AsyncDelegateAssertionBuilder> otherGroup) { }
        public static TUnit.Assertions.AssertionBuilders.Groups.AssertionGroupBuilder<object?, TUnit.Assertions.AssertionBuilders.DelegateAssertionBuilder> ForSameValueAs(TUnit.Assertions.AssertionBuilders.Groups.AssertionGroup<object?, TUnit.Assertions.AssertionBuilders.DelegateAssertionBuilder> otherGroup) { }
        public static TUnit.Assertions.AssertionBuilders.Groups.AssertionGroupBuilder<TActual, TUnit.Assertions.AssertionBuilders.AsyncValueDelegateAssertionBuilder<TActual>> ForSameValueAs<TActual>(TUnit.Assertions.AssertionBuilders.Groups.AssertionGroup<TActual, TUnit.Assertions.AssertionBuilders.AsyncValueDelegateAssertionBuilder<TActual>> otherGroup) { }
        public static TUnit.Assertions.AssertionBuilders.Groups.AssertionGroupBuilder<TActual, TUnit.Assertions.AssertionBuilders.ValueAssertionBuilder<TActual>> ForSameValueAs<TActual>(TUnit.Assertions.AssertionBuilders.Groups.AssertionGroup<TActual, TUnit.Assertions.AssertionBuilders.ValueAssertionBuilder<TActual>> otherGroup) { }
        public static TUnit.Assertions.AssertionBuilders.Groups.AssertionGroupBuilder<TActual, TUnit.Assertions.AssertionBuilders.ValueDelegateAssertionBuilder<TActual>> ForSameValueAs<TActual>(TUnit.Assertions.AssertionBuilders.Groups.AssertionGroup<TActual, TUnit.Assertions.AssertionBuilders.ValueDelegateAssertionBuilder<TActual>> otherGroup) { }
        public static TUnit.Assertions.AssertionBuilders.Groups.OrAssertionGroupInvoker<TActual, TAssertionBuilder> Or<TActual, TAssertionBuilder>(TUnit.Assertions.AssertionBuilders.Groups.AssertionGroup<TActual, TAssertionBuilder> group1, TUnit.Assertions.AssertionBuilders.Groups.AssertionGroup<TActual, TAssertionBuilder> group2)
            where TAssertionBuilder : TUnit.Assertions.AssertionBuilders.AssertionBuilder { }
    }
    public class AssertionGroupBuilder<TActual, TAssertionBuilder>
        where TAssertionBuilder : TUnit.Assertions.AssertionBuilders.AssertionBuilder
    {
        public TUnit.Assertions.AssertionBuilders.Groups.UnknownAssertionGroup<TActual, TAssertionBuilder> WithAssertion(System.Func<TAssertionBuilder, TUnit.Assertions.AssertionBuilders.InvokableAssertionBuilder<TActual>> assert) { }
    }
    public abstract class AssertionGroup<TActual, TAssertionBuilder>
        where TAssertionBuilder : TUnit.Assertions.AssertionBuilders.AssertionBuilder
    {
        public abstract System.Runtime.CompilerServices.TaskAwaiter<TActual?> GetAwaiter();
    }
    public class OrAssertionException : System.AggregateException
    {
        public OrAssertionException(System.Collections.Generic.IEnumerable<System.Exception> exceptions) { }
        public override string Message { get; }
    }
    public class OrAssertionGroupInvoker<TActual, TAssertionBuilder>
        where TAssertionBuilder : TUnit.Assertions.AssertionBuilders.AssertionBuilder
    {
        public OrAssertionGroupInvoker(TUnit.Assertions.AssertionBuilders.Groups.AssertionGroup<TActual, TAssertionBuilder> group1, TUnit.Assertions.AssertionBuilders.Groups.AssertionGroup<TActual, TAssertionBuilder> group2) { }
        public System.Runtime.CompilerServices.TaskAwaiter<TActual?> GetAwaiter() { }
        public TUnit.Assertions.AssertionBuilders.Groups.OrAssertionGroupInvoker<TActual, TAssertionBuilder> Or(TUnit.Assertions.AssertionBuilders.Groups.AssertionGroup<TActual, TAssertionBuilder> group) { }
    }
    public class OrAssertionGroup<TActual, TAssertionBuilder> : TUnit.Assertions.AssertionBuilders.Groups.AssertionGroup<TActual, TAssertionBuilder>
        where TAssertionBuilder : TUnit.Assertions.AssertionBuilders.AssertionBuilder
    {
        public override System.Runtime.CompilerServices.TaskAwaiter<TActual?> GetAwaiter() { }
        public TUnit.Assertions.AssertionBuilders.Groups.OrAssertionGroup<TActual, TAssertionBuilder> Or(System.Func<TAssertionBuilder, TUnit.Assertions.AssertionBuilders.InvokableAssertionBuilder<TActual>> assert) { }
    }
    public class UnknownAssertionGroupInvoker<TActual, TAssertionBuilder>
        where TAssertionBuilder : TUnit.Assertions.AssertionBuilders.AssertionBuilder
    {
        public UnknownAssertionGroupInvoker(TUnit.Assertions.AssertionBuilders.Groups.AssertionGroup<TActual, TAssertionBuilder> group) { }
        public TUnit.Assertions.AssertionBuilders.Groups.AndAssertionGroupInvoker<TActual, TAssertionBuilder> And(TUnit.Assertions.AssertionBuilders.Groups.AssertionGroup<TActual, TAssertionBuilder> otherGroup) { }
        public TUnit.Assertions.AssertionBuilders.Groups.OrAssertionGroupInvoker<TActual, TAssertionBuilder> Or(TUnit.Assertions.AssertionBuilders.Groups.AssertionGroup<TActual, TAssertionBuilder> otherGroup) { }
    }
    public class UnknownAssertionGroup<TActual, TAssertionBuilder>
        where TAssertionBuilder : TUnit.Assertions.AssertionBuilders.AssertionBuilder
    {
        public TUnit.Assertions.AssertionBuilders.Groups.AndAssertionGroup<TActual, TAssertionBuilder> And(System.Func<TAssertionBuilder, TUnit.Assertions.AssertionBuilders.InvokableAssertionBuilder<TActual>> assert) { }
        public TUnit.Assertions.AssertionBuilders.Groups.OrAssertionGroup<TActual, TAssertionBuilder> Or(System.Func<TAssertionBuilder, TUnit.Assertions.AssertionBuilders.InvokableAssertionBuilder<TActual>> assert) { }
    }
}
namespace TUnit.Assertions.AssertionBuilders.Wrappers
{
    public class BetweenAssertionBuilderWrapper<TActual> : TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual>
        where TActual : System.IComparable<TActual>
    {
        public TUnit.Assertions.AssertionBuilders.Wrappers.BetweenAssertionBuilderWrapper<TActual> WithExclusiveBounds() { }
        public TUnit.Assertions.AssertionBuilders.Wrappers.BetweenAssertionBuilderWrapper<TActual> WithInclusiveBounds() { }
    }
    public class DateOnlyEqualToAssertionBuilderWrapper : TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.DateOnly>
    {
        public TUnit.Assertions.AssertionBuilders.Wrappers.DateOnlyEqualToAssertionBuilderWrapper WithinDays(int days, [System.Runtime.CompilerServices.CallerArgumentExpression("days")] string doNotPopulateThis = "") { }
    }
    public class DateTimeEqualToAssertionBuilderWrapper : TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.DateTime>
    {
        public TUnit.Assertions.AssertionBuilders.Wrappers.DateTimeEqualToAssertionBuilderWrapper Within(System.TimeSpan tolerance, [System.Runtime.CompilerServices.CallerArgumentExpression("tolerance")] string doNotPopulateThis = "") { }
    }
    public class DateTimeOffsetEqualToAssertionBuilderWrapper : TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.DateTimeOffset>
    {
        public TUnit.Assertions.AssertionBuilders.Wrappers.DateTimeOffsetEqualToAssertionBuilderWrapper Within(System.TimeSpan tolerance, [System.Runtime.CompilerServices.CallerArgumentExpression("tolerance")] string doNotPopulateThis = "") { }
    }
    public class EquivalentToAssertionBuilderWrapper<TActual, TExpected> : TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual>
    {
        public TUnit.Assertions.AssertionBuilders.Wrappers.EquivalentToAssertionBuilderWrapper<TActual, TExpected> IgnoringMember(string propertyName, [System.Runtime.CompilerServices.CallerArgumentExpression("propertyName")] string doNotPopulateThis = "") { }
        public TUnit.Assertions.AssertionBuilders.Wrappers.EquivalentToAssertionBuilderWrapper<TActual, TExpected> WithPartialEquivalency() { }
    }
    public class GenericEqualToAssertionBuilderWrapper<TActual> : TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> { }
    public class GenericNotEqualToAssertionBuilderWrapper<TActual> : TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> { }
    public class NotBetweenAssertionBuilderWrapper<TActual> : TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual>
        where TActual : System.IComparable<TActual>
    {
        public TUnit.Assertions.AssertionBuilders.Wrappers.NotBetweenAssertionBuilderWrapper<TActual> WithExclusiveBounds() { }
        public TUnit.Assertions.AssertionBuilders.Wrappers.NotBetweenAssertionBuilderWrapper<TActual> WithInclusiveBounds() { }
    }
    public class NotEquivalentToAssertionBuilderWrapper<TActual, TExpected> : TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual>
    {
        public TUnit.Assertions.AssertionBuilders.Wrappers.NotEquivalentToAssertionBuilderWrapper<TActual, TExpected> IgnoringMember(string propertyName, [System.Runtime.CompilerServices.CallerArgumentExpression("propertyName")] string doNotPopulateThis = "") { }
        public TUnit.Assertions.AssertionBuilders.Wrappers.NotEquivalentToAssertionBuilderWrapper<TActual, TExpected> WithPartialEquivalency() { }
    }
    public class NotNullAssertionBuilderWrapper<TActual> : TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual>
        where TActual :  class
    {
        public new System.Runtime.CompilerServices.TaskAwaiter<TActual> GetAwaiter() { }
    }
    public class NotNullStructAssertionBuilderWrapper<TActual> : TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual>
        where TActual :  struct
    {
        public new System.Runtime.CompilerServices.TaskAwaiter<TActual> GetAwaiter() { }
    }
    public class SingleItemAssertionBuilderWrapper<TActual, TInner> : TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual>
        where TActual : System.Collections.Generic.IEnumerable<TInner>
    {
        public new System.Runtime.CompilerServices.TaskAwaiter<TInner?> GetAwaiter() { }
    }
    public class StringContainsAssertionBuilderWrapper : TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<string>
    {
        public TUnit.Assertions.AssertionBuilders.Wrappers.StringContainsAssertionBuilderWrapper IgnoringWhitespace() { }
        public TUnit.Assertions.AssertionBuilders.Wrappers.StringContainsAssertionBuilderWrapper WithTrimming() { }
    }
    public class StringEqualToAssertionBuilderWrapper : TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<string>
    {
        public TUnit.Assertions.AssertionBuilders.Wrappers.StringEqualToAssertionBuilderWrapper IgnoringWhitespace() { }
        public TUnit.Assertions.AssertionBuilders.Wrappers.StringEqualToAssertionBuilderWrapper WithNullAndEmptyEquality() { }
        public TUnit.Assertions.AssertionBuilders.Wrappers.StringEqualToAssertionBuilderWrapper WithTrimming() { }
    }
    public class TimeOnlyEqualToAssertionBuilderWrapper : TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.TimeOnly>
    {
        public TUnit.Assertions.AssertionBuilders.Wrappers.TimeOnlyEqualToAssertionBuilderWrapper Within(System.TimeSpan tolerance, [System.Runtime.CompilerServices.CallerArgumentExpression("tolerance")] string doNotPopulateThis = "") { }
    }
    public class TimeSpanEqualToAssertionBuilderWrapper : TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.TimeSpan>
    {
        public TUnit.Assertions.AssertionBuilders.Wrappers.TimeSpanEqualToAssertionBuilderWrapper Within(System.TimeSpan tolerance, [System.Runtime.CompilerServices.CallerArgumentExpression("tolerance")] string doNotPopulateThis = "") { }
    }
}
namespace TUnit.Assertions.Assertions.Delegates
{
    public class CompleteWithinAssertCondition<TActual> : TUnit.Assertions.AssertConditions.DelegateAssertCondition<TActual>
    {
        public CompleteWithinAssertCondition(System.TimeSpan timeSpan) { }
        public override System.TimeSpan? WaitFor { get; }
        protected override string GetExpectation() { }
        protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TActual? actualValue, System.Exception? exception, TUnit.Assertions.AssertionMetadata assertionMetadata) { }
    }
    public static class DelegateExtensions
    {
        public static TUnit.Assertions.AssertionBuilders.InvokableDelegateAssertionBuilder CompletesWithin(this TUnit.Assertions.AssertConditions.Interfaces.IDelegateSource delegateSource, System.TimeSpan timeSpan, [System.Runtime.CompilerServices.CallerArgumentExpression("timeSpan")] string? doNotPopulateThisValue = null) { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> CompletesWithin<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueDelegateSource<TActual> delegateSource, System.TimeSpan timeSpan, [System.Runtime.CompilerServices.CallerArgumentExpression("timeSpan")] string? doNotPopulateThisValue = null) { }
    }
}
namespace TUnit.Assertions.Assertions.Enums.Conditions
{
    public class EnumDoesNotHaveFlagAssertCondition<TEnum> : TUnit.Assertions.AssertConditions.BaseAssertCondition<TEnum>
        where TEnum : System.Enum
    {
        public EnumDoesNotHaveFlagAssertCondition(TEnum expected) { }
        protected override string GetExpectation() { }
        protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TEnum? actualValue, System.Exception? exception, TUnit.Assertions.AssertionMetadata assertionMetadata) { }
    }
    public class EnumDoesNotHaveSameNameAsCondition<TEnum, TExpected> : TUnit.Assertions.AssertConditions.BaseAssertCondition<TEnum>
        where TEnum : System.Enum
        where TExpected : System.Enum
    {
        public EnumDoesNotHaveSameNameAsCondition(TExpected expected) { }
        protected override string GetExpectation() { }
        protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TEnum? actualValue, System.Exception? exception, TUnit.Assertions.AssertionMetadata assertionMetadata) { }
    }
    public class EnumDoesNotHaveSameValueAsCondition<TEnum, TExpected> : TUnit.Assertions.AssertConditions.BaseAssertCondition<TEnum>
        where TEnum : System.Enum
        where TExpected : System.Enum
    {
        public EnumDoesNotHaveSameValueAsCondition(TExpected expected) { }
        protected override string GetExpectation() { }
        protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TEnum? actualValue, System.Exception? exception, TUnit.Assertions.AssertionMetadata assertionMetadata) { }
    }
    public class EnumHasFlagAssertCondition<TEnum> : TUnit.Assertions.AssertConditions.BaseAssertCondition<TEnum>
        where TEnum : System.Enum
    {
        public EnumHasFlagAssertCondition(TEnum expected) { }
        protected override string GetExpectation() { }
        protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TEnum? actualValue, System.Exception? exception, TUnit.Assertions.AssertionMetadata assertionMetadata) { }
    }
    public class EnumHasSameNameAsCondition<TEnum, TExpected> : TUnit.Assertions.AssertConditions.BaseAssertCondition<TEnum>
        where TEnum : System.Enum
        where TExpected : System.Enum
    {
        public EnumHasSameNameAsCondition(TExpected expected) { }
        protected override string GetExpectation() { }
        protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TEnum? actualValue, System.Exception? exception, TUnit.Assertions.AssertionMetadata assertionMetadata) { }
    }
    public class EnumHasSameValueAsCondition<TEnum, TExpected> : TUnit.Assertions.AssertConditions.BaseAssertCondition<TEnum>
        where TEnum : System.Enum
        where TExpected : System.Enum
    {
        public EnumHasSameValueAsCondition(TExpected expected) { }
        protected override string GetExpectation() { }
        protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TEnum? actualValue, System.Exception? exception, TUnit.Assertions.AssertionMetadata assertionMetadata) { }
    }
    public class EnumIsDefinedAssertCondition<TEnum> : TUnit.Assertions.AssertConditions.BaseAssertCondition<TEnum>
        where TEnum : System.Enum
    {
        public EnumIsDefinedAssertCondition() { }
        protected override string GetExpectation() { }
        protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TEnum? actualValue, System.Exception? exception, TUnit.Assertions.AssertionMetadata assertionMetadata) { }
    }
    public class EnumIsNotDefinedAssertCondition<TEnum> : TUnit.Assertions.AssertConditions.BaseAssertCondition<TEnum>
        where TEnum : System.Enum
    {
        public EnumIsNotDefinedAssertCondition() { }
        protected override string GetExpectation() { }
        protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TEnum? actualValue, System.Exception? exception, TUnit.Assertions.AssertionMetadata assertionMetadata) { }
    }
}
namespace TUnit.Assertions.Assertions.Enums
{
    public static class EnumHasExtensions
    {
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TEnum> DoesNotHaveFlag<TEnum>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TEnum> valueSource, TEnum expected, [System.Runtime.CompilerServices.CallerArgumentExpression("expected")] string? doNotPopulateThisValue1 = null)
            where TEnum : System.Enum { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TEnum> DoesNotHaveSameNameAs<TEnum, TExpected>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TEnum> valueSource, TExpected expected, [System.Runtime.CompilerServices.CallerArgumentExpression("expected")] string? doNotPopulateThisValue1 = null)
            where TEnum : System.Enum
            where TExpected : System.Enum { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TEnum> DoesNotHaveSameValueAs<TEnum, TExpected>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TEnum> valueSource, TExpected expected, [System.Runtime.CompilerServices.CallerArgumentExpression("expected")] string? doNotPopulateThisValue1 = null)
            where TEnum : System.Enum
            where TExpected : System.Enum { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TEnum> HasFlag<TEnum>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TEnum> valueSource, TEnum expected, [System.Runtime.CompilerServices.CallerArgumentExpression("expected")] string? doNotPopulateThisValue1 = null)
            where TEnum : System.Enum { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TEnum> HasSameNameAs<TEnum, TExpected>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TEnum> valueSource, TExpected expected, [System.Runtime.CompilerServices.CallerArgumentExpression("expected")] string? doNotPopulateThisValue1 = null)
            where TEnum : System.Enum
            where TExpected : System.Enum { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TEnum> HasSameValueAs<TEnum, TExpected>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TEnum> valueSource, TExpected expected, [System.Runtime.CompilerServices.CallerArgumentExpression("expected")] string? doNotPopulateThisValue1 = null)
            where TEnum : System.Enum
            where TExpected : System.Enum { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TEnum> IsDefined<TEnum>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TEnum> valueSource)
            where TEnum : System.Enum { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TEnum> IsNotDefined<TEnum>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TEnum> valueSource)
            where TEnum : System.Enum { }
    }
}
namespace TUnit.Assertions.Assertions.Generics.Conditions
{
    public class AssignableFromExpectedValueAssertCondition<TActual> : TUnit.Assertions.AssertConditions.BaseAssertCondition<TActual>
    {
        public AssignableFromExpectedValueAssertCondition(System.Type expectedType) { }
        protected override string GetExpectation() { }
        protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TActual? actualValue, System.Exception? exception, TUnit.Assertions.AssertionMetadata assertionMetadata) { }
    }
    public class AssignableToExpectedValueAssertCondition<TActual> : TUnit.Assertions.AssertConditions.BaseAssertCondition<TActual>
    {
        public AssignableToExpectedValueAssertCondition(System.Type expectedType) { }
        protected override string GetExpectation() { }
        protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TActual? actualValue, System.Exception? exception, TUnit.Assertions.AssertionMetadata assertionMetadata) { }
    }
    public class ConvertExceptionToValueAssertCondition<TException> : TUnit.Assertions.AssertConditions.BaseAssertCondition<object?>
        where TException : System.Exception
    {
        public ConvertExceptionToValueAssertCondition() { }
        public TException ConvertedExceptionValue { get; }
        protected override string GetExpectation() { }
        protected override sealed System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(object? actualValue, System.Exception? exception, TUnit.Assertions.AssertionMetadata assertionMetadata) { }
    }
    public class DefaultExpectedValueAssertCondition<TActual> : TUnit.Assertions.AssertConditions.BaseAssertCondition<TActual>
    {
        public DefaultExpectedValueAssertCondition() { }
        protected override string GetExpectation() { }
        protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TActual? actualValue, System.Exception? exception, TUnit.Assertions.AssertionMetadata assertionMetadata) { }
    }
    public class DelegateConversionAssertionCondition<TToType> : TUnit.Assertions.AssertConditions.BaseAssertCondition<TToType>
        where TToType : System.Exception
    {
        public DelegateConversionAssertionCondition(TUnit.Assertions.AssertConditions.Interfaces.IDelegateSource source, TUnit.Assertions.AssertConditions.BaseAssertCondition<object?> assertCondition) { }
        protected override string GetExpectation() { }
        protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TToType? actualValue, System.Exception? exception, TUnit.Assertions.AssertionMetadata assertionMetadata) { }
    }
    public class EqualsExpectedValueAssertCondition<TActual> : TUnit.Assertions.AssertConditions.ExpectedValueAssertCondition<TActual, TActual>
    {
        public EqualsExpectedValueAssertCondition(TActual expected) { }
        public EqualsExpectedValueAssertCondition(TActual expected, System.Collections.Generic.IEqualityComparer<TActual> equalityComparer) { }
        protected override string GetExpectation() { }
        protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TActual? actualValue, TActual? expectedValue) { }
    }
    public class EquivalentToExpectedValueAssertCondition<[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.None | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicProperties | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicProperties)]  TActual, [System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.None | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicProperties | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicProperties)]  TExpected> : TUnit.Assertions.AssertConditions.ExpectedValueAssertCondition<TActual, TExpected>
    {
        public EquivalentToExpectedValueAssertCondition(TExpected expected, string? expectedExpression) { }
        public TUnit.Assertions.Enums.EquivalencyKind EquivalencyKind { get; set; }
        protected override string GetExpectation() { }
        protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TActual? actualValue, TExpected? expectedValue) { }
        public void IgnoringMember(string fieldName) { }
    }
    public class NotAssignableFromExpectedValueAssertCondition<TActual> : TUnit.Assertions.AssertConditions.BaseAssertCondition<TActual>
    {
        public NotAssignableFromExpectedValueAssertCondition(System.Type expectedType) { }
        protected override string GetExpectation() { }
        protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TActual? actualValue, System.Exception? exception, TUnit.Assertions.AssertionMetadata assertionMetadata) { }
    }
    public class NotAssignableToExpectedValueAssertCondition<TActual> : TUnit.Assertions.AssertConditions.BaseAssertCondition<TActual>
    {
        public NotAssignableToExpectedValueAssertCondition(System.Type expectedType) { }
        protected override string GetExpectation() { }
        protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TActual? actualValue, System.Exception? exception, TUnit.Assertions.AssertionMetadata assertionMetadata) { }
    }
    public class NotDefaultExpectedValueAssertCondition<TActual> : TUnit.Assertions.AssertConditions.ExpectedValueAssertCondition<TActual, TActual>
    {
        public NotDefaultExpectedValueAssertCondition() { }
        protected override string GetExpectation() { }
        protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TActual? actualValue, TActual? expectedValue) { }
    }
    public class NotEqualsExpectedValueAssertCondition<TActual> : TUnit.Assertions.AssertConditions.ExpectedValueAssertCondition<TActual, TActual>
    {
        public NotEqualsExpectedValueAssertCondition(TActual expected) { }
        protected override string GetExpectation() { }
        protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TActual? actualValue, TActual? expectedValue) { }
    }
    public class NotEquivalentToExpectedValueAssertCondition<[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.None | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicProperties | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicProperties)]  TActual, [System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.None | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicProperties | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicProperties)]  TExpected> : TUnit.Assertions.AssertConditions.ExpectedValueAssertCondition<TActual, TExpected>
    {
        public NotEquivalentToExpectedValueAssertCondition(TExpected expected, string? expectedExpression) { }
        public TUnit.Assertions.Enums.EquivalencyKind EquivalencyKind { get; set; }
        protected override string GetExpectation() { }
        protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TActual? actualValue, TExpected? expectedValue) { }
        public void IgnoringMember(string fieldName) { }
    }
    public class NotSameReferenceExpectedValueAssertCondition<TActual, TExpected> : TUnit.Assertions.AssertConditions.ExpectedValueAssertCondition<TActual, TExpected>
    {
        public NotSameReferenceExpectedValueAssertCondition(TExpected expected) { }
        protected override string GetExpectation() { }
        protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TActual? actualValue, TExpected? expectedValue) { }
    }
    public class NotTypeOfExpectedValueAssertCondition<TActual> : TUnit.Assertions.AssertConditions.BaseAssertCondition<TActual>
    {
        public NotTypeOfExpectedValueAssertCondition(System.Type expected) { }
        protected override string GetExpectation() { }
        protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TActual? actualValue, System.Exception? exception, TUnit.Assertions.AssertionMetadata assertionMetadata) { }
    }
    public class SameReferenceExpectedValueAssertCondition<TActual, TExpected> : TUnit.Assertions.AssertConditions.ExpectedValueAssertCondition<TActual, TExpected>
    {
        public SameReferenceExpectedValueAssertCondition(TExpected expected) { }
        protected override string GetExpectation() { }
        protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TActual? actualValue, TExpected? expectedValue) { }
    }
    public class TypeOfExpectedValueAssertCondition<TActual> : TUnit.Assertions.AssertConditions.BaseAssertCondition<TActual>
    {
        public TypeOfExpectedValueAssertCondition(System.Type expectedType) { }
        protected override string GetExpectation() { }
        protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TActual? actualValue, System.Exception? exception, TUnit.Assertions.AssertionMetadata assertionMetadata) { }
    }
    public class ValueConversionAssertionCondition<TFromType, TToType> : TUnit.Assertions.AssertConditions.BaseAssertCondition<TToType>
    {
        public ValueConversionAssertionCondition(TUnit.Assertions.AssertConditions.Interfaces.ISource source, TUnit.Assertions.AssertConditions.ConvertToAssertCondition<TFromType, TToType> convertToAssertCondition) { }
        protected override string GetExpectation() { }
        protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TToType? actualValue, System.Exception? exception, TUnit.Assertions.AssertionMetadata assertionMetadata) { }
    }
}
namespace TUnit.Assertions.Assertions.Strings.Conditions
{
    public class StringContainsExpectedValueAssertCondition : TUnit.Assertions.AssertConditions.ExpectedValueAssertCondition<string, string>
    {
        public StringContainsExpectedValueAssertCondition(string expected, System.StringComparison stringComparison) { }
        protected override string GetExpectation() { }
        protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(string? actualValue, string? expectedValue) { }
    }
}
namespace TUnit.Assertions.Assertions.Throws
{
    public class ThrowsWithinAssertCondition<TActual, TExpectedException> : TUnit.Assertions.AssertConditions.DelegateAssertCondition<TActual, TExpectedException>
        where TExpectedException : System.Exception
    {
        public ThrowsWithinAssertCondition(System.TimeSpan timeSpan) { }
        public override System.TimeSpan? WaitFor { get; }
        protected override string GetExpectation() { }
        protected override System.Threading.Tasks.ValueTask<TUnit.Assertions.AssertConditions.AssertionResult> GetResult(TActual? actualValue, System.Exception? exception, TUnit.Assertions.AssertionMetadata assertionMetadata) { }
    }
}
namespace TUnit.Assertions.Enums
{
    public enum CollectionOrdering
    {
        Matching = 0,
        Any = 1,
    }
    public enum EquivalencyKind
    {
        Full = 0,
        Partial = 1,
    }
    public enum Order
    {
        Ascending = 0,
        Descending = 1,
    }
}
namespace TUnit.Assertions.Equality
{
    public class CollectionEquivalentToEqualityComparer<[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.None | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicProperties | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicProperties)]  T> : TUnit.Assertions.Equality.EquivalentToEqualityComparer<T>
    {
        public CollectionEquivalentToEqualityComparer() { }
        public CollectionEquivalentToEqualityComparer(TUnit.Assertions.CompareOptions compareOptions) { }
        public override int? EnumerableIndex { get; protected set; }
        public override bool Equals(T? x, T? y) { }
    }
    public class EquivalentToEqualityComparer<[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.None | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicProperties | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicProperties)]  T> : System.Collections.Generic.IEqualityComparer<T>
    {
        public EquivalentToEqualityComparer() { }
        public EquivalentToEqualityComparer(TUnit.Assertions.CompareOptions compareOptions) { }
        public TUnit.Assertions.ComparisonFailure[]? ComparisonFailures { get; }
        public virtual int? EnumerableIndex { get; protected set; }
        public virtual bool Equals(T? x, T? y) { }
        public string GetFailureMessages() { }
        public int GetHashCode([System.Diagnostics.CodeAnalysis.DisallowNull] T obj) { }
    }
}
namespace TUnit.Assertions.Exceptions
{
    public class AssertionException : TUnit.Assertions.Exceptions.BaseAssertionException
    {
        public AssertionException(string? message) { }
        public AssertionException(string? message, System.Exception innerException) { }
    }
    public class BaseAssertionException : System.Exception
    {
        public BaseAssertionException() { }
        public BaseAssertionException(string? message) { }
        public BaseAssertionException(string? message, System.Exception? innerException) { }
    }
    public class MaybeCaughtException : System.Exception
    {
        public MaybeCaughtException(System.Exception exception) { }
    }
    public class MixedAndOrAssertionsException : TUnit.Assertions.Exceptions.AssertionException
    {
        public MixedAndOrAssertionsException() { }
    }
}
namespace TUnit.Assertions.Extensions
{
    public static class BooleanIsExtensions
    {
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<bool> IsEqualTo(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<bool> valueSource, bool expected) { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<bool?> IsEqualTo(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<bool?> valueSource, bool expected) { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<bool?> IsEqualTo(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<bool?> valueSource, bool? expected) { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<bool> IsFalse(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<bool> valueSource) { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<bool?> IsFalse(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<bool?> valueSource) { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<bool> IsTrue(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<bool> valueSource) { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<bool?> IsTrue(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<bool?> valueSource) { }
    }
    public static class BooleanIsNotExtensions
    {
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<bool> IsNotEqualTo(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<bool> valueSource, bool expected) { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<bool?> IsNotEqualTo(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<bool?> valueSource, bool expected) { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<bool?> IsNotEqualTo(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<bool?> valueSource, bool? expected) { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<bool> IsNotFalse(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<bool> valueSource) { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<bool?> IsNotFalse(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<bool?> valueSource) { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<bool> IsNotTrue(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<bool> valueSource) { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<bool?> IsNotTrue(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<bool?> valueSource) { }
    }
    public static class CharIsExtensions
    {
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<char> IsEqualTo(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<char> valueSource, char expected) { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<char?> IsEqualTo(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<char?> valueSource, char expected) { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<char?> IsEqualTo(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<char?> valueSource, char? expected) { }
    }
    public static class CharIsNotExtensions
    {
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<char> IsNotEqualTo(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<char> valueSource, char expected) { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<char?> IsNotEqualTo(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<char?> valueSource, char expected) { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<char?> IsNotEqualTo(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<char?> valueSource, char? expected) { }
    }
    public static class CollectionsIsExtensions
    {
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.Collections.Generic.IEnumerable<TInner>> IsEmpty<TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.Collections.Generic.IEnumerable<TInner>> valueSource) { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> IsEquivalentTo<TActual, [System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.None | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicProperties | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicProperties)]  TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, System.Collections.Generic.IEnumerable<TInner> expected, [System.Runtime.CompilerServices.CallerArgumentExpression("expected")] string doNotPopulateThisValue = null)
            where TActual : System.Collections.Generic.IEnumerable<TInner> { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> IsEquivalentTo<TActual, TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, System.Collections.Generic.IEnumerable<TInner> expected, System.Collections.Generic.IEqualityComparer<TInner> comparer, [System.Runtime.CompilerServices.CallerArgumentExpression("expected")] string doNotPopulateThisValue = null, [System.Runtime.CompilerServices.CallerArgumentExpression("comparer")] string doNotPopulateThisValue2 = null)
            where TActual : System.Collections.Generic.IEnumerable<TInner> { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> IsEquivalentTo<TActual, [System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.None | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicProperties | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicProperties)]  TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, System.Collections.Generic.IEnumerable<TInner> expected, TUnit.Assertions.Enums.CollectionOrdering collectionOrdering, [System.Runtime.CompilerServices.CallerArgumentExpression("expected")] string doNotPopulateThisValue = null, [System.Runtime.CompilerServices.CallerArgumentExpression("collectionOrdering")] string doNotPopulateThisValue2 = null)
            where TActual : System.Collections.Generic.IEnumerable<TInner> { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> IsEquivalentTo<TActual, TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, System.Collections.Generic.IEnumerable<TInner> expected, System.Collections.Generic.IEqualityComparer<TInner> comparer, TUnit.Assertions.Enums.CollectionOrdering collectionOrdering, [System.Runtime.CompilerServices.CallerArgumentExpression("expected")] string doNotPopulateThisValue = null, [System.Runtime.CompilerServices.CallerArgumentExpression("collectionOrdering")] string doNotPopulateThisValue2 = null)
            where TActual : System.Collections.Generic.IEnumerable<TInner> { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.Collections.Generic.IEnumerable<TInner>> IsInDescendingOrder<TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.Collections.Generic.IEnumerable<TInner>> valueSource) { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.Collections.Generic.IEnumerable<TInner>> IsInDescendingOrder<TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.Collections.Generic.IEnumerable<TInner>> valueSource, System.Collections.Generic.IComparer<TInner> comparer) { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.Collections.Generic.IEnumerable<TInner>> IsInOrder<TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.Collections.Generic.IEnumerable<TInner>> valueSource) { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.Collections.Generic.IEnumerable<TInner>> IsInOrder<TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.Collections.Generic.IEnumerable<TInner>> valueSource, System.Collections.Generic.IComparer<TInner> comparer) { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.Collections.Generic.IEnumerable<TInner>> IsOrderedBy<TInner, TComparisonItem>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.Collections.Generic.IEnumerable<TInner>> valueSource, System.Func<TInner, TComparisonItem> comparisonItemSelector, [System.Runtime.CompilerServices.CallerArgumentExpression("comparisonItemSelector")] string doNotPopulateThisValue = null) { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.Collections.Generic.IEnumerable<TInner>> IsOrderedBy<TInner, TComparisonItem>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.Collections.Generic.IEnumerable<TInner>> valueSource, System.Func<TInner, TComparisonItem> comparisonItemSelector, System.Collections.Generic.IComparer<TComparisonItem> comparer, [System.Runtime.CompilerServices.CallerArgumentExpression("comparisonItemSelector")] string doNotPopulateThisValue = null, [System.Runtime.CompilerServices.CallerArgumentExpression("comparer")] string doNotPopulateThisValue2 = null) { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.Collections.Generic.IEnumerable<TInner>> IsOrderedByDescending<TInner, TComparisonItem>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.Collections.Generic.IEnumerable<TInner>> valueSource, System.Func<TInner, TComparisonItem> comparisonItemSelector, [System.Runtime.CompilerServices.CallerArgumentExpression("comparisonItemSelector")] string doNotPopulateThisValue = null) { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.Collections.Generic.IEnumerable<TInner>> IsOrderedByDescending<TInner, TComparisonItem>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.Collections.Generic.IEnumerable<TInner>> valueSource, System.Func<TInner, TComparisonItem> comparisonItemSelector, System.Collections.Generic.IComparer<TComparisonItem> comparer, [System.Runtime.CompilerServices.CallerArgumentExpression("comparisonItemSelector")] string doNotPopulateThisValue = null, [System.Runtime.CompilerServices.CallerArgumentExpression("comparer")] string doNotPopulateThisValue2 = null) { }
    }
    public static class CollectionsIsNotExtensions
    {
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.Collections.Generic.IEnumerable<TInner>> IsNotEmpty<TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.Collections.Generic.IEnumerable<TInner>> valueSource) { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> IsNotEquivalentTo<TActual, [System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.None | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicProperties | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicProperties)]  TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, System.Collections.Generic.IEnumerable<TInner> expected, [System.Runtime.CompilerServices.CallerArgumentExpression("expected")] string doNotPopulateThisValue = null)
            where TActual : System.Collections.Generic.IEnumerable<TInner> { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> IsNotEquivalentTo<TActual, TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, System.Collections.Generic.IEnumerable<TInner> expected, System.Collections.Generic.IEqualityComparer<TInner> comparer, [System.Runtime.CompilerServices.CallerArgumentExpression("expected")] string doNotPopulateThisValue = null, [System.Runtime.CompilerServices.CallerArgumentExpression("comparer")] string doNotPopulateThisValue2 = null)
            where TActual : System.Collections.Generic.IEnumerable<TInner> { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> IsNotEquivalentTo<TActual, [System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.None | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicProperties | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicProperties)]  TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, System.Collections.Generic.IEnumerable<TInner> expected, TUnit.Assertions.Enums.CollectionOrdering collectionOrdering, [System.Runtime.CompilerServices.CallerArgumentExpression("expected")] string doNotPopulateThisValue = null, [System.Runtime.CompilerServices.CallerArgumentExpression("collectionOrdering")] string doNotPopulateThisValue2 = null)
            where TActual : System.Collections.Generic.IEnumerable<TInner> { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> IsNotEquivalentTo<TActual, TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, System.Collections.Generic.IEnumerable<TInner> expected, System.Collections.Generic.IEqualityComparer<TInner> comparer, TUnit.Assertions.Enums.CollectionOrdering collectionOrdering, [System.Runtime.CompilerServices.CallerArgumentExpression("expected")] string doNotPopulateThisValue = null, [System.Runtime.CompilerServices.CallerArgumentExpression("collectionOrdering")] string doNotPopulateThisValue2 = null)
            where TActual : System.Collections.Generic.IEnumerable<TInner> { }
    }
    public static class ComparableIsExtensions
    {
        public static TUnit.Assertions.AssertionBuilders.Wrappers.BetweenAssertionBuilderWrapper<TActual> IsBetween<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, TActual lowerBound, TActual upperBound, [System.Runtime.CompilerServices.CallerArgumentExpression("lowerBound")] string doNotPopulateThisValue1 = null, [System.Runtime.CompilerServices.CallerArgumentExpression("upperBound")] string doNotPopulateThisValue2 = null)
            where TActual : System.IComparable<TActual> { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> IsGreaterThan<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, TActual expected, [System.Runtime.CompilerServices.CallerArgumentExpression("expected")] string doNotPopulateThisValue = null)
            where TActual : System.IComparable<TActual> { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> IsGreaterThanOrEqualTo<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, TActual expected, [System.Runtime.CompilerServices.CallerArgumentExpression("expected")] string doNotPopulateThisValue = null)
            where TActual : System.IComparable<TActual> { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> IsLessThan<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, TActual expected, [System.Runtime.CompilerServices.CallerArgumentExpression("expected")] string doNotPopulateThisValue = null)
            where TActual : System.IComparable<TActual> { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> IsLessThanOrEqualTo<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, TActual expected, [System.Runtime.CompilerServices.CallerArgumentExpression("expected")] string doNotPopulateThisValue = null)
            where TActual : System.IComparable<TActual> { }
    }
    public static class ComparableIsNotExtensions
    {
        public static TUnit.Assertions.AssertionBuilders.Wrappers.NotBetweenAssertionBuilderWrapper<TActual> IsNotBetween<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, TActual lowerBound, TActual upperBound, [System.Runtime.CompilerServices.CallerArgumentExpression("lowerBound")] string doNotPopulateThisValue1 = null, [System.Runtime.CompilerServices.CallerArgumentExpression("upperBound")] string doNotPopulateThisValue2 = null)
            where TActual : System.IComparable<TActual> { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> IsNotGreaterThan<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, TActual expected, [System.Runtime.CompilerServices.CallerArgumentExpression("expected")] string doNotPopulateThisValue = null)
            where TActual : System.IComparable<TActual> { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> IsNotGreaterThanOrEqualTo<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, TActual expected, [System.Runtime.CompilerServices.CallerArgumentExpression("expected")] string doNotPopulateThisValue = null)
            where TActual : System.IComparable<TActual> { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> IsNotLessThan<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, TActual expected, [System.Runtime.CompilerServices.CallerArgumentExpression("expected")] string doNotPopulateThisValue = null)
            where TActual : System.IComparable<TActual> { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> IsNotLessThanOrEqualTo<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, TActual expected, [System.Runtime.CompilerServices.CallerArgumentExpression("expected")] string doNotPopulateThisValue = null)
            where TActual : System.IComparable<TActual> { }
    }
    public static class DateOnlyIsExtensions
    {
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.DateOnly> IsAfter(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.DateOnly> valueSource, System.DateOnly expected, [System.Runtime.CompilerServices.CallerArgumentExpression("expected")] string doNotPopulateThisValue = null) { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.DateOnly> IsAfterOrEqualTo(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.DateOnly> valueSource, System.DateOnly expected, [System.Runtime.CompilerServices.CallerArgumentExpression("expected")] string doNotPopulateThisValue = null) { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.DateOnly> IsBefore(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.DateOnly> valueSource, System.DateOnly expected, [System.Runtime.CompilerServices.CallerArgumentExpression("expected")] string doNotPopulateThisValue = null) { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.DateOnly> IsBeforeOrEqualTo(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.DateOnly> valueSource, System.DateOnly expected, [System.Runtime.CompilerServices.CallerArgumentExpression("expected")] string doNotPopulateThisValue = null) { }
        public static TUnit.Assertions.AssertionBuilders.Wrappers.DateOnlyEqualToAssertionBuilderWrapper IsEqualTo(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.DateOnly> valueSource, System.DateOnly expected, [System.Runtime.CompilerServices.CallerArgumentExpression("expected")] string doNotPopulateThisValue1 = null) { }
    }
    public static class DateTimeIsExtensions
    {
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.DateTime> IsAfter(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.DateTime> valueSource, System.DateTime expected, [System.Runtime.CompilerServices.CallerArgumentExpression("expected")] string doNotPopulateThisValue = null) { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.DateTime> IsAfterOrEqualTo(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.DateTime> valueSource, System.DateTime expected, [System.Runtime.CompilerServices.CallerArgumentExpression("expected")] string doNotPopulateThisValue = null) { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.DateTime> IsBefore(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.DateTime> valueSource, System.DateTime expected, [System.Runtime.CompilerServices.CallerArgumentExpression("expected")] string doNotPopulateThisValue = null) { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.DateTime> IsBeforeOrEqualTo(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.DateTime> valueSource, System.DateTime expected, [System.Runtime.CompilerServices.CallerArgumentExpression("expected")] string doNotPopulateThisValue = null) { }
        public static TUnit.Assertions.AssertionBuilders.Wrappers.DateTimeEqualToAssertionBuilderWrapper IsEqualTo(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.DateTime> valueSource, System.DateTime expected, [System.Runtime.CompilerServices.CallerArgumentExpression("expected")] string doNotPopulateThisValue1 = null) { }
    }
    public static class DateTimeOffsetIsExtensions
    {
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.DateTimeOffset> IsAfter(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.DateTimeOffset> valueSource, System.DateTimeOffset expected, [System.Runtime.CompilerServices.CallerArgumentExpression("expected")] string doNotPopulateThisValue = null) { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.DateTimeOffset> IsAfterOrEqualTo(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.DateTimeOffset> valueSource, System.DateTimeOffset expected, [System.Runtime.CompilerServices.CallerArgumentExpression("expected")] string doNotPopulateThisValue = null) { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.DateTimeOffset> IsBefore(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.DateTimeOffset> valueSource, System.DateTimeOffset expected, [System.Runtime.CompilerServices.CallerArgumentExpression("expected")] string doNotPopulateThisValue = null) { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.DateTimeOffset> IsBeforeOrEqualTo(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.DateTimeOffset> valueSource, System.DateTimeOffset expected, [System.Runtime.CompilerServices.CallerArgumentExpression("expected")] string doNotPopulateThisValue = null) { }
        public static TUnit.Assertions.AssertionBuilders.Wrappers.DateTimeOffsetEqualToAssertionBuilderWrapper IsEqualTo(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.DateTimeOffset> valueSource, System.DateTimeOffset expected, [System.Runtime.CompilerServices.CallerArgumentExpression("expected")] string doNotPopulateThisValue1 = null) { }
    }
    public static class DoesExtensions
    {
        public static TUnit.Assertions.AssertionBuilders.Wrappers.StringContainsAssertionBuilderWrapper Contains(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<string> valueSource, string expected, [System.Runtime.CompilerServices.CallerArgumentExpression("expected")] string doNotPopulateThisValue = null) { }
        public static TUnit.Assertions.AssertionBuilders.Wrappers.StringContainsAssertionBuilderWrapper Contains(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<string> valueSource, string expected, System.StringComparison stringComparison, [System.Runtime.CompilerServices.CallerArgumentExpression("expected")] string doNotPopulateThisValue1 = null, [System.Runtime.CompilerServices.CallerArgumentExpression("stringComparison")] string doNotPopulateThisValue2 = null) { }
        public static TUnit.Assertions.AssertionBuilders.MappableResultAssertionBuilder<System.Collections.Generic.IEnumerable<TInner>, TUnit.Assertions.AssertConditions.Collections.EnumerableContainsExpectedFuncAssertCondition<System.Collections.Generic.IEnumerable<TInner>, TInner>, TInner> Contains<TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.Collections.Generic.IEnumerable<TInner>> valueSource, System.Func<TInner, bool> matcher, [System.Runtime.CompilerServices.CallerArgumentExpression("matcher")] string doNotPopulateThisValue = null) { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> Contains<TActual, TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, TInner expected, System.Collections.Generic.IEqualityComparer<TInner> equalityComparer = null, [System.Runtime.CompilerServices.CallerArgumentExpression("expected")] string doNotPopulateThisValue = null)
            where TActual : System.Collections.Generic.IEnumerable<TInner> { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TDictionary> ContainsKey<TDictionary, TKey>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TDictionary> valueSource, TKey expected, System.Collections.Generic.IEqualityComparer<TKey> equalityComparer = null, [System.Runtime.CompilerServices.CallerArgumentExpression("expected")] string doNotPopulateThisValue = null)
            where TDictionary : System.Collections.IDictionary { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.Collections.Generic.IEnumerable<TInner>> ContainsOnly<TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.Collections.Generic.IEnumerable<TInner>> valueSource, System.Func<TInner, bool> matcher, [System.Runtime.CompilerServices.CallerArgumentExpression("matcher")] string doNotPopulateThisValue = null) { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TDictionary> ContainsValue<TDictionary, TValue>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TDictionary> valueSource, TValue expected, System.Collections.Generic.IEqualityComparer<TValue> equalityComparer = null, [System.Runtime.CompilerServices.CallerArgumentExpression("expected")] string doNotPopulateThisValue = null)
            where TDictionary : System.Collections.IDictionary { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<string> EndsWith(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<string> valueSource, string expected, [System.Runtime.CompilerServices.CallerArgumentExpression("expected")] string doNotPopulateThisValue = null) { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<string> EndsWith(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<string> valueSource, string expected, System.StringComparison stringComparison, [System.Runtime.CompilerServices.CallerArgumentExpression("expected")] string doNotPopulateThisValue1 = null, [System.Runtime.CompilerServices.CallerArgumentExpression("stringComparison")] string doNotPopulateThisValue2 = null) { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<string> Matches(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<string> valueSource, System.Text.RegularExpressions.Regex regex, [System.Runtime.CompilerServices.CallerArgumentExpression("regex")] string expression = "") { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<string> Matches(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<string> valueSource, string regex, [System.Runtime.CompilerServices.CallerArgumentExpression("regex")] string expression = "") { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<string> StartsWith(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<string> valueSource, string expected, [System.Runtime.CompilerServices.CallerArgumentExpression("expected")] string doNotPopulateThisValue = null) { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<string> StartsWith(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<string> valueSource, string expected, System.StringComparison stringComparison, [System.Runtime.CompilerServices.CallerArgumentExpression("expected")] string doNotPopulateThisValue1 = null, [System.Runtime.CompilerServices.CallerArgumentExpression("stringComparison")] string doNotPopulateThisValue2 = null) { }
    }
    public static class DoesNotExtensions
    {
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<string> DoesNotContain(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<string> valueSource, string expected, [System.Runtime.CompilerServices.CallerArgumentExpression("expected")] string doNotPopulateThisValue = null) { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<string> DoesNotContain(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<string> valueSource, string expected, System.StringComparison stringComparison, [System.Runtime.CompilerServices.CallerArgumentExpression("expected")] string doNotPopulateThisValue1 = null, [System.Runtime.CompilerServices.CallerArgumentExpression("stringComparison")] string doNotPopulateThisValue2 = null) { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.Collections.Generic.IEnumerable<TInner>> DoesNotContain<TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.Collections.Generic.IEnumerable<TInner>> valueSource, System.Func<TInner, bool> matcher, [System.Runtime.CompilerServices.CallerArgumentExpression("matcher")] string? doNotPopulateThisValue = null) { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> DoesNotContain<TActual, TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, TInner expected, System.Collections.Generic.IEqualityComparer<TInner?>? equalityComparer = null, [System.Runtime.CompilerServices.CallerArgumentExpression("expected")] string? doNotPopulateThisValue = null)
            where TActual : System.Collections.Generic.IEnumerable<TInner> { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TDictionary> DoesNotContainKey<TDictionary, TKey>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TDictionary> valueSource, TKey expected, System.Collections.Generic.IEqualityComparer<TKey> equalityComparer = null, [System.Runtime.CompilerServices.CallerArgumentExpression("expected")] string doNotPopulateThisValue = null)
            where TDictionary : System.Collections.IDictionary { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TDictionary> DoesNotContainValue<TDictionary, TValue>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TDictionary> valueSource, TValue expected, System.Collections.Generic.IEqualityComparer<TValue> equalityComparer = null, [System.Runtime.CompilerServices.CallerArgumentExpression("expected")] string doNotPopulateThisValue = null)
            where TDictionary : System.Collections.IDictionary { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<string> DoesNotEndWith(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<string> valueSource, string expected, [System.Runtime.CompilerServices.CallerArgumentExpression("expected")] string doNotPopulateThisValue = null) { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<string> DoesNotEndWith(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<string> valueSource, string expected, System.StringComparison stringComparison, [System.Runtime.CompilerServices.CallerArgumentExpression("expected")] string doNotPopulateThisValue1 = null, [System.Runtime.CompilerServices.CallerArgumentExpression("stringComparison")] string doNotPopulateThisValue2 = null) { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<string> DoesNotMatch(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<string> valueSource, System.Text.RegularExpressions.Regex regex, [System.Runtime.CompilerServices.CallerArgumentExpression("regex")] string expression = "") { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<string> DoesNotMatch(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<string> valueSource, string regex, [System.Runtime.CompilerServices.CallerArgumentExpression("regex")] string expression = "") { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<string> DoesNotStartWith(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<string> valueSource, string expected, [System.Runtime.CompilerServices.CallerArgumentExpression("expected")] string doNotPopulateThisValue = null) { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<string> DoesNotStartWith(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<string> valueSource, string expected, System.StringComparison stringComparison, [System.Runtime.CompilerServices.CallerArgumentExpression("expected")] string doNotPopulateThisValue1 = null, [System.Runtime.CompilerServices.CallerArgumentExpression("stringComparison")] string doNotPopulateThisValue2 = null) { }
    }
    public class EnumerableCount<TActual, TInner>
        where TActual : System.Collections.Generic.IEnumerable<TInner>
    {
        public EnumerableCount(TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource) { }
        public TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> Empty { get; }
        public TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> EqualTo(int expected, [System.Runtime.CompilerServices.CallerArgumentExpression("expected")] string? doNotPopulateThisValue = null) { }
        public TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> EqualToOne() { }
        public TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> EqualToZero() { }
        public TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> GreaterThan(int expected, [System.Runtime.CompilerServices.CallerArgumentExpression("expected")] string? doNotPopulateThisValue = null) { }
        public TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> GreaterThanOrEqualTo(int expected, [System.Runtime.CompilerServices.CallerArgumentExpression("expected")] string? doNotPopulateThisValue = null) { }
        public TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> LessThan(int expected, [System.Runtime.CompilerServices.CallerArgumentExpression("expected")] string? doNotPopulateThisValue = null) { }
        public TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> LessThanOrEqualTo(int expected, [System.Runtime.CompilerServices.CallerArgumentExpression("expected")] string? doNotPopulateThisValue = null) { }
        public TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> Negative() { }
        public TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> Positive() { }
    }
    public static class GenericIsExtensions
    {
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<object> IsAssignableFrom(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<object> valueSource, System.Type type) { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<object> IsAssignableFrom<TExpected>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<object> valueSource) { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<object> IsAssignableTo(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<object> valueSource, System.Type type) { }
        public static TUnit.Assertions.AssertionBuilders.CastedAssertionBuilder<object, TExpected> IsAssignableTo<TExpected>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<object> valueSource) { }
        public static TUnit.Assertions.AssertionBuilders.Wrappers.GenericEqualToAssertionBuilderWrapper<TActual> IsEqualTo<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, TActual expected, [System.Runtime.CompilerServices.CallerArgumentExpression("expected")] string doNotPopulateThisValue1 = null) { }
        public static TUnit.Assertions.AssertionBuilders.Wrappers.GenericEqualToAssertionBuilderWrapper<TActual> IsEqualTo<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, TActual expected, System.Collections.Generic.IEqualityComparer<TActual> equalityComparer, [System.Runtime.CompilerServices.CallerArgumentExpression("expected")] string doNotPopulateThisValue1 = null) { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> IsEquatableOrEqualTo<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, TActual expected, [System.Runtime.CompilerServices.CallerArgumentExpression("expected")] string doNotPopulateThisValue1 = null) { }
        public static TUnit.Assertions.AssertionBuilders.Wrappers.EquivalentToAssertionBuilderWrapper<TActual, TExpected> IsEquivalentTo<[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.None | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicProperties | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicProperties)]  TActual, [System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.None | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicProperties | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicProperties)]  TExpected>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, TExpected expected, [System.Runtime.CompilerServices.CallerArgumentExpression("expected")] string doNotPopulateThisValue1 = null) { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<object> IsNotAssignableFrom(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<object> valueSource, System.Type type) { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<object> IsNotAssignableFrom<TExpected>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<object> valueSource) { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<object> IsNotAssignableTo(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<object> valueSource, System.Type type) { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<object> IsNotAssignableTo<TExpected>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<object> valueSource) { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<object> IsNotTypeOf(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<object> valueSource, System.Type type) { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<object> IsNotTypeOf<TExpected>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<object> valueSource) { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> IsNull<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource) { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> IsSameReferenceAs<TActual, TExpected>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, TExpected expected, [System.Runtime.CompilerServices.CallerArgumentExpression("expected")] string doNotPopulateThisValue1 = null) { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<object> IsTypeOf(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<object> valueSource, System.Type type) { }
        public static TUnit.Assertions.AssertionBuilders.CastedAssertionBuilder<object, TExpected> IsTypeOf<TExpected>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<object> valueSource) { }
    }
    public static class GenericIsNotExtensions
    {
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> IsDefault<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource) { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> IsNotDefault<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource) { }
        public static TUnit.Assertions.AssertionBuilders.Wrappers.GenericNotEqualToAssertionBuilderWrapper<TActual> IsNotEqualTo<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, TActual expected, [System.Runtime.CompilerServices.CallerArgumentExpression("expected")] string? doNotPopulateThisValue = null) { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> IsNotEquatableOrEqualTo<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, TActual expected, [System.Runtime.CompilerServices.CallerArgumentExpression("expected")] string? doNotPopulateThisValue = null) { }
        public static TUnit.Assertions.AssertionBuilders.Wrappers.NotEquivalentToAssertionBuilderWrapper<TActual, TExpected> IsNotEquivalentTo<[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.None | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicProperties | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicProperties)]  TActual, [System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.None | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicProperties | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicProperties)]  TExpected>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, TExpected expected, [System.Runtime.CompilerServices.CallerArgumentExpression("expected")] string? doNotPopulateThisValue1 = null) { }
        public static TUnit.Assertions.AssertionBuilders.Wrappers.NotNullAssertionBuilderWrapper<TActual> IsNotNull<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual?> valueSource)
            where TActual :  class { }
        public static TUnit.Assertions.AssertionBuilders.Wrappers.NotNullStructAssertionBuilderWrapper<TActual> IsNotNull<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual?> valueSource)
            where TActual :  struct { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> IsNotSameReferenceAs<TActual, TExpected>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, TExpected expected, [System.Runtime.CompilerServices.CallerArgumentExpression("expected")] string? doNotPopulateThisValue1 = null) { }
    }
    public static class GenericSatisfiesExtensions
    {
        public static TUnit.Assertions.CollectionWrapper<TInner> All<TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.Collections.Generic.IEnumerable<TInner>> valueSource) { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> Satisfies<TActual, TExpected>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, System.Func<TActual, System.Threading.Tasks.Task<TExpected>?> asyncMapper, System.Func<TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TExpected?>, TUnit.Assertions.AssertionBuilders.InvokableAssertionBuilder<TExpected?>> assert, [System.Runtime.CompilerServices.CallerArgumentExpression("asyncMapper")] string mapperExpression = "", [System.Runtime.CompilerServices.CallerArgumentExpression("assert")] string assertionBuilderExpression = "") { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> Satisfies<TActual, TExpected>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, System.Func<TActual, TExpected> mapper, System.Func<TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TExpected?>, TUnit.Assertions.AssertionBuilders.InvokableAssertionBuilder<TExpected?>> assert, [System.Runtime.CompilerServices.CallerArgumentExpression("mapper")] string mapperExpression = "", [System.Runtime.CompilerServices.CallerArgumentExpression("assert")] string assertionBuilderExpression = "") { }
    }
    public static class HasExtensions
    {
        public static TUnit.Assertions.Extensions.EnumerableCount<System.Collections.Generic.IEnumerable<TInner>, TInner> HasCount<TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.Collections.Generic.IEnumerable<TInner>> valueSource) { }
        public static TUnit.Assertions.Extensions.EnumerableCount<System.Collections.Immutable.ImmutableArray<TInner>, TInner> HasCount<TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.Collections.Immutable.ImmutableArray<TInner>> valueSource) { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.Collections.Generic.IEnumerable<TInner>> HasCount<TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.Collections.Generic.IEnumerable<TInner>> valueSource, int count) { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.Collections.Generic.IEnumerable<TInner>> HasDistinctItems<TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.Collections.Generic.IEnumerable<TInner>> valueSource) { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.Collections.Immutable.ImmutableArray<TInner>> HasDistinctItems<TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.Collections.Immutable.ImmutableArray<TInner>> valueSource) { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.Collections.Generic.IEnumerable<TInner>> HasDistinctItems<TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.Collections.Generic.IEnumerable<TInner>> valueSource, System.Collections.Generic.IEqualityComparer<TInner> equalityComparer) { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.Collections.Immutable.ImmutableArray<TInner>> HasDistinctItems<TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.Collections.Immutable.ImmutableArray<TInner>> valueSource, System.Collections.Generic.IEqualityComparer<TInner> equalityComparer) { }
        public static TUnit.Assertions.Extensions.StringLength HasLength(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<string> valueSource) { }
        public static TUnit.Assertions.AssertConditions.ClassMember.Member<TRootObject, TPropertyType> HasMember<TRootObject, TPropertyType>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TRootObject> valueSource, System.Linq.Expressions.Expression<System.Func<TRootObject, TPropertyType>> selector, [System.Runtime.CompilerServices.CallerArgumentExpression("selector")] string expression = "") { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> HasMessageContaining<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, string expected, [System.Runtime.CompilerServices.CallerArgumentExpression("expected")] string doNotPopulateThisValue = null)
            where TActual : System.Exception { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> HasMessageContaining<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, string expected, System.StringComparison stringComparison, [System.Runtime.CompilerServices.CallerArgumentExpression("expected")] string doNotPopulateThisValue1 = null, [System.Runtime.CompilerServices.CallerArgumentExpression("stringComparison")] string doNotPopulateThisValue2 = null)
            where TActual : System.Exception { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> HasMessageEndingWith<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, string expected, [System.Runtime.CompilerServices.CallerArgumentExpression("expected")] string doNotPopulateThisValue = null)
            where TActual : System.Exception { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> HasMessageEndingWith<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, string expected, System.StringComparison stringComparison, [System.Runtime.CompilerServices.CallerArgumentExpression("expected")] string doNotPopulateThisValue1 = null, [System.Runtime.CompilerServices.CallerArgumentExpression("stringComparison")] string doNotPopulateThisValue2 = null)
            where TActual : System.Exception { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> HasMessageEqualTo<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, string expected, [System.Runtime.CompilerServices.CallerArgumentExpression("expected")] string doNotPopulateThisValue = null)
            where TActual : System.Exception { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> HasMessageEqualTo<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, string expected, System.StringComparison stringComparison, [System.Runtime.CompilerServices.CallerArgumentExpression("expected")] string doNotPopulateThisValue1 = null, [System.Runtime.CompilerServices.CallerArgumentExpression("stringComparison")] string doNotPopulateThisValue2 = null)
            where TActual : System.Exception { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> HasMessageMatching<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, TUnit.Assertions.AssertConditions.StringMatcher expected, System.StringComparison stringComparison, [System.Runtime.CompilerServices.CallerArgumentExpression("expected")] string doNotPopulateThisValue1 = null, [System.Runtime.CompilerServices.CallerArgumentExpression("stringComparison")] string doNotPopulateThisValue2 = null)
            where TActual : System.Exception { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> HasMessageStartingWith<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, string expected, [System.Runtime.CompilerServices.CallerArgumentExpression("expected")] string doNotPopulateThisValue = null)
            where TActual : System.Exception { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> HasMessageStartingWith<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, string expected, System.StringComparison stringComparison, [System.Runtime.CompilerServices.CallerArgumentExpression("expected")] string doNotPopulateThisValue1 = null, [System.Runtime.CompilerServices.CallerArgumentExpression("stringComparison")] string doNotPopulateThisValue2 = null)
            where TActual : System.Exception { }
        public static TUnit.Assertions.AssertionBuilders.Wrappers.SingleItemAssertionBuilderWrapper<System.Collections.Generic.IEnumerable<TInner>, TInner> HasSingleItem<TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.Collections.Generic.IEnumerable<TInner>> valueSource) { }
        public static TUnit.Assertions.AssertionBuilders.Wrappers.SingleItemAssertionBuilderWrapper<System.Collections.Immutable.ImmutableArray<TInner>, TInner> HasSingleItem<TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.Collections.Immutable.ImmutableArray<TInner>> valueSource) { }
    }
    public static class ImmutableArrayIsExtensions
    {
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.Collections.Immutable.ImmutableArray<TInner>> IsEmpty<TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.Collections.Immutable.ImmutableArray<TInner>> valueSource) { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.Collections.Immutable.ImmutableArray<TInner>> IsEquivalentTo<[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.None | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicProperties | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicProperties)]  TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.Collections.Immutable.ImmutableArray<TInner>> valueSource, System.Collections.Immutable.ImmutableArray<TInner> expected, [System.Runtime.CompilerServices.CallerArgumentExpression("expected")] string doNotPopulateThisValue = null) { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.Collections.Immutable.ImmutableArray<TInner>> IsEquivalentTo<TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.Collections.Immutable.ImmutableArray<TInner>> valueSource, System.Collections.Immutable.ImmutableArray<TInner> expected, System.Collections.Generic.IEqualityComparer<TInner> comparer, [System.Runtime.CompilerServices.CallerArgumentExpression("expected")] string doNotPopulateThisValue = null) { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.Collections.Immutable.ImmutableArray<TInner>> IsEquivalentTo<[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.None | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicProperties | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicProperties)]  TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.Collections.Immutable.ImmutableArray<TInner>> valueSource, System.Collections.Immutable.ImmutableArray<TInner> expected, TUnit.Assertions.Enums.CollectionOrdering collectionOrdering, [System.Runtime.CompilerServices.CallerArgumentExpression("expected")] string doNotPopulateThisValue = null) { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.Collections.Immutable.ImmutableArray<TInner>> IsEquivalentTo<TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.Collections.Immutable.ImmutableArray<TInner>> valueSource, System.Collections.Immutable.ImmutableArray<TInner> expected, System.Collections.Generic.IEqualityComparer<TInner> comparer, TUnit.Assertions.Enums.CollectionOrdering collectionOrdering, [System.Runtime.CompilerServices.CallerArgumentExpression("expected")] string doNotPopulateThisValue = null) { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.Collections.Immutable.ImmutableArray<TInner>> IsInDescendingOrder<TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.Collections.Immutable.ImmutableArray<TInner>> valueSource) { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.Collections.Immutable.ImmutableArray<TInner>> IsInDescendingOrder<TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.Collections.Immutable.ImmutableArray<TInner>> valueSource, System.Collections.Generic.IComparer<TInner> comparer) { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.Collections.Immutable.ImmutableArray<TInner>> IsInOrder<TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.Collections.Immutable.ImmutableArray<TInner>> valueSource) { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.Collections.Immutable.ImmutableArray<TInner>> IsInOrder<TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.Collections.Immutable.ImmutableArray<TInner>> valueSource, System.Collections.Generic.IComparer<TInner> comparer) { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.Collections.Immutable.ImmutableArray<TInner>> IsOrderedBy<TInner, TComparisonItem>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.Collections.Immutable.ImmutableArray<TInner>> valueSource, System.Func<TInner, TComparisonItem> comparisonItemSelector, [System.Runtime.CompilerServices.CallerArgumentExpression("comparisonItemSelector")] string doNotPopulateThisValue = null) { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.Collections.Immutable.ImmutableArray<TInner>> IsOrderedBy<TInner, TComparisonItem>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.Collections.Immutable.ImmutableArray<TInner>> valueSource, System.Func<TInner, TComparisonItem> comparisonItemSelector, System.Collections.Generic.IComparer<TComparisonItem> comparer, [System.Runtime.CompilerServices.CallerArgumentExpression("comparisonItemSelector")] string doNotPopulateThisValue = null, [System.Runtime.CompilerServices.CallerArgumentExpression("comparer")] string doNotPopulateThisValue2 = null) { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.Collections.Immutable.ImmutableArray<TInner>> IsOrderedByDescending<TInner, TComparisonItem>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.Collections.Immutable.ImmutableArray<TInner>> valueSource, System.Func<TInner, TComparisonItem> comparisonItemSelector, [System.Runtime.CompilerServices.CallerArgumentExpression("comparisonItemSelector")] string doNotPopulateThisValue = null) { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.Collections.Immutable.ImmutableArray<TInner>> IsOrderedByDescending<TInner, TComparisonItem>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.Collections.Immutable.ImmutableArray<TInner>> valueSource, System.Func<TInner, TComparisonItem> comparisonItemSelector, System.Collections.Generic.IComparer<TComparisonItem> comparer, [System.Runtime.CompilerServices.CallerArgumentExpression("comparisonItemSelector")] string doNotPopulateThisValue = null, [System.Runtime.CompilerServices.CallerArgumentExpression("comparer")] string doNotPopulateThisValue2 = null) { }
    }
    public static class ImmutableArrayIsNotExtensions
    {
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.Collections.Immutable.ImmutableArray<TInner>> IsNotEmpty<TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.Collections.Immutable.ImmutableArray<TInner>> valueSource) { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.Collections.Immutable.ImmutableArray<TInner>> IsNotEquivalentTo<[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.None | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicProperties | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicProperties)]  TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.Collections.Immutable.ImmutableArray<TInner>> valueSource, System.Collections.Generic.IEnumerable<TInner> expected, [System.Runtime.CompilerServices.CallerArgumentExpression("expected")] string doNotPopulateThisValue = null) { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.Collections.Immutable.ImmutableArray<TInner>> IsNotEquivalentTo<TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.Collections.Immutable.ImmutableArray<TInner>> valueSource, System.Collections.Generic.IEnumerable<TInner> expected, System.Collections.Generic.IEqualityComparer<TInner> comparer, [System.Runtime.CompilerServices.CallerArgumentExpression("expected")] string doNotPopulateThisValue = null, [System.Runtime.CompilerServices.CallerArgumentExpression("comparer")] string doNotPopulateThisValue2 = null) { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.Collections.Immutable.ImmutableArray<TInner>> IsNotEquivalentTo<[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.None | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicProperties | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicProperties)]  TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.Collections.Immutable.ImmutableArray<TInner>> valueSource, System.Collections.Generic.IEnumerable<TInner> expected, TUnit.Assertions.Enums.CollectionOrdering collectionOrdering, [System.Runtime.CompilerServices.CallerArgumentExpression("expected")] string doNotPopulateThisValue = null, [System.Runtime.CompilerServices.CallerArgumentExpression("collectionOrdering")] string doNotPopulateThisValue2 = null) { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.Collections.Immutable.ImmutableArray<TInner>> IsNotEquivalentTo<TInner>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.Collections.Immutable.ImmutableArray<TInner>> valueSource, System.Collections.Generic.IEnumerable<TInner> expected, System.Collections.Generic.IEqualityComparer<TInner> comparer, TUnit.Assertions.Enums.CollectionOrdering collectionOrdering, [System.Runtime.CompilerServices.CallerArgumentExpression("expected")] string doNotPopulateThisValue = null, [System.Runtime.CompilerServices.CallerArgumentExpression("collectionOrdering")] string doNotPopulateThisValue2 = null) { }
    }
    public static class NumberIsExtensions
    {
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> IsDivisibleBy<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, TActual expected, [System.Runtime.CompilerServices.CallerArgumentExpression("expected")] string doNotPopulateThisValue = null)
            where TActual : System.Numerics.INumber<TActual>, System.Numerics.IModulusOperators<TActual, TActual, TActual> { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> IsEven<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource)
            where TActual : System.Numerics.INumber<TActual>, System.Numerics.IModulusOperators<TActual, TActual, TActual> { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> IsNegative<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource)
            where TActual : System.Numerics.INumber<TActual> { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> IsOdd<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource)
            where TActual : System.Numerics.INumber<TActual>, System.Numerics.IModulusOperators<TActual, TActual, TActual> { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> IsPositive<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource)
            where TActual : System.Numerics.INumber<TActual> { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> IsZero<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource)
            where TActual : System.Numerics.INumber<TActual> { }
        public static TUnit.Assertions.AssertionBuilders.Wrappers.GenericEqualToAssertionBuilderWrapper<TActual> Within<TActual>(this TUnit.Assertions.AssertionBuilders.Wrappers.GenericEqualToAssertionBuilderWrapper<TActual> assertionBuilder, TActual tolerance, [System.Runtime.CompilerServices.CallerArgumentExpression("tolerance")] string doNotPopulateThis = "")
            where TActual : System.Numerics.INumber<TActual> { }
    }
    public static class NumberIsNotExtensions
    {
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> IsNotDivisibleBy<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, TActual expected, [System.Runtime.CompilerServices.CallerArgumentExpression("expected")] string doNotPopulateThisValue = null)
            where TActual : System.Numerics.INumber<TActual>, System.Numerics.IModulusOperators<TActual, TActual, TActual> { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> IsNotEven<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource)
            where TActual : System.Numerics.INumber<TActual>, System.Numerics.IModulusOperators<TActual, int, int> { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> IsNotGreaterThan<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, TActual expected, [System.Runtime.CompilerServices.CallerArgumentExpression("expected")] string doNotPopulateThisValue = null)
            where TActual : System.Numerics.INumber<TActual> { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> IsNotGreaterThanOrEqualTo<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, TActual expected, [System.Runtime.CompilerServices.CallerArgumentExpression("expected")] string doNotPopulateThisValue = null)
            where TActual : System.Numerics.INumber<TActual> { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> IsNotLessThan<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, TActual expected, [System.Runtime.CompilerServices.CallerArgumentExpression("expected")] string doNotPopulateThisValue = null)
            where TActual : System.Numerics.INumber<TActual> { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> IsNotLessThanOrEqualTo<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource, TActual expected, [System.Runtime.CompilerServices.CallerArgumentExpression("expected")] string doNotPopulateThisValue = null)
            where TActual : System.Numerics.INumber<TActual> { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> IsNotNegative<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource)
            where TActual : System.Numerics.INumber<TActual> { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> IsNotOdd<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource)
            where TActual : System.Numerics.INumber<TActual>, System.Numerics.IModulusOperators<TActual, int, int> { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> IsNotPositive<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource)
            where TActual : System.Numerics.INumber<TActual> { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> IsNotZero<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> valueSource)
            where TActual : System.Numerics.INumber<TActual> { }
        public static TUnit.Assertions.AssertionBuilders.Wrappers.GenericNotEqualToAssertionBuilderWrapper<TActual> Within<TActual>(this TUnit.Assertions.AssertionBuilders.Wrappers.GenericNotEqualToAssertionBuilderWrapper<TActual> assertionBuilder, TActual tolerance, [System.Runtime.CompilerServices.CallerArgumentExpression("tolerance")] string doNotPopulateThis = "")
            where TActual : System.Numerics.INumber<TActual> { }
    }
    public static class SourceExtensions
    {
        public static TUnit.Assertions.AssertionBuilders.InvokableDelegateAssertionBuilder RegisterAssertion<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IDelegateSource delegateSource, TUnit.Assertions.AssertConditions.BaseAssertCondition<TActual> assertCondition, string?[] argumentExpressions, [System.Runtime.CompilerServices.CallerMemberName] string? caller = null) { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TActual> RegisterAssertion<TActual>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TActual> source, TUnit.Assertions.AssertConditions.BaseAssertCondition<TActual> assertCondition, string?[] argumentExpressions, [System.Runtime.CompilerServices.CallerMemberName] string? caller = null) { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TToType> RegisterConversionAssertion<TToType>(this TUnit.Assertions.AssertConditions.Interfaces.IDelegateSource source)
            where TToType : System.Exception { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<TToType> RegisterConversionAssertion<TFromType, TToType>(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<TFromType> source, TUnit.Assertions.AssertConditions.ConvertToAssertCondition<TFromType, TToType> assertCondition, string?[] argumentExpressions, [System.Runtime.CompilerServices.CallerMemberName] string? caller = null) { }
    }
    public static class StringExtensions
    {
        public static string GetStringOr(this string? value, string defaultValue) { }
        public static string GetStringOrEmpty(this string? value) { }
        public static string PrependAOrAn(this string value) { }
        public static string ReplaceNewLines(this string value) { }
        public static string ShowNewLines(this string value) { }
        public static string TruncateWithEllipsis(this string value, int maxLength) { }
    }
    public static class StringIsExtensions
    {
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<string> IsEmpty(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<string> valueSource) { }
        public static TUnit.Assertions.AssertionBuilders.Wrappers.StringEqualToAssertionBuilderWrapper IsEqualTo(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<string> valueSource, string expected, [System.Runtime.CompilerServices.CallerArgumentExpression("expected")] string doNotPopulateThisValue1 = null) { }
        public static TUnit.Assertions.AssertionBuilders.Wrappers.StringEqualToAssertionBuilderWrapper IsEqualTo(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<string> valueSource, string expected, System.StringComparison stringComparison, [System.Runtime.CompilerServices.CallerArgumentExpression("expected")] string doNotPopulateThisValue1 = null, [System.Runtime.CompilerServices.CallerArgumentExpression("stringComparison")] string doNotPopulateThisValue2 = null) { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<string> IsNullOrEmpty(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<string> valueSource) { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<string> IsNullOrWhitespace(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<string> valueSource) { }
    }
    public static class StringIsNotExtensions
    {
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<string> IsNotEmpty(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<string> valueSource) { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<string> IsNotEqualTo(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<string> valueSource, string expected, [System.Runtime.CompilerServices.CallerArgumentExpression("expected")] string doNotPopulateThisValue = null) { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<string> IsNotEqualTo(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<string> valueSource, string expected, System.StringComparison stringComparison, [System.Runtime.CompilerServices.CallerArgumentExpression("expected")] string doNotPopulateThisValue1 = null, [System.Runtime.CompilerServices.CallerArgumentExpression("stringComparison")] string doNotPopulateThisValue2 = null) { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<string> IsNotNullOrEmpty(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<string> valueSource) { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<string> IsNotNullOrWhitespace(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<string> valueSource) { }
    }
    public class StringLength
    {
        public StringLength(TUnit.Assertions.AssertConditions.Interfaces.IValueSource<string> valueSource) { }
        public TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<string> Positive { get; }
        public TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<string> Zero { get; }
        public TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<string> EqualTo(int expected, [System.Runtime.CompilerServices.CallerArgumentExpression("expected")] string? doNotPopulateThisValue = null) { }
        public TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<string> GreaterThan(int expected, [System.Runtime.CompilerServices.CallerArgumentExpression("expected")] string? doNotPopulateThisValue = null) { }
        public TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<string> GreaterThanOrEqualTo(int expected, [System.Runtime.CompilerServices.CallerArgumentExpression("expected")] string? doNotPopulateThisValue = null) { }
        public TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<string> LessThan(int expected, [System.Runtime.CompilerServices.CallerArgumentExpression("expected")] string? doNotPopulateThisValue = null) { }
        public TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<string> LessThanOrEqualTo(int expected, [System.Runtime.CompilerServices.CallerArgumentExpression("expected")] string? doNotPopulateThisValue = null) { }
    }
    public static class TimeOnlyIsExtensions
    {
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.TimeOnly> IsAfter(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.TimeOnly> valueSource, System.TimeOnly expected, [System.Runtime.CompilerServices.CallerArgumentExpression("expected")] string doNotPopulateThisValue = null) { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.TimeOnly> IsAfterOrEqualTo(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.TimeOnly> valueSource, System.TimeOnly expected, [System.Runtime.CompilerServices.CallerArgumentExpression("expected")] string doNotPopulateThisValue = null) { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.TimeOnly> IsBefore(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.TimeOnly> valueSource, System.TimeOnly expected, [System.Runtime.CompilerServices.CallerArgumentExpression("expected")] string doNotPopulateThisValue = null) { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.TimeOnly> IsBeforeOrEqualTo(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.TimeOnly> valueSource, System.TimeOnly expected, [System.Runtime.CompilerServices.CallerArgumentExpression("expected")] string doNotPopulateThisValue = null) { }
        public static TUnit.Assertions.AssertionBuilders.Wrappers.TimeOnlyEqualToAssertionBuilderWrapper IsEqualTo(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.TimeOnly> valueSource, System.TimeOnly expected, [System.Runtime.CompilerServices.CallerArgumentExpression("expected")] string doNotPopulateThisValue1 = null) { }
    }
    public static class TimeSpanExtensions
    {
        public static System.TimeSpan Days(this int days) { }
        public static System.TimeSpan Hours(this int hours) { }
        public static System.TimeSpan Milliseconds(this int milliseconds) { }
        public static System.TimeSpan Minutes(this int minutes) { }
        public static System.TimeSpan Seconds(this int seconds) { }
    }
    public static class TimeSpanIsExtensions
    {
        public static TUnit.Assertions.AssertionBuilders.Wrappers.TimeSpanEqualToAssertionBuilderWrapper IsEqualTo(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.TimeSpan> valueSource, System.TimeSpan expected, [System.Runtime.CompilerServices.CallerArgumentExpression("expected")] string doNotPopulateThisValue1 = null) { }
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.TimeSpan> IsZero(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.TimeSpan> valueSource) { }
    }
    public static class TimeSpanIsNotExtensions
    {
        public static TUnit.Assertions.AssertionBuilders.InvokableValueAssertionBuilder<System.TimeSpan> IsNotZero(this TUnit.Assertions.AssertConditions.Interfaces.IValueSource<System.TimeSpan> valueSource) { }
    }
}
namespace TUnit.Assertions.Helpers
{
    public static class ExpressionHelpers
    {
        public static string GetName<T1, T2>(System.Linq.Expressions.Expression<System.Func<T1, T2>> exp) { }
    }
    public abstract class Formatter
    {
        protected Formatter() { }
        public abstract bool CanHandle(object? value);
        public abstract string FormatValue(object? value);
        public static string Format(object? value) { }
    }
    public class StringDifference
    {
        public StringDifference(string? actualValue, string? expectedValue, System.Collections.Generic.IEqualityComparer<string>? comparer = null) { }
        public int IgnoreWhiteSpace { get; set; }
        public int? OverriddenIndex { get; set; }
        public int IndexOfFirstMismatch() { }
        public override string ToString() { }
        public string ToString(string prefix) { }
    }
    public static class TimeSpanFormatter
    {
        public static string PrettyPrint(this System.TimeSpan timeSpan) { }
    }
}