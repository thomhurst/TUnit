[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(@"TUnit.Engine, PublicKey=0024000004800000940000000602000000240000525341310004000001000100698a70398fa0b2230c5a72e3bd9d56b48f809f6173e49a19fbb942d621be93ad48c5566b47b28faabc359b9ad3ff4e00bbdea88f5bdfa250f391fedd28182b2e37b55d429c0151a42a98ea7a5821818cd15a79fef9903e8607a88304cf3e0317bf86ec96e32e1381535a6582251e5a6eed40b5a3ed82bc444598b1269cce57a7")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(@"TUnit.UnitTests, PublicKey=0024000004800000940000000602000000240000525341310004000001000100698a70398fa0b2230c5a72e3bd9d56b48f809f6173e49a19fbb942d621be93ad48c5566b47b28faabc359b9ad3ff4e00bbdea88f5bdfa250f391fedd28182b2e37b55d429c0151a42a98ea7a5821818cd15a79fef9903e8607a88304cf3e0317bf86ec96e32e1381535a6582251e5a6eed40b5a3ed82bc444598b1269cce57a7")]
[assembly: System.Runtime.Versioning.TargetFramework(".NETStandard,Version=v2.0", FrameworkDisplayName=".NET Standard 2.0")]
namespace TUnit.Core
{
    [System.AttributeUsage(System.AttributeTargets.Method)]
    public sealed class AfterAttribute : TUnit.Core.HookAttribute
    {
        public AfterAttribute(TUnit.Core.HookType hookType, [System.Runtime.CompilerServices.CallerFilePath] string file = "", [System.Runtime.CompilerServices.CallerLineNumber] int line = 0) { }
    }
    [System.AttributeUsage(System.AttributeTargets.Method)]
    public sealed class AfterEveryAttribute : TUnit.Core.HookAttribute
    {
        public AfterEveryAttribute(TUnit.Core.HookType hookType, [System.Runtime.CompilerServices.CallerFilePath] string file = "", [System.Runtime.CompilerServices.CallerLineNumber] int line = 0) { }
    }
    public abstract class ArgumentDisplayFormatter
    {
        protected ArgumentDisplayFormatter() { }
        public abstract bool CanHandle(object? value);
        public abstract string FormatValue(object? value);
    }
    public abstract class ArgumentDisplayFormatterAttribute : TUnit.Core.TUnitAttribute, TUnit.Core.Interfaces.IEventReceiver, TUnit.Core.Interfaces.ITestDiscoveryEventReceiver
    {
        protected ArgumentDisplayFormatterAttribute() { }
        public abstract TUnit.Core.ArgumentDisplayFormatter Formatter { get; }
        public virtual int Order { get; }
        public void OnTestDiscovery(TUnit.Core.DiscoveredTestContext discoveredTestContext) { }
    }
    [System.AttributeUsage(System.AttributeTargets.Assembly | System.AttributeTargets.Class | System.AttributeTargets.Method, AllowMultiple=true)]
    public class ArgumentDisplayFormatterAttribute<T> : TUnit.Core.ArgumentDisplayFormatterAttribute
        where T : TUnit.Core.ArgumentDisplayFormatter, new ()
    {
        public ArgumentDisplayFormatterAttribute() { }
        public override TUnit.Core.ArgumentDisplayFormatter Formatter { get; }
    }
    [System.AttributeUsage(System.AttributeTargets.Class | System.AttributeTargets.Method | System.AttributeTargets.Property, AllowMultiple=true)]
    public sealed class ArgumentsAttribute : TUnit.Core.TestDataAttribute
    {
        public ArgumentsAttribute() { }
        public ArgumentsAttribute(params object?[]? values) { }
        public object?[] Values { get; }
    }
    public class Artifact
    {
        public Artifact() { }
        public string? Description { get; init; }
        public required string DisplayName { get; init; }
        public required System.IO.FileInfo File { get; init; }
    }
    public class AssemblyHookContext : TUnit.Core.Context
    {
        public System.Collections.Generic.IEnumerable<TUnit.Core.TestContext> AllTests { get; }
        public required System.Reflection.Assembly Assembly { get; init; }
        public System.Collections.Generic.HashSet<TUnit.Core.ClassHookContext> TestClasses { get; init; }
        public int TestCount { get; }
        public new static TUnit.Core.AssemblyHookContext? Current { get; }
    }
    public static class AsyncConvert
    {
        public static System.Threading.Tasks.ValueTask Convert(System.Action action) { }
        public static System.Threading.Tasks.ValueTask Convert(System.Func<System.Threading.Tasks.Task> action) { }
        public static System.Threading.Tasks.ValueTask Convert(System.Func<System.Threading.Tasks.ValueTask> action) { }
        public static System.Threading.Tasks.ValueTask ConvertObject(object? invoke) { }
    }
    public class AsyncEvent<TEventArgs>
    {
        public System.Threading.Tasks.ValueTask InvokeAsync(object sender, TEventArgs eventArgs) { }
        public void Unregister() { }
        public static TUnit.Core.AsyncEvent<TEventArgs> operator +(TUnit.Core.AsyncEvent<TEventArgs>? e, System.Func<object, TEventArgs, System.Threading.Tasks.Task> callback) { }
        public static TUnit.Core.AsyncEvent<TEventArgs>? operator -(TUnit.Core.AsyncEvent<TEventArgs>? e, System.Func<object, TEventArgs, System.Threading.Tasks.Task> callback) { }
    }
    [System.AttributeUsage(System.AttributeTargets.Method)]
    public abstract class BaseTestAttribute : TUnit.Core.TUnitAttribute
    {
        public readonly string File;
        public readonly int Line;
    }
    [System.AttributeUsage(System.AttributeTargets.Method)]
    public sealed class BeforeAttribute : TUnit.Core.HookAttribute
    {
        public BeforeAttribute(TUnit.Core.HookType hookType, [System.Runtime.CompilerServices.CallerFilePath] string file = "", [System.Runtime.CompilerServices.CallerLineNumber] int line = 0) { }
    }
    [System.AttributeUsage(System.AttributeTargets.Method)]
    public sealed class BeforeEveryAttribute : TUnit.Core.HookAttribute
    {
        public BeforeEveryAttribute(TUnit.Core.HookType hookType, [System.Runtime.CompilerServices.CallerFilePath] string file = "", [System.Runtime.CompilerServices.CallerLineNumber] int line = 0) { }
    }
    public class BeforeTestContext
    {
        public TUnit.Core.TestContext TestContext { get; }
        public TUnit.Core.TestDetails TestDetails { get; }
        public void AddAsyncLocalValues() { }
        public void AddLinkedCancellationToken(System.Threading.CancellationToken cancellationToken) { }
        public void SetHookExecutor(TUnit.Core.Interfaces.IHookExecutor hookExecutor) { }
        public void SetTestExecutor(TUnit.Core.Interfaces.ITestExecutor testExecutor) { }
    }
    public class BeforeTestDiscoveryContext : TUnit.Core.Context
    {
        public required string? TestFilter { get; init; }
        public new static TUnit.Core.BeforeTestDiscoveryContext? Current { get; }
    }
    [System.AttributeUsage(System.AttributeTargets.Assembly | System.AttributeTargets.Class | System.AttributeTargets.Method, AllowMultiple=true)]
    public class CategoryAttribute : TUnit.Core.TUnitAttribute, TUnit.Core.Interfaces.IEventReceiver, TUnit.Core.Interfaces.ITestDiscoveryEventReceiver
    {
        public CategoryAttribute(string category) { }
        public string Category { get; }
        public int Order { get; }
        public void OnTestDiscovery(TUnit.Core.DiscoveredTestContext discoveredTestContext) { }
    }
    public abstract class ClassConstructorAttribute : TUnit.Core.TUnitAttribute, TUnit.Core.IDataAttribute
    {
        public abstract System.Type ClassConstructorType { get; }
    }
    [System.AttributeUsage(System.AttributeTargets.Assembly | System.AttributeTargets.Class)]
    public sealed class ClassConstructorAttribute<T> : TUnit.Core.ClassConstructorAttribute
        where T : TUnit.Core.Interfaces.IClassConstructor, new ()
    {
        public ClassConstructorAttribute() { }
        public override System.Type ClassConstructorType { get; }
    }
    public class ClassConstructorMetadata : System.IEquatable<TUnit.Core.ClassConstructorMetadata>
    {
        public ClassConstructorMetadata() { }
        public required TUnit.Core.TestBuilderContext TestBuilderContext { get; init; }
        public required string TestSessionId { get; init; }
    }
    [System.AttributeUsage(System.AttributeTargets.Class | System.AttributeTargets.Method | System.AttributeTargets.Property, AllowMultiple=true)]
    public sealed class ClassDataSourceAttribute : TUnit.Core.NonTypedDataSourceGeneratorAttribute
    {
        public ClassDataSourceAttribute(System.Type type) { }
        public ClassDataSourceAttribute(params System.Type[] types) { }
        public ClassDataSourceAttribute(System.Type type, System.Type type2) { }
        public ClassDataSourceAttribute(System.Type type, System.Type type2, System.Type type3) { }
        public ClassDataSourceAttribute(System.Type type, System.Type type2, System.Type type3, System.Type type4) { }
        public ClassDataSourceAttribute(System.Type type, System.Type type2, System.Type type3, System.Type type4, System.Type type5) { }
        public string Key { get; set; }
        public TUnit.Core.SharedType Shared { get; set; }
        public override System.Collections.Generic.IEnumerable<System.Func<object?[]?>> GenerateDataSources(TUnit.Core.DataGeneratorMetadata dataGeneratorMetadata) { }
    }
    [System.AttributeUsage(System.AttributeTargets.Class | System.AttributeTargets.Method | System.AttributeTargets.Property, AllowMultiple=true)]
    public sealed class ClassDataSourceAttribute<T> : TUnit.Core.DataSourceGeneratorAttribute<T>
        where T : new()
    {
        public ClassDataSourceAttribute() { }
        public string Key { get; set; }
        public TUnit.Core.SharedType Shared { get; set; }
        public override System.Collections.Generic.IEnumerable<System.Func<T>> GenerateDataSources(TUnit.Core.DataGeneratorMetadata dataGeneratorMetadata) { }
    }
    [System.AttributeUsage(System.AttributeTargets.Class | System.AttributeTargets.Method, AllowMultiple=true)]
    public sealed class ClassDataSourceAttribute<T1, T2> : TUnit.Core.DataSourceGeneratorAttribute<T1, T2>
        where T1 : new()
        where T2 : new()
    {
        public ClassDataSourceAttribute() { }
        public string[] Keys { get; set; }
        public TUnit.Core.SharedType[] Shared { get; set; }
        public override System.Collections.Generic.IEnumerable<System.Func<System.ValueTuple<T1, T2>>> GenerateDataSources(TUnit.Core.DataGeneratorMetadata dataGeneratorMetadata) { }
    }
    [System.AttributeUsage(System.AttributeTargets.Class | System.AttributeTargets.Method, AllowMultiple=true)]
    public sealed class ClassDataSourceAttribute<T1, T2, T3> : TUnit.Core.DataSourceGeneratorAttribute<T1, T2, T3>
        where T1 : new()
        where T2 : new()
        where T3 : new()
    {
        public ClassDataSourceAttribute() { }
        public string[] Keys { get; set; }
        public TUnit.Core.SharedType[] Shared { get; set; }
        public override System.Collections.Generic.IEnumerable<System.Func<System.ValueTuple<T1, T2, T3>>> GenerateDataSources(TUnit.Core.DataGeneratorMetadata dataGeneratorMetadata) { }
    }
    [System.AttributeUsage(System.AttributeTargets.Class | System.AttributeTargets.Method, AllowMultiple=true)]
    public sealed class ClassDataSourceAttribute<T1, T2, T3, T4> : TUnit.Core.DataSourceGeneratorAttribute<T1, T2, T3, T4>
        where T1 : new()
        where T2 : new()
        where T3 : new()
        where T4 : new()
    {
        public ClassDataSourceAttribute() { }
        public string[] Keys { get; set; }
        public TUnit.Core.SharedType[] Shared { get; set; }
        public override System.Collections.Generic.IEnumerable<System.Func<System.ValueTuple<T1, T2, T3, T4>>> GenerateDataSources(TUnit.Core.DataGeneratorMetadata dataGeneratorMetadata) { }
    }
    [System.AttributeUsage(System.AttributeTargets.Class | System.AttributeTargets.Method, AllowMultiple=true)]
    public sealed class ClassDataSourceAttribute<T1, T2, T3, T4, T5> : TUnit.Core.DataSourceGeneratorAttribute<T1, T2, T3, T4, T5>
        where T1 : new()
        where T2 : new()
        where T3 : new()
        where T4 : new()
        where T5 : new()
    {
        public ClassDataSourceAttribute() { }
        public string[] Keys { get; set; }
        public TUnit.Core.SharedType[] Shared { get; set; }
        public override System.Collections.Generic.IEnumerable<System.Func<System.ValueTuple<T1, T2, T3, T4, T5>>> GenerateDataSources(TUnit.Core.DataGeneratorMetadata dataGeneratorMetadata) { }
    }
    public class ClassHookContext : TUnit.Core.Context
    {
        public required System.Type ClassType { get; init; }
        public int TestCount { get; }
        public System.Collections.Generic.List<TUnit.Core.TestContext> Tests { get; init; }
        public new static TUnit.Core.ClassHookContext? Current { get; }
        public override bool Equals(object? obj) { }
        public override int GetHashCode() { }
    }
    public abstract class Context : System.IDisposable, TUnit.Core.Interfaces.IContext
    {
        public System.IO.TextWriter ErrorOutputWriter { get; }
        public System.IO.TextWriter OutputWriter { get; }
        public static TUnit.Core.Context Current { get; }
        public void AddAsyncLocalValues() { }
        public void Dispose() { }
        public TUnit.Core.Logging.DefaultLogger GetDefaultLogger() { }
        public string GetErrorOutput() { }
        public string GetStandardOutput() { }
    }
    public class CultureExecutor : TUnit.Core.DedicatedThreadExecutor
    {
        public CultureExecutor(System.Globalization.CultureInfo cultureInfo) { }
        protected override void ConfigureThread(System.Threading.Thread thread) { }
    }
    public class DataGeneratorMetadata : System.IEquatable<TUnit.Core.DataGeneratorMetadata>
    {
        public DataGeneratorMetadata() { }
        public required object?[]? ClassInstanceArguments { get; init; }
        public required TUnit.Core.SourceGeneratedMemberInformation[] MembersToGenerate { get; init; }
        public required TUnit.Core.TestBuilderContextAccessor TestBuilderContext { get; init; }
        public required object? TestClassInstance { get; init; }
        public System.Type TestClassType { get; }
        public required TUnit.Core.SourceGeneratedMethodInformation TestInformation { get; init; }
        public required string TestSessionId { get; init; }
        public required TUnit.Core.Enums.DataGeneratorType Type { get; init; }
    }
    [System.AttributeUsage(System.AttributeTargets.Class | System.AttributeTargets.Method | System.AttributeTargets.Property, AllowMultiple=true)]
    public abstract class DataSourceGeneratorAttribute<T> : TUnit.Core.TestDataAttribute, TUnit.Core.IDataAttribute
    {
        protected DataSourceGeneratorAttribute() { }
        public abstract System.Collections.Generic.IEnumerable<System.Func<T>> GenerateDataSources(TUnit.Core.DataGeneratorMetadata dataGeneratorMetadata);
    }
    [System.AttributeUsage(System.AttributeTargets.Class | System.AttributeTargets.Method, AllowMultiple=true)]
    public abstract class DataSourceGeneratorAttribute<T1, T2> : TUnit.Core.TestDataAttribute, TUnit.Core.IDataAttribute
    {
        protected DataSourceGeneratorAttribute() { }
        public abstract System.Collections.Generic.IEnumerable<System.Func<System.ValueTuple<T1, T2>>> GenerateDataSources(TUnit.Core.DataGeneratorMetadata dataGeneratorMetadata);
    }
    [System.AttributeUsage(System.AttributeTargets.Class | System.AttributeTargets.Method, AllowMultiple=true)]
    public abstract class DataSourceGeneratorAttribute<T1, T2, T3> : TUnit.Core.TestDataAttribute, TUnit.Core.IDataAttribute
    {
        protected DataSourceGeneratorAttribute() { }
        public abstract System.Collections.Generic.IEnumerable<System.Func<System.ValueTuple<T1, T2, T3>>> GenerateDataSources(TUnit.Core.DataGeneratorMetadata dataGeneratorMetadata);
    }
    [System.AttributeUsage(System.AttributeTargets.Class | System.AttributeTargets.Method, AllowMultiple=true)]
    public abstract class DataSourceGeneratorAttribute<T1, T2, T3, T4> : TUnit.Core.TestDataAttribute, TUnit.Core.IDataAttribute
    {
        protected DataSourceGeneratorAttribute() { }
        public abstract System.Collections.Generic.IEnumerable<System.Func<System.ValueTuple<T1, T2, T3, T4>>> GenerateDataSources(TUnit.Core.DataGeneratorMetadata dataGeneratorMetadata);
    }
    [System.AttributeUsage(System.AttributeTargets.Class | System.AttributeTargets.Method, AllowMultiple=true)]
    public abstract class DataSourceGeneratorAttribute<T1, T2, T3, T4, T5> : TUnit.Core.TestDataAttribute, TUnit.Core.IDataAttribute
    {
        protected DataSourceGeneratorAttribute() { }
        public abstract System.Collections.Generic.IEnumerable<System.Func<System.ValueTuple<T1, T2, T3, T4, T5>>> GenerateDataSources(TUnit.Core.DataGeneratorMetadata dataGeneratorMetadata);
    }
    public class DedicatedThreadExecutor : TUnit.Core.GenericAbstractExecutor
    {
        public DedicatedThreadExecutor() { }
        protected virtual void CleanUp() { }
        protected virtual void ConfigureThread(System.Threading.Thread thread) { }
        protected override sealed System.Threading.Tasks.ValueTask ExecuteAsync(System.Func<System.Threading.Tasks.ValueTask> action) { }
        protected virtual void Initialize() { }
    }
    public class DefaultExecutor : TUnit.Core.GenericAbstractExecutor
    {
        public static readonly TUnit.Core.DefaultExecutor Instance;
        protected override System.Threading.Tasks.ValueTask ExecuteAsync(System.Func<System.Threading.Tasks.ValueTask> action) { }
    }
    public abstract class DependencyInjectionDataSourceAttribute<TScope> : TUnit.Core.NonTypedDataSourceGeneratorAttribute
    {
        protected DependencyInjectionDataSourceAttribute() { }
        public abstract object? Create(TScope scope, System.Type type);
        public abstract TScope CreateScope(TUnit.Core.DataGeneratorMetadata dataGeneratorMetadata);
        public override System.Collections.Generic.IEnumerable<System.Func<object?[]?>> GenerateDataSources(TUnit.Core.DataGeneratorMetadata dataGeneratorMetadata) { }
    }
    [System.AttributeUsage(System.AttributeTargets.Class | System.AttributeTargets.Method, AllowMultiple=true)]
    public class DependsOnAttribute : TUnit.Core.TUnitAttribute
    {
        public DependsOnAttribute(System.Type testClass) { }
        public DependsOnAttribute(string testName) { }
        public DependsOnAttribute(System.Type testClass, string testName) { }
        public DependsOnAttribute(string testName, System.Type[] parameterTypes) { }
        public DependsOnAttribute(System.Type testClass, string testName, System.Type[] parameterTypes) { }
        public System.Type[]? ParameterTypes { get; }
        public bool ProceedOnFailure { get; set; }
        public System.Type? TestClass { get; }
        public string? TestName { get; }
        public override string ToString() { }
    }
    [System.AttributeUsage(System.AttributeTargets.Class | System.AttributeTargets.Method, AllowMultiple=true)]
    public class DependsOnAttribute<T> : TUnit.Core.DependsOnAttribute
    {
        public DependsOnAttribute() { }
        public DependsOnAttribute(string testName) { }
        public DependsOnAttribute(string testName, System.Type[] parameterTypes) { }
    }
    public class DiscoveredTestContext
    {
        public bool RunOnTestDiscovery { get; set; }
        public TUnit.Core.TestContext TestContext { get; }
        public TUnit.Core.TestDetails TestDetails { get; }
        public void AddArgumentDisplayFormatter(TUnit.Core.ArgumentDisplayFormatter formatter) { }
        public void AddCategory(string category) { }
        public void AddProperty(string key, string value) { }
        public void SetDisplayName(string displayName) { }
        public void SetParallelConstraint(TUnit.Core.Interfaces.IParallelConstraint parallelConstraint) { }
        public void SetRetryCount(int times) { }
        public void SetRetryCount(int times, System.Func<TUnit.Core.TestContext, System.Exception, int, System.Threading.Tasks.Task<bool>> shouldRetry) { }
    }
    [System.AttributeUsage(System.AttributeTargets.Method, Inherited=false)]
    public sealed class DisplayNameAttribute : TUnit.Core.DisplayNameFormatterAttribute
    {
        public DisplayNameAttribute(string displayName) { }
        protected override string FormatDisplayName(TUnit.Core.TestContext testContext) { }
    }
    [System.AttributeUsage(System.AttributeTargets.Assembly | System.AttributeTargets.Class | System.AttributeTargets.Method, Inherited=false)]
    public abstract class DisplayNameFormatterAttribute : TUnit.Core.TUnitAttribute, TUnit.Core.Interfaces.IEventReceiver, TUnit.Core.Interfaces.ITestDiscoveryEventReceiver
    {
        protected DisplayNameFormatterAttribute() { }
        public int Order { get; }
        protected abstract string FormatDisplayName(TUnit.Core.TestContext testContext);
        public void OnTestDiscovery(TUnit.Core.DiscoveredTestContext discoveredTestContext) { }
    }
    public abstract class DynamicTest : System.IEquatable<TUnit.Core.DynamicTest>
    {
        protected DynamicTest() { }
        public System.Attribute[] Attributes { get; init; }
        public System.Collections.Generic.Dictionary<string, object?>? Properties { get; init; }
        public object?[]? TestClassArguments { get; init; }
        public abstract System.Type TestClassType { get; }
        public abstract string TestId { get; }
        public required object?[] TestMethodArguments { get; init; }
        public string? TestName { get; init; }
        public abstract System.Collections.Generic.IEnumerable<TUnit.Core.TestMetadata> BuildTestMetadatas();
        protected TUnit.Core.SourceGeneratedMethodInformation BuildTestMethod(System.Reflection.MethodInfo methodInfo) { }
        protected TUnit.Core.SourceGeneratedAssemblyInformation GenerateAssembly() { }
        protected TUnit.Core.SourceGeneratedClassInformation GenerateClass() { }
        protected TUnit.Core.SourceGeneratedParameterInformation GenerateParameter(System.Reflection.ParameterInfo parameter) { }
        public System.Attribute[] GetAttributes() { }
        protected TUnit.Core.SourceGeneratedParameterInformation[] GetParameters(System.Reflection.ParameterInfo[] parameters) { }
        public static T Argument<T>() { }
        protected static TUnit.Core.SourceGeneratedPropertyInformation GenerateProperty(System.Collections.Generic.KeyValuePair<string, object?> property) { }
    }
    public class DynamicTestBuilderAttribute : TUnit.Core.BaseTestAttribute
    {
        public DynamicTestBuilderAttribute([System.Runtime.CompilerServices.CallerFilePath] string file = "", [System.Runtime.CompilerServices.CallerLineNumber] int line = 0) { }
    }
    public class DynamicTestBuilderContext
    {
        public DynamicTestBuilderContext(TUnit.Core.TestContext testContext) { }
        public DynamicTestBuilderContext(string filePath, int lineNumber) { }
        public System.Collections.Generic.List<TUnit.Core.DynamicTest> Tests { get; }
        public void AddTest<TClass>(TUnit.Core.DynamicTest<TClass> dynamicTest)
            where TClass :  class { }
        public System.Threading.Tasks.Task AddTestAtRuntime<TClass>(TUnit.Core.TestContext testContext, TUnit.Core.DynamicTest<TClass> dynamicTest)
            where TClass :  class { }
    }
    public class DynamicTest<TClass> : TUnit.Core.DynamicTest, System.IEquatable<TUnit.Core.DynamicTest<TClass>>
        where TClass :  class
    {
        public DynamicTest() { }
        public override System.Type TestClassType { get; }
        public override string TestId { get; }
        public required System.Linq.Expressions.Expression<System.Action<TClass>> TestMethod { get; init; }
        public override System.Collections.Generic.IEnumerable<TUnit.Core.TestMetadata> BuildTestMetadatas() { }
        public class MethodBody : System.IEquatable<TUnit.Core.DynamicTest<TClass>.MethodBody>
        {
            public MethodBody() { }
            public System.Action<TClass>? SynchronousBody { get; init; }
            public System.Func<TClass, System.Threading.Tasks.Task>? TaskBody { get; init; }
            public static TUnit.Core.DynamicTest<TClass>.MethodBody op_Implicit(System.Action<TClass> action) { }
            public static TUnit.Core.DynamicTest<TClass>.MethodBody op_Implicit(System.Func<TClass, System.Threading.Tasks.Task> taskBody) { }
        }
    }
    public class EngineCancellationToken : System.IDisposable
    {
        public EngineCancellationToken() { }
        public System.Threading.CancellationToken Token { get; }
        public void Dispose() { }
    }
    [System.AttributeUsage(System.AttributeTargets.Class | System.AttributeTargets.Method)]
    public sealed class ExplicitAttribute : TUnit.Core.TUnitAttribute
    {
        public ExplicitAttribute([System.Runtime.CompilerServices.CallerFilePath] string callerFile = "", [System.Runtime.CompilerServices.CallerMemberName] string callerMemberName = "") { }
        public string For { get; }
    }
    public class FailedDynamicTest<TClassType> : System.IEquatable<TUnit.Core.FailedDynamicTest<TClassType>>
        where TClassType :  class
    {
        public FailedDynamicTest() { }
        public required System.Exception Exception { get; init; }
        public required string MethodName { get; init; }
        public required string TestFilePath { get; init; }
        public required string TestId { get; init; }
        public required int TestLineNumber { get; init; }
        public static TUnit.Core.DynamicTest<TClassType> op_Implicit(TUnit.Core.FailedDynamicTest<TClassType> failedTestMetadata) { }
    }
    public class FailedTestMetadata<TClassType> : System.IEquatable<TUnit.Core.FailedTestMetadata<TClassType>>
        where TClassType :  class
    {
        public FailedTestMetadata() { }
        public required System.Exception Exception { get; init; }
        public required string MethodName { get; init; }
        public required string TestFilePath { get; init; }
        public required string TestId { get; init; }
        public required int TestLineNumber { get; init; }
        public static TUnit.Core.TestMetadata<TClassType> op_Implicit(TUnit.Core.FailedTestMetadata<TClassType> failedTestMetadata) { }
    }
    public abstract class GenericAbstractExecutor : TUnit.Core.Interfaces.IHookExecutor, TUnit.Core.Interfaces.ITestExecutor
    {
        protected GenericAbstractExecutor() { }
        public System.Threading.Tasks.ValueTask ExecuteAfterAssemblyHook(TUnit.Core.SourceGeneratedMethodInformation hookMethodInfo, TUnit.Core.AssemblyHookContext context, System.Func<System.Threading.Tasks.ValueTask> action) { }
        public System.Threading.Tasks.ValueTask ExecuteAfterClassHook(TUnit.Core.SourceGeneratedMethodInformation hookMethodInfo, TUnit.Core.ClassHookContext context, System.Func<System.Threading.Tasks.ValueTask> action) { }
        public System.Threading.Tasks.ValueTask ExecuteAfterTestDiscoveryHook(TUnit.Core.SourceGeneratedMethodInformation hookMethodInfo, TUnit.Core.TestDiscoveryContext context, System.Func<System.Threading.Tasks.ValueTask> action) { }
        public System.Threading.Tasks.ValueTask ExecuteAfterTestHook(TUnit.Core.SourceGeneratedMethodInformation hookMethodInfo, TUnit.Core.TestContext context, System.Func<System.Threading.Tasks.ValueTask> action) { }
        public System.Threading.Tasks.ValueTask ExecuteAfterTestSessionHook(TUnit.Core.SourceGeneratedMethodInformation hookMethodInfo, TUnit.Core.TestSessionContext context, System.Func<System.Threading.Tasks.ValueTask> action) { }
        protected abstract System.Threading.Tasks.ValueTask ExecuteAsync(System.Func<System.Threading.Tasks.ValueTask> action);
        public System.Threading.Tasks.ValueTask ExecuteBeforeAssemblyHook(TUnit.Core.SourceGeneratedMethodInformation hookMethodInfo, TUnit.Core.AssemblyHookContext context, System.Func<System.Threading.Tasks.ValueTask> action) { }
        public System.Threading.Tasks.ValueTask ExecuteBeforeClassHook(TUnit.Core.SourceGeneratedMethodInformation hookMethodInfo, TUnit.Core.ClassHookContext context, System.Func<System.Threading.Tasks.ValueTask> action) { }
        public System.Threading.Tasks.ValueTask ExecuteBeforeTestDiscoveryHook(TUnit.Core.SourceGeneratedMethodInformation hookMethodInfo, TUnit.Core.BeforeTestDiscoveryContext context, System.Func<System.Threading.Tasks.ValueTask> action) { }
        public System.Threading.Tasks.ValueTask ExecuteBeforeTestHook(TUnit.Core.SourceGeneratedMethodInformation hookMethodInfo, TUnit.Core.TestContext context, System.Func<System.Threading.Tasks.ValueTask> action) { }
        public System.Threading.Tasks.ValueTask ExecuteBeforeTestSessionHook(TUnit.Core.SourceGeneratedMethodInformation hookMethodInfo, TUnit.Core.TestSessionContext context, System.Func<System.Threading.Tasks.ValueTask> action) { }
        public System.Threading.Tasks.ValueTask ExecuteTest(TUnit.Core.TestContext context, System.Func<System.Threading.Tasks.ValueTask> action) { }
    }
    public class GlobalContext : TUnit.Core.Context
    {
        public System.IO.TextWriter OriginalConsoleError { get; set; }
        public System.IO.TextWriter OriginalConsoleOut { get; set; }
        public string? TestFilter { get; }
        public new static TUnit.Core.GlobalContext Current { get; }
    }
    public class GlobalSharedDataKey : TUnit.Core.SharedDataKey, System.IEquatable<TUnit.Core.GlobalSharedDataKey>
    {
        public static readonly System.Guid RandomKey;
        public GlobalSharedDataKey(System.Type Type) { }
    }
    public class HookAttribute : TUnit.Core.TUnitAttribute
    {
        public string File { get; }
        public TUnit.Core.HookType HookType { get; }
        public int Line { get; }
        public int Order { get; init; }
    }
    public enum HookType
    {
        Test = 0,
        Class = 1,
        Assembly = 2,
        TestSession = 3,
        TestDiscovery = 4,
    }
    public interface IAccessesInstanceData { }
    public interface IDataAttribute { }
    public interface IDynamicTestRegistrar
    {
        System.Threading.Tasks.Task Register<TClass>(TUnit.Core.DynamicTest<TClass> dynamicTest)
            where TClass :  class;
    }
    [System.AttributeUsage(System.AttributeTargets.Class)]
    public sealed class InheritsTestsAttribute : TUnit.Core.TUnitAttribute
    {
        public InheritsTestsAttribute() { }
    }
    [System.AttributeUsage(System.AttributeTargets.Method, AllowMultiple=true)]
    public class InstanceMethodDataSourceAttribute : TUnit.Core.MethodDataSourceAttribute, TUnit.Core.IAccessesInstanceData
    {
        public InstanceMethodDataSourceAttribute(string methodNameProvidingDataSource) { }
        public InstanceMethodDataSourceAttribute(System.Type classProvidingDataSource, string methodNameProvidingDataSource) { }
    }
    [System.AttributeUsage(System.AttributeTargets.Method, AllowMultiple=true)]
    public class InstanceMethodDataSourceAttribute<T> : TUnit.Core.MethodDataSourceAttribute<T>, TUnit.Core.IAccessesInstanceData
    {
        public InstanceMethodDataSourceAttribute(string methodNameProvidingDataSource) { }
    }
    [System.AttributeUsage(System.AttributeTargets.Parameter)]
    public class MatrixAttribute : TUnit.Core.TestDataAttribute
    {
        protected MatrixAttribute() { }
        public MatrixAttribute(params object?[]? objects) { }
        public object?[]? Excluding { get; init; }
        public virtual object?[] GetObjects(object? instance) { }
    }
    [System.AttributeUsage(System.AttributeTargets.Parameter)]
    public class MatrixAttribute<T> : TUnit.Core.MatrixAttribute
    {
        public MatrixAttribute(params T?[]? objects) { }
    }
    [System.AttributeUsage(System.AttributeTargets.Class | System.AttributeTargets.Method)]
    public sealed class MatrixDataSourceAttribute : TUnit.Core.NonTypedDataSourceGeneratorAttribute
    {
        public MatrixDataSourceAttribute() { }
        public override System.Collections.Generic.IEnumerable<System.Func<object?[]?>> GenerateDataSources(TUnit.Core.DataGeneratorMetadata dataGeneratorMetadata) { }
    }
    [System.AttributeUsage(System.AttributeTargets.Class | System.AttributeTargets.Method, AllowMultiple=true)]
    public class MatrixExclusionAttribute : TUnit.Core.TUnitAttribute
    {
        public MatrixExclusionAttribute(params object?[]? objects) { }
        public object?[] Objects { get; }
    }
    [System.AttributeUsage(System.AttributeTargets.Parameter)]
    public class MatrixInstanceMethodAttribute<TClass> : TUnit.Core.MatrixMethodAttribute<TClass>, TUnit.Core.IAccessesInstanceData
        where TClass :  class
    {
        public MatrixInstanceMethodAttribute(string methodName) { }
    }
    [System.AttributeUsage(System.AttributeTargets.Parameter)]
    public class MatrixMethodAttribute<TClass> : TUnit.Core.MatrixAttribute
        where TClass :  class
    {
        public MatrixMethodAttribute(string methodName) { }
        public override object?[] GetObjects(object? instance) { }
    }
    [System.AttributeUsage(System.AttributeTargets.Class | System.AttributeTargets.Method | System.AttributeTargets.Property, AllowMultiple=true)]
    public class MethodDataSourceAttribute : TUnit.Core.TestDataAttribute
    {
        public MethodDataSourceAttribute(string methodNameProvidingDataSource) { }
        public MethodDataSourceAttribute(System.Type classProvidingDataSource, string methodNameProvidingDataSource) { }
        public object?[] Arguments { get; set; }
        public System.Type? ClassProvidingDataSource { get; }
        public string MethodNameProvidingDataSource { get; }
    }
    [System.AttributeUsage(System.AttributeTargets.Class | System.AttributeTargets.Method | System.AttributeTargets.Property, AllowMultiple=true)]
    public class MethodDataSourceAttribute<T> : TUnit.Core.MethodDataSourceAttribute
    {
        public MethodDataSourceAttribute(string methodNameProvidingDataSource) { }
    }
    [System.AttributeUsage(System.AttributeTargets.Class | System.AttributeTargets.Method | System.AttributeTargets.Property, AllowMultiple=true)]
    public abstract class NonTypedDataSourceGeneratorAttribute : TUnit.Core.TestDataAttribute, TUnit.Core.IDataAttribute
    {
        protected NonTypedDataSourceGeneratorAttribute() { }
        public abstract System.Collections.Generic.IEnumerable<System.Func<object?[]?>> GenerateDataSources(TUnit.Core.DataGeneratorMetadata dataGeneratorMetadata);
    }
    [System.AttributeUsage(System.AttributeTargets.Assembly | System.AttributeTargets.Class | System.AttributeTargets.Method)]
    public class NotInParallelAttribute : TUnit.Core.SingleTUnitAttribute, TUnit.Core.Interfaces.IEventReceiver, TUnit.Core.Interfaces.ITestDiscoveryEventReceiver
    {
        public NotInParallelAttribute() { }
        public NotInParallelAttribute(string constraintKey) { }
        public NotInParallelAttribute(string[] constraintKeys) { }
        public string[] ConstraintKeys { get; }
        public int Order { get; init; }
        public void OnTestDiscovery(TUnit.Core.DiscoveredTestContext discoveredTestContext) { }
    }
    public class NotInParallelConstraint : System.IEquatable<TUnit.Core.NotInParallelConstraint>, TUnit.Core.Interfaces.IParallelConstraint
    {
        public NotInParallelConstraint(System.Collections.Generic.IReadOnlyList<string> NotInParallelConstraintKeys) { }
        public System.Collections.Generic.IReadOnlyList<string> NotInParallelConstraintKeys { get; init; }
        public int Order { get; set; }
    }
    public class ParallelGroupAttribute : TUnit.Core.TUnitAttribute, TUnit.Core.Interfaces.IEventReceiver, TUnit.Core.Interfaces.ITestDiscoveryEventReceiver
    {
        public ParallelGroupAttribute(string group) { }
        public string Group { get; }
        public int Order { get; set; }
        public void OnTestDiscovery(TUnit.Core.DiscoveredTestContext discoveredTestContext) { }
    }
    public class ParallelGroupConstraint : System.IComparable, System.IComparable<TUnit.Core.ParallelGroupConstraint>, System.IEquatable<TUnit.Core.ParallelGroupConstraint>, TUnit.Core.Interfaces.IParallelConstraint
    {
        public ParallelGroupConstraint(string Group, int Order) { }
        public string Group { get; init; }
        public int Order { get; init; }
        public int CompareTo(TUnit.Core.ParallelGroupConstraint? other) { }
        public int CompareTo(object? obj) { }
        public virtual bool Equals(TUnit.Core.ParallelGroupConstraint? other) { }
        public override int GetHashCode() { }
    }
    public class ParallelLimitLockProvider
    {
        public ParallelLimitLockProvider() { }
    }
    [System.AttributeUsage(System.AttributeTargets.Assembly | System.AttributeTargets.Class | System.AttributeTargets.Method)]
    public sealed class ParallelLimiterAttribute<TParallelLimit> : TUnit.Core.TUnitAttribute, TUnit.Core.Interfaces.IEventReceiver, TUnit.Core.Interfaces.ITestRegisteredEventReceiver
        where TParallelLimit : TUnit.Core.Interfaces.IParallelLimit, new ()
    {
        public ParallelLimiterAttribute() { }
        public int Order { get; }
        public System.Threading.Tasks.ValueTask OnTestRegistered(TUnit.Core.TestRegisteredContext testRegisteredContext) { }
    }
    [System.AttributeUsage(System.AttributeTargets.Assembly | System.AttributeTargets.Class | System.AttributeTargets.Method, AllowMultiple=true)]
    public class PropertyAttribute : TUnit.Core.TUnitAttribute, TUnit.Core.Interfaces.IEventReceiver, TUnit.Core.Interfaces.ITestDiscoveryEventReceiver
    {
        public PropertyAttribute(string name, string value) { }
        public string Name { get; }
        public int Order { get; }
        public string Value { get; }
        public void OnTestDiscovery(TUnit.Core.DiscoveredTestContext discoveredTestContext) { }
    }
    [System.AttributeUsage(System.AttributeTargets.Assembly | System.AttributeTargets.Class | System.AttributeTargets.Method)]
    public sealed class RepeatAttribute : TUnit.Core.TUnitAttribute
    {
        public RepeatAttribute(int times) { }
        public int Times { get; }
    }
    public class ResettableLazy<T> : System.IAsyncDisposable
        where T :  class
    {
        protected readonly string SessionId;
        protected System.Func<T> _factory;
        public ResettableLazy(System.Func<T> factory, string sessionId, TUnit.Core.TestBuilderContext testBuilderContext) { }
        protected ResettableLazy(TUnit.Core.Interfaces.IClassConstructor classConstructor, string sessionId, TUnit.Core.TestBuilderContext testBuilderContext) { }
        public TUnit.Core.Interfaces.IClassConstructor? ClassConstructor { get; protected set; }
        public TUnit.Core.TestBuilderContext TestBuilderContext { get; }
        public T Value { get; }
        public TUnit.Core.ResettableLazy<T> Clone() { }
        public System.Threading.Tasks.ValueTask DisposeAsync() { }
        public virtual System.Threading.Tasks.ValueTask ResetLazy() { }
        protected static System.Threading.Tasks.ValueTask DisposeAsync(object? obj) { }
    }
    public class ResettableLazy<TClassConstructor, T> : TUnit.Core.ResettableLazy<T>
        where TClassConstructor : TUnit.Core.Interfaces.IClassConstructor, new ()
        where T :  class
    {
        public ResettableLazy(string sessionId, TUnit.Core.TestBuilderContext testBuilderContext) { }
        public override System.Threading.Tasks.ValueTask ResetLazy() { }
    }
    [System.AttributeUsage(System.AttributeTargets.Assembly | System.AttributeTargets.Class | System.AttributeTargets.Method)]
    public class RetryAttribute : TUnit.Core.TUnitAttribute, TUnit.Core.Interfaces.IEventReceiver, TUnit.Core.Interfaces.ITestDiscoveryEventReceiver
    {
        public RetryAttribute(int times) { }
        public int Order { get; }
        public int Times { get; }
        public void OnTestDiscovery(TUnit.Core.DiscoveredTestContext discoveredTestContext) { }
        public virtual System.Threading.Tasks.Task<bool> ShouldRetry(TUnit.Core.TestContext context, System.Exception exception, int currentRetryCount) { }
    }
    public class RunOnDiscoveryAttribute : TUnit.Core.TUnitAttribute, TUnit.Core.Interfaces.IEventReceiver, TUnit.Core.Interfaces.ITestDiscoveryEventReceiver
    {
        public RunOnDiscoveryAttribute() { }
        public int Order { get; }
        public void OnTestDiscovery(TUnit.Core.DiscoveredTestContext discoveredTestContext) { }
    }
    public class STAThreadExecutor : TUnit.Core.DedicatedThreadExecutor
    {
        public STAThreadExecutor() { }
        protected override void ConfigureThread(System.Threading.Thread thread) { }
    }
    public class SharedDataKey : System.IEquatable<TUnit.Core.SharedDataKey>
    {
        public SharedDataKey(string Key, System.Type Type) { }
        public string Key { get; init; }
        public System.Type Type { get; init; }
    }
    public enum SharedType
    {
        None = 0,
        PerClass = 1,
        PerAssembly = 2,
        PerTestSession = 3,
        Keyed = 4,
    }
    public class SingleTUnitAttribute : TUnit.Core.TUnitAttribute { }
    public static class Skip
    {
        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void Test(string reason) { }
        public static void Unless([System.Diagnostics.CodeAnalysis.DoesNotReturnIf(false)] bool condition, string reason) { }
        public static void When([System.Diagnostics.CodeAnalysis.DoesNotReturnIf(true)] bool condition, string reason) { }
    }
    [System.AttributeUsage(System.AttributeTargets.Assembly | System.AttributeTargets.Class | System.AttributeTargets.Method)]
    public class SkipAttribute : TUnit.Core.TUnitAttribute, TUnit.Core.Interfaces.IEventReceiver, TUnit.Core.Interfaces.ITestRegisteredEventReceiver
    {
        public SkipAttribute(string reason) { }
        public int Order { get; }
        public string Reason { get; protected set; }
        public System.Threading.Tasks.ValueTask OnTestRegistered(TUnit.Core.TestRegisteredContext context) { }
        public virtual System.Threading.Tasks.Task<bool> ShouldSkip(TUnit.Core.BeforeTestContext context) { }
    }
    [System.Diagnostics.DebuggerDisplay("{Name})")]
    public class SourceGeneratedAssemblyInformation : System.IEquatable<TUnit.Core.SourceGeneratedAssemblyInformation>
    {
        public SourceGeneratedAssemblyInformation() { }
        public required System.Attribute[] Attributes { get; init; }
        public required string Name { get; init; }
        public virtual bool Equals(TUnit.Core.SourceGeneratedAssemblyInformation? other) { }
        public override int GetHashCode() { }
        public static TUnit.Core.SourceGeneratedAssemblyInformation GetOrAdd(string name, System.Func<TUnit.Core.SourceGeneratedAssemblyInformation> factory) { }
    }
    [System.Diagnostics.DebuggerDisplay("{Type})")]
    public class SourceGeneratedClassInformation : TUnit.Core.SourceGeneratedMemberInformation, System.IEquatable<TUnit.Core.SourceGeneratedClassInformation>
    {
        public SourceGeneratedClassInformation() { }
        public required TUnit.Core.SourceGeneratedAssemblyInformation Assembly { get; init; }
        public required string? Namespace { get; init; }
        public required TUnit.Core.SourceGeneratedParameterInformation[] Parameters { get; init; }
        public required TUnit.Core.SourceGeneratedClassInformation? Parent { get; init; }
        public required TUnit.Core.SourceGeneratedPropertyInformation[] Properties { get; init; }
        public override required System.Type Type { get; init; }
        public virtual bool Equals(TUnit.Core.SourceGeneratedClassInformation? other) { }
        public override int GetHashCode() { }
        public static TUnit.Core.SourceGeneratedClassInformation GetOrAdd(string name, System.Func<TUnit.Core.SourceGeneratedClassInformation> factory) { }
    }
    public abstract class SourceGeneratedMemberInformation : System.IEquatable<TUnit.Core.SourceGeneratedMemberInformation>
    {
        protected SourceGeneratedMemberInformation() { }
        public required System.Attribute[] Attributes { get; init; }
        public required string Name { get; init; }
        public abstract System.Type Type { get; init; }
        public virtual bool Equals(TUnit.Core.SourceGeneratedMemberInformation? other) { }
        public override int GetHashCode() { }
        protected virtual bool PrintMembers(System.Text.StringBuilder stringBuilder) { }
    }
    [System.Diagnostics.DebuggerDisplay("{Type}.{Name}")]
    public class SourceGeneratedMethodInformation : TUnit.Core.SourceGeneratedMemberInformation, System.IEquatable<TUnit.Core.SourceGeneratedMethodInformation>
    {
        public SourceGeneratedMethodInformation() { }
        public required TUnit.Core.SourceGeneratedClassInformation Class { get; init; }
        public required int GenericTypeCount { get; init; }
        public required TUnit.Core.SourceGeneratedParameterInformation[] Parameters { get; init; }
        [System.Text.Json.Serialization.JsonIgnore]
        public System.Reflection.MethodInfo ReflectionInformation { get; set; }
        public required System.Type ReturnType { get; init; }
        public override required System.Type Type { get; init; }
        public virtual bool Equals(TUnit.Core.SourceGeneratedMethodInformation? other) { }
        public override int GetHashCode() { }
        protected override bool PrintMembers(System.Text.StringBuilder stringBuilder) { }
    }
    [System.Diagnostics.DebuggerDisplay("{Type} {Name})")]
    public class SourceGeneratedParameterInformation : TUnit.Core.SourceGeneratedMemberInformation, System.IEquatable<TUnit.Core.SourceGeneratedParameterInformation>
    {
        public SourceGeneratedParameterInformation(System.Type Type) { }
        public override System.Type Type { get; init; }
    }
    [System.Diagnostics.DebuggerDisplay("{Type} {Name})")]
    public class SourceGeneratedParameterInformation<T> : TUnit.Core.SourceGeneratedParameterInformation, System.IEquatable<TUnit.Core.SourceGeneratedParameterInformation<T>>
    {
        public SourceGeneratedParameterInformation() { }
    }
    [System.Diagnostics.DebuggerDisplay("{Type} {Name})")]
    public class SourceGeneratedPropertyInformation : TUnit.Core.SourceGeneratedMemberInformation, System.IEquatable<TUnit.Core.SourceGeneratedPropertyInformation>
    {
        public SourceGeneratedPropertyInformation() { }
        public required bool IsStatic { get; init; }
        public override required System.Type Type { get; init; }
    }
    public class SourceRegistrar
    {
        public SourceRegistrar() { }
        public static bool IsEnabled { get; set; }
        public static void Register(TUnit.Core.Interfaces.SourceGenerator.ITestSource testSource) { }
        public static void RegisterAssembly(System.Func<System.Reflection.Assembly> assemblyLoader) { }
        public static void RegisterAssemblyHookSource(TUnit.Core.Interfaces.SourceGenerator.IAssemblyHookSource testSource) { }
        public static void RegisterClassHookSource(TUnit.Core.Interfaces.SourceGenerator.IClassHookSource testSource) { }
        public static void RegisterDynamic(TUnit.Core.Interfaces.SourceGenerator.IDynamicTestSource testSource) { }
        public static void RegisterTestDiscoveryHookSource(TUnit.Core.Interfaces.SourceGenerator.ITestDiscoveryHookSource testSource) { }
        public static void RegisterTestHookSource(TUnit.Core.Interfaces.SourceGenerator.ITestHookSource testSource) { }
        public static void RegisterTestSessionHookSource(TUnit.Core.Interfaces.SourceGenerator.ITestSessionHookSource testSource) { }
    }
    public class TUnitAttribute : System.Attribute { }
    [System.AttributeUsage(System.AttributeTargets.Method)]
    public sealed class TestAttribute : TUnit.Core.BaseTestAttribute
    {
        public TestAttribute([System.Runtime.CompilerServices.CallerFilePath] string file = "", [System.Runtime.CompilerServices.CallerLineNumber] int line = 0) { }
    }
    public class TestBuilderContext : System.IEquatable<TUnit.Core.TestBuilderContext>
    {
        public TestBuilderContext() { }
        public System.Collections.Generic.List<TUnit.Core.IDataAttribute> DataAttributes { get; }
        public TUnit.Core.TestContextEvents Events { get; }
        public System.Guid Id { get; }
        public System.Collections.Generic.Dictionary<string, object?> ObjectBag { get; }
    }
    public class TestBuilderContextAccessor
    {
        public TestBuilderContextAccessor(TUnit.Core.TestBuilderContext context) { }
        public TUnit.Core.TestBuilderContext Current { get; set; }
    }
    public class TestContext : TUnit.Core.Context
    {
        public readonly object Lock;
        public System.Collections.Generic.List<TUnit.Core.ArgumentDisplayFormatter> ArgumentDisplayFormatters { get; }
        public System.Threading.CancellationToken CancellationToken { get; }
        public int CurrentRetryAttempt { get; }
        public TUnit.Core.TestContextEvents Events { get; }
        public bool IsRegistered { get; }
        public System.Collections.Generic.Dictionary<string, object?> ObjectBag { get; }
        public TUnit.Core.TestResult? Result { get; }
        public TUnit.Core.TestDetails TestDetails { get; }
        public System.DateTimeOffset? TestStart { get; }
        public System.Collections.Generic.List<TUnit.Core.Timing> Timings { get; }
        public static TUnit.Core.Interfaces.IConfiguration Configuration { get; }
        public new static TUnit.Core.TestContext? Current { get; }
        public static string? OutputDirectory { get; }
        public static System.Collections.Generic.IReadOnlyDictionary<string, string> Parameters { get; }
        public static string WorkingDirectory { get; set; }
        public void AddArtifact(TUnit.Core.Artifact artifact) { }
        public void SuppressReportingResult() { }
    }
    public class TestContextEvents : System.IAsyncDisposable, System.IEquatable<TUnit.Core.TestContextEvents>, TUnit.Core.Interfaces.IAsyncInitializer, TUnit.Core.Interfaces.IEventReceiver, TUnit.Core.Interfaces.ILastTestInAssemblyEventReceiver, TUnit.Core.Interfaces.ILastTestInClassEventReceiver, TUnit.Core.Interfaces.ILastTestInTestSessionEventReceiver, TUnit.Core.Interfaces.ITestEndEventReceiver, TUnit.Core.Interfaces.ITestRegisteredEventReceiver, TUnit.Core.Interfaces.ITestRetryEventReceiver, TUnit.Core.Interfaces.ITestSkippedEventReceiver, TUnit.Core.Interfaces.ITestStartEventReceiver
    {
        public TestContextEvents() { }
        public TUnit.Core.AsyncEvent<TUnit.Core.TestContext>? OnDispose { get; set; }
        public TUnit.Core.AsyncEvent<TUnit.Core.TestContext>? OnInitialize { get; set; }
        public TUnit.Core.AsyncEvent<System.ValueTuple<TUnit.Core.AssemblyHookContext, TUnit.Core.TestContext>>? OnLastTestInAssembly { get; set; }
        public TUnit.Core.AsyncEvent<System.ValueTuple<TUnit.Core.ClassHookContext, TUnit.Core.TestContext>>? OnLastTestInClass { get; set; }
        public TUnit.Core.AsyncEvent<System.ValueTuple<TUnit.Core.TestSessionContext, TUnit.Core.TestContext>>? OnLastTestInTestSession { get; set; }
        public TUnit.Core.AsyncEvent<TUnit.Core.TestContext>? OnTestEnd { get; set; }
        public TUnit.Core.AsyncEvent<TUnit.Core.TestRegisteredContext>? OnTestRegistered { get; set; }
        [System.Runtime.CompilerServices.TupleElementNames(new string[] {
                null,
                "RetryAttempt"})]
        public TUnit.Core.AsyncEvent<System.ValueTuple<TUnit.Core.TestContext, int>>? OnTestRetry { get; set; }
        public TUnit.Core.AsyncEvent<TUnit.Core.TestContext>? OnTestSkipped { get; set; }
        public TUnit.Core.AsyncEvent<TUnit.Core.BeforeTestContext>? OnTestStart { get; set; }
        public int Order { get; }
        public System.Threading.Tasks.ValueTask DisposeAsync() { }
        public System.Threading.Tasks.Task InitializeAsync() { }
    }
    public class TestDataAttribute : TUnit.Core.TUnitAttribute, TUnit.Core.IDataAttribute
    {
        public TestDataAttribute() { }
        public bool AccessesInstanceData { get; init; }
    }
    public abstract class TestDetails : System.IEquatable<TUnit.Core.TestDetails>
    {
        protected TestDetails() { }
        [System.Text.Json.Serialization.JsonIgnore]
        public System.Attribute[] AssemblyAttributes { get; }
        [System.Text.Json.Serialization.JsonIgnore]
        public System.Attribute[] Attributes { get; }
        public System.Collections.Generic.IReadOnlyList<string> Categories { get; }
        [System.Text.Json.Serialization.JsonIgnore]
        public System.Attribute[] ClassAttributes { get; }
        public abstract object ClassInstance { get; }
        public required int CurrentRepeatAttempt { get; init; }
        public System.Collections.Generic.IReadOnlyDictionary<string, string> CustomProperties { get; }
        [System.Text.Json.Serialization.JsonIgnore]
        public required System.Attribute[] DataAttributes { get; init; }
        [System.Text.Json.Serialization.JsonIgnore]
        public System.Attribute[] DynamicAttributes { get; init; }
        public TUnit.Core.Interfaces.IParallelConstraint? ParallelConstraint { get; }
        public TUnit.Core.Interfaces.IParallelLimit? ParallelLimit { get; }
        public required int RepeatLimit { get; init; }
        public int RetryLimit { get; }
        public required System.Type ReturnType { get; init; }
        [System.Text.Json.Serialization.JsonIgnore]
        public System.Attribute[] TestAttributes { get; }
        public TUnit.Core.SourceGeneratedClassInformation TestClass { get; }
        public required object?[] TestClassArguments { get; init; }
        public required System.Collections.Generic.IDictionary<string, object?> TestClassInjectedPropertyArguments { get; init; }
        public System.Type[] TestClassParameterTypes { get; }
        public required string TestFilePath { get; init; }
        public required string TestId { get; init; }
        public required int TestLineNumber { get; init; }
        public required TUnit.Core.SourceGeneratedMethodInformation TestMethod { get; init; }
        public required object?[] TestMethodArguments { get; init; }
        public System.Type[] TestMethodParameterTypes { get; }
        public required string TestName { get; init; }
        public System.TimeSpan? Timeout { get; }
    }
    public class TestDetails<TClassType> : TUnit.Core.TestDetails, System.IEquatable<TUnit.Core.TestDetails<TClassType>>
        where TClassType :  class
    {
        public TestDetails() { }
        public override object ClassInstance { get; }
        [System.Text.Json.Serialization.JsonIgnore]
        public required TUnit.Core.ResettableLazy<TClassType> LazyClassInstance { get; init; }
    }
    public class TestDiscoveryContext : TUnit.Core.Context
    {
        public System.Collections.Generic.IEnumerable<TUnit.Core.TestContext> AllTests { get; }
        public System.Collections.Generic.IEnumerable<TUnit.Core.AssemblyHookContext> Assemblies { get; }
        public System.Collections.Generic.IEnumerable<TUnit.Core.ClassHookContext> TestClasses { get; }
        public required string? TestFilter { get; init; }
        public new static TUnit.Core.TestDiscoveryContext? Current { get; }
    }
    public abstract class TestMetadata : System.IEquatable<TUnit.Core.TestMetadata>
    {
        protected TestMetadata() { }
        public required int CurrentRepeatAttempt { get; init; }
        public System.Exception? DiscoveryException { get; init; }
        public System.Attribute[] DynamicAttributes { get; init; }
        public required int RepeatLimit { get; init; }
        public required TUnit.Core.TestBuilderContext TestBuilderContext { get; init; }
        public required object?[] TestClassArguments { get; init; }
        public required System.Collections.Generic.IDictionary<string, object?> TestClassProperties { get; init; }
        public abstract System.Type TestClassType { get; }
        public required string TestFilePath { get; init; }
        public required string TestId { get; init; }
        public required int TestLineNumber { get; init; }
        public required TUnit.Core.SourceGeneratedMethodInformation TestMethod { get; init; }
        public required object?[] TestMethodArguments { get; init; }
        public abstract TUnit.Core.TestDetails BuildTestDetails();
        public abstract TUnit.Core.TestMetadata CloneWithNewMethodFactory(System.Func<object, System.Threading.CancellationToken, System.Threading.Tasks.ValueTask> testMethodFactory);
    }
    public class TestMetadata<TClassType> : TUnit.Core.TestMetadata, System.IEquatable<TUnit.Core.TestMetadata<TClassType>>
        where TClassType :  class
    {
        public TestMetadata() { }
        public required TUnit.Core.ResettableLazy<TClassType> ResettableClassFactory { get; init; }
        public override System.Type TestClassType { get; }
        public required System.Func<TClassType, System.Threading.CancellationToken, System.Threading.Tasks.ValueTask> TestMethodFactory { get; init; }
        public override TUnit.Core.TestDetails BuildTestDetails() { }
        public override TUnit.Core.TestMetadata CloneWithNewMethodFactory(System.Func<object, System.Threading.CancellationToken, System.Threading.Tasks.ValueTask> testMethodFactory) { }
    }
    public class TestRegisteredContext : TUnit.Core.BeforeTestContext
    {
        public void SetParallelLimiter(TUnit.Core.Interfaces.IParallelLimit parallelLimit) { }
        public void SkipTest(string reason) { }
    }
    public class TestResult : System.IEquatable<TUnit.Core.TestResult>
    {
        public TestResult() { }
        public required string ComputerName { get; init; }
        public required System.TimeSpan? Duration { get; init; }
        public required System.DateTimeOffset? End { get; init; }
        public required System.Exception? Exception { get; init; }
        public string? Output { get; }
        public required System.DateTimeOffset? Start { get; init; }
        public required TUnit.Core.Enums.Status Status { get; init; }
    }
    public class TestSessionContext : TUnit.Core.Context
    {
        public System.Collections.Generic.IEnumerable<TUnit.Core.TestContext> AllTests { get; }
        public System.Collections.Generic.IEnumerable<TUnit.Core.AssemblyHookContext> Assemblies { get; }
        public required string Id { get; init; }
        public System.Collections.Generic.IEnumerable<TUnit.Core.ClassHookContext> TestClasses { get; }
        public required string? TestFilter { get; init; }
        public new static TUnit.Core.TestSessionContext? Current { get; }
        public void AddArtifact(TUnit.Core.Artifact artifact) { }
    }
    [System.AttributeUsage(System.AttributeTargets.Assembly | System.AttributeTargets.Class | System.AttributeTargets.Method)]
    public class TimeoutAttribute : TUnit.Core.TUnitAttribute, TUnit.Core.Interfaces.IEventReceiver, TUnit.Core.Interfaces.ITestDiscoveryEventReceiver
    {
        public TimeoutAttribute(int timeoutInMilliseconds) { }
        public int Order { get; }
        public System.TimeSpan Timeout { get; }
        public void OnTestDiscovery(TUnit.Core.DiscoveredTestContext discoveredTestContext) { }
    }
    public class Timing : System.IEquatable<TUnit.Core.Timing>
    {
        public Timing(string StepName, System.DateTimeOffset Start, System.DateTimeOffset End) { }
        public System.TimeSpan Duration { get; }
        public System.DateTimeOffset End { get; init; }
        public System.DateTimeOffset Start { get; init; }
        public string StepName { get; init; }
    }
    public class UntypedDynamicTest : TUnit.Core.DynamicTest, System.IEquatable<TUnit.Core.UntypedDynamicTest>
    {
        public UntypedDynamicTest(System.Reflection.MethodInfo testBody) { }
        public UntypedDynamicTest(System.Type testClassType, System.Reflection.MethodInfo testBody) { }
        public TUnit.Core.TestBuilderContext TestBuilderContext { get; set; }
        public override System.Type TestClassType { get; }
        public override string TestId { get; }
        public override System.Collections.Generic.IEnumerable<TUnit.Core.TestMetadata> BuildTestMetadatas() { }
    }
    public class UntypedFailedDynamicTest : System.IEquatable<TUnit.Core.UntypedFailedDynamicTest>
    {
        public UntypedFailedDynamicTest() { }
        public required System.Exception Exception { get; init; }
        public required string MethodName { get; init; }
        public required System.Type TestClassType { get; init; }
        public required string TestFilePath { get; init; }
        public required int TestLineNumber { get; init; }
        public static TUnit.Core.DynamicTest op_Implicit(TUnit.Core.UntypedFailedDynamicTest failedTestMetadata) { }
    }
    public class UntypedTestDetails : TUnit.Core.TestDetails, System.IEquatable<TUnit.Core.UntypedTestDetails>
    {
        public UntypedTestDetails(TUnit.Core.ResettableLazy<object> ResettableLazy) { }
        public override object ClassInstance { get; }
        public TUnit.Core.ResettableLazy<object> ResettableLazy { get; init; }
    }
    public class UntypedTestMetadata : TUnit.Core.TestMetadata, System.IEquatable<TUnit.Core.UntypedTestMetadata>
    {
        public UntypedTestMetadata(System.Type TestClassType) { }
        public override System.Type TestClassType { get; }
        public override TUnit.Core.TestDetails BuildTestDetails() { }
        public override TUnit.Core.TestMetadata CloneWithNewMethodFactory(System.Func<object, System.Threading.CancellationToken, System.Threading.Tasks.ValueTask> testMethodFactory) { }
    }
}
namespace TUnit.Core.Data
{
    public class GetOnlyDictionary<TKey, TValue>
        where TKey :  notnull
    {
        public GetOnlyDictionary() { }
        public TValue this[TKey key] { get; }
        public System.Collections.Generic.ICollection<TKey> Keys { get; }
        public System.Collections.Generic.ICollection<TValue> Values { get; }
        public TValue GetOrAdd(TKey key, System.Func<TKey, TValue> func) { }
        public TValue GetOrAdd(TKey key, System.Func<TKey, TValue> func, out bool previouslyExisted) { }
        public TValue? Remove(TKey key) { }
        public bool TryGetValue(TKey key, [System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out TValue? value) { }
    }
}
namespace TUnit.Core.Enums
{
    public enum DataGeneratorType
    {
        ClassParameters = 0,
        TestParameters = 1,
        Property = 2,
    }
    public enum LogLevel
    {
        None = -1,
        Trace = 0,
        Debug = 1,
        Information = 2,
        Warning = 3,
        Error = 4,
        Critical = 5,
    }
    public enum Status
    {
        None = 0,
        Passed = 1,
        Failed = 2,
        Skipped = 3,
        Cancelled = 4,
    }
}
namespace TUnit.Core.Exceptions
{
    public class AfterAssemblyException : TUnit.Core.Exceptions.TUnitException
    {
        public AfterAssemblyException(string message, System.Exception innerException) { }
    }
    public class AfterClassException : TUnit.Core.Exceptions.TUnitException
    {
        public AfterClassException(string message, System.Exception innerException) { }
    }
    public class AfterTestDiscoveryException : TUnit.Core.Exceptions.TUnitException
    {
        public AfterTestDiscoveryException(string message, System.Exception innerException) { }
    }
    public class AfterTestException : TUnit.Core.Exceptions.TUnitException
    {
        public AfterTestException(string message, System.Exception innerException) { }
    }
    public class AfterTestSessionException : TUnit.Core.Exceptions.TUnitException
    {
        public AfterTestSessionException(string message, System.Exception innerException) { }
    }
    public class BeforeAssemblyException : TUnit.Core.Exceptions.TUnitException
    {
        public BeforeAssemblyException(string message, System.Exception innerException) { }
    }
    public class BeforeClassException : TUnit.Core.Exceptions.TUnitException
    {
        public BeforeClassException(string message, System.Exception innerException) { }
    }
    public class BeforeTestDiscoveryException : TUnit.Core.Exceptions.TUnitException
    {
        public BeforeTestDiscoveryException(string message, System.Exception innerException) { }
    }
    public class BeforeTestException : TUnit.Core.Exceptions.TUnitException
    {
        public BeforeTestException(string message, System.Exception innerException) { }
    }
    public class BeforeTestSessionException : TUnit.Core.Exceptions.TUnitException
    {
        public BeforeTestSessionException(string message, System.Exception innerException) { }
    }
    public class DependencyConflictException : TUnit.Core.Exceptions.TUnitException { }
    public class FailTestException : TUnit.Core.Exceptions.TUnitException
    {
        public FailTestException(string reason) { }
        public string Reason { get; }
    }
    public class InconclusiveTestException : TUnit.Core.Exceptions.TUnitException
    {
        public InconclusiveTestException(string message, System.Exception exception) { }
    }
    public class SkipTestException : TUnit.Core.Exceptions.TUnitException
    {
        public SkipTestException(string reason) { }
        public string Reason { get; }
    }
    public class TUnitException : System.Exception
    {
        public TUnitException() { }
        public TUnitException(string? message) { }
        public TUnitException(string? message, System.Exception? innerException) { }
    }
    public class TestFailedInitializationException : System.Exception
    {
        public TestFailedInitializationException(string? message, System.Exception? innerException) { }
    }
    public class TestNotExecutedException : TUnit.Core.Exceptions.TUnitException { }
    public class TestRunCanceledException : TUnit.Core.Exceptions.TUnitException
    {
        public TestRunCanceledException() { }
    }
    public class TimeoutException : TUnit.Core.Exceptions.TUnitException { }
}
namespace TUnit.Core.Executors
{
    [System.AttributeUsage(System.AttributeTargets.Assembly | System.AttributeTargets.Class | System.AttributeTargets.Method)]
    public class CultureAttribute : TUnit.Core.TUnitAttribute, TUnit.Core.Interfaces.IEventReceiver, TUnit.Core.Interfaces.ITestRegisteredEventReceiver
    {
        public CultureAttribute(System.Globalization.CultureInfo cultureInfo) { }
        public CultureAttribute(string cultureName) { }
        public int Order { get; }
        public System.Threading.Tasks.ValueTask OnTestRegistered(TUnit.Core.TestRegisteredContext context) { }
    }
    public class HookExecutorAttribute : TUnit.Core.TUnitAttribute
    {
        public HookExecutorAttribute(System.Type type) { }
        public System.Type HookExecutorType { get; }
    }
    [System.AttributeUsage(System.AttributeTargets.Assembly | System.AttributeTargets.Class | System.AttributeTargets.Method)]
    public sealed class HookExecutorAttribute<T> : TUnit.Core.Executors.HookExecutorAttribute
        where T : TUnit.Core.Interfaces.IHookExecutor, new ()
    {
        public HookExecutorAttribute() { }
    }
    [System.AttributeUsage(System.AttributeTargets.Assembly | System.AttributeTargets.Class | System.AttributeTargets.Method)]
    public class InvariantCultureAttribute : TUnit.Core.Executors.CultureAttribute
    {
        public InvariantCultureAttribute() { }
    }
    [System.AttributeUsage(System.AttributeTargets.Assembly | System.AttributeTargets.Class | System.AttributeTargets.Method)]
    public class STAThreadExecutorAttribute : TUnit.Core.TUnitAttribute, TUnit.Core.Interfaces.IEventReceiver, TUnit.Core.Interfaces.ITestRegisteredEventReceiver
    {
        public STAThreadExecutorAttribute() { }
        public int Order { get; }
        public System.Threading.Tasks.ValueTask OnTestRegistered(TUnit.Core.TestRegisteredContext context) { }
    }
    [System.AttributeUsage(System.AttributeTargets.Assembly | System.AttributeTargets.Class | System.AttributeTargets.Method)]
    public sealed class TestExecutorAttribute : TUnit.Core.TUnitAttribute, TUnit.Core.Interfaces.IEventReceiver, TUnit.Core.Interfaces.ITestRegisteredEventReceiver
    {
        public TestExecutorAttribute(System.Type type) { }
        public int Order { get; }
        public System.Threading.Tasks.ValueTask OnTestRegistered(TUnit.Core.TestRegisteredContext context) { }
    }
    [System.AttributeUsage(System.AttributeTargets.Assembly | System.AttributeTargets.Class | System.AttributeTargets.Method)]
    public sealed class TestExecutorAttribute<T> : TUnit.Core.TUnitAttribute, TUnit.Core.Interfaces.IEventReceiver, TUnit.Core.Interfaces.ITestRegisteredEventReceiver
        where T : TUnit.Core.Interfaces.ITestExecutor, new ()
    {
        public TestExecutorAttribute() { }
        public int Order { get; }
        public System.Threading.Tasks.ValueTask OnTestRegistered(TUnit.Core.TestRegisteredContext context) { }
    }
}
namespace TUnit.Core.Extensions
{
    public static class ClassConstructorExtensions
    {
        public static T Create<T>(this TUnit.Core.Interfaces.IClassConstructor classConstructor, TUnit.Core.ClassConstructorMetadata classConstructorMetadata)
            where T :  class { }
    }
    public static class TestContextExtensions
    {
        public static System.Threading.Tasks.Task AddDynamicTest<T>(this TUnit.Core.TestContext testContext, TUnit.Core.DynamicTest<T> dynamicTest)
            where T :  class { }
        public static string GetClassTypeName(this TUnit.Core.TestContext testContext) { }
        public static string GetTestDisplayName(this TUnit.Core.TestContext testContext) { }
        public static TUnit.Core.TestContext[] GetTests(this TUnit.Core.TestContext context, string testName) { }
        public static TUnit.Core.TestContext[] GetTests(this TUnit.Core.TestContext context, string testName, System.Type[] parameterTypes) { }
    }
}
namespace TUnit.Core.Helpers
{
    public static class CastHelper
    {
        public static object? Cast(System.Type type, object? value) { }
        public static T? Cast<T>(object? value) { }
    }
    [System.Diagnostics.DebuggerDisplay("Count = {CurrentCount}")]
    public class Counter
    {
        public System.EventHandler<int>? OnCountChanged;
        public Counter() { }
        public int CurrentCount { get; }
        public int Decrement() { }
        public int Increment() { }
    }
    public class DefaultParallelLimit : TUnit.Core.Interfaces.IParallelLimit
    {
        public DefaultParallelLimit() { }
        public int Limit { get; }
    }
    public class MethodInfoRetriever
    {
        public MethodInfoRetriever() { }
        public static System.Reflection.MethodInfo GetMethodInfo(System.Type type, string methodName, int genericParameterCount, System.Type[] parameterTypes) { }
    }
}
namespace TUnit.Core.Hooks
{
    public class AfterAssemblyHookMethod : TUnit.Core.Hooks.StaticHookMethod<TUnit.Core.AssemblyHookContext>, System.IEquatable<TUnit.Core.Hooks.AfterAssemblyHookMethod>
    {
        public AfterAssemblyHookMethod() { }
        public override System.Threading.Tasks.ValueTask ExecuteAsync(TUnit.Core.AssemblyHookContext context, System.Threading.CancellationToken cancellationToken) { }
    }
    public class AfterClassHookMethod : TUnit.Core.Hooks.StaticHookMethod<TUnit.Core.ClassHookContext>, System.IEquatable<TUnit.Core.Hooks.AfterClassHookMethod>
    {
        public AfterClassHookMethod() { }
        public override System.Threading.Tasks.ValueTask ExecuteAsync(TUnit.Core.ClassHookContext context, System.Threading.CancellationToken cancellationToken) { }
    }
    public class AfterTestDiscoveryHookMethod : TUnit.Core.Hooks.StaticHookMethod<TUnit.Core.TestDiscoveryContext>, System.IEquatable<TUnit.Core.Hooks.AfterTestDiscoveryHookMethod>
    {
        public AfterTestDiscoveryHookMethod() { }
        public override System.Threading.Tasks.ValueTask ExecuteAsync(TUnit.Core.TestDiscoveryContext context, System.Threading.CancellationToken cancellationToken) { }
    }
    public class AfterTestHookMethod : TUnit.Core.Hooks.StaticHookMethod<TUnit.Core.TestContext>, System.IEquatable<TUnit.Core.Hooks.AfterTestHookMethod>
    {
        public AfterTestHookMethod() { }
        public override System.Threading.Tasks.ValueTask ExecuteAsync(TUnit.Core.TestContext context, System.Threading.CancellationToken cancellationToken) { }
    }
    public class AfterTestSessionHookMethod : TUnit.Core.Hooks.StaticHookMethod<TUnit.Core.TestSessionContext>, System.IEquatable<TUnit.Core.Hooks.AfterTestSessionHookMethod>
    {
        public AfterTestSessionHookMethod() { }
        public override System.Threading.Tasks.ValueTask ExecuteAsync(TUnit.Core.TestSessionContext context, System.Threading.CancellationToken cancellationToken) { }
    }
    public class BeforeAssemblyHookMethod : TUnit.Core.Hooks.StaticHookMethod<TUnit.Core.AssemblyHookContext>, System.IEquatable<TUnit.Core.Hooks.BeforeAssemblyHookMethod>
    {
        public BeforeAssemblyHookMethod() { }
        public override System.Threading.Tasks.ValueTask ExecuteAsync(TUnit.Core.AssemblyHookContext context, System.Threading.CancellationToken cancellationToken) { }
    }
    public class BeforeClassHookMethod : TUnit.Core.Hooks.StaticHookMethod<TUnit.Core.ClassHookContext>, System.IEquatable<TUnit.Core.Hooks.BeforeClassHookMethod>
    {
        public BeforeClassHookMethod() { }
        public override System.Threading.Tasks.ValueTask ExecuteAsync(TUnit.Core.ClassHookContext context, System.Threading.CancellationToken cancellationToken) { }
    }
    public class BeforeTestDiscoveryHookMethod : TUnit.Core.Hooks.StaticHookMethod<TUnit.Core.BeforeTestDiscoveryContext>, System.IEquatable<TUnit.Core.Hooks.BeforeTestDiscoveryHookMethod>
    {
        public BeforeTestDiscoveryHookMethod() { }
        public override System.Threading.Tasks.ValueTask ExecuteAsync(TUnit.Core.BeforeTestDiscoveryContext context, System.Threading.CancellationToken cancellationToken) { }
    }
    public class BeforeTestHookMethod : TUnit.Core.Hooks.StaticHookMethod<TUnit.Core.TestContext>, System.IEquatable<TUnit.Core.Hooks.BeforeTestHookMethod>
    {
        public BeforeTestHookMethod() { }
        public override System.Threading.Tasks.ValueTask ExecuteAsync(TUnit.Core.TestContext context, System.Threading.CancellationToken cancellationToken) { }
    }
    public class BeforeTestSessionHookMethod : TUnit.Core.Hooks.StaticHookMethod<TUnit.Core.TestSessionContext>, System.IEquatable<TUnit.Core.Hooks.BeforeTestSessionHookMethod>
    {
        public BeforeTestSessionHookMethod() { }
        public override System.Threading.Tasks.ValueTask ExecuteAsync(TUnit.Core.TestSessionContext context, System.Threading.CancellationToken cancellationToken) { }
    }
    public class HookMethod
    {
        public HookMethod(TUnit.Core.Hooks.InstanceHookMethod instanceHookMethod) { }
        public HookMethod(TUnit.Core.Hooks.StaticHookMethod staticHookMethod) { }
        public TUnit.Core.Hooks.InstanceHookMethod? InstanceHookMethod { get; }
        public TUnit.Core.Hooks.StaticHookMethod? StaticHookMethod { get; }
        public static TUnit.Core.Hooks.HookMethod op_Implicit(TUnit.Core.Hooks.InstanceHookMethod instanceHookMethod) { }
        public static TUnit.Core.Hooks.HookMethod op_Implicit(TUnit.Core.Hooks.StaticHookMethod staticHookMethod) { }
    }
    public interface IExecutableHook<in T>
    {
        TUnit.Core.SourceGeneratedMethodInformation MethodInfo { get; }
        string Name { get; }
        int Order { get; }
        System.Threading.Tasks.ValueTask ExecuteAsync(T context, System.Threading.CancellationToken cancellationToken);
    }
    public interface IHookMessagePublisher
    {
        System.Threading.Tasks.Task Discover(string sessionId, string displayName, TUnit.Core.Hooks.StaticHookMethod hookMethod);
        System.Threading.Tasks.Task Push(string sessionId, string displayName, TUnit.Core.Hooks.StaticHookMethod hookMethod, System.Func<System.Threading.Tasks.Task> func);
    }
    public class InstanceHookMethod : System.IEquatable<TUnit.Core.Hooks.InstanceHookMethod>, TUnit.Core.Hooks.IExecutableHook<TUnit.Core.TestContext>
    {
        public InstanceHookMethod() { }
        public System.Reflection.Assembly Assembly { get; }
        public System.Attribute[] AssemblyAttributes { get; }
        public System.Collections.Generic.IEnumerable<System.Attribute> Attributes { get; }
        public System.Func<object, TUnit.Core.TestContext, System.Threading.CancellationToken, System.Threading.Tasks.ValueTask>? Body { get; init; }
        public System.Attribute[] ClassAttributes { get; }
        public required System.Type ClassType { get; init; }
        public required TUnit.Core.Interfaces.IHookExecutor HookExecutor { get; init; }
        public System.Attribute[] MethodAttributes { get; }
        public required TUnit.Core.SourceGeneratedMethodInformation MethodInfo { get; init; }
        public string Name { get; }
        public required int Order { get; init; }
        public System.TimeSpan? Timeout { get; }
        public System.Threading.Tasks.ValueTask ExecuteAsync(TUnit.Core.TestContext context, System.Threading.CancellationToken cancellationToken) { }
        public TAttribute? GetAttribute<TAttribute>()
            where TAttribute : System.Attribute { }
    }
    public class LastTestInAssemblyAdapter : TUnit.Core.Hooks.IExecutableHook<TUnit.Core.AssemblyHookContext>
    {
        public LastTestInAssemblyAdapter(TUnit.Core.Interfaces.ILastTestInAssemblyEventReceiver lastTestInAssemblyEventReceiver, TUnit.Core.TestContext testContext) { }
        public TUnit.Core.SourceGeneratedMethodInformation MethodInfo { get; }
        public string Name { get; }
        public int Order { get; }
        public bool Execute(TUnit.Core.AssemblyHookContext context, System.Threading.CancellationToken cancellationToken) { }
        public System.Threading.Tasks.ValueTask ExecuteAsync(TUnit.Core.AssemblyHookContext context, System.Threading.CancellationToken cancellationToken) { }
    }
    public class LastTestInClassAdapter : TUnit.Core.Hooks.IExecutableHook<TUnit.Core.ClassHookContext>
    {
        public LastTestInClassAdapter(TUnit.Core.Interfaces.ILastTestInClassEventReceiver lastTestInClassEventReceiver, TUnit.Core.TestContext testContext) { }
        public TUnit.Core.SourceGeneratedMethodInformation MethodInfo { get; }
        public string Name { get; }
        public int Order { get; }
        public bool Execute(TUnit.Core.ClassHookContext context, System.Threading.CancellationToken cancellationToken) { }
        public System.Threading.Tasks.ValueTask ExecuteAsync(TUnit.Core.ClassHookContext context, System.Threading.CancellationToken cancellationToken) { }
    }
    public abstract class StaticHookMethod : System.IEquatable<TUnit.Core.Hooks.StaticHookMethod>
    {
        protected StaticHookMethod() { }
        public System.Reflection.Assembly Assembly { get; }
        public System.Attribute[] AssemblyAttributes { get; }
        public System.Collections.Generic.IEnumerable<System.Attribute> Attributes { get; }
        public System.Attribute[] ClassAttributes { get; }
        public System.Type ClassType { get; }
        public required string FilePath { get; init; }
        public required TUnit.Core.Interfaces.IHookExecutor HookExecutor { get; init; }
        public required int LineNumber { get; init; }
        public System.Attribute[] MethodAttributes { get; }
        public required TUnit.Core.SourceGeneratedMethodInformation MethodInfo { get; init; }
        public string Name { get; }
        public required int Order { get; init; }
        public System.TimeSpan? Timeout { get; }
        public TAttribute? GetAttribute<TAttribute>()
            where TAttribute : System.Attribute { }
    }
    public abstract class StaticHookMethod<T> : TUnit.Core.Hooks.StaticHookMethod, System.IEquatable<TUnit.Core.Hooks.StaticHookMethod<T>>, TUnit.Core.Hooks.IExecutableHook<T>
    {
        protected StaticHookMethod() { }
        public System.Func<T, System.Threading.CancellationToken, System.Threading.Tasks.ValueTask>? Body { get; init; }
        public abstract System.Threading.Tasks.ValueTask ExecuteAsync(T context, System.Threading.CancellationToken cancellationToken);
    }
}
namespace TUnit.Core.Interfaces
{
    public interface IAsyncInitializer
    {
        System.Threading.Tasks.Task InitializeAsync();
    }
    public interface IClassConstructor
    {
        object Create(System.Type type, TUnit.Core.ClassConstructorMetadata classConstructorMetadata);
    }
    public interface IConfiguration
    {
        string? Get(string key);
    }
    public interface IContext
    {
        System.IO.TextWriter ErrorOutputWriter { get; }
        System.IO.TextWriter OutputWriter { get; }
        TUnit.Core.Logging.DefaultLogger GetDefaultLogger();
    }
    public interface IEventReceiver
    {
        int Order { get; }
    }
    public interface IFirstTestInAssemblyEventReceiver : TUnit.Core.Interfaces.IEventReceiver
    {
        System.Threading.Tasks.ValueTask OnFirstTestInAssembly(TUnit.Core.AssemblyHookContext context, TUnit.Core.TestContext testContext);
    }
    public interface IFirstTestInClassEventReceiver : TUnit.Core.Interfaces.IEventReceiver
    {
        System.Threading.Tasks.ValueTask OnFirstTestInClass(TUnit.Core.ClassHookContext context, TUnit.Core.TestContext testContext);
    }
    public interface IFirstTestInTestSessionEventReceiver : TUnit.Core.Interfaces.IEventReceiver
    {
        System.Threading.Tasks.ValueTask OnFirstTestInTestSession(TUnit.Core.TestSessionContext current, TUnit.Core.TestContext testContext);
    }
    public interface IHasLoggers
    {
        System.Collections.Generic.List<TUnit.Core.Logging.TUnitLogger> Loggers { get; }
    }
    public interface IHookExecutor
    {
        System.Threading.Tasks.ValueTask ExecuteAfterAssemblyHook(TUnit.Core.SourceGeneratedMethodInformation hookMethodInfo, TUnit.Core.AssemblyHookContext context, System.Func<System.Threading.Tasks.ValueTask> action);
        System.Threading.Tasks.ValueTask ExecuteAfterClassHook(TUnit.Core.SourceGeneratedMethodInformation hookMethodInfo, TUnit.Core.ClassHookContext context, System.Func<System.Threading.Tasks.ValueTask> action);
        System.Threading.Tasks.ValueTask ExecuteAfterTestDiscoveryHook(TUnit.Core.SourceGeneratedMethodInformation hookMethodInfo, TUnit.Core.TestDiscoveryContext context, System.Func<System.Threading.Tasks.ValueTask> action);
        System.Threading.Tasks.ValueTask ExecuteAfterTestHook(TUnit.Core.SourceGeneratedMethodInformation hookMethodInfo, TUnit.Core.TestContext context, System.Func<System.Threading.Tasks.ValueTask> action);
        System.Threading.Tasks.ValueTask ExecuteAfterTestSessionHook(TUnit.Core.SourceGeneratedMethodInformation hookMethodInfo, TUnit.Core.TestSessionContext context, System.Func<System.Threading.Tasks.ValueTask> action);
        System.Threading.Tasks.ValueTask ExecuteBeforeAssemblyHook(TUnit.Core.SourceGeneratedMethodInformation hookMethodInfo, TUnit.Core.AssemblyHookContext context, System.Func<System.Threading.Tasks.ValueTask> action);
        System.Threading.Tasks.ValueTask ExecuteBeforeClassHook(TUnit.Core.SourceGeneratedMethodInformation hookMethodInfo, TUnit.Core.ClassHookContext context, System.Func<System.Threading.Tasks.ValueTask> action);
        System.Threading.Tasks.ValueTask ExecuteBeforeTestDiscoveryHook(TUnit.Core.SourceGeneratedMethodInformation hookMethodInfo, TUnit.Core.BeforeTestDiscoveryContext context, System.Func<System.Threading.Tasks.ValueTask> action);
        System.Threading.Tasks.ValueTask ExecuteBeforeTestHook(TUnit.Core.SourceGeneratedMethodInformation hookMethodInfo, TUnit.Core.TestContext context, System.Func<System.Threading.Tasks.ValueTask> action);
        System.Threading.Tasks.ValueTask ExecuteBeforeTestSessionHook(TUnit.Core.SourceGeneratedMethodInformation hookMethodInfo, TUnit.Core.TestSessionContext context, System.Func<System.Threading.Tasks.ValueTask> action);
    }
    public interface ILastTestInAssemblyEventReceiver : TUnit.Core.Interfaces.IEventReceiver
    {
        System.Threading.Tasks.ValueTask OnLastTestInAssembly(TUnit.Core.AssemblyHookContext context, TUnit.Core.TestContext testContext);
    }
    public interface ILastTestInClassEventReceiver : TUnit.Core.Interfaces.IEventReceiver
    {
        System.Threading.Tasks.ValueTask OnLastTestInClass(TUnit.Core.ClassHookContext context, TUnit.Core.TestContext testContext);
    }
    public interface ILastTestInTestSessionEventReceiver : TUnit.Core.Interfaces.IEventReceiver
    {
        System.Threading.Tasks.ValueTask OnLastTestInTestSession(TUnit.Core.TestSessionContext current, TUnit.Core.TestContext testContext);
    }
    public interface IParallelConstraint { }
    public interface IParallelLimit
    {
        int Limit { get; }
    }
    public interface ITestDiscoveryEventReceiver : TUnit.Core.Interfaces.IEventReceiver
    {
        void OnTestDiscovery(TUnit.Core.DiscoveredTestContext discoveredTestContext);
    }
    public interface ITestEndEventReceiver : TUnit.Core.Interfaces.IEventReceiver
    {
        System.Threading.Tasks.ValueTask OnTestEnd(TUnit.Core.TestContext testContext);
    }
    public interface ITestExecutor
    {
        System.Threading.Tasks.ValueTask ExecuteTest(TUnit.Core.TestContext context, System.Func<System.Threading.Tasks.ValueTask> action);
    }
    public interface ITestFinder
    {
        System.Collections.Generic.IEnumerable<TUnit.Core.TestContext> GetTests(System.Type classType);
        TUnit.Core.TestContext[] GetTestsByNameAndParameters(string testName, System.Collections.Generic.IEnumerable<System.Type> methodParameterTypes, System.Type classType, System.Collections.Generic.IEnumerable<System.Type> classParameterTypes, System.Collections.Generic.IEnumerable<object?> classArguments);
    }
    public interface ITestRegisteredEventReceiver : TUnit.Core.Interfaces.IEventReceiver
    {
        System.Threading.Tasks.ValueTask OnTestRegistered(TUnit.Core.TestRegisteredContext context);
    }
    public interface ITestRetryEventReceiver : TUnit.Core.Interfaces.IEventReceiver
    {
        System.Threading.Tasks.ValueTask OnTestRetry(TUnit.Core.TestContext testContext, int retryAttempt);
    }
    public interface ITestSkippedEventReceiver : TUnit.Core.Interfaces.IEventReceiver
    {
        System.Threading.Tasks.ValueTask OnTestSkipped(TUnit.Core.TestContext testContext);
    }
    public interface ITestStartEventReceiver : TUnit.Core.Interfaces.IEventReceiver
    {
        System.Threading.Tasks.ValueTask OnTestStart(TUnit.Core.BeforeTestContext beforeTestContext);
    }
}
namespace TUnit.Core.Interfaces.SourceGenerator
{
    public interface IAssemblyHookSource
    {
        System.Collections.Generic.IReadOnlyList<TUnit.Core.Hooks.StaticHookMethod<TUnit.Core.AssemblyHookContext>> CollectAfterAssemblyHooks(string sessionId);
        System.Collections.Generic.IReadOnlyList<TUnit.Core.Hooks.StaticHookMethod<TUnit.Core.AssemblyHookContext>> CollectAfterEveryAssemblyHooks(string sessionId);
        System.Collections.Generic.IReadOnlyList<TUnit.Core.Hooks.StaticHookMethod<TUnit.Core.AssemblyHookContext>> CollectBeforeAssemblyHooks(string sessionId);
        System.Collections.Generic.IReadOnlyList<TUnit.Core.Hooks.StaticHookMethod<TUnit.Core.AssemblyHookContext>> CollectBeforeEveryAssemblyHooks(string sessionId);
    }
    public interface IClassHookSource
    {
        System.Collections.Generic.IReadOnlyList<TUnit.Core.Hooks.StaticHookMethod<TUnit.Core.ClassHookContext>> CollectAfterClassHooks(string sessionId);
        System.Collections.Generic.IReadOnlyList<TUnit.Core.Hooks.StaticHookMethod<TUnit.Core.ClassHookContext>> CollectAfterEveryClassHooks(string sessionId);
        System.Collections.Generic.IReadOnlyList<TUnit.Core.Hooks.StaticHookMethod<TUnit.Core.ClassHookContext>> CollectBeforeClassHooks(string sessionId);
        System.Collections.Generic.IReadOnlyList<TUnit.Core.Hooks.StaticHookMethod<TUnit.Core.ClassHookContext>> CollectBeforeEveryClassHooks(string sessionId);
    }
    public interface IDynamicTestSource
    {
        System.Collections.Generic.IReadOnlyList<TUnit.Core.DynamicTest> CollectDynamicTests(string sessionId);
    }
    public interface ITestDiscoveryHookSource
    {
        System.Collections.Generic.IReadOnlyList<TUnit.Core.Hooks.StaticHookMethod<TUnit.Core.TestDiscoveryContext>> CollectAfterTestDiscoveryHooks(string sessionId);
        System.Collections.Generic.IReadOnlyList<TUnit.Core.Hooks.StaticHookMethod<TUnit.Core.BeforeTestDiscoveryContext>> CollectBeforeTestDiscoveryHooks(string sessionId);
    }
    public interface ITestHookSource
    {
        System.Collections.Generic.IReadOnlyList<TUnit.Core.Hooks.StaticHookMethod<TUnit.Core.TestContext>> CollectAfterEveryTestHooks(string sessionId);
        System.Collections.Generic.IReadOnlyList<TUnit.Core.Hooks.InstanceHookMethod> CollectAfterTestHooks(string sessionId);
        System.Collections.Generic.IReadOnlyList<TUnit.Core.Hooks.StaticHookMethod<TUnit.Core.TestContext>> CollectBeforeEveryTestHooks(string sessionId);
        System.Collections.Generic.IReadOnlyList<TUnit.Core.Hooks.InstanceHookMethod> CollectBeforeTestHooks(string sessionId);
    }
    public interface ITestSessionHookSource
    {
        System.Collections.Generic.IReadOnlyList<TUnit.Core.Hooks.StaticHookMethod<TUnit.Core.TestSessionContext>> CollectAfterTestSessionHooks(string sessionId);
        System.Collections.Generic.IReadOnlyList<TUnit.Core.Hooks.StaticHookMethod<TUnit.Core.TestSessionContext>> CollectBeforeTestSessionHooks(string sessionId);
    }
    public interface ITestSource
    {
        System.Collections.Generic.IReadOnlyList<TUnit.Core.TestMetadata> CollectTests(string sessionId);
    }
}
namespace TUnit.Core.Logging
{
    public class DefaultLogger : TUnit.Core.Logging.TUnitLogger
    {
        public DefaultLogger(TUnit.Core.Context context) { }
        public override void Log<TState>(TUnit.Core.Logging.LogLevel logLevel, TState state, System.Exception? exception, System.Func<TState, System.Exception?, string> formatter) { }
        public override System.Threading.Tasks.ValueTask LogAsync<TState>(TUnit.Core.Logging.LogLevel logLevel, TState state, System.Exception? exception, System.Func<TState, System.Exception?, string> formatter) { }
        public void PushProperties(System.Collections.Generic.IDictionary<string, System.Collections.Generic.List<object>> dictionary) { }
        public void PushProperty(string name, object? value) { }
    }
    public interface ILogger
    {
        bool IsEnabled(TUnit.Core.Logging.LogLevel logLevel);
        void Log<TState>(TUnit.Core.Logging.LogLevel logLevel, TState state, System.Exception? exception, System.Func<TState, System.Exception?, string> formatter);
        System.Threading.Tasks.ValueTask LogAsync<TState>(TUnit.Core.Logging.LogLevel logLevel, TState state, System.Exception? exception, System.Func<TState, System.Exception?, string> formatter);
    }
    public interface ILogger<out TCategoryName> : TUnit.Core.Logging.ILogger { }
    public enum LogLevel
    {
        Trace = 0,
        Debug = 1,
        Information = 2,
        Warning = 3,
        Error = 4,
        Critical = 5,
        None = 6,
    }
    public static class LoggingExtensions
    {
        public static void LogCritical(this TUnit.Core.Logging.ILogger logger, string message) { }
        public static System.Threading.Tasks.ValueTask LogCriticalAsync(this TUnit.Core.Logging.ILogger logger, string message) { }
        public static void LogDebug(this TUnit.Core.Logging.ILogger logger, string message) { }
        public static System.Threading.Tasks.ValueTask LogDebugAsync(this TUnit.Core.Logging.ILogger logger, string message) { }
        public static void LogError(this TUnit.Core.Logging.ILogger logger, System.Exception ex) { }
        public static void LogError(this TUnit.Core.Logging.ILogger logger, string message) { }
        public static void LogError(this TUnit.Core.Logging.ILogger logger, string message, System.Exception ex) { }
        public static System.Threading.Tasks.ValueTask LogErrorAsync(this TUnit.Core.Logging.ILogger logger, System.Exception ex) { }
        public static System.Threading.Tasks.ValueTask LogErrorAsync(this TUnit.Core.Logging.ILogger logger, string message) { }
        public static System.Threading.Tasks.ValueTask LogErrorAsync(this TUnit.Core.Logging.ILogger logger, string message, System.Exception ex) { }
        public static void LogInformation(this TUnit.Core.Logging.ILogger logger, string message) { }
        public static System.Threading.Tasks.ValueTask LogInformationAsync(this TUnit.Core.Logging.ILogger logger, string message) { }
        public static void LogTrace(this TUnit.Core.Logging.ILogger logger, string message) { }
        public static System.Threading.Tasks.ValueTask LogTraceAsync(this TUnit.Core.Logging.ILogger logger, string message) { }
        public static void LogWarning(this TUnit.Core.Logging.ILogger logger, string message) { }
        public static System.Threading.Tasks.ValueTask LogWarningAsync(this TUnit.Core.Logging.ILogger logger, string message) { }
    }
    public abstract class TUnitLogger : TUnit.Core.Logging.ILogger
    {
        protected TUnitLogger() { }
        public virtual bool IsEnabled(TUnit.Core.Logging.LogLevel logLevel) { }
        public abstract void Log<TState>(TUnit.Core.Logging.LogLevel logLevel, TState state, System.Exception? exception, System.Func<TState, System.Exception?, string> formatter);
        public abstract System.Threading.Tasks.ValueTask LogAsync<TState>(TUnit.Core.Logging.LogLevel logLevel, TState state, System.Exception? exception, System.Func<TState, System.Exception?, string> formatter);
    }
}