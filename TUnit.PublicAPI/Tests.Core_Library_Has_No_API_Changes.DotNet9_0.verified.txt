[assembly: .(@", PublicKey=0024000004800000940000000602000000240000525341310004000001000100698a70398fa0b2230c5a72e3bd9d56b48f809f6173e49a19fbb942d621be93ad48c5566b47b28faabc359b9ad3ff4e00bbdea88f5bdfa250f391fedd28182b2e37b55d429c0151a42a98ea7a5821818cd15a79fef9903e8607a88304cf3e0317bf86ec96e32e1381535a6582251e5a6eed40b5a3ed82bc444598b1269cce57a7")]
[assembly: .(@", PublicKey=0024000004800000940000000602000000240000525341310004000001000100698a70398fa0b2230c5a72e3bd9d56b48f809f6173e49a19fbb942d621be93ad48c5566b47b28faabc359b9ad3ff4e00bbdea88f5bdfa250f391fedd28182b2e37b55d429c0151a42a98ea7a5821818cd15a79fef9903e8607a88304cf3e0317bf86ec96e32e1381535a6582251e5a6eed40b5a3ed82bc444598b1269cce57a7")]
[assembly: .(".NETCoreApp,Version=v9.0", FrameworkDisplayName=".NET 9.0")]
namespace 
{
    [(.Method)]
    public sealed class AfterAttribute : .HookAttribute
    {
        public AfterAttribute(.HookType hookType, [.] string file = "", [.] int line = 0) { }
    }
    [(.Method)]
    public sealed class AfterEveryAttribute : .HookAttribute
    {
        public AfterEveryAttribute(.HookType hookType, [.] string file = "", [.] int line = 0) { }
    }
    public class AfterTestContext
    {
        public .TestContext TestContext { get; }
        public .TestDetails TestDetails { get; }
        public void OverrideResult( exception, string reason) { }
        public void OverrideResult(. status, string reason) { }
        public static .TestContext op_Implicit(.AfterTestContext afterTestContext) { }
    }
    public abstract class ArgumentDisplayFormatter
    {
        protected ArgumentDisplayFormatter() { }
        public abstract bool CanHandle(object? value);
        public abstract string FormatValue(object? value);
    }
    public abstract class ArgumentDisplayFormatterAttribute : .TUnitAttribute, ., .
    {
        protected ArgumentDisplayFormatterAttribute() { }
        public abstract .ArgumentDisplayFormatter Formatter { get; }
        public virtual int Order { get; }
        public void OnTestDiscovery(.DiscoveredTestContext discoveredTestContext) { }
    }
    [(.Assembly | .Class | .Method, AllowMultiple=true)]
    public class ArgumentDisplayFormatterAttribute<T> : .ArgumentDisplayFormatterAttribute
        where T : .ArgumentDisplayFormatter, new ()
    {
        public ArgumentDisplayFormatterAttribute() { }
        public override .ArgumentDisplayFormatter Formatter { get; }
    }
    [(.Class | .Method | .Property, AllowMultiple=true)]
    public sealed class ArgumentsAttribute : .TestDataAttribute
    {
        public ArgumentsAttribute() { }
        public ArgumentsAttribute(params object?[]? values) { }
        public object?[] Values { get; }
    }
    public class ArgumentsDataProvider : .IDataProvider
    {
        public ArgumentsDataProvider(params object?[] arguments) { }
        public .<.<object?[]>> GetData() { }
    }
    public class Artifact
    {
        public Artifact() { }
        public string? Description { get; init; }
        public required string DisplayName { get; init; }
        public required .FileInfo File { get; init; }
    }
    public class AssemblyHookContext : .Context
    {
        public .<.TestContext> AllTests { get; }
        public required .Assembly Assembly { get; init; }
        public .<.ClassHookContext> TestClasses { get; }
        public int TestCount { get; }
        public .TestSessionContext TestSessionContext { get; }
        public new static .AssemblyHookContext? Current { get; }
        public void AddClass(.ClassHookContext classHookContext) { }
    }
    [.DebuggerDisplay("{Name})")]
    public class AssemblyMetadata : <.AssemblyMetadata>
    {
        public AssemblyMetadata() { }
        public required .AttributeMetadata[] Attributes { get; init; }
        public required string Name { get; init; }
        public virtual bool Equals(.AssemblyMetadata? other) { }
        public override int GetHashCode() { }
        public static .AssemblyMetadata GetOrAdd(string name, <.AssemblyMetadata> factory) { }
    }
    public static class AsyncConvert
    {
        public static . Convert( action) { }
        public static . Convert(<.> action) { }
        public static . Convert(<.> action) { }
        public static . ConvertObject(object? invoke) { }
        [.("Trimming", "IL2075:\'this\' argument does not satisfy \'DynamicallyAccessedMembersAttribute\' in " +
            "call to target method. The return value of the source method does not have match" +
            "ing annotations.")]
        public static bool TryGetAwaitableTask(object awaitable, [.(true)] out .? task) { }
    }
    public class AsyncDataGeneratorProvider : .IDataProvider
    {
        public AsyncDataGeneratorProvider(.IAsyncDataSourceGeneratorAttribute generator, .DataGeneratorMetadata metadata) { }
        public .<.<object?[]>> GetData() { }
    }
    [(.Class | .Method | .Property, AllowMultiple=true)]
    public abstract class AsyncDataSourceGeneratorAttribute<T> : .TestDataAttribute, .IAsyncDataSourceGeneratorAttribute, .IDataAttribute, .IRequiresImmediateInitialization
    {
        protected AsyncDataSourceGeneratorAttribute() { }
        [.(typeof(.AsyncDataSourceGeneratorAttribute<T>.<GenerateAsync>d__1))]
        public .<<.<T>>> GenerateAsync(.DataGeneratorMetadata dataGeneratorMetadata) { }
        protected abstract .<<.<T>>> GenerateDataSourcesAsync(.DataGeneratorMetadata dataGeneratorMetadata);
    }
    [(.Class | .Method, AllowMultiple=true)]
    public abstract class AsyncDataSourceGeneratorAttribute<T1, T2> : .TestDataAttribute, .IAsyncDataSourceGeneratorAttribute, .IDataAttribute, .IRequiresImmediateInitialization
    {
        protected AsyncDataSourceGeneratorAttribute() { }
        [.(typeof(.AsyncDataSourceGeneratorAttribute<T1, T2>.<GenerateAsync>d__1))]
        public .<<.<<T1, T2>>>> GenerateAsync(.DataGeneratorMetadata dataGeneratorMetadata) { }
        protected abstract .<<.<<T1, T2>>>> GenerateDataSourcesAsync(.DataGeneratorMetadata dataGeneratorMetadata);
    }
    [(.Class | .Method, AllowMultiple=true)]
    public abstract class AsyncDataSourceGeneratorAttribute<T1, T2, T3> : .TestDataAttribute, .IAsyncDataSourceGeneratorAttribute, .IDataAttribute, .IRequiresImmediateInitialization
    {
        protected AsyncDataSourceGeneratorAttribute() { }
        [.(typeof(.AsyncDataSourceGeneratorAttribute<T1, T2, T3>.<GenerateAsync>d__1))]
        public .<<.<<T1, T2, T3>>>> GenerateAsync(.DataGeneratorMetadata dataGeneratorMetadata) { }
        protected abstract .<<.<<T1, T2, T3>>>> GenerateDataSourcesAsync(.DataGeneratorMetadata dataGeneratorMetadata);
    }
    [(.Class | .Method, AllowMultiple=true)]
    public abstract class AsyncDataSourceGeneratorAttribute<T1, T2, T3, T4> : .TestDataAttribute, .IAsyncDataSourceGeneratorAttribute, .IDataAttribute, .IRequiresImmediateInitialization
    {
        protected AsyncDataSourceGeneratorAttribute() { }
        [.(typeof(.AsyncDataSourceGeneratorAttribute<T1, T2, T3, T4>.<GenerateAsync>d__1))]
        public .<<.<<T1, T2, T3, T4>>>> GenerateAsync(.DataGeneratorMetadata dataGeneratorMetadata) { }
        protected abstract .<<.<<T1, T2, T3, T4>>>> GenerateDataSourcesAsync(.DataGeneratorMetadata dataGeneratorMetadata);
    }
    [(.Class | .Method, AllowMultiple=true)]
    public abstract class AsyncDataSourceGeneratorAttribute<T1, T2, T3, T4, T5> : .TestDataAttribute, .IAsyncDataSourceGeneratorAttribute, .IDataAttribute, .IRequiresImmediateInitialization
    {
        protected AsyncDataSourceGeneratorAttribute() { }
        [.(typeof(.AsyncDataSourceGeneratorAttribute<T1, T2, T3, T4, T5>.<GenerateAsync>d__1))]
        public .<<.<<T1, T2, T3, T4, T5>>>> GenerateAsync(.DataGeneratorMetadata dataGeneratorMetadata) { }
        protected abstract .<<.<<T1, T2, T3, T4, T5>>>> GenerateDataSourcesAsync(.DataGeneratorMetadata dataGeneratorMetadata);
    }
    public class AsyncEvent<TEventArgs>
    {
        public AsyncEvent() { }
        public int Order { get; set; }
        public static .AsyncEvent<TEventArgs> operator +(.AsyncEvent<TEventArgs>? e, <object, TEventArgs, .> callback) { }
        public class Invocation : .
        {
            public Invocation(<object, TEventArgs, .> factory, int order) { }
            public int Order { get; }
            public . InvokeAsync(object sender, TEventArgs eventArgs) { }
        }
    }
    [(.Class | .Method | .Property, AllowMultiple=true)]
    public abstract class AsyncUntypedDataSourceGeneratorAttribute : .TestDataAttribute, .IAsyncDataSourceGeneratorAttribute, .IDataAttribute, .IRequiresImmediateInitialization
    {
        protected AsyncUntypedDataSourceGeneratorAttribute() { }
        [.(typeof(.AsyncUntypedDataSourceGeneratorAttribute.<GenerateAsync>d__1))]
        public .<<.<object?[]?>>> GenerateAsync(.DataGeneratorMetadata dataGeneratorMetadata) { }
        protected abstract .<<.<object?[]?>>> GenerateDataSourcesAsync(.DataGeneratorMetadata dataGeneratorMetadata);
    }
    [.DebuggerDisplay("{} on {TargetElement}")]
    public class AttributeMetadata : <.AttributeMetadata>
    {
        public AttributeMetadata() { }
        public bool AllowMultiple { get; }
        public  AttributeType { get; }
        public .ClassMetadata? ClassMetadata { get; init; }
        public object?[]? ConstructorArguments { get; init; }
        public bool Inherited { get; }
        public required  Instance { get; init; }
        public .<string, object?>? NamedArguments { get; init; }
        public required .TestAttributeTarget TargetElement { get; init; }
        public string? TargetMemberName { get; init; }
        public ? TargetType { get; init; }
        public  ValidTargets { get; }
        public virtual bool Equals(.AttributeMetadata? other) { }
        public override int GetHashCode() { }
    }
    public abstract class BaseClassConstructorAttribute : .TUnitAttribute, .IDataAttribute
    {
        [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods | ..PublicProperties)]
        public abstract  ClassConstructorType { get; init; }
    }
    [(.Method)]
    public abstract class BaseTestAttribute : .TUnitAttribute
    {
        public readonly string File;
        public readonly int Line;
    }
    [(.Method)]
    public sealed class BeforeAttribute : .HookAttribute
    {
        public BeforeAttribute(.HookType hookType, [.] string file = "", [.] int line = 0) { }
    }
    [(.Method)]
    public sealed class BeforeEveryAttribute : .HookAttribute
    {
        public BeforeEveryAttribute(.HookType hookType, [.] string file = "", [.] int line = 0) { }
    }
    public class BeforeTestContext
    {
        public .TestContext TestContext { get; }
        public .TestDetails TestDetails { get; }
        public void AddAsyncLocalValues() { }
        public void AddLinkedCancellationToken(.CancellationToken cancellationToken) { }
        public void SetHookExecutor(. hookExecutor) { }
        public void SetTestExecutor(. testExecutor) { }
        public static .TestContext op_Implicit(.BeforeTestContext beforeTestContext) { }
    }
    public class BeforeTestDiscoveryContext : .Context
    {
        public .GlobalContext GlobalContext { get; }
        public required string? TestFilter { get; init; }
        public new static .BeforeTestDiscoveryContext? Current { get; }
    }
    [(.Assembly | .Class | .Method, AllowMultiple=true)]
    public class CategoryAttribute : .TUnitAttribute, ., .
    {
        public CategoryAttribute(string category) { }
        public string Category { get; }
        public int Order { get; }
        public void OnTestDiscovery(.DiscoveredTestContext discoveredTestContext) { }
    }
    [(.Assembly | .Class)]
    public class ClassConstructorAttribute : .BaseClassConstructorAttribute
    {
        public ClassConstructorAttribute([.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods | ..PublicProperties)]  classConstructorType) { }
        [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods | ..PublicProperties)]
        public override  ClassConstructorType { get; init; }
    }
    [(.Assembly | .Class)]
    public sealed class ClassConstructorAttribute<[.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods | ..PublicProperties)]  T> : .ClassConstructorAttribute
        where T : ., new ()
    {
        public ClassConstructorAttribute() { }
        [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods | ..PublicProperties)]
        public override  ClassConstructorType { get; init; }
    }
    public class ClassConstructorMetadata : <.ClassConstructorMetadata>
    {
        public ClassConstructorMetadata() { }
        public required .TestBuilderContext TestBuilderContext { get; init; }
        public required string TestSessionId { get; init; }
    }
    [(.Class | .Method | .Property, AllowMultiple=true)]
    public sealed class ClassDataSourceAttribute : .UntypedDataSourceGeneratorAttribute, .IDataAttribute, .ISharedDataSourceAttribute
    {
        [.("AOT", "IL3050:Calling members annotated with \'RequiresDynamicCodeAttribute\' may break fu" +
            "nctionality when AOT compiling.")]
        [.("Trimming", "IL2026:Members annotated with \'RequiresUnreferencedCodeAttribute\' require dynamic" +
            " access otherwise can break functionality when trimming application code", Justification="<Pending>")]
        public ClassDataSourceAttribute([.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicProperties)]  type) { }
        [.("Reflection")]
        [.("Reflection")]
        public ClassDataSourceAttribute(params [] types) { }
        [.("AOT", "IL3050:Calling members annotated with \'RequiresDynamicCodeAttribute\' may break fu" +
            "nctionality when AOT compiling.")]
        [.("Trimming", "IL2026:Members annotated with \'RequiresUnreferencedCodeAttribute\' require dynamic" +
            " access otherwise can break functionality when trimming application code", Justification="<Pending>")]
        public ClassDataSourceAttribute([.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicProperties)]  type, [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicProperties)]  type2) { }
        [.("AOT", "IL3050:Calling members annotated with \'RequiresDynamicCodeAttribute\' may break fu" +
            "nctionality when AOT compiling.")]
        [.("Trimming", "IL2026:Members annotated with \'RequiresUnreferencedCodeAttribute\' require dynamic" +
            " access otherwise can break functionality when trimming application code", Justification="<Pending>")]
        public ClassDataSourceAttribute([.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicProperties)]  type, [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicProperties)]  type2, [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicProperties)]  type3) { }
        [.("AOT", "IL3050:Calling members annotated with \'RequiresDynamicCodeAttribute\' may break fu" +
            "nctionality when AOT compiling.")]
        [.("Trimming", "IL2026:Members annotated with \'RequiresUnreferencedCodeAttribute\' require dynamic" +
            " access otherwise can break functionality when trimming application code", Justification="<Pending>")]
        public ClassDataSourceAttribute([.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicProperties)]  type, [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicProperties)]  type2, [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicProperties)]  type3, [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicProperties)]  type4) { }
        [.("AOT", "IL3050:Calling members annotated with \'RequiresDynamicCodeAttribute\' may break fu" +
            "nctionality when AOT compiling.")]
        [.("Trimming", "IL2026:Members annotated with \'RequiresUnreferencedCodeAttribute\' require dynamic" +
            " access otherwise can break functionality when trimming application code", Justification="<Pending>")]
        public ClassDataSourceAttribute([.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicProperties)]  type, [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicProperties)]  type2, [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicProperties)]  type3, [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicProperties)]  type4, [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicProperties)]  type5) { }
        public string[] Keys { get; set; }
        public .SharedType[] Shared { get; set; }
        [.("Trimming", "IL2062:The parameter of method has a DynamicallyAccessedMembersAttribute, but the" +
            " value passed to it can not be statically analyzed.")]
        protected override .<<object?[]?>> GenerateDataSources(.DataGeneratorMetadata dataGeneratorMetadata) { }
        public .<string> GetKeys() { }
        public .<.SharedType> GetSharedTypes() { }
    }
    [(.Class | .Method | .Property, AllowMultiple=true)]
    public sealed class ClassDataSourceAttribute<[.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicProperties)]  T> : .DataSourceGeneratorAttribute<T>, .IDataAttribute, .ISharedDataSourceAttribute
    {
        public ClassDataSourceAttribute() { }
        public  ClassType { get; }
        public string Key { get; set; }
        public .SharedType Shared { get; set; }
        protected override .<<T>> GenerateDataSources(.DataGeneratorMetadata dataGeneratorMetadata) { }
        public .<string> GetKeys() { }
        public .<.SharedType> GetSharedTypes() { }
    }
    [(.Class | .Method, AllowMultiple=true)]
    public sealed class ClassDataSourceAttribute<[.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicProperties)]  T1, [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicProperties)]  T2> : .DataSourceGeneratorAttribute<T1, T2>, .IDataAttribute, .ISharedDataSourceAttribute
        where T1 : new()
        where T2 : new()
    {
        public ClassDataSourceAttribute() { }
        public string[] Keys { get; set; }
        public .SharedType[] Shared { get; set; }
        protected override .<<<T1, T2>>> GenerateDataSources(.DataGeneratorMetadata dataGeneratorMetadata) { }
        public .<string> GetKeys() { }
        public .<.SharedType> GetSharedTypes() { }
    }
    [(.Class | .Method, AllowMultiple=true)]
    public sealed class ClassDataSourceAttribute<[.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicProperties)]  T1, [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicProperties)]  T2, [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicProperties)]  T3> : .DataSourceGeneratorAttribute<T1, T2, T3>, .IDataAttribute, .ISharedDataSourceAttribute
        where T1 : new()
        where T2 : new()
        where T3 : new()
    {
        public ClassDataSourceAttribute() { }
        public string[] Keys { get; set; }
        public .SharedType[] Shared { get; set; }
        protected override .<<<T1, T2, T3>>> GenerateDataSources(.DataGeneratorMetadata dataGeneratorMetadata) { }
        public .<string> GetKeys() { }
        public .<.SharedType> GetSharedTypes() { }
    }
    [(.Class | .Method, AllowMultiple=true)]
    public sealed class ClassDataSourceAttribute<[.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicProperties)]  T1, [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicProperties)]  T2, [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicProperties)]  T3, [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicProperties)]  T4> : .DataSourceGeneratorAttribute<T1, T2, T3, T4>, .IDataAttribute, .ISharedDataSourceAttribute
        where T1 : new()
        where T2 : new()
        where T3 : new()
        where T4 : new()
    {
        public ClassDataSourceAttribute() { }
        public string[] Keys { get; set; }
        public .SharedType[] Shared { get; set; }
        protected override .<<<T1, T2, T3, T4>>> GenerateDataSources(.DataGeneratorMetadata dataGeneratorMetadata) { }
        public .<string> GetKeys() { }
        public .<.SharedType> GetSharedTypes() { }
    }
    [(.Class | .Method, AllowMultiple=true)]
    public sealed class ClassDataSourceAttribute<[.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicProperties)]  T1, [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicProperties)]  T2, [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicProperties)]  T3, [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicProperties)]  T4, [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicProperties)]  T5> : .DataSourceGeneratorAttribute<T1, T2, T3, T4, T5>, .IDataAttribute, .ISharedDataSourceAttribute
        where T1 : new()
        where T2 : new()
        where T3 : new()
        where T4 : new()
        where T5 : new()
    {
        public ClassDataSourceAttribute() { }
        public string[] Keys { get; set; }
        public .SharedType[] Shared { get; set; }
        protected override .<<<T1, T2, T3, T4, T5>>> GenerateDataSources(.DataGeneratorMetadata dataGeneratorMetadata) { }
        public .<string> GetKeys() { }
        public .<.SharedType> GetSharedTypes() { }
    }
    public class ClassHookContext : .Context
    {
        public .AssemblyHookContext AssemblyContext { get; }
        public required  ClassType { get; init; }
        public int TestCount { get; }
        public .<.TestContext> Tests { get; }
        public new static .ClassHookContext? Current { get; }
        public void AddTest(.TestContext testContext) { }
        public override bool Equals(object? obj) { }
        public override int GetHashCode() { }
    }
    [.DebuggerDisplay("{Type}")]
    public class ClassMetadata : .MemberMetadata, <.ClassMetadata>
    {
        public ClassMetadata() { }
        public required .AssemblyMetadata Assembly { get; init; }
        public required string? Namespace { get; init; }
        public required .ParameterMetadata[] Parameters { get; init; }
        public required .ClassMetadata? Parent { get; init; }
        public required .PropertyMetadata[] Properties { get; init; }
        [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..NonPublicConstructors | ..PublicMethods | ..NonPublicMethods | ..PublicProperties)]
        public override required  Type { get; init; }
        public required .TypeReference TypeReference { get; init; }
        public virtual bool Equals(.ClassMetadata? other) { }
        public override int GetHashCode() { }
        public static .ClassMetadata GetOrAdd(string name, <.ClassMetadata> factory) { }
    }
    public class CompileTimeDataGeneratorMetadata : .DataGeneratorMetadata, <.CompileTimeDataGeneratorMetadata>
    {
        public CompileTimeDataGeneratorMetadata() { }
    }
    public abstract class Context : , .
    {
        public .TextWriter ErrorOutputWriter { get; }
        public .TextWriter OutputWriter { get; }
        protected .Context? Parent { get; }
        public static .Context Current { get; }
        public void AddAsyncLocalValues() { }
        public void Dispose() { }
        public . GetDefaultLogger() { }
        public string GetErrorOutput() { }
        public string GetStandardOutput() { }
        public void RestoreExecutionContext() { }
    }
    public class CultureExecutor : .DedicatedThreadExecutor
    {
        public CultureExecutor(.CultureInfo cultureInfo) { }
        protected override void ConfigureThread(.Thread thread) { }
    }
    public class DataGeneratorMetadata : <.DataGeneratorMetadata>
    {
        public DataGeneratorMetadata() { }
        public required object?[]? ClassInstanceArguments { get; init; }
        public required .MemberMetadata[] MembersToGenerate { get; init; }
        public required .TestBuilderContextAccessor TestBuilderContext { get; init; }
        public required object? TestClassInstance { get; init; }
        public  TestClassType { get; }
        public required .MethodMetadata TestInformation { get; init; }
        public required string TestSessionId { get; init; }
        public required . Type { get; init; }
    }
    public class DataSourceException : .TestBuilderException
    {
        public DataSourceException(string dataSourceName,  innerException) { }
        public DataSourceException(string dataSourceName, string message) { }
        public string DataSourceName { get; }
    }
    [(.Class | .Method | .Property, AllowMultiple=true)]
    public abstract class DataSourceGeneratorAttribute<T> : .AsyncDataSourceGeneratorAttribute<T>
    {
        protected DataSourceGeneratorAttribute() { }
        protected abstract .<<T>> GenerateDataSources(.DataGeneratorMetadata dataGeneratorMetadata);
        [.(typeof(.DataSourceGeneratorAttribute<T>.<GenerateDataSourcesAsync>d__1))]
        protected override .<<.<T>>> GenerateDataSourcesAsync(.DataGeneratorMetadata dataGeneratorMetadata) { }
    }
    [(.Class | .Method, AllowMultiple=true)]
    public abstract class DataSourceGeneratorAttribute<T1, T2> : .AsyncDataSourceGeneratorAttribute<T1, T2>
    {
        protected DataSourceGeneratorAttribute() { }
        protected abstract .<<<T1, T2>>> GenerateDataSources(.DataGeneratorMetadata dataGeneratorMetadata);
        [.(typeof(.DataSourceGeneratorAttribute<T1, T2>.<GenerateDataSourcesAsync>d__1))]
        protected override .<<.<<T1, T2>>>> GenerateDataSourcesAsync(.DataGeneratorMetadata dataGeneratorMetadata) { }
    }
    [(.Class | .Method, AllowMultiple=true)]
    public abstract class DataSourceGeneratorAttribute<T1, T2, T3> : .AsyncDataSourceGeneratorAttribute<T1, T2, T3>
    {
        protected DataSourceGeneratorAttribute() { }
        protected abstract .<<<T1, T2, T3>>> GenerateDataSources(.DataGeneratorMetadata dataGeneratorMetadata);
        [.(typeof(.DataSourceGeneratorAttribute<T1, T2, T3>.<GenerateDataSourcesAsync>d__1))]
        protected override sealed .<<.<<T1, T2, T3>>>> GenerateDataSourcesAsync(.DataGeneratorMetadata dataGeneratorMetadata) { }
    }
    [(.Class | .Method, AllowMultiple=true)]
    public abstract class DataSourceGeneratorAttribute<T1, T2, T3, T4> : .AsyncDataSourceGeneratorAttribute<T1, T2, T3, T4>
    {
        protected DataSourceGeneratorAttribute() { }
        protected abstract .<<<T1, T2, T3, T4>>> GenerateDataSources(.DataGeneratorMetadata dataGeneratorMetadata);
        [.(typeof(.DataSourceGeneratorAttribute<T1, T2, T3, T4>.<GenerateDataSourcesAsync>d__1))]
        protected override .<<.<<T1, T2, T3, T4>>>> GenerateDataSourcesAsync(.DataGeneratorMetadata dataGeneratorMetadata) { }
    }
    [(.Class | .Method, AllowMultiple=true)]
    public abstract class DataSourceGeneratorAttribute<T1, T2, T3, T4, T5> : .AsyncDataSourceGeneratorAttribute<T1, T2, T3, T4, T5>
    {
        protected DataSourceGeneratorAttribute() { }
        protected abstract .<<<T1, T2, T3, T4, T5>>> GenerateDataSources(.DataGeneratorMetadata dataGeneratorMetadata);
        [.(typeof(.DataSourceGeneratorAttribute<T1, T2, T3, T4, T5>.<GenerateDataSourcesAsync>d__1))]
        protected override .<<.<<T1, T2, T3, T4, T5>>>> GenerateDataSourcesAsync(.DataGeneratorMetadata dataGeneratorMetadata) { }
    }
    public class DedicatedThreadExecutor : .GenericAbstractExecutor, ., .
    {
        public DedicatedThreadExecutor() { }
        protected virtual void CleanUp() { }
        protected virtual void ConfigureThread(.Thread thread) { }
        protected override sealed . ExecuteAsync(<.> action) { }
        protected virtual void Initialize() { }
        public . OnTestRegistered(.TestRegisteredContext context) { }
    }
    public class DefaultExecutor : .GenericAbstractExecutor
    {
        public static readonly .DefaultExecutor Instance;
        protected override . ExecuteAsync(<.> action) { }
    }
    public abstract class DependencyInjectionDataSourceAttribute<TScope> : .UntypedDataSourceGeneratorAttribute
    {
        protected DependencyInjectionDataSourceAttribute() { }
        public abstract object? Create(TScope scope,  type);
        public abstract TScope CreateScope(.DataGeneratorMetadata dataGeneratorMetadata);
        protected override .<<object?[]?>> GenerateDataSources(.DataGeneratorMetadata dataGeneratorMetadata) { }
    }
    [(.Class | .Method, AllowMultiple=true)]
    public class DependsOnAttribute : .TUnitAttribute
    {
        public DependsOnAttribute( testClass) { }
        public DependsOnAttribute(string testName) { }
        public DependsOnAttribute( testClass, string testName) { }
        public DependsOnAttribute(string testName, [] parameterTypes) { }
        public DependsOnAttribute( testClass, string testName, [] parameterTypes) { }
        public ? ClassMetadata { get; }
        public []? ParameterTypes { get; }
        public bool ProceedOnFailure { get; set; }
        public string? TestName { get; }
        public override string ToString() { }
    }
    [(.Class | .Method, AllowMultiple=true)]
    public class DependsOnAttribute<T> : .DependsOnAttribute
    {
        public DependsOnAttribute() { }
        public DependsOnAttribute(string testName) { }
        public DependsOnAttribute(string testName, [] parameterTypes) { }
    }
    public class DiscoveredTestContext
    {
        public bool RunOnTestDiscovery { get; set; }
        public .TestContext TestContext { get; }
        public .TestDetails TestDetails { get; }
        public void AddArgumentDisplayFormatter(.ArgumentDisplayFormatter formatter) { }
        public void AddCategory(string category) { }
        public void AddProperty(string key, string value) { }
        public void SetDisplayName(string displayName) { }
        public void SetParallelConstraint(. parallelConstraint) { }
        public void SetRetryCount(int times) { }
        public void SetRetryCount(int times, <.TestContext, , int, .<bool>> shouldRetry) { }
    }
    public sealed class DiscoveryFailure : <.DiscoveryFailure>
    {
        public DiscoveryFailure() { }
        public required  Exception { get; init; }
        public string Reason { get; }
        public string? TestClassName { get; init; }
        public required string TestFilePath { get; init; }
        public required string TestId { get; init; }
        public required int TestLineNumber { get; init; }
        public required string TestMethodName { get; init; }
    }
    public sealed class DiscoveryResult : <.DiscoveryResult>
    {
        public DiscoveryResult() { }
        public required .<.DiscoveryFailure> DiscoveryFailures { get; init; }
        public bool HasFailures { get; }
        public required .<.ITestDefinition> TestDefinitions { get; init; }
        public int TotalCount { get; }
    }
    [(.Method, Inherited=false)]
    public sealed class DisplayNameAttribute : .DisplayNameFormatterAttribute
    {
        public DisplayNameAttribute(string displayName) { }
        protected override string FormatDisplayName(.TestContext testContext) { }
    }
    [(.Assembly | .Class | .Method, Inherited=false)]
    public abstract class DisplayNameFormatterAttribute : .TUnitAttribute, ., .
    {
        protected DisplayNameFormatterAttribute() { }
        public int Order { get; }
        protected abstract string FormatDisplayName(.TestContext testContext);
        public void OnTestDiscovery(.DiscoveredTestContext discoveredTestContext) { }
    }
    [.("Reflection")]
    [.("Reflection")]
    public abstract class DynamicTest : <.DynamicTest>
    {
        protected DynamicTest() { }
        public [] Attributes { get; init; }
        public .<string, object?>? Properties { get; init; }
        public object?[]? TestClassArguments { get; init; }
        [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods | ..PublicProperties)]
        public abstract  TestClassType { get; }
        public abstract string TestId { get; }
        public required object?[] TestMethodArguments { get; init; }
        public string? TestName { get; init; }
        protected .MethodMetadata BuildTestMethod(.MethodInfo methodInfo) { }
        public abstract .DiscoveryResult BuildTests();
        protected .AssemblyMetadata GenerateAssembly() { }
        protected .ClassMetadata GenerateClass() { }
        protected .ParameterMetadata GenerateParameter(.ParameterInfo parameter) { }
        public [] GetAttributes() { }
        protected .ParameterMetadata[] GetParameters(.ParameterInfo[] parameters) { }
        public static T Argument<T>() { }
        protected static .PropertyMetadata GenerateProperty(.<string, object?> property) { }
    }
    [.("DynamicTestBuilder uses dynamic code generation for performance optimization and " +
        "generic type support")]
    [.("DynamicTestBuilder may use types that aren\'t statically referenced when resolving" +
        " generic types")]
    public class DynamicTestBuilder : .ITestDefinitionBuilder
    {
        public DynamicTestBuilder() { }
        public .<.<.TestDefinition>> BuildTestDefinitionsAsync(.ITestDescriptor testDescriptor, .CancellationToken cancellationToken = default) { }
    }
    [.("TUnitWIP0001")]
    public class DynamicTestBuilderAttribute : .BaseTestAttribute
    {
        public DynamicTestBuilderAttribute([.] string file = "", [.] int line = 0) { }
    }
    public class DynamicTestBuilderContext
    {
        public DynamicTestBuilderContext(.TestContext testContext) { }
        public DynamicTestBuilderContext(string filePath, int lineNumber) { }
        public .<.DynamicTest> Tests { get; }
        public void AddTest<[.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods | ..PublicProperties)]  TClass>(.DynamicTest<TClass> dynamicTest)
            where TClass :  class { }
        public . AddTestAtRuntime<[.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods | ..PublicProperties)]  TClass>(.TestContext testContext, .DynamicTest<TClass> dynamicTest)
            where TClass :  class { }
    }
    [.("DynamicTestMetadata uses runtime type resolution and reflection")]
    [.("DynamicTestMetadata may require types that aren\'t statically referenced")]
    public class DynamicTestMetadata : <.DynamicTestMetadata>, .ITestDescriptor
    {
        public DynamicTestMetadata() { }
        public required .<.IDataSourceProvider> ClassDataSources { get; init; }
        public string DisplayName { get; }
        public required string DisplayNameTemplate { get; init; }
        public required bool IsAsync { get; init; }
        public required bool IsSkipped { get; init; }
        public required .<.IDataSourceProvider> MethodDataSources { get; init; }
        public required .MethodMetadata MethodMetadata { get; init; }
        public required .<.PropertyInfo, .IDataSourceProvider> PropertyDataSources { get; init; }
        public required int RepeatCount { get; init; }
        public string? SkipReason { get; init; }
        public required <object?[]?, object?> TestClassFactory { get; init; }
        [.(..PublicConstructors)]
        public ? TestClassType { get; init; }
        public required .TypeReference TestClassTypeReference { get; init; }
        public required string TestFilePath { get; init; }
        public string TestId { get; }
        public required string TestIdTemplate { get; init; }
        public required int TestLineNumber { get; init; }
        public ? Timeout { get; init; }
    }
    [.("Reflection")]
    [.("Reflection")]
    public class DynamicTest<[.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods | ..PublicProperties)]  TClass> : .DynamicTest, <.DynamicTest<TClass>>
        where TClass :  class
    {
        public DynamicTest() { }
        [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods | ..PublicProperties)]
        public override  TestClassType { get; }
        public override string TestId { get; }
        public required .<<TClass>> TestMethod { get; init; }
        public override .DiscoveryResult BuildTests() { }
        public class MethodBody : <.DynamicTest<TClass>.MethodBody>
        {
            public MethodBody() { }
            public <TClass>? SynchronousBody { get; init; }
            public <TClass, .>? TaskBody { get; init; }
            public static .DynamicTest<TClass>.MethodBody op_Implicit(<TClass> action) { }
            public static .DynamicTest<TClass>.MethodBody op_Implicit(<TClass, .> taskBody) { }
        }
    }
    public class EmptyDataProvider : .IDataProvider
    {
        public EmptyDataProvider() { }
        public .<.<object?[]>> GetData() { }
    }
    public class EngineCancellationToken : 
    {
        public EngineCancellationToken() { }
        public .CancellationToken Token { get; }
        public void Dispose() { }
    }
    public sealed class ExcludeOnAttribute : .SkipAttribute
    {
        public ExcludeOnAttribute(. OperatingSystem) { }
        public override .<bool> ShouldSkip(.BeforeTestContext context) { }
    }
    [(.Class | .Method)]
    public sealed class ExplicitAttribute : .TUnitAttribute
    {
        public ExplicitAttribute([.] string callerFile = "", [.] string callerMemberName = "") { }
        public string For { get; }
    }
    [.("Reflection")]
    [.("Reflection")]
    public class FailedDynamicTest<[.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods | ..PublicProperties)]  TClassType> : <.FailedDynamicTest<TClassType>>
        where TClassType :  class
    {
        public FailedDynamicTest() { }
        public required  Exception { get; init; }
        public required string MethodName { get; init; }
        public required string TestFilePath { get; init; }
        public required string TestId { get; init; }
        public required int TestLineNumber { get; init; }
        public static .DynamicTest<TClassType> op_Implicit(.FailedDynamicTest<TClassType> failedTestMetadata) { }
    }
    public abstract class GenericAbstractExecutor : ., .
    {
        protected GenericAbstractExecutor() { }
        public int Order { get; }
        public . ExecuteAfterAssemblyHook(.MethodMetadata hookMethodInfo, .AssemblyHookContext context, <.> action) { }
        public . ExecuteAfterClassHook(.MethodMetadata hookMethodInfo, .ClassHookContext context, <.> action) { }
        public . ExecuteAfterTestDiscoveryHook(.MethodMetadata hookMethodInfo, .TestDiscoveryContext context, <.> action) { }
        public . ExecuteAfterTestHook(.MethodMetadata hookMethodInfo, .TestContext context, <.> action) { }
        public . ExecuteAfterTestSessionHook(.MethodMetadata hookMethodInfo, .TestSessionContext context, <.> action) { }
        protected abstract . ExecuteAsync(<.> action);
        public . ExecuteBeforeAssemblyHook(.MethodMetadata hookMethodInfo, .AssemblyHookContext context, <.> action) { }
        public . ExecuteBeforeClassHook(.MethodMetadata hookMethodInfo, .ClassHookContext context, <.> action) { }
        public . ExecuteBeforeTestDiscoveryHook(.MethodMetadata hookMethodInfo, .BeforeTestDiscoveryContext context, <.> action) { }
        public . ExecuteBeforeTestHook(.MethodMetadata hookMethodInfo, .TestContext context, <.> action) { }
        public . ExecuteBeforeTestSessionHook(.MethodMetadata hookMethodInfo, .TestSessionContext context, <.> action) { }
        public . ExecuteTest(.TestContext context, <.> action) { }
    }
    public class GlobalContext : .Context
    {
        public .TextWriter OriginalConsoleError { get; set; }
        public .TextWriter OriginalConsoleOut { get; set; }
        public string? TestFilter { get; }
        public new static .GlobalContext Current { get; }
    }
    public class GlobalSharedDataKey : .SharedDataKey, <.GlobalSharedDataKey>
    {
        public static readonly  RandomKey;
        public GlobalSharedDataKey( Type) { }
    }
    public class HookAttribute : .TUnitAttribute
    {
        public string File { get; }
        public .HookType HookType { get; }
        public int Line { get; }
        public int Order { get; init; }
    }
    public enum HookType
    {
        Test = 0,
        Class = 1,
        Assembly = 2,
        TestSession = 3,
        TestDiscovery = 4,
    }
    public interface IAccessesInstanceData { }
    public interface IAsyncDataSourceGeneratorAttribute : .IDataAttribute, .IRequiresImmediateInitialization
    {
        .<<.<object?[]?>>> GenerateAsync(.DataGeneratorMetadata dataGeneratorMetadata);
    }
    public interface IDataAttribute { }
    public interface IDataProvider
    {
        .<.<object?[]>> GetData();
    }
    public interface IDataSourceProvider
    {
        bool IsAsync { get; }
        bool IsShared { get; }
        .<object?[]> GetData();
        .<object?[]> GetDataAsync();
    }
    public interface IDynamicTestRegistrar
    {
        . Register<[.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods | ..PublicProperties)]  TClass>(.DynamicTest<TClass> dynamicTest)
            where TClass :  class;
    }
    public interface IRequiresImmediateInitialization { }
    public interface ISharedDataSourceAttribute : .IDataAttribute
    {
        .<string> GetKeys();
        .<.SharedType> GetSharedTypes();
    }
    public interface ITestDefinition
    {
        .IDataProvider ClassDataProvider { get; }
        .IDataProvider MethodDataProvider { get; }
        .MethodMetadata MethodMetadata { get; }
        string TestFilePath { get; }
        string TestId { get; }
        int TestLineNumber { get; }
    }
    public interface ITestDefinitionBuilder
    {
        .<.<.TestDefinition>> BuildTestDefinitionsAsync(.ITestDescriptor testDescriptor, .CancellationToken cancellationToken = default);
    }
    public interface ITestDescriptor
    {
        string DisplayName { get; }
        bool IsAsync { get; }
        bool IsSkipped { get; }
        int RepeatCount { get; }
        string? SkipReason { get; }
        string TestFilePath { get; }
        string TestId { get; }
        int TestLineNumber { get; }
        ? Timeout { get; }
    }
    [(.Class)]
    public sealed class InheritsTestsAttribute : .TUnitAttribute
    {
        public InheritsTestsAttribute() { }
    }
    [(.Method, AllowMultiple=true)]
    public class InstanceMethodDataSourceAttribute : .MethodDataSourceAttribute, .IAccessesInstanceData
    {
        public InstanceMethodDataSourceAttribute(string methodNameProvidingDataSource) { }
        public InstanceMethodDataSourceAttribute([.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods | ..PublicProperties)]  classProvidingDataSource, string methodNameProvidingDataSource) { }
    }
    [(.Method, AllowMultiple=true)]
    public class InstanceMethodDataSourceAttribute<[.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods | ..PublicProperties)]  T> : .MethodDataSourceAttribute<T>, .IAccessesInstanceData
    {
        public InstanceMethodDataSourceAttribute(string methodNameProvidingDataSource) { }
    }
    public class InvalidTestMetadataException : .TestBuilderException
    {
        public InvalidTestMetadataException(string message, .DynamicTestMetadata metadata) { }
        public InvalidTestMetadataException(string message, .DynamicTestMetadata metadata,  innerException) { }
    }
    [(.Parameter)]
    public class MatrixAttribute : .TestDataAttribute
    {
        protected MatrixAttribute() { }
        public MatrixAttribute(params object?[]? objects) { }
        public object?[]? Excluding { get; init; }
        public virtual object?[] GetObjects(object? instance) { }
    }
    [(.Parameter)]
    public class MatrixAttribute<T> : .MatrixAttribute
    {
        public MatrixAttribute(params T?[]? objects) { }
    }
    [(.Class | .Method)]
    public sealed class MatrixDataSourceAttribute : .UntypedDataSourceGeneratorAttribute
    {
        public MatrixDataSourceAttribute() { }
        protected override .<<object?[]?>> GenerateDataSources(.DataGeneratorMetadata dataGeneratorMetadata) { }
    }
    [(.Class | .Method, AllowMultiple=true)]
    public class MatrixExclusionAttribute : .TUnitAttribute
    {
        public MatrixExclusionAttribute(params object?[]? objects) { }
        public object?[] Objects { get; }
    }
    [(.Parameter)]
    public class MatrixInstanceMethodAttribute<[.(..None | ..PublicMethods | ..NonPublicMethods | ..PublicProperties)]  TClass> : .MatrixMethodAttribute<TClass>, .IAccessesInstanceData
        where TClass :  class
    {
        public MatrixInstanceMethodAttribute(string methodName) { }
    }
    [(.Parameter)]
    public class MatrixMethodAttribute<[.(..None | ..PublicMethods | ..NonPublicMethods)]  TClass> : .MatrixAttribute
        where TClass :  class
    {
        public MatrixMethodAttribute(string methodName) { }
        public override object?[] GetObjects(object? instance) { }
    }
    [(.Parameter)]
    public class MatrixRangeAttribute<T> : .MatrixAttribute<T>
        where T : .INumber<T>
    {
        public MatrixRangeAttribute(T min, T max) { }
        public MatrixRangeAttribute(T min, T max, T step) { }
    }
    public abstract class MemberMetadata : <.MemberMetadata>
    {
        protected MemberMetadata() { }
        public required .AttributeMetadata[] Attributes { get; init; }
        public required string Name { get; init; }
        [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..NonPublicConstructors | ..PublicMethods | ..NonPublicMethods | ..PublicProperties)]
        public abstract  Type { get; init; }
        public virtual bool Equals(.MemberMetadata? other) { }
        public override int GetHashCode() { }
        protected virtual bool PrintMembers(.StringBuilder stringBuilder) { }
    }
    public class MethodDataProvider : .IDataProvider
    {
        public MethodDataProvider(<.<object?>> valuesProvider) { }
        public MethodDataProvider(<.<.<object?>>> valuesProvider) { }
        public MethodDataProvider(<.<object?>> valueProvider) { }
        public MethodDataProvider(<object?> valueProvider) { }
        public .<.<object?[]>> GetData() { }
    }
    [(.Class | .Method | .Property, AllowMultiple=true)]
    public class MethodDataSourceAttribute : .TestDataAttribute
    {
        public MethodDataSourceAttribute(string methodNameProvidingDataSource) { }
        public MethodDataSourceAttribute([.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods | ..PublicProperties)]  classProvidingDataSource, string methodNameProvidingDataSource) { }
        public object?[] Arguments { get; set; }
        [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods | ..PublicProperties)]
        public ? ClassProvidingDataSource { get; }
        public string MethodNameProvidingDataSource { get; }
    }
    [(.Class | .Method | .Property, AllowMultiple=true)]
    public class MethodDataSourceAttribute<[.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods | ..PublicProperties)]  T> : .MethodDataSourceAttribute
    {
        public MethodDataSourceAttribute(string methodNameProvidingDataSource) { }
    }
    [.DebuggerDisplay("{Type}.{Name}")]
    public class MethodMetadata : .MemberMetadata, <.MethodMetadata>
    {
        public MethodMetadata() { }
        public required .ClassMetadata Class { get; init; }
        public required int GenericTypeCount { get; init; }
        public required .ParameterMetadata[] Parameters { get; init; }
        [..JsonIgnore]
        public .MethodInfo ReflectionInformation { get; set; }
        public ? ReturnType { get; init; }
        public required .TypeReference ReturnTypeReference { get; init; }
        [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..NonPublicConstructors | ..PublicMethods | ..NonPublicMethods | ..PublicProperties)]
        public override required  Type { get; init; }
        public required .TypeReference TypeReference { get; init; }
        public virtual bool Equals(.MethodMetadata? other) { }
        public override int GetHashCode() { }
        protected override bool PrintMembers(.StringBuilder stringBuilder) { }
    }
    [(.Assembly | .Class | .Method)]
    public class NotInParallelAttribute : .SingleTUnitAttribute, ., .
    {
        public NotInParallelAttribute() { }
        public NotInParallelAttribute(string constraintKey) { }
        public NotInParallelAttribute(string[] constraintKeys) { }
        public string[] ConstraintKeys { get; }
        public int Order { get; init; }
        public void OnTestDiscovery(.DiscoveredTestContext discoveredTestContext) { }
    }
    public class NotInParallelConstraint : <.NotInParallelConstraint>, .
    {
        public NotInParallelConstraint(.<string> NotInParallelConstraintKeys) { }
        public .<string> NotInParallelConstraintKeys { get; init; }
        public int Order { get; set; }
    }
    public static class ObjectInitializer
    {
        public static . InitializeAsync(object? obj, .CancellationToken cancellationToken = default) { }
    }
    public class ParallelGroupAttribute : .TUnitAttribute, ., .
    {
        public ParallelGroupAttribute(string group) { }
        public string Group { get; }
        public int Order { get; set; }
        public void OnTestDiscovery(.DiscoveredTestContext discoveredTestContext) { }
    }
    public class ParallelGroupConstraint : , <.ParallelGroupConstraint>, <.ParallelGroupConstraint>, .
    {
        public ParallelGroupConstraint(string Group, int Order) { }
        public string Group { get; init; }
        public int Order { get; init; }
        public int CompareTo(.ParallelGroupConstraint? other) { }
        public int CompareTo(object? obj) { }
        public virtual bool Equals(.ParallelGroupConstraint? other) { }
        public override int GetHashCode() { }
    }
    public class ParallelLimitLockProvider
    {
        public ParallelLimitLockProvider() { }
    }
    [(.Assembly | .Class | .Method)]
    public sealed class ParallelLimiterAttribute<TParallelLimit> : .TUnitAttribute, ., .
        where TParallelLimit : ., new ()
    {
        public ParallelLimiterAttribute() { }
        public int Order { get; }
        public . OnTestRegistered(.TestRegisteredContext testRegisteredContext) { }
    }
    [.DebuggerDisplay("{Type} {Name})")]
    public class ParameterMetadata : .MemberMetadata, <.ParameterMetadata>
    {
        public ParameterMetadata([.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods | ..PublicProperties)]  Type) { }
        public object? DefaultValue { get; }
        public bool IsOptional { get; }
        public bool IsParams { get; }
        public required .ParameterInfo ReflectionInfo { get; set; }
        public override  Type { get; init; }
        public required .TypeReference TypeReference { get; init; }
    }
    [.DebuggerDisplay("{Type} {Name})")]
    public class ParameterMetadata<[.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods | ..PublicProperties)]  T> : .ParameterMetadata, <.ParameterMetadata<T>>
    {
        public ParameterMetadata() { }
    }
    [(.Assembly | .Class | .Method, AllowMultiple=true)]
    public class PropertyAttribute : .TUnitAttribute, ., .
    {
        public PropertyAttribute(string name, string value) { }
        public string Name { get; }
        public int Order { get; }
        public string Value { get; }
        public void OnTestDiscovery(.DiscoveredTestContext discoveredTestContext) { }
    }
    public class PropertyInjectionException : .TestBuilderException
    {
        public PropertyInjectionException(string propertyName,  propertyType,  innerException) { }
        public string PropertyName { get; }
        public  PropertyType { get; }
    }
    [.DebuggerDisplay("{Type} {Name})")]
    public class PropertyMetadata : .MemberMetadata, <.PropertyMetadata>
    {
        public PropertyMetadata() { }
        public .ClassMetadata? ClassMetadata { get; set; }
        public required <object?, object?> Getter { get; init; }
        public required bool IsStatic { get; init; }
        public string? Key { get; init; }
        public required .PropertyInfo ReflectionInfo { get; init; }
        public .SharedType Shared { get; init; }
        [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..NonPublicConstructors | ..PublicMethods | ..NonPublicMethods | ..PublicProperties)]
        public override required  Type { get; init; }
    }
    [(.Assembly | .Class | .Method)]
    public sealed class RepeatAttribute : .TUnitAttribute
    {
        public RepeatAttribute(int times) { }
        public int Times { get; }
    }
    public class ResettableLazy<[.(..PublicConstructors)]  T> : 
        where T :  class
    {
        protected readonly string SessionId;
        protected <T> _factory;
        public ResettableLazy(<T> factory, string sessionId, .TestBuilderContext testBuilderContext) { }
        protected ResettableLazy(. classConstructor, string sessionId, .TestBuilderContext testBuilderContext) { }
        public .? ClassConstructor { get; protected set; }
        public .TestBuilderContext TestBuilderContext { get; }
        public T Value { get; }
        public .ResettableLazy<T> Clone() { }
        public . DisposeAsync() { }
        public virtual . ResetLazy() { }
        protected static . DisposeAsync(object? obj) { }
    }
    public class ResettableLazy<[.(..PublicConstructors)]  TClassConstructor, [.(..PublicConstructors)]  T> : .ResettableLazy<T>
        where TClassConstructor : ., new ()
        where T :  class
    {
        public ResettableLazy(string sessionId, .TestBuilderContext testBuilderContext) { }
        public override . ResetLazy() { }
    }
    [(.Assembly | .Class | .Method)]
    public class RetryAttribute : .TUnitAttribute, ., .
    {
        public RetryAttribute(int times) { }
        public int Order { get; }
        public int Times { get; }
        public void OnTestDiscovery(.DiscoveredTestContext discoveredTestContext) { }
        public virtual .<bool> ShouldRetry(.TestContext context,  exception, int currentRetryCount) { }
    }
    public sealed class RunOnAttribute : .SkipAttribute
    {
        public RunOnAttribute(. OperatingSystem) { }
        public override .<bool> ShouldSkip(.BeforeTestContext context) { }
    }
    public class RunOnDiscoveryAttribute : .TUnitAttribute, ., .
    {
        public RunOnDiscoveryAttribute() { }
        public int Order { get; }
        public void OnTestDiscovery(.DiscoveredTestContext discoveredTestContext) { }
    }
    [.("windows")]
    public class STAThreadExecutor : .DedicatedThreadExecutor
    {
        public STAThreadExecutor() { }
        protected override void ConfigureThread(.Thread thread) { }
    }
    public class SharedDataKey : <.SharedDataKey>
    {
        public SharedDataKey(string Key,  Type) { }
        public string Key { get; init; }
        public  Type { get; init; }
    }
    public enum SharedType
    {
        None = 0,
        PerClass = 1,
        PerAssembly = 2,
        PerTestSession = 3,
        Keyed = 4,
    }
    public class SingleTUnitAttribute : .TUnitAttribute { }
    public static class Skip
    {
        [.]
        public static void Test(string reason) { }
        public static void Unless([.(false)] bool condition, string reason) { }
        public static void When([.(true)] bool condition, string reason) { }
    }
    [(.Assembly | .Class | .Method)]
    public class SkipAttribute : .TUnitAttribute, ., .
    {
        public SkipAttribute(string reason) { }
        public int Order { get; }
        public string Reason { get; protected set; }
        public . OnTestRegistered(.TestRegisteredContext context) { }
        public virtual .<bool> ShouldSkip(.BeforeTestContext context) { }
    }
    []
    public class SourceGeneratedAssemblyInformation : .AssemblyMetadata, <.SourceGeneratedAssemblyInformation>
    {
        public SourceGeneratedAssemblyInformation() { }
    }
    []
    public abstract class SourceGeneratedMemberInformation : .MemberMetadata, <.SourceGeneratedMemberInformation>
    {
        protected SourceGeneratedMemberInformation() { }
    }
    []
    public class SourceGeneratedMethodInformation : .MethodMetadata, <.SourceGeneratedMethodInformation>
    {
        public SourceGeneratedMethodInformation() { }
    }
    []
    public class SourceGeneratedParameterInformation : .ParameterMetadata, <.SourceGeneratedParameterInformation>
    {
        public SourceGeneratedParameterInformation([.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods | ..PublicProperties)]  Type) { }
    }
    public class SourceGeneratedParameterInformation<[.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods | ..PublicProperties)]  T> : .ParameterMetadata<T>, <.SourceGeneratedParameterInformation<T>>
    {
        public SourceGeneratedParameterInformation() { }
    }
    []
    public class SourceGeneratedPropertyInformation : .PropertyMetadata, <.SourceGeneratedPropertyInformation>
    {
        public SourceGeneratedPropertyInformation() { }
    }
    [.StackTraceHidden]
    public class SourceRegistrar
    {
        public SourceRegistrar() { }
        public static bool IsEnabled { get; set; }
        public static void Register(..ITestSource testSource) { }
        public static void RegisterAssembly(<.Assembly> assemblyLoader) { }
        public static void RegisterAssemblyHookSource(..IAssemblyHookSource testSource) { }
        public static void RegisterClassHookSource(..IClassHookSource testSource) { }
        public static void RegisterDynamic(..IDynamicTestSource testSource) { }
        public static void RegisterGlobalInitializer(<.> initializer) { }
        public static void RegisterProperty(..IPropertySource propertySource) { }
        public static void RegisterTestDiscoveryHookSource(..ITestDiscoveryHookSource testSource) { }
        public static void RegisterTestHookSource(..ITestHookSource testSource) { }
        public static void RegisterTestSessionHookSource(..ITestSessionHookSource testSource) { }
    }
    public class StaticTestBuilder : .ITestDefinitionBuilder
    {
        public StaticTestBuilder() { }
        public .<.<.TestDefinition>> BuildTestDefinitionsAsync(.ITestDescriptor testDescriptor, .CancellationToken cancellationToken = default) { }
    }
    public sealed class StaticTestDefinition : .ITestDescriptor
    {
        public StaticTestDefinition() { }
        public required .IDataProvider ClassDataProvider { get; init; }
        public required <object?[], object> ClassFactory { get; init; }
        public required string DisplayName { get; init; }
        public required bool IsAsync { get; init; }
        public required bool IsSkipped { get; init; }
        public required .IDataProvider MethodDataProvider { get; init; }
        public required <object, object?[], .CancellationToken, .> MethodInvoker { get; init; }
        public required <.<.<string, object?>>> PropertyValuesProvider { get; init; }
        public required int RepeatCount { get; init; }
        public string? SkipReason { get; init; }
        [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..NonPublicConstructors | ..PublicMethods | ..NonPublicMethods | ..PublicProperties)]
        public required  TestClassType { get; init; }
        public required string TestFilePath { get; init; }
        public required string TestId { get; init; }
        public required int TestLineNumber { get; init; }
        public required .MethodMetadata TestMethodMetadata { get; init; }
        public ? Timeout { get; init; }
    }
    public class TUnitAttribute :  { }
    [(.Method)]
    public sealed class TestAttribute : .BaseTestAttribute
    {
        public TestAttribute([.] string file = "", [.] int line = 0) { }
    }
    public enum TestAttributeTarget
    {
        Assembly = 0,
        Module = 1,
        Class = 2,
        Struct = 3,
        Enum = 4,
        Interface = 5,
        Delegate = 6,
        Method = 7,
        Constructor = 8,
        Property = 9,
        Field = 10,
        Event = 11,
        Parameter = 12,
        ReturnValue = 13,
        GenericParameter = 14,
    }
    public class TestBuilderContext : <.TestBuilderContext>
    {
        public TestBuilderContext() { }
        public .ClassMetadata? ClassInformation { get; init; }
        public .<.IDataAttribute> DataAttributes { get; }
        public .TestContextEvents Events { get; }
        public  Id { get; }
        public .MethodMetadata? MethodInformation { get; init; }
        public .<string, object?> ObjectBag { get; }
        public string? TestMethodName { get; init; }
        public static .TestBuilderContext? Current { get; }
        public void RegisterForInitialization(object? obj) { }
    }
    public class TestBuilderContextAccessor
    {
        public TestBuilderContextAccessor(.TestBuilderContext context) { }
        public .TestBuilderContext Current { get; set; }
    }
    public class TestBuilderException : 
    {
        public TestBuilderException() { }
        public TestBuilderException(string message) { }
        public TestBuilderException(string message,  innerException) { }
        public .<string, object?> Context { get; set; }
        public .DynamicTestMetadata? TestMetadata { get; set; }
    }
    [.DebuggerDisplay("{.Name}.{}")]
    public class TestContext : .Context
    {
        public readonly .Lock Lock;
        public .<.ArgumentDisplayFormatter> ArgumentDisplayFormatters { get; }
        public .AssemblyHookContext AssemblyContext { get; }
        public .CancellationToken CancellationToken { get; }
        public .ClassHookContext ClassContext { get; }
        public int CurrentRetryAttempt { get; }
        public .TestContext[] Dependencies { get; }
        public .TestContextEvents Events { get; }
        public bool IsRegistered { get; }
        public .<string, object?> ObjectBag { get; }
        public .TestResult? Result { get; }
        public .TestDetails TestDetails { get; }
        public ? TestStart { get; }
        public .<.Timing> Timings { get; }
        public static . Configuration { get; }
        public new static .TestContext? Current { get; }
        [get: .("SingleFile", "IL3000:Avoid accessing Assembly file path when publishing as a single file", Justification="Dynamic code check implemented")]
        public static string? OutputDirectory { get; }
        public static .<string, string> Parameters { get; }
        public static string WorkingDirectory { get; set; }
        public void AddArtifact(.Artifact artifact) { }
        public void SuppressReportingResult() { }
    }
    public class TestContextEvents : <.TestContextEvents>
    {
        public TestContextEvents() { }
        public .AsyncEvent<.TestContext>? OnDispose { get; set; }
        public .AsyncEvent<<.AssemblyHookContext, .TestContext>>? OnFirstTestInAssembly { get; set; }
        public .AsyncEvent<<.ClassHookContext, .TestContext>>? OnFirstTestInClass { get; set; }
        public .AsyncEvent<<.TestSessionContext, .TestContext>>? OnFirstTestInTestSession { get; set; }
        public .AsyncEvent<.TestContext>? OnInitialize { get; set; }
        public .AsyncEvent<<.AssemblyHookContext, .TestContext>>? OnLastTestInAssembly { get; set; }
        public .AsyncEvent<<.ClassHookContext, .TestContext>>? OnLastTestInClass { get; set; }
        public .AsyncEvent<<.TestSessionContext, .TestContext>>? OnLastTestInTestSession { get; set; }
        public .AsyncEvent<.AfterTestContext>? OnTestEnd { get; set; }
        public .AsyncEvent<.TestRegisteredContext>? OnTestRegistered { get; set; }
        [.(new string[] {
                null,
                "RetryAttempt"})]
        public .AsyncEvent<<.TestContext, int>>? OnTestRetry { get; set; }
        public .AsyncEvent<.TestContext>? OnTestSkipped { get; set; }
        public .AsyncEvent<.BeforeTestContext>? OnTestStart { get; set; }
    }
    public class TestDataAttribute : .TUnitAttribute, .IDataAttribute
    {
        public TestDataAttribute() { }
        public bool AccessesInstanceData { get; init; }
    }
    public sealed class TestDefinition : .TestDefinitionBase, <.TestDefinition>
    {
        public TestDefinition() { }
        public override required .IDataProvider ClassDataProvider { get; init; }
        public override required .IDataProvider MethodDataProvider { get; init; }
        public override required .MethodMetadata MethodMetadata { get; init; }
        public <object?[], object>? OriginalClassFactory { get; init; }
        public <object, object?[], .CancellationToken, .>? OriginalMethodInvoker { get; init; }
        public required <.<string, object?>> PropertiesProvider { get; init; }
        public required <object> TestClassFactory { get; init; }
        public override required string TestFilePath { get; init; }
        public override required string TestId { get; init; }
        public override required int TestLineNumber { get; init; }
        public required <object, .CancellationToken, .> TestMethodInvoker { get; init; }
    }
    public abstract class TestDefinitionBase : <.TestDefinitionBase>, .ITestDefinition
    {
        protected TestDefinitionBase() { }
        public abstract .IDataProvider ClassDataProvider { get; init; }
        public abstract .IDataProvider MethodDataProvider { get; init; }
        public abstract .MethodMetadata MethodMetadata { get; init; }
        public abstract string TestFilePath { get; init; }
        public abstract string TestId { get; init; }
        public abstract int TestLineNumber { get; init; }
    }
    public sealed class TestDefinition<[.(..PublicConstructors)]  TTestClass> : .TestDefinitionBase, <.TestDefinition<TTestClass>>
        where TTestClass :  class
    {
        public TestDefinition() { }
        public override required .IDataProvider ClassDataProvider { get; init; }
        public override required .IDataProvider MethodDataProvider { get; init; }
        public override required .MethodMetadata MethodMetadata { get; init; }
        public <object?[], TTestClass>? OriginalClassFactory { get; init; }
        public <TTestClass, object?[], .CancellationToken, .>? OriginalMethodInvoker { get; init; }
        public required <.<string, object?>> PropertiesProvider { get; init; }
        public required <TTestClass> TestClassFactory { get; init; }
        public  TestClassType { get; }
        public override required string TestFilePath { get; init; }
        public override required string TestId { get; init; }
        public override required int TestLineNumber { get; init; }
        public required <TTestClass, .CancellationToken, .> TestMethodInvoker { get; init; }
        public static .TestDefinition op_Implicit(.TestDefinition<TTestClass> definition) { }
    }
    public abstract class TestDetails : <.TestDetails>
    {
        protected TestDetails() { }
        [..JsonIgnore]
        public .AttributeMetadata[] AssemblyAttributes { get; }
        [..JsonIgnore]
        public .AttributeMetadata[] Attributes { get; }
        public .<string> Categories { get; }
        [..JsonIgnore]
        public .AttributeMetadata[] ClassAttributes { get; }
        public abstract object ClassInstance { get; }
        public .ClassMetadata ClassMetadata { get; }
        public .<string, .<string>> CustomProperties { get; }
        [..JsonIgnore]
        public required .AttributeMetadata[] DataAttributes { get; init; }
        [..JsonIgnore]
        public .AttributeMetadata[] DynamicAttributes { get; init; }
        public required .MethodMetadata MethodMetadata { get; init; }
        public .? ParallelConstraint { get; }
        public .? ParallelLimit { get; }
        public int RetryLimit { get; }
        public required  ReturnType { get; init; }
        [..JsonIgnore]
        public .AttributeMetadata[] TestAttributes { get; }
        public .ClassMetadata TestClass { get; }
        public required object?[] TestClassArguments { get; init; }
        public required .<string, object?> TestClassInjectedPropertyArguments { get; init; }
        public [] TestClassParameterTypes { get; }
        public required string TestFilePath { get; init; }
        public required string TestId { get; init; }
        public required int TestLineNumber { get; init; }
        public .MethodMetadata TestMethod { get; }
        public required object?[] TestMethodArguments { get; init; }
        public [] TestMethodParameterTypes { get; }
        public required string TestName { get; init; }
        public ? Timeout { get; }
        public static .TestDetails<TClassType> CreateWithRawAttributes<[.(..PublicConstructors)]  TClassType>(string testId, .ResettableLazy<TClassType> lazyClassInstance, object?[] testClassArguments, object?[] testMethodArguments, .<string, object?> testClassInjectedPropertyArguments, .MethodMetadata testMethod, string testName,  returnType, string testFilePath, int testLineNumber, [] dynamicAttributes, [] dataAttributes)
            where TClassType :  class { }
    }
    public class TestDetails<[.(..PublicConstructors)]  TClassType> : .TestDetails, <.TestDetails<TClassType>>
        where TClassType :  class
    {
        public TestDetails() { }
        public override object ClassInstance { get; }
        [..JsonIgnore]
        public required .ResettableLazy<TClassType> LazyClassInstance { get; init; }
    }
    public class TestDiscoveryContext : .Context
    {
        public .<.TestContext> AllTests { get; }
        public .<.AssemblyHookContext> Assemblies { get; }
        public .BeforeTestDiscoveryContext BeforeTestDiscoveryContext { get; }
        public .<.ClassHookContext> TestClasses { get; }
        public required string? TestFilter { get; init; }
        public new static .TestDiscoveryContext? Current { get; }
        public void AddTests(.<.TestContext> tests) { }
    }
    public class TestExecutionContext
    {
        public readonly .Lock Lock;
        public TestExecutionContext(.ITestDefinition definition) { }
        public .<.ArgumentDisplayFormatter> ArgumentDisplayFormatters { get; }
        public .<.Artifact> Artifacts { get; }
        public int CurrentRetryAttempt { get; set; }
        public .ITestDefinition Definition { get; }
        public ? Duration { get; }
        public ? Exception { get; set; }
        public .<.CancellationToken> LinkedCancellationTokens { get; }
        public .<string> Logs { get; }
        public .<string, object?> Properties { get; }
        public .TestStatus Status { get; set; }
        public ? TestEnd { get; set; }
        public ? TestStart { get; set; }
        public .<.Timing> Timings { get; }
    }
    public class TestInstantiationException : .TestBuilderException
    {
        public TestInstantiationException( testClassType,  innerException) { }
        public TestInstantiationException( testClassType, string message) { }
        public  TestClassType { get; }
    }
    public class TestMetadataSource : ..ITestSource
    {
        [.("AOT", "IL3050:RequiresDynamicCode", Justification="DynamicTestBuilder is only used for dynamic test paths which are not AOT-compatib" +
            "le by design")]
        [.("Trimming", "IL2026:RequiresUnreferencedCode", Justification="DynamicTestBuilder is only used for dynamic test paths which are not AOT-compatib" +
            "le by design")]
        public TestMetadataSource(.<.ITestDescriptor> testDescriptors) { }
        public .<.DiscoveryResult> DiscoverTestsAsync(string sessionId) { }
    }
    public class TestRegisteredContext : .BeforeTestContext
    {
        public void SetParallelLimiter(. parallelLimit) { }
        public void SkipTest(string reason) { }
    }
    public class TestResult : <.TestResult>
    {
        public TestResult() { }
        public required string ComputerName { get; init; }
        public required ? Duration { get; init; }
        public required ? End { get; init; }
        public required ? Exception { get; init; }
        public bool IsOverridden { get; set; }
        public string? Output { get; }
        public string? OverrideReason { get; set; }
        public required ? Start { get; init; }
        public required . Status { get; init; }
    }
    public class TestSessionContext : .Context
    {
        public .<.TestContext> AllTests { get; }
        public .<.AssemblyHookContext> Assemblies { get; }
        public required string Id { get; init; }
        public .<.ClassHookContext> TestClasses { get; }
        public .BeforeTestDiscoveryContext TestDiscoveryContext { get; }
        public required string? TestFilter { get; init; }
        public new static .TestSessionContext? Current { get; }
        public void AddArtifact(.Artifact artifact) { }
        public void AddAssembly(.AssemblyHookContext assemblyHookContext) { }
    }
    public enum TestStatus
    {
        NotStarted = 0,
        InProgress = 1,
        Passed = 2,
        Failed = 3,
        Skipped = 4,
        Cancelled = 5,
        Timeout = 6,
    }
    [(.Assembly | .Class | .Method)]
    public class TimeoutAttribute : .TUnitAttribute, ., .
    {
        public TimeoutAttribute(int timeoutInMilliseconds) { }
        public int Order { get; }
        public  Timeout { get; }
        public void OnTestDiscovery(.DiscoveredTestContext discoveredTestContext) { }
    }
    public class Timing : <.Timing>
    {
        public Timing(string StepName,  Start,  End) { }
        public  Duration { get; }
        public  End { get; init; }
        public  Start { get; init; }
        public string StepName { get; init; }
    }
    public sealed class TypeReference
    {
        public TypeReference() { }
        public int ArrayRank { get; set; }
        public string? AssemblyQualifiedName { get; set; }
        public .TypeReference? ElementType { get; set; }
        public .<.TypeReference> GenericArguments { get; set; }
        public string? GenericParameterName { get; set; }
        public int GenericParameterPosition { get; set; }
        public bool IsArray { get; set; }
        public bool IsByRef { get; set; }
        public bool IsGenericParameter { get; set; }
        public bool IsMethodGenericParameter { get; set; }
        public bool IsPointer { get; set; }
        public static .TypeReference CreateArray(.TypeReference elementType, int rank = 1) { }
        public static .TypeReference CreateConcrete(string assemblyQualifiedName) { }
        public static .TypeReference CreateConstructedGeneric(string genericTypeDefinition, params .TypeReference[] genericArguments) { }
        public static .TypeReference CreateGenericParameter(int position, bool isMethodParameter, string? name = null) { }
    }
    [.("TypeResolver uses dynamic type creation for generics, arrays, and other complex t" +
        "ypes")]
    [.("TypeResolver uses  which may require types that aren\'t statically ref" +
        "erenced")]
    public sealed class TypeResolver
    {
        public TypeResolver(? declaringType = null, .MethodInfo? declaringMethod = null) { }
        [.("AOT", "IL2055:MakeGenericType", Justification="TypeResolver is not AOT-compatible by design")]
        [.("AOT", "IL2057:TypeGetType", Justification="TypeResolver is not AOT-compatible by design")]
        [.("AOT", "IL2073:ReturnValueMismatch", Justification="TypeResolver is not AOT-compatible by design")]
        [.("AOT", "IL3050:RequiresDynamicCode", Justification="TypeResolver is not AOT-compatible by design")]
        public  Resolve(.TypeReference typeReference) { }
        public [] ResolveMany(.<.TypeReference> typeReferences) { }
        public static .TypeResolver CreateSimple() { }
        public static .TypeResolver FromTestInstance(object testInstance, .MethodInfo? testMethod = null) { }
    }
    [(.Class | .Method | .Property, AllowMultiple=true)]
    public abstract class UntypedDataSourceGeneratorAttribute : .AsyncUntypedDataSourceGeneratorAttribute
    {
        protected UntypedDataSourceGeneratorAttribute() { }
        protected abstract .<<object?[]?>> GenerateDataSources(.DataGeneratorMetadata dataGeneratorMetadata);
        [.(typeof(.UntypedDataSourceGeneratorAttribute.<GenerateDataSourcesAsync>d__1))]
        protected override sealed .<<.<object?[]?>>> GenerateDataSourcesAsync(.DataGeneratorMetadata dataGeneratorMetadata) { }
    }
    [.("Reflection")]
    [.("Reflection")]
    public class UntypedDynamicTest : .DynamicTest, <.UntypedDynamicTest>
    {
        public UntypedDynamicTest(.MethodInfo testBody) { }
        public UntypedDynamicTest( testClassType, .MethodInfo testBody) { }
        public .TestBuilderContext TestBuilderContext { get; set; }
        [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods | ..PublicProperties)]
        public override  TestClassType { get; }
        public override string TestId { get; }
        public override .DiscoveryResult BuildTests() { }
    }
    [.("Reflection")]
    [.("Reflection")]
    public class UntypedFailedDynamicTest : <.UntypedFailedDynamicTest>
    {
        public UntypedFailedDynamicTest(.MethodInfo MethodMetadata) { }
        public required  Exception { get; init; }
        public .MethodInfo MethodMetadata { get; init; }
        public required string MethodName { get; init; }
        [.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods | ..PublicProperties)]
        public required  TestClassType { get; init; }
        public required string TestFilePath { get; init; }
        public required int TestLineNumber { get; init; }
        public static .DynamicTest op_Implicit(.UntypedFailedDynamicTest failedTestMetadata) { }
    }
    public class UntypedTestDetails : .TestDetails, <.UntypedTestDetails>
    {
        public UntypedTestDetails(.ResettableLazy<object> ResettableLazy) { }
        public override object ClassInstance { get; }
        public .ResettableLazy<object> ResettableLazy { get; init; }
        public static .UntypedTestDetails CreateWithRawAttributes(.ResettableLazy<object> resettableLazy, string testId, string testName, .MethodMetadata testMethod, string testFilePath, int testLineNumber, object?[] testClassArguments, object?[] testMethodArguments, .<string, object?> testClassInjectedPropertyArguments, int repeatLimit, int currentRepeatAttempt,  returnType, [] dataAttributes) { }
    }
}
namespace .Data
{
    public class GetOnlyDictionary<TKey, TValue>
        where TKey :  notnull
    {
        public GetOnlyDictionary() { }
        public TValue this[TKey key] { get; }
        public .<TKey> Keys { get; }
        public .<TValue> Values { get; }
        public TValue GetOrAdd(TKey key, <TKey, TValue> func) { }
        public TValue GetOrAdd(TKey key, <TKey, TValue> func, out bool previouslyExisted) { }
        public TValue? Remove(TKey key) { }
        public bool TryGetValue(TKey key, [.(true)] out TValue? value) { }
    }
}
namespace .DataSources
{
    public class AttributeDataSourceProvider : .IDataSourceProvider
    {
        public AttributeDataSourceProvider(object dataAttribute) { }
        public bool IsAsync { get; }
        public bool IsShared { get; }
        public .<object?[]> GetData() { }
        [.(typeof(..<GetDataAsync>d__3))]
        public .<object?[]> GetDataAsync() { }
    }
    public class ClassDataSourceProvider : .IDataSourceProvider
    {
        public ClassDataSourceProvider([.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods | ..PublicProperties)]  dataSourceType, bool isShared = false) { }
        public bool IsAsync { get; }
        public bool IsShared { get; }
        public .<object?[]> GetData() { }
        [.(typeof(..<GetDataAsync>d__5))]
        public .<object?[]> GetDataAsync() { }
    }
    public class EnumerableDataSourceProvider : .IDataSourceProvider
    {
        public EnumerableDataSourceProvider(.<object?[]> data, bool isShared = false) { }
        public bool IsAsync { get; }
        public bool IsShared { get; }
        public .<object?[]> GetData() { }
        public .<object?[]> GetDataAsync() { }
    }
    public class InlineDataSourceProvider : .IDataSourceProvider
    {
        public InlineDataSourceProvider(params object?[] data) { }
        public bool IsAsync { get; }
        public bool IsShared { get; }
        public .<object?[]> GetData() { }
        public .<object?[]> GetDataAsync() { }
    }
    public class MethodDataSourceProvider : .IDataSourceProvider
    {
        public MethodDataSourceProvider(.MethodInfo method, object? instance = null, bool isShared = false) { }
        public bool IsAsync { get; }
        public bool IsShared { get; }
        public .<object?[]> GetData() { }
        [.(typeof(..<GetDataAsync>d__6))]
        public .<object?[]> GetDataAsync() { }
    }
    public class PropertyDataSourceProvider : .IDataSourceProvider
    {
        public PropertyDataSourceProvider([.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicProperties | ..NonPublicProperties)]  type, string propertyName, bool isShared = false) { }
        public bool IsAsync { get; }
        public bool IsShared { get; }
        public .<object?[]> GetData() { }
        [.(typeof(..<GetDataAsync>d__5))]
        public .<object?[]> GetDataAsync() { }
    }
}
namespace .Enums
{
    public enum DataGeneratorType
    {
        ClassParameters = 0,
        TestParameters = 1,
        Property = 2,
    }
    public enum LogLevel
    {
        None = -1,
        Trace = 0,
        Debug = 1,
        Information = 2,
        Warning = 3,
        Error = 4,
        Critical = 5,
    }
    []
    public enum OS
    {
        Linux = 1,
        Windows = 2,
        MacOs = 4,
    }
    public enum Status
    {
        None = 0,
        Passed = 1,
        Failed = 2,
        Skipped = 3,
        Cancelled = 4,
    }
}
namespace .Events
{
    []
    public enum EventType
    {
        Initialize = 1,
        Dispose = 2,
        TestRegistered = 4,
        TestStart = 8,
        TestEnd = 16,
        TestSkipped = 32,
        FirstTestInClass = 64,
        FirstTestInAssembly = 128,
        FirstTestInTestSession = 256,
        LastTestInClass = 512,
        LastTestInAssembly = 1024,
        LastTestInTestSession = 2048,
        TestRetry = 2049,
        All = 4095,
    }
    public class FirstTestInAssemblyEventWrapper : ., .
    {
        public FirstTestInAssemblyEventWrapper(.AsyncEvent<<.AssemblyHookContext, .TestContext>>.Invocation invocation) { }
        public int Order { get; }
        public . OnFirstTestInAssembly(.AssemblyHookContext context, .TestContext testContext) { }
    }
    public class FirstTestInClassEventWrapper : ., .
    {
        public FirstTestInClassEventWrapper(.AsyncEvent<<.ClassHookContext, .TestContext>>.Invocation invocation) { }
        public int Order { get; }
        public . OnFirstTestInClass(.ClassHookContext context, .TestContext testContext) { }
    }
    public class FirstTestInTestSessionEventWrapper : ., .
    {
        public FirstTestInTestSessionEventWrapper(.AsyncEvent<<.TestSessionContext, .TestContext>>.Invocation invocation) { }
        public int Order { get; }
        public . OnFirstTestInTestSession(.TestSessionContext context, .TestContext testContext) { }
    }
    public class LastTestInAssemblyEventWrapper : ., .
    {
        public LastTestInAssemblyEventWrapper(.AsyncEvent<<.AssemblyHookContext, .TestContext>>.Invocation invocation) { }
        public int Order { get; }
        public . OnLastTestInAssembly(.AssemblyHookContext context, .TestContext testContext) { }
    }
    public class LastTestInClassEventWrapper : ., .
    {
        public LastTestInClassEventWrapper(.AsyncEvent<<.ClassHookContext, .TestContext>>.Invocation invocation) { }
        public int Order { get; }
        public . OnLastTestInClass(.ClassHookContext context, .TestContext testContext) { }
    }
    public class LastTestInTestSessionEventWrapper : ., .
    {
        public LastTestInTestSessionEventWrapper(.AsyncEvent<<.TestSessionContext, .TestContext>>.Invocation invocation) { }
        public int Order { get; }
        public . OnLastTestInTestSession(.TestSessionContext context, .TestContext testContext) { }
    }
    public class TestDisposeEventWrapper : , .
    {
        public TestDisposeEventWrapper(.AsyncEvent<.TestContext>.Invocation invocation) { }
        public int Order { get; }
        public . DisposeAsync() { }
    }
    public class TestEndEventWrapper : ., .
    {
        public TestEndEventWrapper(.AsyncEvent<.AfterTestContext>.Invocation invocation) { }
        public int Order { get; }
        public . OnTestEnd(.AfterTestContext testContext) { }
    }
    public class TestInitializeEventWrapper : ., .
    {
        public TestInitializeEventWrapper(.AsyncEvent<.TestContext>.Invocation invocation) { }
        public int Order { get; }
        public . InitializeAsync() { }
    }
    public class TestRegisteredEventWrapper : ., .
    {
        public TestRegisteredEventWrapper(.AsyncEvent<.TestRegisteredContext>.Invocation invocation) { }
        public int Order { get; }
        public . OnTestRegistered(.TestRegisteredContext context) { }
    }
    public class TestRetryEventWrapper : ., .
    {
        public TestRetryEventWrapper([.(new string[] {
                null,
                "RetryAttempt"})] .AsyncEvent<<.TestContext, int>>.Invocation invocation) { }
        public int Order { get; }
        public . OnTestRetry(.TestContext testContext, int retryAttempt) { }
    }
    public class TestSkippedEventWrapper : ., .
    {
        public TestSkippedEventWrapper(.AsyncEvent<.TestContext>.Invocation invocation) { }
        public int Order { get; }
        public . OnTestSkipped(.TestContext testContext) { }
    }
    public class TestStartEventWrapper : ., .
    {
        public TestStartEventWrapper(.AsyncEvent<.BeforeTestContext>.Invocation invocation) { }
        public int Order { get; }
        public . OnTestStart(.BeforeTestContext beforeTestContext) { }
    }
}
namespace .Exceptions
{
    public class AfterAssemblyException : .
    {
        public AfterAssemblyException(string message,  innerException) { }
    }
    public class AfterClassException : .
    {
        public AfterClassException(string message,  innerException) { }
    }
    public class AfterTestDiscoveryException : .
    {
        public AfterTestDiscoveryException(string message,  innerException) { }
    }
    public class AfterTestException : .
    {
        public AfterTestException(string message,  innerException) { }
    }
    public class AfterTestSessionException : .
    {
        public AfterTestSessionException(string message,  innerException) { }
    }
    public class BeforeAssemblyException : .
    {
        public BeforeAssemblyException(string message,  innerException) { }
    }
    public class BeforeClassException : .
    {
        public BeforeClassException(string message,  innerException) { }
    }
    public class BeforeTestDiscoveryException : .
    {
        public BeforeTestDiscoveryException(string message,  innerException) { }
    }
    public class BeforeTestException : .
    {
        public BeforeTestException(string message,  innerException) { }
    }
    public class BeforeTestSessionException : .
    {
        public BeforeTestSessionException(string message,  innerException) { }
    }
    public class DependencyConflictException : . { }
    public class FailTestException : .
    {
        public FailTestException(string reason) { }
        public string Reason { get; }
    }
    public class InconclusiveTestException : .
    {
        public InconclusiveTestException(string message,  exception) { }
    }
    public class SkipTestException : .
    {
        public SkipTestException(string reason) { }
        public string Reason { get; }
    }
    public class TUnitException : 
    {
        public TUnitException() { }
        public TUnitException(string? message) { }
        public TUnitException(string? message, ? innerException) { }
    }
    public class TestFailedInitializationException : 
    {
        public TestFailedInitializationException(string? message, ? innerException) { }
    }
    public class TestNotExecutedException : . { }
    public class TestRunCanceledException : .
    {
        public TestRunCanceledException() { }
    }
    public class TimeoutException : . { }
}
namespace .Executors
{
    [(.Assembly | .Class | .Method)]
    public class CultureAttribute : .TUnitAttribute, ., .
    {
        public CultureAttribute(.CultureInfo cultureInfo) { }
        public CultureAttribute(string cultureName) { }
        public int Order { get; }
        public . OnTestRegistered(.TestRegisteredContext context) { }
    }
    public class HookExecutorAttribute : .TUnitAttribute
    {
        public HookExecutorAttribute( type) { }
        public  HookExecutorType { get; }
    }
    [(.Assembly | .Class | .Method)]
    public sealed class HookExecutorAttribute<T> : .
        where T : ., new ()
    {
        public HookExecutorAttribute() { }
    }
    [(.Assembly | .Class | .Method)]
    public class InvariantCultureAttribute : .
    {
        public InvariantCultureAttribute() { }
    }
    [(.Assembly | .Class | .Method)]
    [.("windows")]
    public class STAThreadExecutorAttribute : .TUnitAttribute, ., .
    {
        public STAThreadExecutorAttribute() { }
        public int Order { get; }
        public . OnTestRegistered(.TestRegisteredContext context) { }
    }
    [(.Assembly | .Class | .Method)]
    public sealed class TestExecutorAttribute : .TUnitAttribute, ., .
    {
        public TestExecutorAttribute([.(..PublicConstructors)]  type) { }
        public int Order { get; }
        public . OnTestRegistered(.TestRegisteredContext context) { }
    }
    [(.Assembly | .Class | .Method)]
    public sealed class TestExecutorAttribute<T> : .TUnitAttribute, ., .
        where T : ., new ()
    {
        public TestExecutorAttribute() { }
        public int Order { get; }
        public . OnTestRegistered(.TestRegisteredContext context) { }
    }
}
namespace .Extensions
{
    public static class ClassConstructorExtensions
    {
        public static T Create<[.(..PublicConstructors)]  T>(this . classConstructor, .ClassConstructorMetadata classConstructorMetadata)
            where T :  class { }
    }
    public static class MetadataExtensions
    {
        public static T? GetAttribute<T>(this .MethodMetadata method)
            where T :  { }
    }
    public static class ReflectionExtensions
    {
        public static [] GetCustomAttributesSafe(this .ICustomAttributeProvider provider, bool inherit = true) { }
        public static T[] GetCustomAttributesSafe<T>(this .ICustomAttributeProvider provider, bool inherit = true)
            where T :  { }
    }
    public static class TestAttributeExtensions
    {
        public static .AttributeMetadata? FirstOfAttributeType<TAttribute>(this .<.AttributeMetadata> attributes)
            where TAttribute :  { }
        public static .<.AttributeMetadata> ForMember(this .<.AttributeMetadata> attributes, string memberName) { }
        public static .<.AttributeMetadata> ForTarget(this .<.AttributeMetadata> attributes, .TestAttributeTarget target) { }
        public static object? GetConstructorArgument(this .AttributeMetadata attribute, int index) { }
        public static TAttribute? GetInstance<TAttribute>(this .AttributeMetadata attribute)
            where TAttribute :  { }
        public static object? GetNamedArgument(this .AttributeMetadata attribute, string propertyName) { }
        public static bool IsAttributeType<TAttribute>(this .AttributeMetadata attribute)
            where TAttribute :  { }
        public static .<.AttributeMetadata> OfAttributeType<TAttribute>(this .<.AttributeMetadata> attributes)
            where TAttribute :  { }
        public static .<TAttribute> OfType<TAttribute>(this .<.AttributeMetadata> attributes)
            where TAttribute :  { }
        public static bool TryGetNamedArgument(this .AttributeMetadata attribute, string propertyName, [.(true)] out object? value) { }
    }
    public static class TestContextExtensions
    {
        [.("WIP")]
        public static . AddDynamicTest<[.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicMethods | ..PublicProperties)]  T>(this .TestContext testContext, .DynamicTest<T> dynamicTest)
            where T :  class { }
        public static string GetClassTypeName(this .TestContext testContext) { }
        public static string GetTestDisplayName(this .TestContext testContext) { }
        public static .TestContext[] GetTests(this .TestContext context, string testName) { }
        public static .TestContext[] GetTests(this .TestContext context, string testName, [] parameterTypes) { }
    }
}
namespace .Helpers
{
    public static class CastHelper
    {
        [.("", "IL2072")]
        public static object? Cast([.(..PublicMethods)]  type, object? value) { }
        [.("", "IL2072")]
        public static T? Cast<[.(..PublicMethods)]  T>(object? value) { }
        public static .MethodInfo? GetConversionMethod([.(..PublicMethods)]  baseType, [.(..PublicMethods)]  targetType) { }
    }
    [.DebuggerDisplay("Count = {CurrentCount}")]
    public class Counter
    {
        public <int>? OnCountChanged;
        public Counter() { }
        public int CurrentCount { get; }
        public int Decrement() { }
        public int Increment() { }
    }
    public class DataSourceInitializationException : 
    {
        public DataSourceInitializationException(string message) { }
        public DataSourceInitializationException(string message,  innerException) { }
    }
    public class MethodInfoRetriever
    {
        public MethodInfoRetriever() { }
        public static .MethodInfo GetMethodInfo([.(..None | ..PublicMethods | ..NonPublicMethods)]  type, string methodName, int genericParameterCount, [] parameterTypes) { }
    }
    public class ProcessorCountParallelLimit : .
    {
        public ProcessorCountParallelLimit() { }
        public int Limit { get; }
    }
    public class ReferenceEqualityComparer : .<object>
    {
        public ReferenceEqualityComparer() { }
        public bool Equals(object? x, object? y) { }
        public int GetHashCode(object obj) { }
    }
    [.("Uses reflection to retrieve parameter information")]
    [.("Uses reflection to retrieve parameter information")]
    public static class RobustParameterInfoRetriever
    {
        public static .ParameterInfo GetConstructorParameterInfo([.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..NonPublicConstructors)]  type, [] parameterTypes, int parameterIndex,  expectedType, string parameterName) { }
        public static .ParameterInfo GetMethodParameterInfo([.(..None | ..PublicMethods | ..PublicProperties)]  type, string methodName, int parameterIndex, [] parameterTypes, bool isStatic, int genericParameterCount) { }
    }
    public static class RuntimeAttributeHelper
    {
        public static  CreateAttribute([.(..None | ..PublicParameterlessConstructor | ..PublicConstructors | ..PublicProperties)]  attributeType, object?[]? constructorArgs, .<string, object?>? namedArgs) { }
    }
}
namespace .Hooks
{
    public class AfterAssemblyHookMethod : .<.AssemblyHookContext>, <.>
    {
        public AfterAssemblyHookMethod() { }
        public override . ExecuteAsync(.AssemblyHookContext context, .CancellationToken cancellationToken) { }
    }
    public class AfterClassHookMethod : .<.ClassHookContext>, <.>
    {
        public AfterClassHookMethod() { }
        public override . ExecuteAsync(.ClassHookContext context, .CancellationToken cancellationToken) { }
    }
    public class AfterTestDiscoveryHookMethod : .<.TestDiscoveryContext>, <.>
    {
        public AfterTestDiscoveryHookMethod() { }
        public override . ExecuteAsync(.TestDiscoveryContext context, .CancellationToken cancellationToken) { }
    }
    public class AfterTestHookMethod : .<.TestContext>, <.>
    {
        public AfterTestHookMethod() { }
        public override . ExecuteAsync(.TestContext context, .CancellationToken cancellationToken) { }
    }
    public class AfterTestSessionHookMethod : .<.TestSessionContext>, <.>
    {
        public AfterTestSessionHookMethod() { }
        public override . ExecuteAsync(.TestSessionContext context, .CancellationToken cancellationToken) { }
    }
    public class BeforeAssemblyHookMethod : .<.AssemblyHookContext>, <.>
    {
        public BeforeAssemblyHookMethod() { }
        public override . ExecuteAsync(.AssemblyHookContext context, .CancellationToken cancellationToken) { }
    }
    public class BeforeClassHookMethod : .<.ClassHookContext>, <.>
    {
        public BeforeClassHookMethod() { }
        public override . ExecuteAsync(.ClassHookContext context, .CancellationToken cancellationToken) { }
    }
    public class BeforeTestDiscoveryHookMethod : .<.BeforeTestDiscoveryContext>, <.>
    {
        public BeforeTestDiscoveryHookMethod() { }
        public override . ExecuteAsync(.BeforeTestDiscoveryContext context, .CancellationToken cancellationToken) { }
    }
    public class BeforeTestHookMethod : .<.TestContext>, <.>
    {
        public BeforeTestHookMethod() { }
        public override . ExecuteAsync(.TestContext context, .CancellationToken cancellationToken) { }
    }
    public class BeforeTestSessionHookMethod : .<.TestSessionContext>, <.>
    {
        public BeforeTestSessionHookMethod() { }
        public override . ExecuteAsync(.TestSessionContext context, .CancellationToken cancellationToken) { }
    }
    public class HookMethod
    {
        public HookMethod(. instanceHookMethod) { }
        public HookMethod(. staticHookMethod) { }
        public .? InstanceHookMethod { get; }
        public .? StaticHookMethod { get; }
        public static . op_Implicit(. instanceHookMethod) { }
        public static . op_Implicit(. staticHookMethod) { }
    }
    public interface IExecutableHook<in T>
    {
        .MethodMetadata MethodInfo { get; }
        string Name { get; }
        int Order { get; }
        . ExecuteAsync(T context, .CancellationToken cancellationToken);
    }
    public interface IHookMessagePublisher
    {
        . Discover(string sessionId, string displayName, . hookMethod);
        . Push(string sessionId, string displayName, . hookMethod, <.> func);
    }
    public class InstanceHookMethod : <.>, .<.TestContext>
    {
        public InstanceHookMethod() { }
        public .Assembly Assembly { get; }
        public [] AssemblyAttributes { get; }
        public .<> Attributes { get; }
        public <object, .TestContext, .CancellationToken, .>? Body { get; init; }
        public [] ClassAttributes { get; }
        [.(..PublicMethods)]
        public required  ClassType { get; init; }
        public required . HookExecutor { get; init; }
        public [] MethodAttributes { get; }
        public required .MethodMetadata MethodInfo { get; init; }
        public string Name { get; }
        public required int Order { get; init; }
        public ? Timeout { get; }
        public . ExecuteAsync(.TestContext context, .CancellationToken cancellationToken) { }
        public TAttribute? GetAttribute<TAttribute>()
            where TAttribute :  { }
    }
    public class LastTestInAssemblyAdapter : .<.AssemblyHookContext>
    {
        public LastTestInAssemblyAdapter(. lastTestInAssemblyEventReceiver, .TestContext testContext) { }
        public .MethodMetadata MethodInfo { get; }
        public string Name { get; }
        public int Order { get; }
        public bool Execute(.AssemblyHookContext context, .CancellationToken cancellationToken) { }
        public . ExecuteAsync(.AssemblyHookContext context, .CancellationToken cancellationToken) { }
    }
    public class LastTestInClassAdapter : .<.ClassHookContext>
    {
        public LastTestInClassAdapter(. lastTestInClassEventReceiver, .TestContext testContext) { }
        public .MethodMetadata MethodInfo { get; }
        public string Name { get; }
        public int Order { get; }
        public bool Execute(.ClassHookContext context, .CancellationToken cancellationToken) { }
        public . ExecuteAsync(.ClassHookContext context, .CancellationToken cancellationToken) { }
    }
    public abstract class StaticHookMethod : <.>
    {
        protected StaticHookMethod() { }
        public .Assembly Assembly { get; }
        public [] AssemblyAttributes { get; }
        public .<> Attributes { get; }
        public [] ClassAttributes { get; }
        public  ClassType { get; }
        public required string FilePath { get; init; }
        public required . HookExecutor { get; init; }
        public required int LineNumber { get; init; }
        public [] MethodAttributes { get; }
        public required .MethodMetadata MethodInfo { get; init; }
        public string Name { get; }
        public required int Order { get; init; }
        public ? Timeout { get; }
        public TAttribute? GetAttribute<TAttribute>()
            where TAttribute :  { }
    }
    public abstract class StaticHookMethod<T> : ., <.<T>>, .<T>
    {
        protected StaticHookMethod() { }
        public <T, .CancellationToken, .>? Body { get; init; }
        public abstract . ExecuteAsync(T context, .CancellationToken cancellationToken);
    }
}
namespace .Interfaces
{
    public interface IAsyncInitializer
    {
        . InitializeAsync();
    }
    public interface IClassConstructor
    {
        object Create([.(..PublicConstructors)]  type, .ClassConstructorMetadata classConstructorMetadata);
    }
    public interface IConfiguration
    {
        string? Get(string key);
    }
    public interface IContext
    {
        .TextWriter ErrorOutputWriter { get; }
        .TextWriter OutputWriter { get; }
        . GetDefaultLogger();
    }
    public interface IEventReceiver
    {
        int Order { get; }
    }
    public interface IFirstTestInAssemblyEventReceiver : .
    {
        . OnFirstTestInAssembly(.AssemblyHookContext context, .TestContext testContext);
    }
    public interface IFirstTestInClassEventReceiver : .
    {
        . OnFirstTestInClass(.ClassHookContext context, .TestContext testContext);
    }
    public interface IFirstTestInTestSessionEventReceiver : .
    {
        . OnFirstTestInTestSession(.TestSessionContext current, .TestContext testContext);
    }
    public interface IHasLoggers
    {
        .<.> Loggers { get; }
    }
    public interface IHookExecutor
    {
        . ExecuteAfterAssemblyHook(.MethodMetadata hookMethodInfo, .AssemblyHookContext context, <.> action);
        . ExecuteAfterClassHook(.MethodMetadata hookMethodInfo, .ClassHookContext context, <.> action);
        . ExecuteAfterTestDiscoveryHook(.MethodMetadata hookMethodInfo, .TestDiscoveryContext context, <.> action);
        . ExecuteAfterTestHook(.MethodMetadata hookMethodInfo, .TestContext context, <.> action);
        . ExecuteAfterTestSessionHook(.MethodMetadata hookMethodInfo, .TestSessionContext context, <.> action);
        . ExecuteBeforeAssemblyHook(.MethodMetadata hookMethodInfo, .AssemblyHookContext context, <.> action);
        . ExecuteBeforeClassHook(.MethodMetadata hookMethodInfo, .ClassHookContext context, <.> action);
        . ExecuteBeforeTestDiscoveryHook(.MethodMetadata hookMethodInfo, .BeforeTestDiscoveryContext context, <.> action);
        . ExecuteBeforeTestHook(.MethodMetadata hookMethodInfo, .TestContext context, <.> action);
        . ExecuteBeforeTestSessionHook(.MethodMetadata hookMethodInfo, .TestSessionContext context, <.> action);
    }
    public interface ILastTestInAssemblyEventReceiver : .
    {
        . OnLastTestInAssembly(.AssemblyHookContext context, .TestContext testContext);
    }
    public interface ILastTestInClassEventReceiver : .
    {
        . OnLastTestInClass(.ClassHookContext context, .TestContext testContext);
    }
    public interface ILastTestInTestSessionEventReceiver : .
    {
        . OnLastTestInTestSession(.TestSessionContext current, .TestContext testContext);
    }
    public interface IParallelConstraint { }
    public interface IParallelLimit
    {
        int Limit { get; }
    }
    public interface ITestDiscoveryEventReceiver : .
    {
        void OnTestDiscovery(.DiscoveredTestContext discoveredTestContext);
    }
    public interface ITestEndEventReceiver : .
    {
        . OnTestEnd(.AfterTestContext afterTestContext);
    }
    public interface ITestExecutor
    {
        . ExecuteTest(.TestContext context, <.> action);
    }
    public interface ITestFinder
    {
        .<.TestContext> GetTests( classType);
        .TestContext[] GetTestsByNameAndParameters(string testName, .<> methodParameterTypes,  classType, .<> classParameterTypes, .<object?> classArguments);
    }
    public interface ITestRegisteredEventReceiver : .
    {
        . OnTestRegistered(.TestRegisteredContext context);
    }
    public interface ITestRetryEventReceiver : .
    {
        . OnTestRetry(.TestContext testContext, int retryAttempt);
    }
    public interface ITestSkippedEventReceiver : .
    {
        . OnTestSkipped(.TestContext testContext);
    }
    public interface ITestStartEventReceiver : .
    {
        . OnTestStart(.BeforeTestContext beforeTestContext);
    }
}
namespace .
{
    public interface IAssemblyHookSource
    {
        .<.<.AssemblyHookContext>> CollectAfterAssemblyHooks(string sessionId);
        .<.<.AssemblyHookContext>> CollectAfterEveryAssemblyHooks(string sessionId);
        .<.<.AssemblyHookContext>> CollectBeforeAssemblyHooks(string sessionId);
        .<.<.AssemblyHookContext>> CollectBeforeEveryAssemblyHooks(string sessionId);
    }
    public interface IClassHookSource
    {
        .<.<.ClassHookContext>> CollectAfterClassHooks(string sessionId);
        .<.<.ClassHookContext>> CollectAfterEveryClassHooks(string sessionId);
        .<.<.ClassHookContext>> CollectBeforeClassHooks(string sessionId);
        .<.<.ClassHookContext>> CollectBeforeEveryClassHooks(string sessionId);
    }
    public interface IDynamicTestSource
    {
        .<.DynamicTest> CollectDynamicTests(string sessionId);
    }
    public interface IPropertySource
    {
        string PropertyName { get; }
        bool ShouldInitialize { get; }
         Type { get; }
        . InitializeAsync(object instance);
    }
    public interface ITestDiscoveryHookSource
    {
        .<.<.TestDiscoveryContext>> CollectAfterTestDiscoveryHooks(string sessionId);
        .<.<.BeforeTestDiscoveryContext>> CollectBeforeTestDiscoveryHooks(string sessionId);
    }
    public interface ITestHookSource
    {
        .<.<.TestContext>> CollectAfterEveryTestHooks(string sessionId);
        .<.> CollectAfterTestHooks(string sessionId);
        .<.<.TestContext>> CollectBeforeEveryTestHooks(string sessionId);
        .<.> CollectBeforeTestHooks(string sessionId);
    }
    public interface ITestSessionHookSource
    {
        .<.<.TestSessionContext>> CollectAfterTestSessionHooks(string sessionId);
        .<.<.TestSessionContext>> CollectBeforeTestSessionHooks(string sessionId);
    }
    public interface ITestSource
    {
        .<.DiscoveryResult> DiscoverTestsAsync(string sessionId);
    }
}
namespace .Logging
{
    public class DefaultLogger : .
    {
        public DefaultLogger(.Context context) { }
        public override void Log<TState>(. logLevel, TState state, ? exception, <TState, ?, string> formatter) { }
        public override . LogAsync<TState>(. logLevel, TState state, ? exception, <TState, ?, string> formatter) { }
        public void PushProperties(.<string, .<object>> dictionary) { }
        public void PushProperty(string name, object? value) { }
    }
    public interface ILogger
    {
        bool IsEnabled(. logLevel);
        void Log<TState>(. logLevel, TState state, ? exception, <TState, ?, string> formatter);
        . LogAsync<TState>(. logLevel, TState state, ? exception, <TState, ?, string> formatter);
    }
    public interface ILogger<out TCategoryName> : . { }
    public enum LogLevel
    {
        Trace = 0,
        Debug = 1,
        Information = 2,
        Warning = 3,
        Error = 4,
        Critical = 5,
        None = 6,
    }
    public static class LoggingExtensions
    {
        public static void LogCritical(this . logger, string message) { }
        public static . LogCriticalAsync(this . logger, string message) { }
        public static void LogDebug(this . logger, string message) { }
        public static . LogDebugAsync(this . logger, string message) { }
        public static void LogError(this . logger,  ex) { }
        public static void LogError(this . logger, string message) { }
        public static void LogError(this . logger, string message,  ex) { }
        public static . LogErrorAsync(this . logger,  ex) { }
        public static . LogErrorAsync(this . logger, string message) { }
        public static . LogErrorAsync(this . logger, string message,  ex) { }
        public static void LogInformation(this . logger, string message) { }
        public static . LogInformationAsync(this . logger, string message) { }
        public static void LogTrace(this . logger, string message) { }
        public static . LogTraceAsync(this . logger, string message) { }
        public static void LogWarning(this . logger, string message) { }
        public static . LogWarningAsync(this . logger, string message) { }
    }
    public abstract class TUnitLogger : .
    {
        protected TUnitLogger() { }
        public virtual bool IsEnabled(. logLevel) { }
        public abstract void Log<TState>(. logLevel, TState state, ? exception, <TState, ?, string> formatter);
        public abstract . LogAsync<TState>(. logLevel, TState state, ? exception, <TState, ?, string> formatter);
    }
}
namespace .SourceGenerator
{
    public static class TestSourceRegistrar
    {
        [("Use RegisterTests instead")]
        public static void RegisterMetadata(.<.DynamicTestMetadata> testMetadata) { }
        public static void RegisterTests(.<.ITestDescriptor> testDescriptors) { }
    }
}