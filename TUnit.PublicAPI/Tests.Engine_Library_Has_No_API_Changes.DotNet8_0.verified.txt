[assembly: .(@", PublicKey=0024000004800000940000000602000000240000525341310004000001000100698a70398fa0b2230c5a72e3bd9d56b48f809f6173e49a19fbb942d621be93ad48c5566b47b28faabc359b9ad3ff4e00bbdea88f5bdfa250f391fedd28182b2e37b55d429c0151a42a98ea7a5821818cd15a79fef9903e8607a88304cf3e0317bf86ec96e32e1381535a6582251e5a6eed40b5a3ed82bc444598b1269cce57a7")]
[assembly: .(@", PublicKey=0024000004800000940000000602000000240000525341310004000001000100698a70398fa0b2230c5a72e3bd9d56b48f809f6173e49a19fbb942d621be93ad48c5566b47b28faabc359b9ad3ff4e00bbdea88f5bdfa250f391fedd28182b2e37b55d429c0151a42a98ea7a5821818cd15a79fef9903e8607a88304cf3e0317bf86ec96e32e1381535a6582251e5a6eed40b5a3ed82bc444598b1269cce57a7")]
[assembly: .(".NETCoreApp,Version=v8.0", FrameworkDisplayName=".NET 8.0")]
namespace .
{
    public interface ITestDataCollector
    {
        .<.<.TestMetadata>> CollectTestsAsync(string testSessionId);
    }
}
namespace .Capabilities
{
    [.("TPEXP")]
    public class StopExecutionCapability : ..ICapability, .., ..
    {
        public StopExecutionCapability() { }
        public bool IsStopRequested { get; }
        public .AsyncEvent<>? OnStopRequested { get; set; }
        public . StopTestExecutionAsync(.CancellationToken cancellationToken) { }
    }
}
namespace .Configuration
{
    public static class DiscoveryConfiguration
    {
        public static  DataSourceTimeout { get; set; }
        public static  DiscoveryTimeout { get; set; }
        public static bool EnableDiagnostics { get; set; }
        public static void ConfigureFromEnvironment() { }
        public static . CreateCircuitBreaker() { }
    }
}
namespace .Enums
{
    public enum EngineMode
    {
        SourceGenerated = 0,
        Reflection = 1,
    }
}
namespace .Exceptions
{
    public class HookFailedException : .
    {
        public HookFailedException( exception) { }
        public HookFailedException(string? message, ? innerException) { }
    }
    public abstract class TUnitFailedException : .
    {
        protected TUnitFailedException( exception) { }
        protected TUnitFailedException(string? message, ? innerException) { }
        public override string StackTrace { get; }
    }
    public class TestFailedException : .
    {
        public TestFailedException( exception) { }
        public TestFailedException(string? message, ? innerException) { }
    }
}
namespace .Extensions
{
    public static class JsonExtensions
    {
        public static . ToJsonModel(this  exception) { }
        public static . ToJsonModel(this .AssemblyHookContext context) { }
        public static . ToJsonModel(this .ClassHookContext context) { }
        public static . ToJsonModel(this .TestContext context) { }
        public static . ToJsonModel(this .TestResult result) { }
        public static . ToJsonModel(this .TestSessionContext context) { }
    }
    public static class TestApplicationBuilderExtensions
    {
        public static void AddTUnit(this ..ITestApplicationBuilder testApplicationBuilder) { }
    }
}
namespace .Framework
{
    public interface IFilterReceiver
    {
        string? Filter { set; }
    }
    public static class TestingPlatformBuilderHook
    {
        public static void AddExtensions(..ITestApplicationBuilder testApplicationBuilder, string[] _) { }
    }
}
namespace .Helpers
{
    public class DataUnwrapper
    {
        public DataUnwrapper() { }
        public static object?[] Unwrap(object?[] values) { }
    }
    public static class DotNetAssemblyHelper
    {
        public static bool IsDotNetCoreLibrary(byte[]? publicKeyToken) { }
        public static bool IsInDotNetCoreLibrary( type) { }
    }
}
namespace 
{
    public interface ITestMetadataScanner
    {
        .<.<.TestMetadata>> ScanAssembly(.Assembly assembly);
    }
    public static class TestNodeProperties
    {
        public static readonly string DisplayName;
        public static readonly string FullyQualifiedName;
        public static readonly string TestFileLocation;
        public static readonly string Traits;
    }
    public class Trait
    {
        public Trait(string name, string value) { }
        public string Name { get; }
        public string Value { get; }
    }
}
namespace .Interfaces
{
    public interface IDataSourceResolver
    {
        .<.<object?[]>> ResolveDataAsync(.IDataSourceAttribute dataSource);
        .<.<object?[]>> ResolveDataSource(.IDataSourceAttribute dataSource);
        .<object?> ResolvePropertyDataAsync(.PropertyDataSource propertyDataSource);
    }
    public interface IExecutableTestFactory
    {
        .AbstractExecutableTest CreateExecutableTest(string testId, string displayName, object[] arguments, object[] classArguments, .<string, object?> propertyValues, <.TestContext, .CancellationToken, .>[] beforeTestHooks, <.TestContext, .CancellationToken, .>[] afterTestHooks, .TestContext context, .TestMetadata metadata);
    }
    public interface IHookCollectionService
    {
        .<.<<.AssemblyHookContext, .CancellationToken, .>>> CollectAfterAssemblyHooksAsync(.Assembly assembly);
        .<.<<.ClassHookContext, .CancellationToken, .>>> CollectAfterClassHooksAsync( testClassType);
        .<.<<.AssemblyHookContext, .CancellationToken, .>>> CollectAfterEveryAssemblyHooksAsync();
        .<.<<.ClassHookContext, .CancellationToken, .>>> CollectAfterEveryClassHooksAsync();
        .<.<<.TestContext, .CancellationToken, .>>> CollectAfterEveryTestHooksAsync( testClassType);
        .<.<<.TestDiscoveryContext, .CancellationToken, .>>> CollectAfterTestDiscoveryHooksAsync();
        .<.<<.TestContext, .CancellationToken, .>>> CollectAfterTestHooksAsync( testClassType);
        .<.<<.TestSessionContext, .CancellationToken, .>>> CollectAfterTestSessionHooksAsync();
        .<.<<.AssemblyHookContext, .CancellationToken, .>>> CollectBeforeAssemblyHooksAsync(.Assembly assembly);
        .<.<<.ClassHookContext, .CancellationToken, .>>> CollectBeforeClassHooksAsync( testClassType);
        .<.<<.AssemblyHookContext, .CancellationToken, .>>> CollectBeforeEveryAssemblyHooksAsync();
        .<.<<.ClassHookContext, .CancellationToken, .>>> CollectBeforeEveryClassHooksAsync();
        .<.<<.TestContext, .CancellationToken, .>>> CollectBeforeEveryTestHooksAsync( testClassType);
        .<.<<.BeforeTestDiscoveryContext, .CancellationToken, .>>> CollectBeforeTestDiscoveryHooksAsync();
        .<.<<.TestContext, .CancellationToken, .>>> CollectBeforeTestHooksAsync( testClassType);
        .<.<<.TestSessionContext, .CancellationToken, .>>> CollectBeforeTestSessionHooksAsync();
    }
    public interface ISingleTestExecutor
    {
        .<..> ExecuteTestAsync(.AbstractExecutableTest test, .CancellationToken cancellationToken);
    }
    public interface ITestExecutor
    {
        . ExecuteTests(.<.AbstractExecutableTest> tests, ..ITestExecutionFilter? filter, ..IMessageBus messageBus, .CancellationToken cancellationToken);
    }
}
namespace .Json
{
    public class ExceptionJson : <.>
    {
        public ExceptionJson() { }
        public required .? InnerException { get; init; }
        public required string Message { get; init; }
        public required string? Stacktrace { get; init; }
        public required string? Type { get; init; }
    }
    public class TestAssemblyJson : <.>
    {
        public TestAssemblyJson() { }
        public required string? AssemblyName { get; init; }
        public required .[] Classes { get; init; }
    }
    public class TestClassJson : <.>
    {
        public TestClassJson() { }
        public required .[] Tests { get; init; }
        public required string? Type { get; init; }
    }
    public class TestJson : <.>
    {
        public TestJson() { }
        public required .<string> Categories { get; init; }
        public required string? ClassType { get; init; }
        public required .<string, .<string>> CustomProperties { get; init; }
        public required string DisplayName { get; set; }
        public required .<string, object?> ObjectBag { get; init; }
        public required .? Result { get; set; }
        public required int RetryLimit { get; init; }
        public required string? ReturnType { get; init; }
        public required object?[]? TestClassArguments { get; init; }
        public required string?[]? TestClassParameterTypes { get; init; }
        public required string TestFilePath { get; init; }
        public required string TestId { get; init; }
        public required int TestLineNumber { get; init; }
        public required object?[]? TestMethodArguments { get; init; }
        public required string?[]? TestMethodParameterTypes { get; init; }
        public required string TestName { get; init; }
        public required ? Timeout { get; init; }
    }
    public class TestResultJson : <.>
    {
        public TestResultJson() { }
        public required string ComputerName { get; init; }
        public required ? Duration { get; init; }
        public required ? End { get; init; }
        public required .? Exception { get; init; }
        public required string? Output { get; init; }
        public required ? Start { get; init; }
        public required .TestState Status { get; init; }
    }
    public class TestSessionJson : <.>
    {
        public TestSessionJson() { }
        public required .[] Assemblies { get; init; }
    }
}
namespace .Logging
{
    public class TUnitFrameworkLogger : ..IExtension, .., .
    {
        public TUnitFrameworkLogger(..IExtension extension, ..IOutputDevice outputDevice, ..ILogger logger, . verbosityService) { }
        public string Description { get; }
        public string DisplayName { get; }
        public string Uid { get; }
        public string Version { get; }
        public bool IsEnabled(. logLevel) { }
        public .<bool> IsEnabledAsync() { }
        public void Log<TState>(. logLevel, TState state, ? exception, <TState, ?, string> formatter) { }
        public . LogAsync<TState>(. logLevel, TState state, ? exception, <TState, ?, string> formatter) { }
        public . LogErrorAsync( exception) { }
        public . LogErrorAsync(string message) { }
    }
    public enum TUnitVerbosity
    {
        Minimal = 0,
        Normal = 1,
        Verbose = 2,
        Debug = 3,
    }
    public static class TUnitVerbosityExtensions
    {
        public static bool Includes(this . current, . level) { }
        public static string ToDisplayString(this . verbosity) { }
    }
}
namespace .Reporters
{
    public class GitHubReporter : ..IExtension, .., .., .., .., .
    {
        public GitHubReporter(..IExtension extension) { }
        public [] DataTypesConsumed { get; }
        public string Description { get; }
        public string DisplayName { get; }
        public string? Filter { get; set; }
        public string Uid { get; }
        public string Version { get; }
        public . AfterRunAsync(int exitCode, .CancellationToken cancellation) { }
        public . BeforeRunAsync(.CancellationToken cancellationToken) { }
        public . ConsumeAsync(.. dataProducer, .. value, .CancellationToken cancellationToken) { }
        public .<bool> IsEnabledAsync() { }
    }
}
namespace .Scheduling
{
    public interface ITestExecutor
    {
        . ExecuteTestAsync(.AbstractExecutableTest test, .CancellationToken cancellationToken);
    }
    public interface ITestScheduler
    {
        . ScheduleAndExecuteAsync(.<.AbstractExecutableTest> tests, . executor, .CancellationToken cancellationToken);
    }
    public enum ParallelismStrategy
    {
        Fixed = 0,
        Adaptive = 1,
    }
}
namespace .Services
{
    public sealed class DiscoveryCircuitBreaker
    {
        public DiscoveryCircuitBreaker(double maxMemoryPercentage = 0.7, ? maxGenerationTime = default) { }
        public string CreateResourceReport(int testCount) { }
        public void Dispose() { }
        public . GetResourceUsage() { }
        public bool ShouldContinue(int currentTestCount = 0) { }
    }
    public class DiscoveryResourceUsage : <.>
    {
        public DiscoveryResourceUsage() { }
        public  ElapsedTime { get; init; }
        public long MaxMemoryBytes { get; init; }
        public  MaxTime { get; init; }
        public long MemoryGrowthBytes { get; init; }
        public double MemoryUsagePercentage { get; init; }
        public double TimeUsagePercentage { get; init; }
    }
    public class FilterParser
    {
        public FilterParser() { }
        public string? GetTestFilter(.. context) { }
        public static string? StringifyFilter(..ITestExecutionFilter filter) { }
    }
    public class LogLevelProvider
    {
        public LogLevelProvider(..ICommandLineOptions commandLineOptions) { }
        public . LogLevel { get; }
    }
    public sealed class VerbosityService
    {
        public VerbosityService(..ICommandLineOptions commandLineOptions) { }
        public . CurrentVerbosity { get; }
        public bool EnableDiscoveryDiagnostics { get; }
        public bool EnableVerboseSourceGeneratorDiagnostics { get; }
        public bool HideTestOutput { get; }
        public bool ShowDetailedStackTrace { get; }
        public bool ShowDiscoveryProgress { get; }
        public bool ShowExecutionTiming { get; }
        public bool ShowLogo { get; }
        public bool ShowParallelExecutionDetails { get; }
        public bool ShowResourceUsage { get; }
        public string CreateVerbositySummary() { }
    }
}