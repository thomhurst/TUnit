using TUnit.Mocks.SourceGenerator.Models;

namespace TUnit.Mocks.SourceGenerator.Builders;

internal static class MockVerifyBuilder
{
    public static string Build(MockTypeModel model)
    {
        var writer = new CodeWriter();
        var safeName = MockImplBuilder.GetSafeName(model.FullyQualifiedName);

        writer.AppendLine("// <auto-generated/>");
        writer.AppendLine("#nullable enable");
        writer.AppendLine();

        using (writer.Block("namespace TUnit.Mocks.Generated"))
        {
            // Data holder class implementing marker interface
            using (writer.Block($"public sealed class {safeName}_MockVerify : global::TUnit.Mocks.IMockVerify<{model.FullyQualifiedName}>"))
            {
                writer.AppendLine($"internal readonly global::TUnit.Mocks.MockEngine<{model.FullyQualifiedName}> Engine;");
                writer.AppendLine();
                writer.AppendLine($"internal {safeName}_MockVerify(global::TUnit.Mocks.MockEngine<{model.FullyQualifiedName}> engine) => Engine = engine;");
            }

            writer.AppendLine();

            // Extension methods class
            using (writer.Block($"public static class {safeName}_MockVerifyExtensions"))
            {
                bool firstMember = true;

                // Methods
                foreach (var method in model.Methods)
                {
                    if (!firstMember) writer.AppendLine();
                    firstMember = false;
                    GenerateVerifyMethod(writer, method, model, safeName);
                }

                // Properties â€” extension properties via C# 14 extension blocks
                var verifyProps = model.Properties
                    .Where(p => !p.IsIndexer && (p.HasGetter || p.HasSetter))
                    .ToList();
                if (verifyProps.Count > 0)
                {
                    if (!firstMember) writer.AppendLine();
                    firstMember = false;
                    GenerateVerifyPropertyExtensionBlock(writer, verifyProps, model, safeName);
                }
            }
        }

        return writer.ToString();
    }

    private static void GenerateVerifyMethod(CodeWriter writer, MockMemberModel method, MockTypeModel model, string safeName)
    {
        var paramList = GetArgParameterList(method);
        var typeParams = GetTypeParameterList(method);
        var constraints = GetConstraintClauses(method);

        var extensionParam = $"this global::TUnit.Mocks.IMockVerify<{model.FullyQualifiedName}> verify";
        var fullParamList = string.IsNullOrEmpty(paramList) ? extensionParam : $"{extensionParam}, {paramList}";

        using (writer.Block($"public static global::TUnit.Mocks.Verification.ICallVerification {method.Name}{typeParams}({fullParamList}){constraints}"))
        {
            writer.AppendLine($"var v = ({safeName}_MockVerify)verify;");

            // Build matchers array
            var nonOutParams = method.Parameters.Where(p => p.Direction != ParameterDirection.Out).ToList();

            if (nonOutParams.Count == 0)
            {
                writer.AppendLine("var matchers = global::System.Array.Empty<global::TUnit.Mocks.Arguments.IArgumentMatcher>();");
            }
            else
            {
                var matcherArgs = string.Join(", ", nonOutParams.Select(p => $"{p.Name}.Matcher"));
                writer.AppendLine($"var matchers = new global::TUnit.Mocks.Arguments.IArgumentMatcher[] {{ {matcherArgs} }};");
            }

            writer.AppendLine($"return new global::TUnit.Mocks.Verification.CallVerificationBuilder<{model.FullyQualifiedName}>(v.Engine, {method.MemberId}, \"{method.Name}\", matchers);");
        }
    }

    private static void GenerateVerifyPropertyExtensionBlock(CodeWriter writer, List<MockMemberModel> props, MockTypeModel model, string safeName)
    {
        using (writer.Block($"extension(global::TUnit.Mocks.IMockVerify<{model.FullyQualifiedName}> verify)"))
        {
            bool first = true;
            foreach (var prop in props)
            {
                if (!first) writer.AppendLine();
                first = false;

                var getterMemberId = prop.HasGetter ? prop.MemberId.ToString() : "0";
                var setterMemberId = prop.HasSetter ? prop.SetterMemberId.ToString() : "0";
                var hasGetter = prop.HasGetter ? "true" : "false";
                var hasSetter = prop.HasSetter ? "true" : "false";

                writer.AppendLine($"public global::TUnit.Mocks.Verification.PropertyVerifyAccessor<{prop.ReturnType}> {prop.Name}");
                writer.AppendLine($"    => new((({safeName}_MockVerify)verify).Engine, {getterMemberId}, {setterMemberId}, \"{prop.Name}\", {hasGetter}, {hasSetter});");
            }
        }
    }

    private static string GetArgParameterList(MockMemberModel method)
    {
        return string.Join(", ", method.Parameters
            .Where(p => p.Direction != ParameterDirection.Out)
            .Select(p => $"global::TUnit.Mocks.Arguments.Arg<{p.FullyQualifiedType}> {p.Name}"));
    }

    private static string GetTypeParameterList(MockMemberModel method)
    {
        if (method.TypeParameters.Length == 0) return "";
        return "<" + string.Join(", ", method.TypeParameters.Select(tp => tp.Name)) + ">";
    }

    private static string GetConstraintClauses(MockMemberModel method)
    {
        var clauses = new List<string>();
        foreach (var tp in method.TypeParameters)
        {
            if (!string.IsNullOrEmpty(tp.Constraints))
            {
                clauses.Add($"where {tp.Name} : {tp.Constraints}");
            }
        }
        return clauses.Count > 0 ? " " + string.Join(" ", clauses) : "";
    }
}
