using TUnit.Mocks.SourceGenerator.Models;

namespace TUnit.Mocks.SourceGenerator.Builders;

internal static class MockSetupBuilder
{
    private const int MaxTypedParams = 8;

    public static string Build(MockTypeModel model)
    {
        var writer = new CodeWriter();
        var safeName = MockImplBuilder.GetSafeName(model.FullyQualifiedName);
        var hasEvents = model.Events.Length > 0;

        writer.AppendLine("// <auto-generated/>");
        writer.AppendLine("#nullable enable");
        writer.AppendLine();

        using (writer.Block("namespace TUnit.Mocks.Generated"))
        {
            // Data holder class implementing marker interface
            using (writer.Block($"public sealed class {safeName}_MockSetup : global::TUnit.Mocks.IMockSetup<{model.FullyQualifiedName}>"))
            {
                writer.AppendLine($"internal readonly global::TUnit.Mocks.MockEngine<{model.FullyQualifiedName}> Engine;");
                writer.AppendLine();
                writer.AppendLine($"internal {safeName}_MockSetup(global::TUnit.Mocks.MockEngine<{model.FullyQualifiedName}> engine) => Engine = engine;");
            }

            writer.AppendLine();

            // Extension methods class
            using (writer.Block($"public static class {safeName}_MockSetupExtensions"))
            {
                bool firstMember = true;

                // Methods
                foreach (var method in model.Methods)
                {
                    if (!firstMember) writer.AppendLine();
                    firstMember = false;
                    GenerateSetupMethod(writer, method, model, safeName);
                }

                // Properties — extension properties via C# 14 extension blocks
                var setupProps = model.Properties
                    .Where(p => !p.IsIndexer && (p.HasGetter || p.HasSetter))
                    .ToList();
                if (setupProps.Count > 0)
                {
                    if (!firstMember) writer.AppendLine();
                    firstMember = false;
                    GenerateSetupPropertyExtensionBlock(writer, setupProps, model, safeName);
                }
            }

            // Generate typed wrapper structs for qualifying methods
            foreach (var method in model.Methods)
            {
                if (!ShouldGenerateTypedWrapper(method, hasEvents)) continue;
                writer.AppendLine();
                GenerateTypedWrapperStruct(writer, method, safeName, model.Events);
            }
        }

        return writer.ToString();
    }

    private static bool ShouldGenerateTypedWrapper(MockMemberModel method, bool hasEvents)
    {
        if (method.IsGenericMethod) return false;

        var nonOutParams = method.Parameters.Where(p => p.Direction != ParameterDirection.Out).ToList();
        if (nonOutParams.Count == 0) return hasEvents;
        return nonOutParams.Count <= MaxTypedParams;
    }

    private static string GetWrapperName(string safeName, MockMemberModel method)
        => $"{safeName}_{method.Name}_M{method.MemberId}_TypedSetup";

    private static void GenerateTypedWrapperStruct(CodeWriter writer, MockMemberModel method, string safeName,
        EquatableArray<MockEventModel> events)
    {
        var setupReturnType = method.IsAsync && !method.IsVoid
            ? method.UnwrappedReturnType
            : method.ReturnType;

        var wrapperName = GetWrapperName(safeName, method);
        var nonOutParams = method.Parameters.Where(p => p.Direction != ParameterDirection.Out).ToList();

        if (method.IsVoid)
        {
            GenerateVoidTypedWrapper(writer, wrapperName, nonOutParams, events);
        }
        else
        {
            GenerateReturnTypedWrapper(writer, wrapperName, nonOutParams, setupReturnType, events);
        }
    }

    private static void GenerateReturnTypedWrapper(CodeWriter writer, string wrapperName,
        List<MockParameterModel> nonOutParams, string returnType, EquatableArray<MockEventModel> events)
    {
        var chainType = $"global::TUnit.Mocks.Setup.ISetupChain<{returnType}>";
        var setupInterface = $"global::TUnit.Mocks.Setup.IMethodSetup<{returnType}>";
        var builderType = $"global::TUnit.Mocks.Setup.MethodSetupBuilder<{returnType}>";

        // Only implement both interfaces when there are events — the dual-interface pattern
        // preserves the concrete wrapper type through the chain so RaisesX() stays accessible.
        var interfaces = events.Length > 0 ? $" : {setupInterface}, {chainType}" : "";

        writer.AppendLine("[global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]");
        using (writer.Block($"public readonly struct {wrapperName}{interfaces}"))
        {
            writer.AppendLine($"private readonly {builderType} _inner;");
            writer.AppendLine();
            writer.AppendLine($"internal {wrapperName}({builderType} inner) => _inner = inner;");

            if (events.Length > 0)
            {
                writer.AppendLine();

                // Explicit IMethodSetup<TReturn> implementations
                writer.AppendLine($"{chainType} {setupInterface}.Returns({returnType} value) => _inner.Returns(value);");
                writer.AppendLine($"{chainType} {setupInterface}.Returns(global::System.Func<{returnType}> factory) => _inner.Returns(factory);");
                writer.AppendLine($"{chainType} {setupInterface}.ReturnsSequentially(params {returnType}[] values) => _inner.ReturnsSequentially(values);");
                writer.AppendLine($"{chainType} {setupInterface}.Throws<TException>() => _inner.Throws<TException>();");
                writer.AppendLine($"{chainType} {setupInterface}.Throws(global::System.Exception exception) => _inner.Throws(exception);");
                writer.AppendLine($"{chainType} {setupInterface}.Callback(global::System.Action callback) => _inner.Callback(callback);");
                writer.AppendLine($"{chainType} {setupInterface}.Callback(global::System.Action<object?[]> callback) => _inner.Callback(callback);");
                writer.AppendLine($"{chainType} {setupInterface}.Returns(global::System.Func<object?[], {returnType}> factory) => _inner.Returns(factory);");
                writer.AppendLine($"{chainType} {setupInterface}.Throws(global::System.Func<object?[], global::System.Exception> exceptionFactory) => _inner.Throws(exceptionFactory);");
                writer.AppendLine($"{chainType} {setupInterface}.Raises(string eventName, object? args) => _inner.Raises(eventName, args);");
                writer.AppendLine($"{chainType} {setupInterface}.SetsOutParameter(int paramIndex, object? value) => _inner.SetsOutParameter(paramIndex, value);");
                writer.AppendLine($"{chainType} {setupInterface}.TransitionsTo(string stateName) => _inner.TransitionsTo(stateName);");
                writer.AppendLine();

                // Explicit ISetupChain<TReturn> implementations
                writer.AppendLine($"{setupInterface} {chainType}.Then() {{ _inner.Then(); return this; }}");
                writer.AppendLine($"{chainType} {chainType}.Raises(string eventName, object? args) => _inner.Raises(eventName, args);");
                writer.AppendLine($"{chainType} {chainType}.SetsOutParameter(int paramIndex, object? value) => _inner.SetsOutParameter(paramIndex, value);");
                writer.AppendLine($"{chainType} {chainType}.TransitionsTo(string stateName) => _inner.TransitionsTo(stateName);");
            }

            writer.AppendLine();

            // Public self-returning methods (preserve wrapper type through fluent chain)
            writer.AppendLine($"/// <inheritdoc />");
            writer.AppendLine($"public {wrapperName} Returns({returnType} value) {{ _inner.Returns(value); return this; }}");
            writer.AppendLine($"/// <inheritdoc />");
            writer.AppendLine($"public {wrapperName} Returns(global::System.Func<{returnType}> factory) {{ _inner.Returns(factory); return this; }}");
            writer.AppendLine($"/// <inheritdoc />");
            writer.AppendLine($"public {wrapperName} ReturnsSequentially(params {returnType}[] values) {{ _inner.ReturnsSequentially(values); return this; }}");
            writer.AppendLine($"/// <inheritdoc />");
            writer.AppendLine($"public {wrapperName} Throws<TException>() where TException : global::System.Exception, new() {{ _inner.Throws<TException>(); return this; }}");
            writer.AppendLine($"/// <inheritdoc />");
            writer.AppendLine($"public {wrapperName} Throws(global::System.Exception exception) {{ _inner.Throws(exception); return this; }}");
            writer.AppendLine($"/// <inheritdoc />");
            writer.AppendLine($"public {wrapperName} Callback(global::System.Action callback) {{ _inner.Callback(callback); return this; }}");
            writer.AppendLine($"/// <inheritdoc />");
            writer.AppendLine($"public {wrapperName} Callback(global::System.Action<object?[]> callback) {{ _inner.Callback(callback); return this; }}");
            writer.AppendLine($"/// <inheritdoc />");
            writer.AppendLine($"public {wrapperName} Returns(global::System.Func<object?[], {returnType}> factory) {{ _inner.Returns(factory); return this; }}");
            writer.AppendLine($"/// <inheritdoc />");
            writer.AppendLine($"public {wrapperName} Throws(global::System.Func<object?[], global::System.Exception> exceptionFactory) {{ _inner.Throws(exceptionFactory); return this; }}");
            writer.AppendLine($"/// <inheritdoc />");
            writer.AppendLine($"public {wrapperName} Raises(string eventName, object? args = null) {{ _inner.Raises(eventName, args); return this; }}");
            writer.AppendLine($"/// <inheritdoc />");
            writer.AppendLine($"public {wrapperName} SetsOutParameter(int paramIndex, object? value) {{ _inner.SetsOutParameter(paramIndex, value); return this; }}");
            writer.AppendLine($"/// <inheritdoc />");
            writer.AppendLine($"public {wrapperName} TransitionsTo(string stateName) {{ _inner.TransitionsTo(stateName); return this; }}");
            writer.AppendLine($"/// <inheritdoc />");
            writer.AppendLine($"public {wrapperName} Then() {{ _inner.Then(); return this; }}");

            // Typed parameter overloads (only for methods with typed params)
            if (nonOutParams.Count >= 1)
            {
                writer.AppendLine();
                GenerateTypedReturnsOverload(writer, nonOutParams, returnType, wrapperName);
                writer.AppendLine();
                GenerateTypedCallbackOverload(writer, nonOutParams, wrapperName);
                writer.AppendLine();
                GenerateTypedThrowsOverload(writer, nonOutParams, wrapperName);
            }

            // Typed event raises
            if (events.Length > 0)
            {
                writer.AppendLine();
                GenerateTypedEventRaises(writer, events, wrapperName);
            }
        }
    }

    private static void GenerateVoidTypedWrapper(CodeWriter writer, string wrapperName,
        List<MockParameterModel> nonOutParams, EquatableArray<MockEventModel> events)
    {
        var chainType = "global::TUnit.Mocks.Setup.IVoidSetupChain";
        var setupInterface = "global::TUnit.Mocks.Setup.IVoidMethodSetup";
        var builderType = "global::TUnit.Mocks.Setup.VoidMethodSetupBuilder";

        // Only implement both interfaces when there are events — the dual-interface pattern
        // preserves the concrete wrapper type through the chain so RaisesX() stays accessible.
        var interfaces = events.Length > 0 ? $" : {setupInterface}, {chainType}" : "";

        writer.AppendLine($"[global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]");
        using (writer.Block($"public readonly struct {wrapperName}{interfaces}"))
        {
            writer.AppendLine($"private readonly {builderType} _inner;");
            writer.AppendLine();
            writer.AppendLine($"internal {wrapperName}({builderType} inner) => _inner = inner;");

            if (events.Length > 0)
            {
                writer.AppendLine();

                // Explicit IVoidMethodSetup implementations
                writer.AppendLine($"{chainType} {setupInterface}.Throws<TException>() => _inner.Throws<TException>();");
                writer.AppendLine($"{chainType} {setupInterface}.Throws(global::System.Exception exception) => _inner.Throws(exception);");
                writer.AppendLine($"{chainType} {setupInterface}.Callback(global::System.Action callback) => _inner.Callback(callback);");
                writer.AppendLine($"{chainType} {setupInterface}.Callback(global::System.Action<object?[]> callback) => _inner.Callback(callback);");
                writer.AppendLine($"{chainType} {setupInterface}.Throws(global::System.Func<object?[], global::System.Exception> exceptionFactory) => _inner.Throws(exceptionFactory);");
                writer.AppendLine($"{chainType} {setupInterface}.Raises(string eventName, object? args) => _inner.Raises(eventName, args);");
                writer.AppendLine($"{chainType} {setupInterface}.SetsOutParameter(int paramIndex, object? value) => _inner.SetsOutParameter(paramIndex, value);");
                writer.AppendLine($"{chainType} {setupInterface}.TransitionsTo(string stateName) => _inner.TransitionsTo(stateName);");
                writer.AppendLine();

                // Explicit IVoidSetupChain implementations
                writer.AppendLine($"{setupInterface} {chainType}.Then() {{ _inner.Then(); return this; }}");
                writer.AppendLine($"{chainType} {chainType}.Raises(string eventName, object? args) => _inner.Raises(eventName, args);");
                writer.AppendLine($"{chainType} {chainType}.SetsOutParameter(int paramIndex, object? value) => _inner.SetsOutParameter(paramIndex, value);");
                writer.AppendLine($"{chainType} {chainType}.TransitionsTo(string stateName) => _inner.TransitionsTo(stateName);");
            }

            writer.AppendLine();

            // Public self-returning methods (preserve wrapper type through fluent chain)
            writer.AppendLine($"/// <inheritdoc />");
            writer.AppendLine($"public {wrapperName} Throws<TException>() where TException : global::System.Exception, new() {{ _inner.Throws<TException>(); return this; }}");
            writer.AppendLine($"/// <inheritdoc />");
            writer.AppendLine($"public {wrapperName} Throws(global::System.Exception exception) {{ _inner.Throws(exception); return this; }}");
            writer.AppendLine($"/// <inheritdoc />");
            writer.AppendLine($"public {wrapperName} Callback(global::System.Action callback) {{ _inner.Callback(callback); return this; }}");
            writer.AppendLine($"/// <inheritdoc />");
            writer.AppendLine($"public {wrapperName} Callback(global::System.Action<object?[]> callback) {{ _inner.Callback(callback); return this; }}");
            writer.AppendLine($"/// <inheritdoc />");
            writer.AppendLine($"public {wrapperName} Throws(global::System.Func<object?[], global::System.Exception> exceptionFactory) {{ _inner.Throws(exceptionFactory); return this; }}");
            writer.AppendLine($"/// <inheritdoc />");
            writer.AppendLine($"public {wrapperName} Raises(string eventName, object? args = null) {{ _inner.Raises(eventName, args); return this; }}");
            writer.AppendLine($"/// <inheritdoc />");
            writer.AppendLine($"public {wrapperName} SetsOutParameter(int paramIndex, object? value) {{ _inner.SetsOutParameter(paramIndex, value); return this; }}");
            writer.AppendLine($"/// <inheritdoc />");
            writer.AppendLine($"public {wrapperName} TransitionsTo(string stateName) {{ _inner.TransitionsTo(stateName); return this; }}");
            writer.AppendLine($"/// <inheritdoc />");
            writer.AppendLine($"public {wrapperName} Then() {{ _inner.Then(); return this; }}");

            // Typed parameter overloads (only for methods with typed params)
            if (nonOutParams.Count >= 1)
            {
                writer.AppendLine();
                GenerateTypedCallbackOverload(writer, nonOutParams, wrapperName);
                writer.AppendLine();
                GenerateTypedThrowsOverload(writer, nonOutParams, wrapperName);
            }

            // Typed event raises
            if (events.Length > 0)
            {
                writer.AppendLine();
                GenerateTypedEventRaises(writer, events, wrapperName);
            }
        }
    }

    private static void GenerateTypedReturnsOverload(CodeWriter writer, List<MockParameterModel> nonOutParams,
        string returnType, string wrapperName)
    {
        var typeList = string.Join(", ", nonOutParams.Select(p => p.FullyQualifiedType));
        var funcType = $"global::System.Func<{typeList}, {returnType}>";
        var castArgs = BuildCastArgs(nonOutParams);

        writer.AppendLine("/// <summary>Configure a typed computed return value using the actual method parameters.</summary>");
        using (writer.Block($"public {wrapperName} Returns({funcType} factory)"))
        {
            writer.AppendLine($"_inner.Returns(args => factory({castArgs}));");
            writer.AppendLine("return this;");
        }
    }

    private static void GenerateTypedCallbackOverload(CodeWriter writer, List<MockParameterModel> nonOutParams,
        string wrapperName)
    {
        var typeList = string.Join(", ", nonOutParams.Select(p => p.FullyQualifiedType));
        var actionType = $"global::System.Action<{typeList}>";
        var castArgs = BuildCastArgs(nonOutParams);

        writer.AppendLine("/// <summary>Execute a typed callback using the actual method parameters.</summary>");
        using (writer.Block($"public {wrapperName} Callback({actionType} callback)"))
        {
            writer.AppendLine($"_inner.Callback(args => callback({castArgs}));");
            writer.AppendLine("return this;");
        }
    }

    private static void GenerateTypedThrowsOverload(CodeWriter writer, List<MockParameterModel> nonOutParams,
        string wrapperName)
    {
        var typeList = string.Join(", ", nonOutParams.Select(p => p.FullyQualifiedType));
        var funcType = $"global::System.Func<{typeList}, global::System.Exception>";
        var castArgs = BuildCastArgs(nonOutParams);

        writer.AppendLine("/// <summary>Configure a typed computed exception using the actual method parameters.</summary>");
        using (writer.Block($"public {wrapperName} Throws({funcType} exceptionFactory)"))
        {
            writer.AppendLine($"_inner.Throws(args => exceptionFactory({castArgs}));");
            writer.AppendLine("return this;");
        }
    }

    private static void GenerateTypedEventRaises(CodeWriter writer, EquatableArray<MockEventModel> events,
        string wrapperName)
    {
        bool first = true;
        foreach (var evt in events)
        {
            if (!first) writer.AppendLine();
            first = false;

            var paramList = evt.RaiseParameterList.Length == 0
                ? ""
                : string.Join(", ", evt.RaiseParameterList.Select(p => $"{p.FullyQualifiedType} {p.Name}"));

            string argsExpr;
            if (evt.RaiseParameterList.Length == 0)
            {
                argsExpr = "";
            }
            else if (evt.RaiseParameterList.Length == 1)
            {
                argsExpr = $", (object?){evt.RaiseParameterList[0].Name}";
            }
            else
            {
                var argNames = string.Join(", ", evt.RaiseParameterList.Select(p => p.Name));
                argsExpr = $", (object?)new object?[] {{ {argNames} }}";
            }

            writer.AppendLine($"/// <summary>Auto-raise the {evt.Name} event when this method is called.</summary>");
            writer.AppendLine($"public {wrapperName} Raises{evt.Name}({paramList}) {{ _inner.Raises(\"{evt.Name}\"{argsExpr}); return this; }}");
        }
    }

    private static string BuildCastArgs(List<MockParameterModel> nonOutParams)
    {
        return string.Join(", ", nonOutParams.Select((p, i) =>
            $"({p.FullyQualifiedType})args[{i}]!"));
    }

    private static void GenerateSetupMethod(CodeWriter writer, MockMemberModel method, MockTypeModel model, string safeName)
    {
        // For async methods (Task<T>/ValueTask<T>), unwrap the return type so users write .Returns(5) not .Returns(Task.FromResult(5))
        // For void-async methods (Task/ValueTask), IsVoid is already true
        var setupReturnType = method.IsAsync && !method.IsVoid
            ? method.UnwrappedReturnType
            : method.ReturnType;

        var hasEvents = model.Events.Length > 0;
        var useTypedWrapper = ShouldGenerateTypedWrapper(method, hasEvents);
        string returnType;

        if (useTypedWrapper)
        {
            returnType = GetWrapperName(safeName, method);
        }
        else if (method.IsVoid)
        {
            returnType = "global::TUnit.Mocks.Setup.IVoidMethodSetup";
        }
        else
        {
            returnType = $"global::TUnit.Mocks.Setup.IMethodSetup<{setupReturnType}>";
        }

        var paramList = GetArgParameterList(method);
        var typeParams = GetTypeParameterList(method);
        var constraints = GetConstraintClauses(method);

        var extensionParam = $"this global::TUnit.Mocks.IMockSetup<{model.FullyQualifiedName}> setup";
        var fullParamList = string.IsNullOrEmpty(paramList) ? extensionParam : $"{extensionParam}, {paramList}";

        using (writer.Block($"public static {returnType} {method.Name}{typeParams}({fullParamList}){constraints}"))
        {
            writer.AppendLine($"var s = ({safeName}_MockSetup)setup;");

            // Build matchers array
            var nonOutParams = method.Parameters.Where(p => p.Direction != ParameterDirection.Out).ToList();

            if (nonOutParams.Count == 0)
            {
                writer.AppendLine("var matchers = global::System.Array.Empty<global::TUnit.Mocks.Arguments.IArgumentMatcher>();");
            }
            else
            {
                var matcherArgs = string.Join(", ", nonOutParams.Select(p => $"{p.Name}.Matcher"));
                writer.AppendLine($"var matchers = new global::TUnit.Mocks.Arguments.IArgumentMatcher[] {{ {matcherArgs} }};");
            }

            writer.AppendLine($"var methodSetup = new global::TUnit.Mocks.Setup.MethodSetup({method.MemberId}, matchers, \"{method.Name}\");");
            writer.AppendLine("s.Engine.AddSetup(methodSetup);");

            if (useTypedWrapper)
            {
                var wrapperName = GetWrapperName(safeName, method);
                if (method.IsVoid)
                {
                    writer.AppendLine($"return new {wrapperName}(new global::TUnit.Mocks.Setup.VoidMethodSetupBuilder(methodSetup));");
                }
                else
                {
                    writer.AppendLine($"return new {wrapperName}(new global::TUnit.Mocks.Setup.MethodSetupBuilder<{setupReturnType}>(methodSetup));");
                }
            }
            else if (method.IsVoid)
            {
                writer.AppendLine("return new global::TUnit.Mocks.Setup.VoidMethodSetupBuilder(methodSetup);");
            }
            else
            {
                writer.AppendLine($"return new global::TUnit.Mocks.Setup.MethodSetupBuilder<{setupReturnType}>(methodSetup);");
            }
        }
    }

    private static void GenerateSetupPropertyExtensionBlock(CodeWriter writer, List<MockMemberModel> props, MockTypeModel model, string safeName)
    {
        using (writer.Block($"extension(global::TUnit.Mocks.IMockSetup<{model.FullyQualifiedName}> setup)"))
        {
            bool first = true;
            foreach (var prop in props)
            {
                if (!first) writer.AppendLine();
                first = false;

                var getterMemberId = prop.HasGetter ? prop.MemberId.ToString() : "0";
                var setterMemberId = prop.HasSetter ? prop.SetterMemberId.ToString() : "0";
                var hasGetter = prop.HasGetter ? "true" : "false";
                var hasSetter = prop.HasSetter ? "true" : "false";

                writer.AppendLine($"public global::TUnit.Mocks.Setup.PropertySetupAccessor<{prop.ReturnType}> {prop.Name}");
                writer.AppendLine($"    => new((({safeName}_MockSetup)setup).Engine, {getterMemberId}, {setterMemberId}, \"{prop.Name}\", {hasGetter}, {hasSetter});");
            }
        }
    }

    private static string GetArgParameterList(MockMemberModel method)
    {
        // Only include non-out parameters as Arg<T> in setup
        return string.Join(", ", method.Parameters
            .Where(p => p.Direction != ParameterDirection.Out)
            .Select(p => $"global::TUnit.Mocks.Arguments.Arg<{p.FullyQualifiedType}> {p.Name}"));
    }

    private static string GetTypeParameterList(MockMemberModel method)
    {
        if (method.TypeParameters.Length == 0) return "";
        return "<" + string.Join(", ", method.TypeParameters.Select(tp => tp.Name)) + ">";
    }

    private static string GetConstraintClauses(MockMemberModel method)
    {
        var clauses = new List<string>();
        foreach (var tp in method.TypeParameters)
        {
            if (!string.IsNullOrEmpty(tp.Constraints))
            {
                clauses.Add($"where {tp.Name} : {tp.Constraints}");
            }
        }
        return clauses.Count > 0 ? " " + string.Join(" ", clauses) : "";
    }
}
