using TUnit.Mocks.SourceGenerator.Models;

namespace TUnit.Mocks.SourceGenerator.Builders;

internal static class MockImplBuilder
{
    public static string Build(MockTypeModel model)
    {
        var writer = new CodeWriter();
        var safeName = GetCompositeSafeName(model);

        writer.AppendLine("// <auto-generated/>");
        writer.AppendLine("#nullable enable");
        writer.AppendLine();

        using (writer.Block("namespace TUnit.Mocks.Generated"))
        {
            if (model.IsWrapMock)
            {
                BuildWrapMockImpl(writer, model, safeName);
            }
            else if (model.IsPartialMock && !model.IsInterface)
            {
                BuildPartialMockImpl(writer, model, safeName);
            }
            else
            {
                BuildInterfaceMockImpl(writer, model, safeName);
            }
        }

        return writer.ToString();
    }

    private static void BuildInterfaceMockImpl(CodeWriter writer, MockTypeModel model, string safeName)
    {
        var baseTypes = model.FullyQualifiedName;
        if (model.AdditionalInterfaceNames.Length > 0)
        {
            baseTypes += ", " + string.Join(", ", model.AdditionalInterfaceNames);
        }

        using (writer.Block($"internal sealed class {safeName}_MockImpl : {baseTypes}, global::TUnit.Mocks.IRaisable"))
        {
            writer.AppendLine($"private readonly global::TUnit.Mocks.MockEngine<{model.FullyQualifiedName}> _engine;");
            writer.AppendLine();

            // Constructor
            using (writer.Block($"internal {safeName}_MockImpl(global::TUnit.Mocks.MockEngine<{model.FullyQualifiedName}> engine)"))
            {
                writer.AppendLine("_engine = engine;");
            }

            // Methods
            foreach (var method in model.Methods)
            {
                writer.AppendLine();
                GenerateInterfaceMethod(writer, method, model);
            }

            // Properties
            foreach (var prop in model.Properties)
            {
                if (prop.IsIndexer) continue;
                writer.AppendLine();
                GenerateInterfaceProperty(writer, prop, model);
            }

            // Events
            foreach (var evt in model.Events)
            {
                writer.AppendLine();
                GenerateEvent(writer, evt);
            }

            // IRaisable.RaiseEvent dispatch
            writer.AppendLine();
            GenerateRaiseEventDispatch(writer, model);
        }
    }

    private static void BuildWrapMockImpl(CodeWriter writer, MockTypeModel model, string safeName)
    {
        using (writer.Block($"internal sealed class {safeName}_WrapMockImpl : {model.FullyQualifiedName}, global::TUnit.Mocks.IRaisable"))
        {
            writer.AppendLine($"private readonly global::TUnit.Mocks.MockEngine<{model.FullyQualifiedName}> _engine;");
            writer.AppendLine($"private readonly {model.FullyQualifiedName} _wrappedInstance;");
            writer.AppendLine();

            // Generate constructors that pass through to base + accept wrapped instance
            GenerateWrapConstructors(writer, model, safeName);

            // Methods
            foreach (var method in model.Methods)
            {
                writer.AppendLine();
                GenerateWrapMethod(writer, method, model);
            }

            // Properties
            foreach (var prop in model.Properties)
            {
                if (prop.IsIndexer) continue;
                writer.AppendLine();
                GenerateWrapProperty(writer, prop, model);
            }

            // Events
            foreach (var evt in model.Events)
            {
                writer.AppendLine();
                GeneratePartialEvent(writer, evt);
            }

            // IRaisable.RaiseEvent dispatch
            writer.AppendLine();
            GenerateRaiseEventDispatch(writer, model);
        }
    }

    private static void GenerateWrapConstructors(CodeWriter writer, MockTypeModel model, string safeName)
    {
        if (model.Constructors.Length == 0)
        {
            using (writer.Block($"internal {safeName}_WrapMockImpl(global::TUnit.Mocks.MockEngine<{model.FullyQualifiedName}> engine, {model.FullyQualifiedName} wrappedInstance)"))
            {
                writer.AppendLine("_engine = engine;");
                writer.AppendLine("_wrappedInstance = wrappedInstance;");
            }
            return;
        }

        foreach (var ctor in model.Constructors)
        {
            if (ctor.Parameters.Length == 0)
            {
                using (writer.Block($"internal {safeName}_WrapMockImpl(global::TUnit.Mocks.MockEngine<{model.FullyQualifiedName}> engine, {model.FullyQualifiedName} wrappedInstance) : base()"))
                {
                    writer.AppendLine("_engine = engine;");
                    writer.AppendLine("_wrappedInstance = wrappedInstance;");
                }
            }
            else
            {
                var paramList = string.Join(", ", ctor.Parameters.Select(p => $"{p.FullyQualifiedType} {p.Name}"));
                var argList = string.Join(", ", ctor.Parameters.Select(p => p.Name));
                using (writer.Block($"internal {safeName}_WrapMockImpl(global::TUnit.Mocks.MockEngine<{model.FullyQualifiedName}> engine, {model.FullyQualifiedName} wrappedInstance, {paramList}) : base({argList})"))
                {
                    writer.AppendLine("_engine = engine;");
                    writer.AppendLine("_wrappedInstance = wrappedInstance;");
                }
            }
        }
    }

    private static void GenerateWrapMethod(CodeWriter writer, MockMemberModel method, MockTypeModel model)
    {
        var signatureReturnType = (method.IsVoid && !method.IsAsync) ? "void" : method.ReturnType;
        var paramList = GetParameterList(method);
        var typeParams = GetTypeParameterList(method);
        var constraints = GetConstraintClauses(method);

        var accessModifier = method.IsProtected ? "protected" : "public";
        using (writer.Block($"{accessModifier} override {signatureReturnType} {method.Name}{typeParams}({paramList}){constraints}"))
        {
            if (method.IsAbstractMember)
            {
                // Abstract methods: dispatch through engine (wrapped instance can't have abstract methods by definition,
                // but we still handle it for consistency)
                GenerateEngineDispatchBody(writer, method);
            }
            else
            {
                // Virtual/override methods: try engine first, fall back to wrapped instance
                GenerateWrapMethodBody(writer, method);
            }
        }
    }

    private static void GenerateWrapMethodBody(CodeWriter writer, MockMemberModel method)
    {
        // Initialize out parameters
        foreach (var p in method.Parameters)
        {
            if (p.Direction == ParameterDirection.Out)
            {
                writer.AppendLine($"{p.Name} = default!;");
            }
        }

        var argsArray = GetArgsArrayExpression(method);
        var argPassList = GetArgPassList(method);

        if (method.IsVoid && !method.IsAsync)
        {
            writer.AppendLine($"if (_engine.TryHandleCall({method.MemberId}, \"{method.Name}\", {argsArray}))");
            writer.AppendLine("{");
            writer.IncreaseIndent();
            EmitOutRefReadback(writer, method);
            writer.AppendLine("return;");
            writer.DecreaseIndent();
            writer.AppendLine("}");
            writer.AppendLine($"_wrappedInstance.{method.Name}({argPassList});");
        }
        else if (method.IsVoid && method.IsAsync)
        {
            writer.AppendLine($"if (_engine.TryHandleCall({method.MemberId}, \"{method.Name}\", {argsArray}))");
            writer.AppendLine("{");
            writer.IncreaseIndent();
            EmitOutRefReadback(writer, method);
            if (method.IsValueTask)
            {
                writer.AppendLine("return default(global::System.Threading.Tasks.ValueTask);");
            }
            else
            {
                writer.AppendLine("return global::System.Threading.Tasks.Task.CompletedTask;");
            }
            writer.DecreaseIndent();
            writer.AppendLine("}");
            writer.AppendLine($"return _wrappedInstance.{method.Name}({argPassList});");
        }
        else if (method.IsAsync)
        {
            writer.AppendLine($"if (_engine.TryHandleCallWithReturn<{method.UnwrappedReturnType}>({method.MemberId}, \"{method.Name}\", {argsArray}, {method.UnwrappedSmartDefault}, out var __result))");
            writer.AppendLine("{");
            writer.IncreaseIndent();
            EmitOutRefReadback(writer, method);
            if (method.IsValueTask)
            {
                writer.AppendLine($"return new global::System.Threading.Tasks.ValueTask<{method.UnwrappedReturnType}>(__result);");
            }
            else
            {
                writer.AppendLine($"return global::System.Threading.Tasks.Task.FromResult<{method.UnwrappedReturnType}>(__result);");
            }
            writer.DecreaseIndent();
            writer.AppendLine("}");
            writer.AppendLine($"return _wrappedInstance.{method.Name}({argPassList});");
        }
        else
        {
            writer.AppendLine($"if (_engine.TryHandleCallWithReturn<{method.ReturnType}>({method.MemberId}, \"{method.Name}\", {argsArray}, {method.SmartDefault}, out var __result))");
            writer.AppendLine("{");
            writer.IncreaseIndent();
            EmitOutRefReadback(writer, method);
            writer.AppendLine("return __result;");
            writer.DecreaseIndent();
            writer.AppendLine("}");
            writer.AppendLine($"return _wrappedInstance.{method.Name}({argPassList});");
        }
    }

    private static void GenerateWrapProperty(CodeWriter writer, MockMemberModel prop, MockTypeModel model)
    {
        var accessModifier = prop.IsProtected ? "protected" : "public";
        writer.AppendLine($"{accessModifier} override {prop.ReturnType} {prop.Name}");
        writer.OpenBrace();

        if (prop.HasGetter)
        {
            if (prop.IsAbstractMember)
            {
                writer.AppendLine($"get => _engine.HandleCallWithReturn<{prop.ReturnType}>({prop.MemberId}, \"get_{prop.Name}\", global::System.Array.Empty<object?>(), {prop.SmartDefault});");
            }
            else
            {
                writer.AppendLine("get");
                writer.OpenBrace();
                writer.AppendLine($"if (_engine.TryHandleCallWithReturn<{prop.ReturnType}>({prop.MemberId}, \"get_{prop.Name}\", global::System.Array.Empty<object?>(), {prop.SmartDefault}, out var __result))");
                writer.AppendLine("{");
                writer.IncreaseIndent();
                writer.AppendLine("return __result;");
                writer.DecreaseIndent();
                writer.AppendLine("}");
                writer.AppendLine($"return _wrappedInstance.{prop.Name};");
                writer.CloseBrace();
            }
        }

        if (prop.HasSetter)
        {
            if (prop.IsAbstractMember)
            {
                writer.AppendLine($"set => _engine.HandleCall({prop.SetterMemberId}, \"set_{prop.Name}\", new object?[] {{ value }});");
            }
            else
            {
                writer.AppendLine("set");
                writer.OpenBrace();
                writer.AppendLine($"if (!_engine.TryHandleCall({prop.SetterMemberId}, \"set_{prop.Name}\", new object?[] {{ value }}))");
                writer.AppendLine("{");
                writer.IncreaseIndent();
                writer.AppendLine($"_wrappedInstance.{prop.Name} = value;");
                writer.DecreaseIndent();
                writer.AppendLine("}");
                writer.CloseBrace();
            }
        }

        writer.CloseBrace();
    }

    private static void BuildPartialMockImpl(CodeWriter writer, MockTypeModel model, string safeName)
    {
        using (writer.Block($"internal sealed class {safeName}_MockImpl : {model.FullyQualifiedName}, global::TUnit.Mocks.IRaisable"))
        {
            writer.AppendLine($"private readonly global::TUnit.Mocks.MockEngine<{model.FullyQualifiedName}> _engine;");
            writer.AppendLine();

            // Generate constructors that pass through to base
            GeneratePartialConstructors(writer, model, safeName);

            // Methods
            foreach (var method in model.Methods)
            {
                writer.AppendLine();
                GeneratePartialMethod(writer, method, model);
            }

            // Properties
            foreach (var prop in model.Properties)
            {
                if (prop.IsIndexer) continue;
                writer.AppendLine();
                GeneratePartialProperty(writer, prop, model);
            }

            // Events - for partial mocks, events need override
            foreach (var evt in model.Events)
            {
                writer.AppendLine();
                GeneratePartialEvent(writer, evt);
            }

            // IRaisable.RaiseEvent dispatch
            writer.AppendLine();
            GenerateRaiseEventDispatch(writer, model);
        }
    }

    private static void GeneratePartialConstructors(CodeWriter writer, MockTypeModel model, string safeName)
    {
        if (model.Constructors.Length == 0)
        {
            // No explicit constructors found, generate a default one
            using (writer.Block($"internal {safeName}_MockImpl(global::TUnit.Mocks.MockEngine<{model.FullyQualifiedName}> engine)"))
            {
                writer.AppendLine("_engine = engine;");
            }
            return;
        }

        foreach (var ctor in model.Constructors)
        {
            if (ctor.Parameters.Length == 0)
            {
                // Parameterless constructor
                using (writer.Block($"internal {safeName}_MockImpl(global::TUnit.Mocks.MockEngine<{model.FullyQualifiedName}> engine) : base()"))
                {
                    writer.AppendLine("_engine = engine;");
                }
            }
            else
            {
                // Constructor with parameters - pass them through to base
                var paramList = string.Join(", ", ctor.Parameters.Select(p => $"{p.FullyQualifiedType} {p.Name}"));
                var argList = string.Join(", ", ctor.Parameters.Select(p => p.Name));
                using (writer.Block($"internal {safeName}_MockImpl(global::TUnit.Mocks.MockEngine<{model.FullyQualifiedName}> engine, {paramList}) : base({argList})"))
                {
                    writer.AppendLine("_engine = engine;");
                }
            }
        }
    }

    private static void GenerateInterfaceMethod(CodeWriter writer, MockMemberModel method, MockTypeModel model)
    {
        var signatureReturnType = (method.IsVoid && !method.IsAsync) ? "void" : method.ReturnType;
        var paramList = GetParameterList(method);
        var typeParams = GetTypeParameterList(method);
        var constraints = GetConstraintClauses(method);

        using (writer.Block($"public {signatureReturnType} {method.Name}{typeParams}({paramList}){constraints}"))
        {
            GenerateEngineDispatchBody(writer, method);
        }
    }

    private static void GeneratePartialMethod(CodeWriter writer, MockMemberModel method, MockTypeModel model)
    {
        var signatureReturnType = (method.IsVoid && !method.IsAsync) ? "void" : method.ReturnType;
        var paramList = GetParameterList(method);
        var typeParams = GetTypeParameterList(method);
        var constraints = GetConstraintClauses(method);

        // For partial mocks, all methods get "override" since we only discover virtual/abstract/override members
        var accessModifier = method.IsProtected ? "protected" : "public";
        using (writer.Block($"{accessModifier} override {signatureReturnType} {method.Name}{typeParams}({paramList}){constraints}"))
        {
            if (method.IsAbstractMember)
            {
                // Abstract methods: same as interface methods - dispatch through engine
                GenerateEngineDispatchBody(writer, method);
            }
            else
            {
                // Virtual/override methods: try engine first, fall back to base
                GeneratePartialMethodBody(writer, method);
            }
        }
    }

    private static void GeneratePartialMethodBody(CodeWriter writer, MockMemberModel method)
    {
        // Initialize out parameters
        foreach (var p in method.Parameters)
        {
            if (p.Direction == ParameterDirection.Out)
            {
                writer.AppendLine($"{p.Name} = default!;");
            }
        }

        var argsArray = GetArgsArrayExpression(method);
        var argPassList = GetArgPassList(method);

        if (method.IsVoid && !method.IsAsync)
        {
            // void virtual method
            writer.AppendLine($"if (_engine.TryHandleCall({method.MemberId}, \"{method.Name}\", {argsArray}))");
            writer.AppendLine("{");
            writer.IncreaseIndent();
            EmitOutRefReadback(writer, method);
            writer.AppendLine("return;");
            writer.DecreaseIndent();
            writer.AppendLine("}");
            writer.AppendLine($"base.{method.Name}({argPassList});");
        }
        else if (method.IsVoid && method.IsAsync)
        {
            // async void virtual method (Task/ValueTask)
            writer.AppendLine($"if (_engine.TryHandleCall({method.MemberId}, \"{method.Name}\", {argsArray}))");
            writer.AppendLine("{");
            writer.IncreaseIndent();
            EmitOutRefReadback(writer, method);
            if (method.IsValueTask)
            {
                writer.AppendLine("return default(global::System.Threading.Tasks.ValueTask);");
            }
            else
            {
                writer.AppendLine("return global::System.Threading.Tasks.Task.CompletedTask;");
            }
            writer.DecreaseIndent();
            writer.AppendLine("}");
            writer.AppendLine($"return base.{method.Name}({argPassList});");
        }
        else if (method.IsAsync)
        {
            // async method with return (Task<T>/ValueTask<T>)
            writer.AppendLine($"if (_engine.TryHandleCallWithReturn<{method.UnwrappedReturnType}>({method.MemberId}, \"{method.Name}\", {argsArray}, {method.UnwrappedSmartDefault}, out var __result))");
            writer.AppendLine("{");
            writer.IncreaseIndent();
            EmitOutRefReadback(writer, method);
            if (method.IsValueTask)
            {
                writer.AppendLine($"return new global::System.Threading.Tasks.ValueTask<{method.UnwrappedReturnType}>(__result);");
            }
            else
            {
                writer.AppendLine($"return global::System.Threading.Tasks.Task.FromResult<{method.UnwrappedReturnType}>(__result);");
            }
            writer.DecreaseIndent();
            writer.AppendLine("}");
            writer.AppendLine($"return base.{method.Name}({argPassList});");
        }
        else
        {
            // synchronous method with return value
            writer.AppendLine($"if (_engine.TryHandleCallWithReturn<{method.ReturnType}>({method.MemberId}, \"{method.Name}\", {argsArray}, {method.SmartDefault}, out var __result))");
            writer.AppendLine("{");
            writer.IncreaseIndent();
            EmitOutRefReadback(writer, method);
            writer.AppendLine("return __result;");
            writer.DecreaseIndent();
            writer.AppendLine("}");
            writer.AppendLine($"return base.{method.Name}({argPassList});");
        }
    }

    private static void GenerateEngineDispatchBody(CodeWriter writer, MockMemberModel method)
    {
        // Initialize out parameters
        foreach (var p in method.Parameters)
        {
            if (p.Direction == ParameterDirection.Out)
            {
                writer.AppendLine($"{p.Name} = default!;");
            }
        }

        var argsArray = GetArgsArrayExpression(method);

        var hasOutRef = HasOutRefParams(method);

        if (method.IsVoid && !method.IsAsync)
        {
            // Pure void method
            writer.AppendLine($"_engine.HandleCall({method.MemberId}, \"{method.Name}\", {argsArray});");
            EmitOutRefReadback(writer, method);
        }
        else if (method.IsVoid && method.IsAsync)
        {
            // Async void method (Task or ValueTask with no generic arg)
            using (writer.Block("try"))
            {
                writer.AppendLine($"_engine.HandleCall({method.MemberId}, \"{method.Name}\", {argsArray});");
                EmitOutRefReadback(writer, method);
                if (method.IsValueTask)
                {
                    writer.AppendLine("return default(global::System.Threading.Tasks.ValueTask);");
                }
                else
                {
                    writer.AppendLine("return global::System.Threading.Tasks.Task.CompletedTask;");
                }
            }
            using (writer.Block("catch (global::System.Exception __ex)"))
            {
                if (method.IsValueTask)
                {
                    writer.AppendLine("return new global::System.Threading.Tasks.ValueTask(global::System.Threading.Tasks.Task.FromException(__ex));");
                }
                else
                {
                    writer.AppendLine("return global::System.Threading.Tasks.Task.FromException(__ex);");
                }
            }
        }
        else if (method.IsAsync)
        {
            // Async method with return value (Task<T> or ValueTask<T>)
            using (writer.Block("try"))
            {
                writer.AppendLine($"var __result = _engine.HandleCallWithReturn<{method.UnwrappedReturnType}>({method.MemberId}, \"{method.Name}\", {argsArray}, {method.UnwrappedSmartDefault});");
                EmitOutRefReadback(writer, method);
                if (method.IsValueTask)
                {
                    writer.AppendLine($"return new global::System.Threading.Tasks.ValueTask<{method.UnwrappedReturnType}>(__result);");
                }
                else
                {
                    writer.AppendLine($"return global::System.Threading.Tasks.Task.FromResult<{method.UnwrappedReturnType}>(__result);");
                }
            }
            using (writer.Block("catch (global::System.Exception __ex)"))
            {
                if (method.IsValueTask)
                {
                    writer.AppendLine($"return new global::System.Threading.Tasks.ValueTask<{method.UnwrappedReturnType}>(global::System.Threading.Tasks.Task.FromException<{method.UnwrappedReturnType}>(__ex));");
                }
                else
                {
                    writer.AppendLine($"return global::System.Threading.Tasks.Task.FromException<{method.UnwrappedReturnType}>(__ex);");
                }
            }
        }
        else
        {
            // Synchronous method with return value — need to read back out/ref before returning
            if (hasOutRef)
            {
                writer.AppendLine($"var __result = _engine.HandleCallWithReturn<{method.ReturnType}>({method.MemberId}, \"{method.Name}\", {argsArray}, {method.SmartDefault});");
                EmitOutRefReadback(writer, method);
                writer.AppendLine("return __result;");
            }
            else
            {
                writer.AppendLine($"return _engine.HandleCallWithReturn<{method.ReturnType}>({method.MemberId}, \"{method.Name}\", {argsArray}, {method.SmartDefault});");
            }
        }
    }

    private static void GenerateInterfaceProperty(CodeWriter writer, MockMemberModel prop, MockTypeModel model)
    {
        writer.AppendLine($"public {prop.ReturnType} {prop.Name}");
        writer.OpenBrace();

        if (prop.HasGetter)
        {
            writer.AppendLine($"get => _engine.HandleCallWithReturn<{prop.ReturnType}>({prop.MemberId}, \"get_{prop.Name}\", global::System.Array.Empty<object?>(), {prop.SmartDefault});");
        }

        if (prop.HasSetter)
        {
            writer.AppendLine($"set => _engine.HandleCall({prop.SetterMemberId}, \"set_{prop.Name}\", new object?[] {{ value }});");
        }

        writer.CloseBrace();
    }

    private static void GeneratePartialProperty(CodeWriter writer, MockMemberModel prop, MockTypeModel model)
    {
        var accessModifier = prop.IsProtected ? "protected" : "public";
        writer.AppendLine($"{accessModifier} override {prop.ReturnType} {prop.Name}");
        writer.OpenBrace();

        if (prop.HasGetter)
        {
            if (prop.IsAbstractMember)
            {
                writer.AppendLine($"get => _engine.HandleCallWithReturn<{prop.ReturnType}>({prop.MemberId}, \"get_{prop.Name}\", global::System.Array.Empty<object?>(), {prop.SmartDefault});");
            }
            else
            {
                // Virtual property getter: try engine, fall back to base
                writer.AppendLine("get");
                writer.OpenBrace();
                writer.AppendLine($"if (_engine.TryHandleCallWithReturn<{prop.ReturnType}>({prop.MemberId}, \"get_{prop.Name}\", global::System.Array.Empty<object?>(), {prop.SmartDefault}, out var __result))");
                writer.AppendLine("{");
                writer.IncreaseIndent();
                writer.AppendLine("return __result;");
                writer.DecreaseIndent();
                writer.AppendLine("}");
                writer.AppendLine($"return base.{prop.Name};");
                writer.CloseBrace();
            }
        }

        if (prop.HasSetter)
        {
            if (prop.IsAbstractMember)
            {
                writer.AppendLine($"set => _engine.HandleCall({prop.SetterMemberId}, \"set_{prop.Name}\", new object?[] {{ value }});");
            }
            else
            {
                // Virtual property setter: try engine, fall back to base
                writer.AppendLine("set");
                writer.OpenBrace();
                writer.AppendLine($"if (!_engine.TryHandleCall({prop.SetterMemberId}, \"set_{prop.Name}\", new object?[] {{ value }}))");
                writer.AppendLine("{");
                writer.IncreaseIndent();
                writer.AppendLine($"base.{prop.Name} = value;");
                writer.DecreaseIndent();
                writer.AppendLine("}");
                writer.CloseBrace();
            }
        }

        writer.CloseBrace();
    }

    private static void GenerateEvent(CodeWriter writer, MockEventModel evt)
    {
        // Backing delegate field
        writer.AppendLine($"private {evt.EventHandlerType}? _backing_{evt.Name};");
        writer.AppendLine();

        // Event add/remove accessors
        writer.AppendLine($"public event {evt.EventHandlerType}? {evt.Name}");
        writer.OpenBrace();
        writer.AppendLine($"add {{ _backing_{evt.Name} += value; _engine.RecordEventSubscription(\"{evt.Name}\", true); }}");
        writer.AppendLine($"remove {{ _backing_{evt.Name} -= value; _engine.RecordEventSubscription(\"{evt.Name}\", false); }}");
        writer.CloseBrace();
        writer.AppendLine();

        // Raise method for generated code to call
        writer.AppendLine("[global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]");
        var raiseParams = evt.RaiseParameterList.Length == 0
            ? ""
            : string.Join(", ", evt.RaiseParameterList.Select(p => $"{p.FullyQualifiedType} {p.Name}"));
        var invokeArgs = string.IsNullOrEmpty(evt.InvokeArgs) ? "" : evt.InvokeArgs;
        using (writer.Block($"internal void Raise_{evt.Name}({raiseParams})"))
        {
            if (string.IsNullOrEmpty(invokeArgs))
            {
                writer.AppendLine($"_backing_{evt.Name}?.Invoke();");
            }
            else
            {
                writer.AppendLine($"_backing_{evt.Name}?.Invoke({invokeArgs});");
            }
        }
    }

    private static void GeneratePartialEvent(CodeWriter writer, MockEventModel evt)
    {
        // Backing delegate field
        writer.AppendLine($"private {evt.EventHandlerType}? _backing_{evt.Name};");
        writer.AppendLine();

        // Event add/remove accessors with override
        writer.AppendLine($"public override event {evt.EventHandlerType}? {evt.Name}");
        writer.OpenBrace();
        writer.AppendLine($"add {{ _backing_{evt.Name} += value; _engine.RecordEventSubscription(\"{evt.Name}\", true); }}");
        writer.AppendLine($"remove {{ _backing_{evt.Name} -= value; _engine.RecordEventSubscription(\"{evt.Name}\", false); }}");
        writer.CloseBrace();
        writer.AppendLine();

        // Raise method for generated code to call
        writer.AppendLine("[global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]");
        var raiseParams = evt.RaiseParameterList.Length == 0
            ? ""
            : string.Join(", ", evt.RaiseParameterList.Select(p => $"{p.FullyQualifiedType} {p.Name}"));
        var invokeArgs = string.IsNullOrEmpty(evt.InvokeArgs) ? "" : evt.InvokeArgs;
        using (writer.Block($"internal void Raise_{evt.Name}({raiseParams})"))
        {
            if (string.IsNullOrEmpty(invokeArgs))
            {
                writer.AppendLine($"_backing_{evt.Name}?.Invoke();");
            }
            else
            {
                writer.AppendLine($"_backing_{evt.Name}?.Invoke({invokeArgs});");
            }
        }
    }

    private static void GenerateRaiseEventDispatch(CodeWriter writer, MockTypeModel model)
    {
        writer.AppendLine("[global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]");
        using (writer.Block("public void RaiseEvent(string eventName, object? args)"))
        {
            if (model.Events.Length == 0)
            {
                writer.AppendLine("throw new global::System.InvalidOperationException($\"No event named '{eventName}' exists on this mock.\");");
            }
            else
            {
                using (writer.Block("switch (eventName)"))
                {
                    foreach (var evt in model.Events)
                    {
                        writer.AppendLine($"case \"{evt.Name}\":");
                        writer.IncreaseIndent();

                        // Determine how to invoke: if the event handler has parameters matching EventArgs, pass args
                        if (evt.RaiseParameterList.Length == 0)
                        {
                            // No-parameter event (e.g., Action)
                            writer.AppendLine($"Raise_{evt.Name}();");
                        }
                        else if (evt.RaiseParameterList.Length > 1)
                        {
                            // Multi-parameter delegate — cast args to object[] and spread
                            writer.AppendLine("if (args is object?[] __argArray)");
                            writer.AppendLine("{");
                            writer.IncreaseIndent();

                            var castArgs = new List<string>();
                            for (int i = 0; i < evt.RaiseParameterList.Length; i++)
                            {
                                castArgs.Add($"({evt.RaiseParameterList[i].FullyQualifiedType})__argArray[{i}]");
                            }
                            writer.AppendLine($"Raise_{evt.Name}({string.Join(", ", castArgs)});");
                            writer.DecreaseIndent();
                            writer.AppendLine("}");
                            writer.AppendLine("else");
                            writer.AppendLine("{");
                            writer.IncreaseIndent();
                            writer.AppendLine($"throw new global::System.ArgumentException($\"Event '{evt.Name}' requires an object[] of arguments.\");");
                            writer.DecreaseIndent();
                            writer.AppendLine("}");
                        }
                        else
                        {
                            // Single-parameter event (e.g., EventHandler<TArgs>)
                            writer.AppendLine($"Raise_{evt.Name}(({evt.RaiseParameterList[0].FullyQualifiedType})args!);");
                        }

                        writer.AppendLine("break;");
                        writer.DecreaseIndent();
                    }

                    writer.AppendLine("default:");
                    writer.IncreaseIndent();
                    writer.AppendLine("throw new global::System.InvalidOperationException($\"No event named '{eventName}' exists on this mock.\");");
                    writer.DecreaseIndent();
                }
            }
        }
    }

    private static string GetParameterList(MockMemberModel method)
    {
        return string.Join(", ", method.Parameters.Select(p =>
        {
            var direction = p.Direction switch
            {
                ParameterDirection.Out => "out ",
                ParameterDirection.Ref => "ref ",
                ParameterDirection.In_Readonly => "in ",
                _ => ""
            };
            return $"{direction}{p.FullyQualifiedType} {p.Name}";
        }));
    }

    private static string GetTypeParameterList(MockMemberModel method)
    {
        if (method.TypeParameters.Length == 0) return "";
        return "<" + string.Join(", ", method.TypeParameters.Select(tp => tp.Name)) + ">";
    }

    private static string GetConstraintClauses(MockMemberModel method)
    {
        var clauses = new List<string>();
        foreach (var tp in method.TypeParameters)
        {
            if (!string.IsNullOrEmpty(tp.Constraints))
            {
                clauses.Add($"where {tp.Name} : {tp.Constraints}");
            }
        }
        return clauses.Count > 0 ? " " + string.Join(" ", clauses) : "";
    }

    /// <summary>
    /// Returns true if the method has any out or ref parameters that need read-back.
    /// </summary>
    private static bool HasOutRefParams(MockMemberModel method)
    {
        return method.Parameters.Any(p => p.Direction == ParameterDirection.Out || p.Direction == ParameterDirection.Ref);
    }

    /// <summary>
    /// Emits code to read back out/ref parameter values from OutRefContext after an engine call.
    /// </summary>
    private static void EmitOutRefReadback(CodeWriter writer, MockMemberModel method)
    {
        if (!HasOutRefParams(method)) return;

        writer.AppendLine("var __outRef = global::TUnit.Mocks.Setup.OutRefContext.Consume();");
        using (writer.Block("if (__outRef is not null)"))
        {
            for (int i = 0; i < method.Parameters.Length; i++)
            {
                var p = method.Parameters[i];
                if (p.Direction == ParameterDirection.Out || p.Direction == ParameterDirection.Ref)
                {
                    writer.AppendLine($"if (__outRef.TryGetValue({i}, out var __v{i})) {p.Name} = ({p.FullyQualifiedType})__v{i}!;");
                }
            }
        }
    }

    private static string GetArgsArrayExpression(MockMemberModel method)
    {
        // Only include non-out parameters in args array
        var matchableParams = method.Parameters.Where(p => p.Direction != ParameterDirection.Out).ToList();
        if (matchableParams.Count == 0) return "global::System.Array.Empty<object?>()";
        var args = string.Join(", ", matchableParams.Select(p => p.Name));
        return $"new object?[] {{ {args} }}";
    }

    /// <summary>
    /// Gets the argument pass-through list for calling base.Method(), preserving ref/out/in directions.
    /// </summary>
    private static string GetArgPassList(MockMemberModel method)
    {
        return string.Join(", ", method.Parameters.Select(p =>
        {
            var direction = p.Direction switch
            {
                ParameterDirection.Out => "out ",
                ParameterDirection.Ref => "ref ",
                ParameterDirection.In_Readonly => "in ",
                _ => ""
            };
            return $"{direction}{p.Name}";
        }));
    }

    public static string GetSafeName(string typeName)
    {
        return typeName
            .Replace("global::", "")
            .Replace(".", "_")
            .Replace("<", "_")
            .Replace(">", "_")
            .Replace(",", "_")
            .Replace("[", "_")
            .Replace("]", "_")
            .Replace(" ", "");
    }

    /// <summary>
    /// Gets a safe name that includes additional interfaces for multi-interface mocks.
    /// </summary>
    public static string GetCompositeSafeName(MockTypeModel model)
    {
        var name = model.FullyQualifiedName;
        if (model.AdditionalInterfaceNames.Length > 0)
        {
            name += "_" + string.Join("_", model.AdditionalInterfaceNames);
        }
        return GetSafeName(name);
    }
}
