using TUnit.Mocks.SourceGenerator.Models;

namespace TUnit.Mocks.SourceGenerator.Builders;

internal static class MockEventsBuilder
{
    public static string Build(MockTypeModel model)
    {
        var writer = new CodeWriter();
        var safeName = MockImplBuilder.GetSafeName(model.FullyQualifiedName);

        writer.AppendLine("// <auto-generated/>");
        writer.AppendLine("#nullable enable");
        writer.AppendLine();

        using (writer.Block("namespace TUnit.Mocks.Generated"))
        {
            // Data holder class implementing marker interface
            using (writer.Block($"public sealed class {safeName}_MockEvents : global::TUnit.Mocks.IMockEvents<{model.FullyQualifiedName}>"))
            {
                writer.AppendLine($"internal readonly global::TUnit.Mocks.MockEngine<{model.FullyQualifiedName}> Engine;");
                writer.AppendLine();
                writer.AppendLine($"internal {safeName}_MockEvents(global::TUnit.Mocks.MockEngine<{model.FullyQualifiedName}> engine) => Engine = engine;");
            }

            writer.AppendLine();

            // Extension properties class using C# 14 extension block
            using (writer.Block($"public static class {safeName}_MockEventsExtensions"))
            {
                using (writer.Block($"extension(global::TUnit.Mocks.IMockEvents<{model.FullyQualifiedName}> events)"))
                {
                    bool first = true;
                    foreach (var evt in model.Events)
                    {
                        if (!first) writer.AppendLine();
                        first = false;

                        writer.AppendLine($"public global::TUnit.Mocks.EventSubscriptionAccessor {evt.Name}");
                        writer.AppendLine($"    => new((({safeName}_MockEvents)events).Engine, \"{evt.Name}\");");
                    }
                }
            }
        }

        return writer.ToString();
    }
}
