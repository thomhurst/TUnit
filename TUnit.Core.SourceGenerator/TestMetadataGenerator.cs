using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;

namespace TUnit.Core.SourceGenerator;

/// <summary>
/// Source generator that emits TestMetadata for discovered tests.
/// </summary>
[Generator]
public class TestMetadataGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Find all test methods
        var testMethods = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                "TUnit.Core.TestAttribute",
                predicate: static (node, _) => node is MethodDeclarationSyntax,
                transform: static (ctx, _) => GetTestMethodMetadata(ctx))
            .Where(static m => m is not null);

        // Generate a separate file for each test method to avoid Collect()
        context.RegisterSourceOutput(testMethods, GenerateTestRegistration);
    }

    private static TestMethodInfo? GetTestMethodMetadata(GeneratorAttributeSyntaxContext context)
    {
        if (context.TargetSymbol is not IMethodSymbol methodSymbol)
        {
            return null;
        }

        var typeSymbol = methodSymbol.ContainingType;

        // Skip abstract classes, static methods, and generic types
        if (typeSymbol.IsAbstract || methodSymbol.IsStatic || typeSymbol.IsGenericType)
        {
            return null;
        }

        // Skip non-public methods
        if (methodSymbol.DeclaredAccessibility != Accessibility.Public)
        {
            return null;
        }

        // Get location info
        var location = context.TargetNode.GetLocation();
        var filePath = location.SourceTree?.FilePath ?? "";
        var lineNumber = location.GetLineSpan().StartLinePosition.Line + 1;

        return new TestMethodInfo
        {
            MethodSymbol = methodSymbol,
            TypeSymbol = typeSymbol,
            FilePath = filePath,
            LineNumber = lineNumber,
            TestAttribute = context.Attributes[0]
        };
    }

    private static void GenerateTestRegistration(SourceProductionContext context, TestMethodInfo? testInfo)
    {
        if (testInfo == null)
        {
            return;
        }

        var sb = new StringBuilder();
        
        // Generate a unique identifier for this test
        var guid = Guid.NewGuid().ToString("N");
        var className = GetFullTypeName(testInfo.TypeSymbol);
        var methodName = testInfo.MethodSymbol.Name;
        // Sanitize class and method names for use in filenames
        var safeClassName = SanitizeForFilename(className);
        var safeMethodName = SanitizeForFilename(methodName);
        
        // Check for required properties
        var requiredProperties = testInfo.TypeSymbol.GetMembers()
            .OfType<IPropertySymbol>()
            .Where(p => p.IsRequired)
            .ToList();
            
        // Check for constructor parameters
        var constructors = testInfo.TypeSymbol.Constructors
            .Where(c => !c.IsStatic && c.DeclaredAccessibility == Accessibility.Public)
            .OrderBy(c => c.Parameters.Length)
            .ToList();
        
        var hasParameterlessConstructor = constructors.Any(c => c.Parameters.Length == 0);
        var constructorWithParameters = !hasParameterlessConstructor ? constructors.FirstOrDefault() : null;

        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("#nullable enable");
        sb.AppendLine("#pragma warning disable CS9113 // Parameter is unread.");
        sb.AppendLine();
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("using System.Reflection;");
        sb.AppendLine("using global::TUnit.Core;");
        sb.AppendLine();
        sb.AppendLine("using global::TUnit.Core.SourceGenerator;");
        sb.AppendLine();
        sb.AppendLine("namespace TUnit.Generated;");
        sb.AppendLine();
        sb.AppendLine($"internal static class TestMetadataRegistry_{safeClassName}_{safeMethodName}_{guid}");
        sb.AppendLine("{");
        sb.AppendLine("    [System.Runtime.CompilerServices.ModuleInitializer]");
        sb.AppendLine("    public static void Initialize()");
        sb.AppendLine("    {");
        sb.AppendLine("        var testMetadata = new System.Collections.Generic.List<TestMetadata>();");
        sb.AppendLine();
        // Extract skip information
        var (isSkipped, skipReason) = CodeGenerationHelpers.ExtractSkipInfo(testInfo.MethodSymbol);
        
        sb.AppendLine($@"        testMetadata.Add(new TestMetadata
        {{
            TestIdTemplate = ""{className}.{methodName}_{{{{TestIndex}}}}"",
            TestClassType = typeof({className}),
            TestMethod = typeof({className}).GetMethod(""{methodName}"", BindingFlags.Public | BindingFlags.Instance),
            MethodMetadata = new MethodMetadata
            {{
                Name = ""{testInfo.MethodSymbol.Name}"",
                Type = typeof({className}),
                Parameters = {CodeGenerationHelpers.GenerateParameterMetadataArray(testInfo.MethodSymbol)},
                GenericTypeCount = {testInfo.MethodSymbol.TypeParameters.Length},
                Class = new ClassMetadata
                {{
                    Name = ""{testInfo.TypeSymbol.Name}"",
                    Type = typeof({className}),
                    Attributes = {CodeGenerationHelpers.GenerateAttributeMetadataArray(testInfo.TypeSymbol.GetAttributes())},
                    Namespace = ""{testInfo.TypeSymbol.ContainingNamespace}"",
                    Assembly = new AssemblyMetadata {{ Name = ""{testInfo.TypeSymbol.ContainingAssembly.Name}"", Attributes = {CodeGenerationHelpers.GenerateAttributeMetadataArray(testInfo.TypeSymbol.ContainingAssembly.GetAttributes())} }},
                    Parameters = System.Array.Empty<ParameterMetadata>(),
                    Properties = {CodeGenerationHelpers.GeneratePropertyMetadataArray(testInfo.TypeSymbol)},
                    Constructors = {CodeGenerationHelpers.GenerateConstructorMetadataArray(testInfo.TypeSymbol)},
                    Parent = null
                }},
                ReturnType = typeof({GetReturnTypeName(testInfo.MethodSymbol)}),
                Attributes = {CodeGenerationHelpers.GenerateAttributeMetadataArray(testInfo.MethodSymbol.GetAttributes())}
            }},
            TestFilePath = @""{testInfo.FilePath.Replace("\\", "\\\\").Replace("\"", "\\\"")}"",
            TestLineNumber = {testInfo.LineNumber},
            TestClassFactory = args => {GenerateTestClassFactory(className, requiredProperties, constructorWithParameters, hasParameterlessConstructor)},
            ClassDataSources = {CodeGenerationHelpers.GenerateClassDataSourceProviders(testInfo.TypeSymbol)},
            MethodDataSources = {CodeGenerationHelpers.GenerateMethodDataSourceProviders(testInfo.MethodSymbol)},
            PropertyDataSources = {CodeGenerationHelpers.GeneratePropertyDataSourceDictionary(testInfo.TypeSymbol)},
            DisplayNameTemplate = ""{methodName}"",
            RepeatCount = {CodeGenerationHelpers.ExtractRepeatCount(testInfo.MethodSymbol)},
            IsAsync = {(IsAsyncMethod(testInfo.MethodSymbol) ? "true" : "false")},
            IsSkipped = {(isSkipped ? "true" : "false")},
            SkipReason = {skipReason},
            Attributes = {CodeGenerationHelpers.GenerateTestAttributes(testInfo.MethodSymbol)},
            Timeout = {CodeGenerationHelpers.ExtractTimeout(testInfo.MethodSymbol)}
        }});");
        sb.AppendLine();
        sb.AppendLine("        TestSourceRegistrar.RegisterMetadata(testMetadata);");
        sb.AppendLine("    }");
        sb.AppendLine("}");

        // Use GUID in the filename to prevent overwrites
        context.AddSource($"TestMetadata_{safeClassName}_{safeMethodName}_{guid}.g.cs", sb.ToString());
    }

    private static string GetFullTypeName(ITypeSymbol typeSymbol)
    {
        return typeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat
            .WithGlobalNamespaceStyle(SymbolDisplayGlobalNamespaceStyle.Omitted));
    }
    
    private static string SanitizeForFilename(string name)
    {
        // Replace all invalid filename characters with underscores
        var invalid = System.IO.Path.GetInvalidFileNameChars()
            .Concat(new[] { '<', '>', '(', ')', '[', ']', '{', '}', ',', ' ', '`', '.' })
            .Distinct();
            
        var sanitized = name;
        foreach (var c in invalid)
        {
            sanitized = sanitized.Replace(c, '_');
        }
        
        return sanitized;
    }

    private static string GetReturnTypeName(IMethodSymbol methodSymbol)
    {
        var returnType = methodSymbol.ReturnType;
        if (returnType.SpecialType == SpecialType.System_Void)
        {
            return "void";
        }

        return returnType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat
            .WithGlobalNamespaceStyle(SymbolDisplayGlobalNamespaceStyle.Omitted));
    }

    private static bool IsAsyncMethod(IMethodSymbol methodSymbol)
    {
        var returnType = methodSymbol.ReturnType;
        return returnType.Name == "Task" || returnType.Name == "ValueTask";
    }

    private static string GenerateTestClassFactory(string className, List<IPropertySymbol> requiredProperties, IMethodSymbol? constructorWithParameters, bool hasParameterlessConstructor)
    {
        var sb = new StringBuilder();
        
        // If the class has a constructor with parameters and no parameterless constructor
        if (constructorWithParameters != null && !hasParameterlessConstructor)
        {
            // Use the args parameter which contains class constructor arguments
            sb.Append($"new {className}(");
            
            // Generate argument list with proper type casting
            var parameterList = string.Join(", ", constructorWithParameters.Parameters
                .Select((param, i) => 
                {
                    var typeName = param.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat
                        .WithGlobalNamespaceStyle(SymbolDisplayGlobalNamespaceStyle.Omitted));
                    return $"({typeName})args[{i}]";
                }));
            
            sb.Append(parameterList);
            sb.Append(")");
            
            // If there are also required properties, add object initializer
            if (requiredProperties.Any())
            {
                sb.Append(" { ");
                var propertyInitializers = requiredProperties.Select(prop => 
                {
                    var defaultValue = GetDefaultValueForType(prop.Type);
                    return $"{prop.Name} = {defaultValue}";
                });
                sb.Append(string.Join(", ", propertyInitializers));
                sb.Append(" }");
            }
        }
        else if (requiredProperties.Any())
        {
            // Only required properties, no constructor parameters
            sb.Append($"new {className} {{ ");
            
            var propertyInitializers = requiredProperties.Select(prop => 
            {
                var defaultValue = GetDefaultValueForType(prop.Type);
                return $"{prop.Name} = {defaultValue}";
            });
            
            sb.Append(string.Join(", ", propertyInitializers));
            sb.Append(" }");
        }
        else
        {
            // Simple parameterless constructor
            return $"new {className}()";
        }
        
        return sb.ToString();
    }

    private static string GetDefaultValueForType(ITypeSymbol type)
    {
        if (type.IsReferenceType || type.NullableAnnotation == NullableAnnotation.Annotated)
        {
            return "null!";
        }

        return type.SpecialType switch
        {
            SpecialType.System_Boolean => "false",
            SpecialType.System_Char => "'\\0'",
            SpecialType.System_SByte => "(sbyte)0",
            SpecialType.System_Byte => "(byte)0",
            SpecialType.System_Int16 => "(short)0",
            SpecialType.System_UInt16 => "(ushort)0",
            SpecialType.System_Int32 => "0",
            SpecialType.System_UInt32 => "0u",
            SpecialType.System_Int64 => "0L",
            SpecialType.System_UInt64 => "0ul",
            SpecialType.System_Decimal => "0m",
            SpecialType.System_Single => "0f",
            SpecialType.System_Double => "0d",
            _ => $"default({type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat.WithGlobalNamespaceStyle(SymbolDisplayGlobalNamespaceStyle.Omitted))})"
        };
    }

    private class TestMethodInfo
    {
        public IMethodSymbol MethodSymbol { get; set; } = null!;
        public INamedTypeSymbol TypeSymbol { get; set; } = null!;
        public string FilePath { get; set; } = "";
        public int LineNumber { get; set; }
        public AttributeData TestAttribute { get; set; } = null!;
    }
}