using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System;
using System.Collections.Immutable;
using System.Text;
using System.Linq;

namespace TUnit.Core.SourceGenerator;

/// <summary>
/// Source generator that emits TestMetadata for discovered tests.
/// </summary>
[Generator]
public class TestMetadataGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Find all test methods
        var testMethods = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                "TUnit.Core.TestAttribute",
                predicate: static (node, _) => node is MethodDeclarationSyntax,
                transform: static (ctx, _) => GetTestMethodMetadata(ctx))
            .Where(static m => m is not null);

        // Generate a separate file for each test method to avoid Collect()
        context.RegisterSourceOutput(testMethods, GenerateTestRegistration);
    }

    private static TestMethodInfo? GetTestMethodMetadata(GeneratorAttributeSyntaxContext context)
    {
        if (context.TargetSymbol is not IMethodSymbol methodSymbol)
        {
            return null;
        }

        var typeSymbol = methodSymbol.ContainingType;

        // Skip abstract classes and static methods
        if (typeSymbol.IsAbstract || methodSymbol.IsStatic)
        {
            return null;
        }

        // Skip non-public methods
        if (methodSymbol.DeclaredAccessibility != Accessibility.Public)
        {
            return null;
        }

        // Get location info
        var location = context.TargetNode.GetLocation();
        var filePath = location.SourceTree?.FilePath ?? "";
        var lineNumber = location.GetLineSpan().StartLinePosition.Line + 1;

        return new TestMethodInfo
        {
            MethodSymbol = methodSymbol,
            TypeSymbol = typeSymbol,
            FilePath = filePath,
            LineNumber = lineNumber,
            TestAttribute = context.Attributes[0]
        };
    }

    private static void GenerateTestRegistration(SourceProductionContext context, TestMethodInfo? testInfo)
    {
        if (testInfo == null)
        {
            return;
        }

        var sb = new StringBuilder();
        
        // Generate a unique identifier for this test
        var guid = Guid.NewGuid().ToString("N");
        var className = GetFullTypeName(testInfo.TypeSymbol);
        var methodName = testInfo.MethodSymbol.Name;
        // Sanitize class and method names for use in filenames
        var safeClassName = SanitizeForFilename(className);
        var safeMethodName = SanitizeForFilename(methodName);

        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("#nullable enable");
        sb.AppendLine("#pragma warning disable CS9113 // Parameter is unread.");
        sb.AppendLine();
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("using System.Reflection;");
        sb.AppendLine("using global::TUnit.Core;");
        sb.AppendLine();
        sb.AppendLine("using global::TUnit.Core.SourceGenerator;");
        sb.AppendLine();
        sb.AppendLine("namespace TUnit.Generated;");
        sb.AppendLine();
        sb.AppendLine($"internal static class TestMetadataRegistry_{safeClassName}_{safeMethodName}_{guid}");
        sb.AppendLine("{");
        sb.AppendLine("    [System.Runtime.CompilerServices.ModuleInitializer]");
        sb.AppendLine("    public static void Initialize()");
        sb.AppendLine("    {");
        sb.AppendLine("        var testMetadata = new System.Collections.Generic.List<TestMetadata>();");
        sb.AppendLine();
        sb.AppendLine($@"        testMetadata.Add(new TestMetadata
        {{
            TestIdTemplate = ""{className}.{methodName}_{{{{TestIndex}}}}"",
            TestClassType = typeof({className}),
            TestMethod = typeof({className}).GetMethod(""{methodName}"", BindingFlags.Public | BindingFlags.Instance),
            MethodMetadata = new MethodMetadata
            {{
                Name = ""{testInfo.MethodSymbol.Name}"",
                Type = typeof({className}),
                Parameters = System.Array.Empty<ParameterMetadata>(),
                GenericTypeCount = 0,
                Class = new ClassMetadata
                {{
                    Name = ""{testInfo.TypeSymbol.Name}"",
                    Type = typeof({className}),
                    Attributes = System.Array.Empty<AttributeMetadata>(),
                    Namespace = ""{testInfo.TypeSymbol.ContainingNamespace}"",
                    Assembly = new AssemblyMetadata {{ Name = ""{testInfo.TypeSymbol.ContainingAssembly.Name}"", Attributes = System.Array.Empty<AttributeMetadata>() }},
                    Parameters = System.Array.Empty<ParameterMetadata>(),
                    Properties = System.Array.Empty<PropertyMetadata>(),
                    Constructors = System.Array.Empty<ConstructorMetadata>(),
                    Parent = null
                }},
                ReturnType = typeof({GetReturnTypeName(testInfo.MethodSymbol)}),
                Attributes = System.Array.Empty<AttributeMetadata>()
            }},
            TestFilePath = @""{testInfo.FilePath.Replace("\\", "\\\\").Replace("\"", "\\\"")}"",
            TestLineNumber = {testInfo.LineNumber},
            TestClassFactory = args => new {className}(),
            ClassDataSources = System.Array.Empty<IDataSourceProvider>(),
            MethodDataSources = System.Array.Empty<IDataSourceProvider>(),
            PropertyDataSources = new System.Collections.Generic.Dictionary<PropertyInfo, IDataSourceProvider>(),
            DisplayNameTemplate = ""{methodName}"",
            RepeatCount = 1,
            IsAsync = {(IsAsyncMethod(testInfo.MethodSymbol) ? "true" : "false")},
            IsSkipped = false,
            SkipReason = null,
            Attributes = System.Array.Empty<Attribute>(),
            Timeout = null
        }});");
        sb.AppendLine();
        sb.AppendLine("        TestSourceRegistrar.RegisterMetadata(testMetadata);");
        sb.AppendLine("    }");
        sb.AppendLine("}");

        // Use GUID in the filename to prevent overwrites
        context.AddSource($"TestMetadata_{safeClassName}_{safeMethodName}_{guid}.g.cs", sb.ToString());
    }

    private static string GetFullTypeName(ITypeSymbol typeSymbol)
    {
        return typeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat
            .WithGlobalNamespaceStyle(SymbolDisplayGlobalNamespaceStyle.Omitted));
    }
    
    private static string SanitizeForFilename(string name)
    {
        // Replace all invalid filename characters with underscores
        var invalid = System.IO.Path.GetInvalidFileNameChars()
            .Concat(new[] { '<', '>', '(', ')', '[', ']', '{', '}', ',', ' ', '`', '.' })
            .Distinct();
            
        var sanitized = name;
        foreach (var c in invalid)
        {
            sanitized = sanitized.Replace(c, '_');
        }
        
        return sanitized;
    }

    private static string GetReturnTypeName(IMethodSymbol methodSymbol)
    {
        var returnType = methodSymbol.ReturnType;
        if (returnType.SpecialType == SpecialType.System_Void)
        {
            return "void";
        }

        return returnType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat
            .WithGlobalNamespaceStyle(SymbolDisplayGlobalNamespaceStyle.Omitted));
    }

    private static bool IsAsyncMethod(IMethodSymbol methodSymbol)
    {
        var returnType = methodSymbol.ReturnType;
        return returnType.Name == "Task" || returnType.Name == "ValueTask";
    }

    private class TestMethodInfo
    {
        public IMethodSymbol MethodSymbol { get; set; } = null!;
        public INamedTypeSymbol TypeSymbol { get; set; } = null!;
        public string FilePath { get; set; } = "";
        public int LineNumber { get; set; }
        public AttributeData TestAttribute { get; set; } = null!;
    }
}