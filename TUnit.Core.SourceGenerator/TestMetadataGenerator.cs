using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Collections.Immutable;
using System.Text;

namespace TUnit.Core.SourceGenerator;

/// <summary>
/// Source generator that emits TestMetadata for discovered tests.
/// </summary>
[Generator]
public class TestMetadataGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Find all test methods
        var testMethods = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                "TUnit.Core.TestAttribute",
                predicate: static (node, _) => node is MethodDeclarationSyntax,
                transform: static (ctx, _) => GetTestMethodMetadata(ctx))
            .Where(static m => m is not null);

        // Collect all test methods and generate registration
        var collected = testMethods.Collect();
        context.RegisterSourceOutput(collected, GenerateTestRegistration);
    }

    private static TestMethodInfo? GetTestMethodMetadata(GeneratorAttributeSyntaxContext context)
    {
        if (context.TargetSymbol is not IMethodSymbol methodSymbol)
            return null;

        var typeSymbol = methodSymbol.ContainingType;
        
        // Skip abstract classes and static methods
        if (typeSymbol.IsAbstract || methodSymbol.IsStatic)
            return null;

        // Skip non-public methods
        if (methodSymbol.DeclaredAccessibility != Accessibility.Public)
            return null;

        // Get location info
        var location = context.TargetNode.GetLocation();
        var filePath = location.SourceTree?.FilePath ?? "";
        var lineNumber = location.GetLineSpan().StartLinePosition.Line + 1;

        return new TestMethodInfo
        {
            MethodSymbol = methodSymbol,
            TypeSymbol = typeSymbol,
            FilePath = filePath,
            LineNumber = lineNumber,
            TestAttribute = context.Attributes[0]
        };
    }

    private static void GenerateTestRegistration(SourceProductionContext context, ImmutableArray<TestMethodInfo?> testMethods)
    {
        var validTests = testMethods.Where(t => t != null).Cast<TestMethodInfo>().ToList();
        if (!validTests.Any())
            return;

        var sourceBuilder = new StringBuilder();
        
        // Generate file header
        sourceBuilder.AppendLine("// <auto-generated/>");
        sourceBuilder.AppendLine("#nullable enable");
        sourceBuilder.AppendLine("using System;");
        sourceBuilder.AppendLine("using System.Collections.Generic;");
        sourceBuilder.AppendLine("using System.Reflection;");
        sourceBuilder.AppendLine("using TUnit.Core;");
        sourceBuilder.AppendLine("using TUnit.Core.DataSources;");
        sourceBuilder.AppendLine("using TUnit.Core.SourceGenerator;");
        sourceBuilder.AppendLine();
        sourceBuilder.AppendLine("namespace TUnit.Generated;");
        sourceBuilder.AppendLine();
        sourceBuilder.AppendLine("internal static class TestMetadataRegistry");
        sourceBuilder.AppendLine("{");
        sourceBuilder.AppendLine("    [System.Runtime.CompilerServices.ModuleInitializer]");
        sourceBuilder.AppendLine("    public static void Initialize()");
        sourceBuilder.AppendLine("    {");
        sourceBuilder.AppendLine("        var testMetadata = new List<TestMetadata>();");
        sourceBuilder.AppendLine();

        // Generate metadata for each test
        int testIndex = 0;
        foreach (var testInfo in validTests)
        {
            GenerateTestMetadata(sourceBuilder, testInfo, testIndex++);
        }

        sourceBuilder.AppendLine();
        sourceBuilder.AppendLine("        TestSourceRegistrar.RegisterMetadata(testMetadata);");
        sourceBuilder.AppendLine("    }");
        
        // Generate helper methods
        foreach (var testInfo in validTests.Select((t, i) => new { Test = t, Index = i }))
        {
            GenerateHelperMethods(sourceBuilder, testInfo.Test, testInfo.Index);
        }
        
        sourceBuilder.AppendLine("}");

        context.AddSource("TestMetadataRegistry.g.cs", sourceBuilder.ToString());
    }

    private static void GenerateTestMetadata(StringBuilder sb, TestMethodInfo testInfo, int index)
    {
        var className = GetFullTypeName(testInfo.TypeSymbol);
        var methodName = testInfo.MethodSymbol.Name;
        
        sb.AppendLine($"        // {className}.{methodName}");
        sb.AppendLine($"        testMetadata.Add(CreateTestMetadata_{index}());");
    }

    private static void GenerateHelperMethods(StringBuilder sb, TestMethodInfo testInfo, int index)
    {
        var className = GetFullTypeName(testInfo.TypeSymbol);
        var methodName = testInfo.MethodSymbol.Name;
        
        sb.AppendLine();
        sb.AppendLine($"    private static TestMetadata CreateTestMetadata_{index}()");
        sb.AppendLine("    {");
        sb.AppendLine("        return new TestMetadata");
        sb.AppendLine("        {");
        sb.AppendLine($"            TestIdTemplate = \"{className}.{methodName}_{{{{TestIndex}}}}\",");
        sb.AppendLine($"            TestClassType = typeof({className}),");
        sb.AppendLine($"            TestMethod = typeof({className}).GetMethod(\"{methodName}\", BindingFlags.Public | BindingFlags.Instance),");
        sb.AppendLine($"            MethodMetadata = CreateMethodMetadata_{index}(),");
        sb.AppendLine($"            TestFilePath = @\"{testInfo.FilePath}\",");
        sb.AppendLine($"            TestLineNumber = {testInfo.LineNumber},");
        sb.AppendLine($"            TestClassFactory = CreateClassFactory_{index}(),");
        sb.AppendLine($"            ClassDataSources = GetClassDataSources_{index}(),");
        sb.AppendLine($"            MethodDataSources = GetMethodDataSources_{index}(),");
        sb.AppendLine($"            PropertyDataSources = GetPropertyDataSources_{index}(),");
        sb.AppendLine($"            DisplayNameTemplate = \"{methodName}\",");
        sb.AppendLine($"            RepeatCount = {GetRepeatCount(testInfo)},");
        sb.AppendLine($"            IsAsync = {(IsAsyncMethod(testInfo.MethodSymbol) ? "true" : "false")},");
        sb.AppendLine($"            IsSkipped = {(IsSkipped(testInfo) ? "true" : "false")},");
        
        var skipReason = GetSkipReason(testInfo);
        if (skipReason != null)
            sb.AppendLine($"            SkipReason = \"{skipReason}\",");
        
        sb.AppendLine("            Attributes = Array.Empty<Attribute>(),");
        
        var timeout = GetTimeout(testInfo);
        if (timeout.HasValue)
            sb.AppendLine($"            Timeout = TimeSpan.FromMilliseconds({timeout.Value})");
        else
            sb.AppendLine("            Timeout = null");
        
        sb.AppendLine("        };");
        sb.AppendLine("    }");
        
        // Generate MethodMetadata helper
        GenerateMethodMetadataHelper(sb, testInfo, index);
        
        // Generate class factory
        GenerateClassFactoryHelper(sb, testInfo, index);
        
        // Generate data source helpers
        GenerateDataSourceHelpers(sb, testInfo, index);
    }

    private static void GenerateMethodMetadataHelper(StringBuilder sb, TestMethodInfo testInfo, int index)
    {
        var className = GetFullTypeName(testInfo.TypeSymbol);
        
        sb.AppendLine();
        sb.AppendLine($"    private static MethodMetadata CreateMethodMetadata_{index}()");
        sb.AppendLine("    {");
        sb.AppendLine("        return new MethodMetadata");
        sb.AppendLine("        {");
        sb.AppendLine($"            Name = \"{testInfo.MethodSymbol.Name}\",");
        sb.AppendLine($"            Type = typeof({className}),");
        
        // Generate parameter metadata
        sb.AppendLine("            Parameters = new ParameterMetadata[]");
        sb.AppendLine("            {");
        foreach (var param in testInfo.MethodSymbol.Parameters)
        {
            sb.AppendLine($"                new ParameterMetadata(typeof({GetFullTypeName(param.Type)}))");
            sb.AppendLine("                {");
            sb.AppendLine($"                    Name = \"{param.Name}\",");
            sb.AppendLine("                    Attributes = Array.Empty<AttributeMetadata>(),");
            sb.AppendLine($"                    ReflectionInfo = typeof({GetFullTypeName(testInfo.TypeSymbol)}).GetMethod(\"{testInfo.MethodSymbol.Name}\")!.GetParameters()[{param.Ordinal}]");
            sb.AppendLine("                },");
        }
        sb.AppendLine("            },");
        
        sb.AppendLine($"            GenericTypeCount = {testInfo.MethodSymbol.TypeParameters.Length},");
        sb.AppendLine("            Class = new ClassMetadata");
        sb.AppendLine("            {");
        sb.AppendLine($"                Name = \"{testInfo.TypeSymbol.Name}\",");
        sb.AppendLine($"                Type = typeof({className}),");
        sb.AppendLine("                Attributes = Array.Empty<AttributeMetadata>(),");
        sb.AppendLine($"                Namespace = \"{testInfo.TypeSymbol.ContainingNamespace}\",");
        sb.AppendLine($"                Assembly = new AssemblyMetadata {{ Name = \"{testInfo.TypeSymbol.ContainingAssembly.Name}\", Attributes = Array.Empty<AttributeMetadata>() }},");
        
        // Generate constructor parameters
        var constructors = testInfo.TypeSymbol.Constructors
            .Where(c => c.DeclaredAccessibility == Accessibility.Public)
            .ToList();
        
        if (constructors.Any())
        {
            var primaryConstructor = constructors.OrderBy(c => c.Parameters.Length).First();
            sb.AppendLine("                Parameters = new ParameterMetadata[]");
            sb.AppendLine("                {");
            foreach (var param in primaryConstructor.Parameters)
            {
                sb.AppendLine($"                    new ParameterMetadata(typeof({GetFullTypeName(param.Type)}))");
                sb.AppendLine("                    {");
                sb.AppendLine($"                        Name = \"{param.Name}\",");
                sb.AppendLine("                        Attributes = Array.Empty<AttributeMetadata>(),");
                sb.AppendLine($"                        ReflectionInfo = typeof({GetFullTypeName(testInfo.TypeSymbol)}).GetConstructors()[0].GetParameters()[{param.Ordinal}]");
                sb.AppendLine("                    },");
            }
            sb.AppendLine("                },");
        }
        else
        {
            sb.AppendLine("                Parameters = Array.Empty<ParameterMetadata>(),");
        }
        
        sb.AppendLine("                Properties = Array.Empty<PropertyMetadata>(),");
        sb.AppendLine("                Constructors = Array.Empty<ConstructorMetadata>(),");
        sb.AppendLine("                Parent = null");
        sb.AppendLine("            },");
        sb.AppendLine($"            ReturnType = typeof({GetReturnTypeName(testInfo.MethodSymbol)}),");
        sb.AppendLine("            Attributes = Array.Empty<AttributeMetadata>()");
        sb.AppendLine("        };");
        sb.AppendLine("    }");
    }

    private static void GenerateClassFactoryHelper(StringBuilder sb, TestMethodInfo testInfo, int index)
    {
        var className = GetFullTypeName(testInfo.TypeSymbol);
        
        sb.AppendLine();
        sb.AppendLine($"    private static Func<object?[]?, object?> CreateClassFactory_{index}()");
        sb.AppendLine("    {");
        sb.AppendLine("        return args =>");
        sb.AppendLine("        {");
        
        // Get public constructors
        var constructors = testInfo.TypeSymbol.Constructors
            .Where(c => c.DeclaredAccessibility == Accessibility.Public)
            .OrderBy(c => c.Parameters.Length)
            .ToList();
        
        if (!constructors.Any())
        {
            // No public constructors - use Activator
            sb.AppendLine($"            return Activator.CreateInstance(typeof({className}), args);");
        }
        else
        {
            var primaryConstructor = constructors.First();
            
            if (primaryConstructor.Parameters.Length == 0)
            {
                // Parameterless constructor
                sb.AppendLine($"            return new {className}();");
            }
            else
            {
                // Constructor with parameters
                sb.AppendLine("            if (args == null || args.Length == 0)");
                sb.AppendLine("            {");
                
                // Check if all parameters have defaults
                var allHaveDefaults = primaryConstructor.Parameters.All(p => p.HasExplicitDefaultValue);
                if (allHaveDefaults)
                {
                    var defaultArgs = string.Join(", ", 
                        primaryConstructor.Parameters.Select(p => FormatValue(p.ExplicitDefaultValue)));
                    sb.AppendLine($"                return new {className}({defaultArgs});");
                }
                else
                {
                    sb.AppendLine($"                throw new InvalidOperationException(\"Constructor for {className} requires {primaryConstructor.Parameters.Length} arguments\");");
                }
                
                sb.AppendLine("            }");
                sb.AppendLine();
                
                // Generate constructor call with args
                sb.AppendLine($"            return new {className}(");
                for (int i = 0; i < primaryConstructor.Parameters.Length; i++)
                {
                    var param = primaryConstructor.Parameters[i];
                    var comma = i < primaryConstructor.Parameters.Length - 1 ? "," : "";
                    sb.AppendLine($"                ({GetFullTypeName(param.Type)})args[{i}]{comma}");
                }
                sb.AppendLine("            );");
            }
        }
        
        sb.AppendLine("        };");
        sb.AppendLine("    }");
    }

    private static void GenerateDataSourceHelpers(StringBuilder sb, TestMethodInfo testInfo, int index)
    {
        var className = GetFullTypeName(testInfo.TypeSymbol);
        
        // Class data sources
        sb.AppendLine();
        sb.AppendLine($"    private static IReadOnlyList<IDataSourceProvider> GetClassDataSources_{index}()");
        sb.AppendLine("    {");
        
        var classDataSources = GetClassDataSources(testInfo);
        if (classDataSources.Any())
        {
            sb.AppendLine("        return new IDataSourceProvider[]");
            sb.AppendLine("        {");
            foreach (var source in classDataSources)
            {
                sb.AppendLine($"            {source},");
            }
            sb.AppendLine("        };");
        }
        else
        {
            sb.AppendLine("        return Array.Empty<IDataSourceProvider>();");
        }
        
        sb.AppendLine("    }");
        
        // Method data sources
        sb.AppendLine();
        sb.AppendLine($"    private static IReadOnlyList<IDataSourceProvider> GetMethodDataSources_{index}()");
        sb.AppendLine("    {");
        
        var methodDataSources = GetMethodDataSources(testInfo);
        if (methodDataSources.Any())
        {
            sb.AppendLine("        return new IDataSourceProvider[]");
            sb.AppendLine("        {");
            foreach (var source in methodDataSources)
            {
                sb.AppendLine($"            {source},");
            }
            sb.AppendLine("        };");
        }
        else
        {
            sb.AppendLine("        return Array.Empty<IDataSourceProvider>();");
        }
        
        sb.AppendLine("    }");
        
        // Property data sources
        sb.AppendLine();
        sb.AppendLine($"    private static IReadOnlyDictionary<PropertyInfo, IDataSourceProvider> GetPropertyDataSources_{index}()");
        sb.AppendLine("    {");
        
        var propertyDataSources = GetPropertyDataSources(testInfo);
        if (propertyDataSources.Any())
        {
            sb.AppendLine("        var dict = new Dictionary<PropertyInfo, IDataSourceProvider>();");
            foreach (var (propName, source) in propertyDataSources)
            {
                sb.AppendLine($"        dict[typeof({className}).GetProperty(\"{propName}\")] = {source};");
            }
            sb.AppendLine("        return dict;");
        }
        else
        {
            sb.AppendLine("        return new Dictionary<PropertyInfo, IDataSourceProvider>();");
        }
        
        sb.AppendLine("    }");
    }

    private static string GetFullTypeName(ITypeSymbol typeSymbol)
    {
        return typeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat
            .WithGlobalNamespaceStyle(SymbolDisplayGlobalNamespaceStyle.Omitted));
    }

    private static string GetReturnTypeName(IMethodSymbol methodSymbol)
    {
        var returnType = methodSymbol.ReturnType;
        if (returnType.SpecialType == SpecialType.System_Void)
            return "void";
        
        return returnType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat
            .WithGlobalNamespaceStyle(SymbolDisplayGlobalNamespaceStyle.Omitted));
    }

    private static bool IsAsyncMethod(IMethodSymbol methodSymbol)
    {
        var returnType = methodSymbol.ReturnType;
        return returnType.Name == "Task" || returnType.Name == "ValueTask";
    }

    private static int GetRepeatCount(TestMethodInfo testInfo)
    {
        var repeatAttr = testInfo.MethodSymbol.GetAttributes()
            .FirstOrDefault(a => a.AttributeClass?.ToDisplayString() == "TUnit.Core.RepeatAttribute");
        
        if (repeatAttr != null && repeatAttr.ConstructorArguments.Length > 0)
        {
            var count = repeatAttr.ConstructorArguments[0].Value;
            if (count is int repeatCount && repeatCount > 0)
            {
                return repeatCount;
            }
        }
        
        return 1;
    }

    private static bool IsSkipped(TestMethodInfo testInfo)
    {
        return testInfo.MethodSymbol.GetAttributes()
            .Any(a => a.AttributeClass?.ToDisplayString() == "TUnit.Core.SkipAttribute");
    }

    private static string? GetSkipReason(TestMethodInfo testInfo)
    {
        var skipAttr = testInfo.MethodSymbol.GetAttributes()
            .FirstOrDefault(a => a.AttributeClass?.ToDisplayString() == "TUnit.Core.SkipAttribute");
        
        if (skipAttr != null && skipAttr.ConstructorArguments.Length > 0)
        {
            return skipAttr.ConstructorArguments[0].Value?.ToString();
        }
        
        return null;
    }

    private static int? GetTimeout(TestMethodInfo testInfo)
    {
        var timeoutAttr = testInfo.MethodSymbol.GetAttributes()
            .FirstOrDefault(a => a.AttributeClass?.ToDisplayString() == "TUnit.Core.TimeoutAttribute");
        
        if (timeoutAttr != null && timeoutAttr.ConstructorArguments.Length > 0)
        {
            var timeout = timeoutAttr.ConstructorArguments[0].Value;
            if (timeout is int milliseconds && milliseconds > 0)
            {
                return milliseconds;
            }
        }
        
        return null;
    }

    private static List<object?[]> GetArgumentsAttributes(TestMethodInfo testInfo)
    {
        var result = new List<object?[]>();
        
        // Find ArgumentsAttribute on the method
        var argumentsAttributes = testInfo.MethodSymbol.GetAttributes()
            .Where(a => a.AttributeClass?.ToDisplayString() == "TUnit.Core.ArgumentsAttribute");
        
        foreach (var attr in argumentsAttributes)
        {
            var args = attr.ConstructorArguments
                .SelectMany<TypedConstant, TypedConstant>(a => a.Kind == TypedConstantKind.Array ? a.Values : new[] { a })
                .Select(a => a.Value)
                .ToArray();
            result.Add(args);
        }
        
        return result;
    }

    private static string FormatValue(object? value)
    {
        if (value == null)
            return "null";
        if (value is string s)
            return $"\"{s.Replace("\"", "\\\"")}\"";
        if (value is bool b)
            return b.ToString().ToLower();
        if (value is char c)
            return $"'{c}'";
        if (value is ITypeSymbol typeSymbol)
            return $"typeof({GetFullTypeName(typeSymbol)})";
        
        return value.ToString() ?? "null";
    }
    
    private static List<string> GetClassDataSources(TestMethodInfo testInfo)
    {
        var sources = new List<string>();
        
        // Check for ClassDataSource attributes on the class
        var classDataSourceAttrs = testInfo.TypeSymbol.GetAttributes()
            .Where(a => a.AttributeClass?.ToDisplayString() == "TUnit.Core.ClassDataSourceAttribute");
        
        foreach (var attr in classDataSourceAttrs)
        {
            if (attr.ConstructorArguments.Length > 0)
            {
                var sourceType = attr.ConstructorArguments[0].Value as ITypeSymbol;
                if (sourceType != null)
                {
                    var typeName = GetFullTypeName(sourceType);
                    var sharedStr = attr.NamedArguments.FirstOrDefault(n => n.Key == "Shared").Value.Value?.ToString()?.ToLower() ?? "false";
                    sources.Add($"new EnumerableDataSourceProvider(typeof({typeName}), {sharedStr})");
                }
            }
        }
        
        // Check for ClassConstructor attributes
        var constructorAttrs = testInfo.TypeSymbol.GetAttributes()
            .Where(a => a.AttributeClass?.ToDisplayString() == "TUnit.Core.ClassConstructorAttribute");
        
        foreach (var attr in constructorAttrs)
        {
            var args = attr.ConstructorArguments
                .SelectMany<TypedConstant, TypedConstant>(a => a.Kind == TypedConstantKind.Array ? a.Values : new[] { a })
                .Select(a => a.Value)
                .ToArray();
            
            if (args.Length > 0)
            {
                sources.Add($"new InlineDataSourceProvider({string.Join(", ", args.Select(FormatValue))})");
            }
        }
        
        return sources;
    }
    
    private static List<string> GetMethodDataSources(TestMethodInfo testInfo)
    {
        var sources = new List<string>();
        
        // Get inline Arguments attributes
        var argumentsAttributes = GetArgumentsAttributes(testInfo);
        foreach (var args in argumentsAttributes)
        {
            sources.Add($"new InlineDataSourceProvider({string.Join(", ", args.Select(FormatValue))})");
        }
        
        // Get MethodDataSource attributes
        var methodDataSourceAttrs = testInfo.MethodSymbol.GetAttributes()
            .Where(a => a.AttributeClass?.ToDisplayString() == "TUnit.Core.MethodDataSourceAttribute");
        
        foreach (var attr in methodDataSourceAttrs)
        {
            if (attr.ConstructorArguments.Length >= 1)
            {
                var methodName = attr.ConstructorArguments[0].Value?.ToString();
                if (!string.IsNullOrEmpty(methodName))
                {
                    var declaringType = attr.ConstructorArguments.Length >= 2 
                        ? attr.ConstructorArguments[1].Value as ITypeSymbol 
                        : testInfo.TypeSymbol;
                    
                    var typeName = GetFullTypeName(declaringType ?? testInfo.TypeSymbol);
                    sources.Add($"new MethodDataSourceProvider(typeof({typeName}), \"{methodName}\")");
                }
            }
        }
        
        return sources;
    }
    
    private static List<(string PropertyName, string Source)> GetPropertyDataSources(TestMethodInfo testInfo)
    {
        var sources = new List<(string, string)>();
        
        // Check properties for data source attributes
        var properties = testInfo.TypeSymbol.GetMembers()
            .OfType<IPropertySymbol>()
            .Where(p => p.DeclaredAccessibility == Accessibility.Public);
        
        foreach (var property in properties)
        {
            // Check for Arguments attribute on property
            var argsAttr = property.GetAttributes()
                .FirstOrDefault(a => a.AttributeClass?.ToDisplayString() == "TUnit.Core.ArgumentsAttribute");
            
            if (argsAttr != null)
            {
                var args = argsAttr.ConstructorArguments
                    .SelectMany<TypedConstant, TypedConstant>(a => a.Kind == TypedConstantKind.Array ? a.Values : new[] { a })
                    .Select(a => a.Value)
                    .ToArray();
                
                if (args.Length > 0)
                {
                    sources.Add((property.Name, $"new InlineDataSourceProvider({string.Join(", ", args.Select(FormatValue))})"));
                }
            }
            
            // Check for MethodDataSource attribute on property
            var methodDataSourceAttr = property.GetAttributes()
                .FirstOrDefault(a => a.AttributeClass?.ToDisplayString() == "TUnit.Core.MethodDataSourceAttribute");
            
            if (methodDataSourceAttr != null && methodDataSourceAttr.ConstructorArguments.Length >= 1)
            {
                var methodName = methodDataSourceAttr.ConstructorArguments[0].Value?.ToString();
                if (!string.IsNullOrEmpty(methodName))
                {
                    var declaringType = methodDataSourceAttr.ConstructorArguments.Length >= 2 
                        ? methodDataSourceAttr.ConstructorArguments[1].Value as ITypeSymbol 
                        : testInfo.TypeSymbol;
                    
                    var typeName = GetFullTypeName(declaringType ?? testInfo.TypeSymbol);
                    sources.Add((property.Name, $"new MethodDataSourceProvider(typeof({typeName}), \"{methodName}\")"));
                }
            }
        }
        
        return sources;
    }

    private class TestMethodInfo
    {
        public IMethodSymbol MethodSymbol { get; set; } = null!;
        public INamedTypeSymbol TypeSymbol { get; set; } = null!;
        public string FilePath { get; set; } = "";
        public int LineNumber { get; set; }
        public AttributeData TestAttribute { get; set; } = null!;
    }
}