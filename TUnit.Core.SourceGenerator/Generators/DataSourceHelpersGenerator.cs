using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using TUnit.Core.SourceGenerator.CodeGenerators.Helpers;
using TUnit.Core.SourceGenerator.Extensions;
using TUnit.Core.SourceGenerator.Models;

namespace TUnit.Core.SourceGenerator.Generators;

[Generator]
public class DataSourceHelpersGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var typesWithDataSourceProperties = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (s, _) => s is ClassDeclarationSyntax,
                transform: static (ctx, _) => GetTypeWithDataSourceProperties(ctx))
            .Where(static t => t is not null)
            .Collect()
            .SelectMany((types, _) => types.DistinctBy(t => t!.Value.TypeSymbol, SymbolEqualityComparer.Default));

        // Generate individual files for each unique type
        context.RegisterSourceOutput(typesWithDataSourceProperties, (spc, type) => { if (type != null) GenerateIndividualDataSourceHelper(spc, type); });
    }

    private static TypeWithDataSourceProperties? GetTypeWithDataSourceProperties(GeneratorSyntaxContext context)
    {
        var classDeclaration = (ClassDeclarationSyntax)context.Node;
        var semanticModel = context.SemanticModel;
        
        if (semanticModel.GetDeclaredSymbol(classDeclaration) is not INamedTypeSymbol typeSymbol)
        {
            return null;
        }

        var propertiesWithDataSource = typeSymbol.GetMembers()
            .OfType<IPropertySymbol>()
            .Where(p => p.DeclaredAccessibility == Accessibility.Public && 
                       (p.SetMethod != null || p.GetMethod != null) && // Include properties with getter (for init-only)
                       p.GetAttributes().Any(a => DataSourceAttributeHelper.IsDataSourceAttribute(a.AttributeClass)))
            .Select(p => new PropertyWithDataSource
            {
                Property = p,
                DataSourceAttribute = p.GetAttributes()
                    .First(a => DataSourceAttributeHelper.IsDataSourceAttribute(a.AttributeClass))
            })
            .ToList();

        if (!propertiesWithDataSource.Any())
        {
            return null;
        }

        return new TypeWithDataSourceProperties
        {
            TypeSymbol = typeSymbol,
            Properties = propertiesWithDataSource
        };
    }

    private static void GenerateIndividualDataSourceHelper(SourceProductionContext context, TypeWithDataSourceProperties? type)
    {
        // Skip if null, no properties or abstract class
        if (type == null || !type.Value.Properties.Any() || type.Value.TypeSymbol.IsAbstract)
        {
            return;
        }

        var fullyQualifiedType = type.Value.TypeSymbol.GloballyQualified();
        var safeName = GetSafeTypeName(type.Value.TypeSymbol);
        var fileName = $"{safeName}_DataSourceHelper.g.cs";

        var sb = new StringBuilder();
        
        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("#pragma warning disable");
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Runtime.CompilerServices;");
        sb.AppendLine("using System.Threading.Tasks;");
        sb.AppendLine("using TUnit.Core;");
        sb.AppendLine();
        sb.AppendLine("namespace TUnit.Core.Generated;");
        sb.AppendLine();
        
        // Generate individual module initializer for this type
        sb.AppendLine($"internal static class {safeName}_DataSourceInitializer");
        sb.AppendLine("{");
        sb.AppendLine("    [ModuleInitializer]");
        sb.AppendLine("    public static void Initialize()");
        sb.AppendLine("    {");
        sb.AppendLine($"        global::TUnit.Core.Helpers.DataSourceHelpers.RegisterPropertyInitializer<{fullyQualifiedType}>(InitializePropertiesAsync_{safeName});");
        sb.AppendLine("    }");
        
        // Generate the property initialization method for this specific type
        GeneratePropertyInitializationMethod(sb, type.Value, safeName, fullyQualifiedType);
        
        sb.AppendLine("}");

        context.AddSource(fileName, sb.ToString());
    }

    private static string GetSafeTypeName(INamedTypeSymbol typeSymbol)
    {
        var fullyQualifiedType = typeSymbol.GloballyQualified();
        return fullyQualifiedType
            .Replace("global::", "")
            .Replace(".", "_")
            .Replace("<", "_")
            .Replace(">", "_")
            .Replace(",", "_")
            .Replace(" ", "")
            .Replace("`", "_")
            .Replace("+", "_");
    }

    private static void GeneratePropertyInitializationMethod(StringBuilder sb, TypeWithDataSourceProperties type, string safeName, string fullyQualifiedType)
    {
        var settableProperties = type.Properties.Where(p => p.Property.SetMethod != null && !p.Property.SetMethod.IsInitOnly).ToList();
        var initOnlyProperties = type.Properties.Where(p => p.Property.SetMethod?.IsInitOnly == true).ToList();

        sb.AppendLine($"    public static async Task InitializePropertiesAsync_{safeName}({fullyQualifiedType} instance, global::TUnit.Core.MethodMetadata testInformation, string testSessionId)");
        sb.AppendLine("    {");

        // Handle init-only properties with reflection
        if (initOnlyProperties.Any())
        {
            sb.AppendLine("        // Set init-only properties that are null using reflection");
            foreach (var propInfo in initOnlyProperties)
            {
                var property = propInfo.Property;
                var propertyName = property.Name;
                
                if (!property.Type.IsValueType)
                {
                    sb.AppendLine($"        if (instance.{propertyName} == null)");
                    sb.AppendLine("        {");
                }
                else
                {
                    sb.AppendLine("        {");
                }
                
                sb.AppendLine($"            var value = await global::TUnit.Core.Helpers.DataSourceHelpers.ResolveDataSourcePropertyAsync(");
                sb.AppendLine($"                instance, \"{propertyName}\", testInformation, testSessionId);");
                sb.AppendLine($"            var backingField = instance.GetType().GetField(\"<{propertyName}>k__BackingField\", ");
                sb.AppendLine("                global::System.Reflection.BindingFlags.Instance | global::System.Reflection.BindingFlags.NonPublic);");
                sb.AppendLine("            backingField?.SetValue(instance, value);");
                sb.AppendLine("        }");
            }
            sb.AppendLine();
        }

        // Handle settable properties
        foreach (var propInfo in settableProperties)
        {
            var property = propInfo.Property;
            var propertyName = property.Name;
            
            if (property.IsStatic)
            {
                // Generate static property initialization
                sb.AppendLine($"        // Initialize static property {propertyName}");
                sb.AppendLine($"        if ({fullyQualifiedType}.{propertyName} == default)");
                sb.AppendLine("        {");
                sb.AppendLine($"            var value = await global::TUnit.Core.Helpers.DataSourceHelpers.ResolveDataSourcePropertyAsync(");
                sb.AppendLine($"                instance, \"{propertyName}\", testInformation, testSessionId);");
                sb.AppendLine($"            {fullyQualifiedType}.{propertyName} = ({property.Type.GloballyQualified()})value;");
                sb.AppendLine("        }");
            }
            else
            {
                GeneratePropertyInitialization(sb, propInfo);
            }
            sb.AppendLine();
        }

        sb.AppendLine("    }");
    }

    private static void GeneratePropertyInitialization(StringBuilder sb, PropertyWithDataSource propInfo)
    {
        var property = propInfo.Property;
        var attr = propInfo.DataSourceAttribute;
        var propertyName = property.Name;

        if (attr.AttributeClass == null)
        {
            return;
        }

        sb.AppendLine($"        // Initialize {propertyName} property");
        sb.AppendLine($"        if (instance.{propertyName} == default)");
        sb.AppendLine("        {");
        sb.AppendLine($"            var value = await global::TUnit.Core.Helpers.DataSourceHelpers.ResolveDataSourcePropertyAsync(");
        sb.AppendLine($"                instance, \"{propertyName}\", testInformation, testSessionId);");
        sb.AppendLine($"            instance.{propertyName} = ({property.Type.GloballyQualified()})value;");
        sb.AppendLine("        }");
        sb.AppendLine();
    }
}
