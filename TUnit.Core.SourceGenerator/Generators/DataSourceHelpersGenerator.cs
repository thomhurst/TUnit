using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using TUnit.Core.SourceGenerator.CodeGenerators.Helpers;
using TUnit.Core.SourceGenerator.Extensions;
using TUnit.Core.SourceGenerator.Models;

namespace TUnit.Core.SourceGenerator.Generators;

[Generator]
public class DataSourceHelpersGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var typesWithDataSourceProperties = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (s, _) => s is ClassDeclarationSyntax,
                transform: static (ctx, _) => GetTypeWithDataSourceProperties(ctx))
            .Where(static t => t is not null)
            .Collect();

        context.RegisterSourceOutput(typesWithDataSourceProperties, static (spc, types) => GenerateDataSourceHelpers(spc, types!));
    }

    private static TypeWithDataSourceProperties? GetTypeWithDataSourceProperties(GeneratorSyntaxContext context)
    {
        var classDeclaration = (ClassDeclarationSyntax)context.Node;
        var semanticModel = context.SemanticModel;
        
        if (semanticModel.GetDeclaredSymbol(classDeclaration) is not INamedTypeSymbol typeSymbol)
            return null;

        var propertiesWithDataSource = typeSymbol.GetMembers()
            .OfType<IPropertySymbol>()
            .Where(p => p.DeclaredAccessibility == Accessibility.Public && 
                       p.SetMethod != null &&
                       p.GetAttributes().Any(a => DataSourceAttributeHelper.IsDataSourceAttribute(a.AttributeClass)))
            .Select(p => new PropertyWithDataSource
            {
                Property = p,
                DataSourceAttribute = p.GetAttributes()
                    .First(a => DataSourceAttributeHelper.IsDataSourceAttribute(a.AttributeClass))
            })
            .ToList();

        if (!propertiesWithDataSource.Any())
            return null;

        return new TypeWithDataSourceProperties
        {
            TypeSymbol = typeSymbol,
            Properties = propertiesWithDataSource
        };
    }

    private static void GenerateDataSourceHelpers(SourceProductionContext context, ImmutableArray<TypeWithDataSourceProperties> types)
    {
        if (!types.Any()) return;

        // Deduplicate types by their fully qualified name
        var uniqueTypes = types
            .GroupBy(t => t.TypeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat))
            .Select(g => g.First())
            .ToArray();

        var sb = new StringBuilder();
        
        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Threading.Tasks;");
        sb.AppendLine("using TUnit.Core;");
        sb.AppendLine();
        sb.AppendLine("namespace TUnit.Core.Generated;");
        sb.AppendLine();
        sb.AppendLine("/// <summary>");
        sb.AppendLine("/// AOT-compatible generated helpers for data source property initialization");
        sb.AppendLine("/// </summary>");
        sb.AppendLine("public static class DataSourceHelpers");
        sb.AppendLine("{");
        
        // Generate static constructor to register all initializers
        sb.AppendLine("    static DataSourceHelpers()");
        sb.AppendLine("    {");
        foreach (var typeWithProperties in uniqueTypes)
        {
            var fullyQualifiedType = typeWithProperties.TypeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            var safeName = fullyQualifiedType.Replace("global::", "").Replace(".", "_").Replace("<", "_").Replace(">", "_").Replace(",", "_");
            sb.AppendLine($"        global::TUnit.Core.Helpers.DataSourceHelpers.RegisterPropertyInitializer<{fullyQualifiedType}>(InitializePropertiesAsync_{safeName});");
        }
        sb.AppendLine("    }");
        sb.AppendLine();

        foreach (var typeWithProperties in uniqueTypes)
        {
            GenerateTypeSpecificHelpers(sb, typeWithProperties);
        }

        sb.AppendLine("}");

        context.AddSource("DataSourceHelpers.g.cs", sb.ToString());
    }

    private static void GenerateTypeSpecificHelpers(StringBuilder sb, TypeWithDataSourceProperties typeInfo)
    {
        var typeSymbol = typeInfo.TypeSymbol;
        var fullyQualifiedTypeName = typeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        var safeName = fullyQualifiedTypeName.Replace("global::", "").Replace(".", "_").Replace("<", "_").Replace(">", "_").Replace(",", "_");

        // Generate CreateAndInitialize method
        sb.AppendLine($"    /// <summary>");
        sb.AppendLine($"    /// Creates and initializes an instance of {typeSymbol.Name} with data source properties");
        sb.AppendLine($"    /// </summary>");
        sb.AppendLine($"    public static async Task<{fullyQualifiedTypeName}> CreateAndInitializeAsync_{safeName}(global::TUnit.Core.MethodMetadata testInformation, string testSessionId)");
        sb.AppendLine("    {");
        
        // Handle required properties
        var requiredProperties = RequiredPropertyHelper.GetAllRequiredProperties(typeSymbol).ToList();
        if (requiredProperties.Any())
        {
            sb.AppendLine($"        var instance = new {fullyQualifiedTypeName}()");
            sb.AppendLine("        {");
            foreach (var prop in requiredProperties)
            {
                var defaultValue = RequiredPropertyHelper.GetDefaultValueForType(prop.Type);
                sb.AppendLine($"            {prop.Name} = {defaultValue},");
            }
            sb.AppendLine("        };");
        }
        else
        {
            sb.AppendLine($"        var instance = new {fullyQualifiedTypeName}();");
        }

        // Initialize data source properties
        sb.AppendLine($"        await InitializePropertiesAsync_{safeName}(instance, testInformation, testSessionId);");
        sb.AppendLine("        await global::TUnit.Core.ObjectInitializer.InitializeAsync(instance);");
        sb.AppendLine("        return instance;");
        sb.AppendLine("    }");
        sb.AppendLine();

        // Generate InitializeProperties method
        sb.AppendLine($"    /// <summary>");
        sb.AppendLine($"    /// Initializes data source properties on an existing instance of {typeSymbol.Name}");
        sb.AppendLine($"    /// </summary>");
        sb.AppendLine($"    public static async Task InitializePropertiesAsync_{safeName}({fullyQualifiedTypeName} instance, global::TUnit.Core.MethodMetadata testInformation, string testSessionId)");
        sb.AppendLine("    {");

        foreach (var propInfo in typeInfo.Properties)
        {
            GeneratePropertyInitialization(sb, propInfo, safeName);
        }

        sb.AppendLine("    }");
        sb.AppendLine();
    }

    private static void GeneratePropertyInitialization(StringBuilder sb, PropertyWithDataSource propInfo, string typeSafeName)
    {
        var property = propInfo.Property;
        var attr = propInfo.DataSourceAttribute;
        var propertyName = property.Name;

        if (attr.AttributeClass == null) return;

        var fullyQualifiedName = attr.AttributeClass.GloballyQualifiedNonGeneric();

        sb.AppendLine($"        // Initialize {propertyName} property");
        
        if (attr.AttributeClass.IsOrInherits("TUnit.Core.AsyncDataSourceGeneratorAttribute") ||
            attr.AttributeClass.IsOrInherits("TUnit.Core.AsyncUntypedDataSourceGeneratorAttribute"))
        {
            GenerateAsyncDataSourcePropertyInit(sb, propInfo);
        }
        else if (fullyQualifiedName == "global::TUnit.Core.ArgumentsAttribute")
        {
            GenerateArgumentsPropertyInit(sb, propInfo);
        }
        else if (fullyQualifiedName == "global::TUnit.Core.ClassDataSourceAttribute")
        {
            GenerateClassDataSourcePropertyInit(sb, propInfo);
        }
    }

    private static void GenerateAsyncDataSourcePropertyInit(StringBuilder sb, PropertyWithDataSource propInfo)
    {
        var property = propInfo.Property;
        var attr = propInfo.DataSourceAttribute;
        
        // For generic data source attributes, get the type from generic type argument
        if (attr.AttributeClass?.IsGenericType == true && attr.AttributeClass.TypeArguments.Length > 0)
        {
            var dataSourceType = attr.AttributeClass.TypeArguments[0];
            var fullyQualifiedType = dataSourceType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            var safeName = fullyQualifiedType.Replace("global::", "").Replace(".", "_").Replace("<", "_").Replace(">", "_").Replace(",", "_");
            
            sb.AppendLine("        {");
            sb.AppendLine($"            var dataSourceInstance = await CreateAndInitializeAsync_{safeName}(testInformation, testSessionId);");
            sb.AppendLine($"            instance.{property.Name} = dataSourceInstance;");
            sb.AppendLine("        }");
        }
        // For non-generic data source attributes, get type from constructor arguments
        else if (attr.ConstructorArguments.Length > 0 && attr.ConstructorArguments[0].Value is ITypeSymbol dataSourceType)
        {
            var fullyQualifiedType = dataSourceType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            var safeName = fullyQualifiedType.Replace("global::", "").Replace(".", "_").Replace("<", "_").Replace(">", "_").Replace(",", "_");
            
            sb.AppendLine("        {");
            sb.AppendLine($"            var dataSourceInstance = await CreateAndInitializeAsync_{safeName}(testInformation, testSessionId);");
            sb.AppendLine($"            instance.{property.Name} = dataSourceInstance;");
            sb.AppendLine("        }");
        }
    }

    private static void GenerateArgumentsPropertyInit(StringBuilder sb, PropertyWithDataSource propInfo)
    {
        var property = propInfo.Property;
        var attr = propInfo.DataSourceAttribute;
        
        if (attr.ConstructorArguments.Length > 0)
        {
            if (attr.ConstructorArguments[0].Kind == TypedConstantKind.Array &&
                attr.ConstructorArguments[0].Values.Length > 0)
            {
                var value = FormatConstantValue(attr.ConstructorArguments[0].Values[0]);
                sb.AppendLine($"        instance.{property.Name} = {value};");
            }
            else if (attr.ConstructorArguments[0].Kind != TypedConstantKind.Array)
            {
                var value = FormatConstantValue(attr.ConstructorArguments[0]);
                sb.AppendLine($"        instance.{property.Name} = {value};");
            }
        }
    }

    private static void GenerateClassDataSourcePropertyInit(StringBuilder sb, PropertyWithDataSource propInfo)
    {
        var property = propInfo.Property;
        var attr = propInfo.DataSourceAttribute;
        
        // For generic ClassDataSource<T>, get type from generic type argument
        if (attr.AttributeClass?.IsGenericType == true && attr.AttributeClass.TypeArguments.Length > 0)
        {
            var dataSourceType = attr.AttributeClass.TypeArguments[0];
            var fullyQualifiedType = dataSourceType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            var safeName = fullyQualifiedType.Replace("global::", "").Replace(".", "_").Replace("<", "_").Replace(">", "_").Replace(",", "_");
            
            sb.AppendLine("        {");
            sb.AppendLine($"            var dataSourceInstance = await CreateAndInitializeAsync_{safeName}(testInformation, testSessionId);");
            sb.AppendLine($"            instance.{property.Name} = dataSourceInstance;");
            sb.AppendLine("        }");
        }
        // For non-generic ClassDataSource, get type from constructor arguments
        else if (attr.ConstructorArguments.Length > 0 && attr.ConstructorArguments[0].Value is ITypeSymbol dataSourceType)
        {
            var fullyQualifiedType = dataSourceType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            var safeName = fullyQualifiedType.Replace("global::", "").Replace(".", "_").Replace("<", "_").Replace(">", "_").Replace(",", "_");
            
            sb.AppendLine("        {");
            sb.AppendLine($"            var dataSourceInstance = await CreateAndInitializeAsync_{safeName}(testInformation, testSessionId);");
            sb.AppendLine($"            instance.{property.Name} = dataSourceInstance;");
            sb.AppendLine("        }");
        }
    }

    private static string FormatConstantValue(TypedConstant constant)
    {
        return constant.Kind switch
        {
            TypedConstantKind.Primitive => constant.Value?.ToString() ?? "null",
            TypedConstantKind.Enum => $"({constant.Type!.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)}){constant.Value}",
            TypedConstantKind.Type => $"typeof({((ITypeSymbol)constant.Value!).ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)})",
            _ when constant.IsNull => "null",
            _ => "null"
        };
    }
}

public class TypeWithDataSourceProperties
{
    public required INamedTypeSymbol TypeSymbol { get; set; }
    public required List<PropertyWithDataSource> Properties { get; set; }
}