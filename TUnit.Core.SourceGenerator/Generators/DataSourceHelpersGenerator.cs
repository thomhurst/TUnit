using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using TUnit.Core.SourceGenerator.CodeGenerators.Helpers;
using TUnit.Core.SourceGenerator.Extensions;
using TUnit.Core.SourceGenerator.Models;

namespace TUnit.Core.SourceGenerator.Generators;

[Generator]
public class DataSourceHelpersGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var typesWithDataSourceProperties = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (s, _) => s is ClassDeclarationSyntax,
                transform: static (ctx, _) => GetTypeWithDataSourceProperties(ctx))
            .Where(static t => t is not null)
            .Collect();

        context.RegisterSourceOutput(typesWithDataSourceProperties, static (spc, types) => GenerateDataSourceHelpers(spc, types!));
    }

    private static TypeWithDataSourceProperties? GetTypeWithDataSourceProperties(GeneratorSyntaxContext context)
    {
        var classDeclaration = (ClassDeclarationSyntax)context.Node;
        var semanticModel = context.SemanticModel;
        
        if (semanticModel.GetDeclaredSymbol(classDeclaration) is not INamedTypeSymbol typeSymbol)
        {
            return null;
        }

        var propertiesWithDataSource = typeSymbol.GetMembers()
            .OfType<IPropertySymbol>()
            .Where(p => p.DeclaredAccessibility == Accessibility.Public && 
                       p.SetMethod != null &&
                       p.GetAttributes().Any(a => DataSourceAttributeHelper.IsDataSourceAttribute(a.AttributeClass)))
            .Select(p => new PropertyWithDataSource
            {
                Property = p,
                DataSourceAttribute = p.GetAttributes()
                    .First(a => DataSourceAttributeHelper.IsDataSourceAttribute(a.AttributeClass))
            })
            .ToList();

        if (!propertiesWithDataSource.Any())
        {
            return null;
        }

        return new TypeWithDataSourceProperties
        {
            TypeSymbol = typeSymbol,
            Properties = propertiesWithDataSource
        };
    }

    private static void GenerateDataSourceHelpers(SourceProductionContext context, ImmutableArray<TypeWithDataSourceProperties> types)
    {
        if (!types.Any())
        {
            return;
        }

        // Collect all referenced target types
        var referencedTypes = new HashSet<ITypeSymbol>(SymbolEqualityComparer.Default);
        foreach (var typeWithProps in types)
        {
            foreach (var prop in typeWithProps.Properties)
            {
                var attr = prop.DataSourceAttribute;
                
                // For generic data source attributes, get type from generic type argument
                if (attr.AttributeClass is { IsGenericType: true, TypeArguments.Length: > 0 })
                {
                    referencedTypes.Add(attr.AttributeClass.TypeArguments[0]);
                }
                // For non-generic data source attributes, get type from constructor arguments
                else if (attr.ConstructorArguments.Length > 0)
                {
                    var firstArg = attr.ConstructorArguments[0];
                    if (firstArg is { Kind: TypedConstantKind.Type, Value: ITypeSymbol targetType })
                    {
                        referencedTypes.Add(targetType);
                    }
                }
            }
        }
        
        // Create TypeWithDataSourceProperties entries for referenced types (with empty properties)
        var allTypes = types.ToList();
        foreach (var refType in referencedTypes)
        {
            if (!allTypes.Any(t => SymbolEqualityComparer.Default.Equals(t.TypeSymbol, refType)))
            {
                allTypes.Add(new TypeWithDataSourceProperties
                {
                    TypeSymbol = (INamedTypeSymbol)refType,
                    Properties =
                    [
                    ]
                });
            }
        }

        // Filter out types that shouldn't have helpers generated
        var filteredTypes = allTypes.Where(ShouldGenerateHelperFor).ToList();

        // Deduplicate types by their fully qualified name
        var uniqueTypes = filteredTypes
            .GroupBy(t => t.TypeSymbol.GloballyQualified())
            .Select(g => g.First())
            .ToArray();

        var sb = new StringBuilder();
        
        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Threading.Tasks;");
        sb.AppendLine("using TUnit.Core;");
        sb.AppendLine();
        sb.AppendLine("namespace TUnit.Core.Generated;");
        sb.AppendLine();
        sb.AppendLine("/// <summary>");
        sb.AppendLine("/// AOT-compatible generated helpers for data source property initialization");
        sb.AppendLine("/// </summary>");
        sb.AppendLine("public static class DataSourceHelpers");
        sb.AppendLine("{");
        
        // Generate static constructor to register all initializers
        sb.AppendLine("    static DataSourceHelpers()");
        sb.AppendLine("    {");
        foreach (var typeWithProperties in uniqueTypes)
        {
            var fullyQualifiedType = typeWithProperties.TypeSymbol.GloballyQualified();
            var safeName = fullyQualifiedType.Replace("global::", "").Replace(".", "_").Replace("<", "_").Replace(">", "_").Replace(",", "_");
            sb.AppendLine($"        global::TUnit.Core.Helpers.DataSourceHelpers.RegisterPropertyInitializer<{fullyQualifiedType}>(InitializePropertiesAsync_{safeName});");
        }
        sb.AppendLine("    }");
        sb.AppendLine();

        foreach (var typeWithProperties in uniqueTypes)
        {
            GenerateTypeSpecificHelpers(sb, typeWithProperties);
        }

        sb.AppendLine("}");

        context.AddSource("DataSourceHelpers.g.cs", sb.ToString());
    }

    private static bool ShouldGenerateHelperFor(TypeWithDataSourceProperties typeInfo)
    {
        var typeSymbol = typeInfo.TypeSymbol;
        
        // Skip primitive types and built-in .NET types
        if (typeSymbol.SpecialType != SpecialType.None)
        {
            return false;
        }

        // Skip string specifically
        if (typeSymbol.ToDisplayString() == "string")
        {
            return false;
        }

        // Skip if it's a system type
        var namespaceName = typeSymbol.ContainingNamespace?.ToDisplayString();
        if (namespaceName?.StartsWith("System") == true && !namespaceName.StartsWith("System.Threading.Tasks"))
        {
            return false;
        }

        // Skip test classes (classes that have TestAttribute or inherit from test base classes)
        if (IsTestClass(typeSymbol))
        {
            return false;
        }

        // Skip classes with complex constructor requirements that are likely test classes
        if (HasComplexConstructorRequirements(typeSymbol))
        {
            return false;
        }

        return true;
    }

    private static bool IsTestClass(INamedTypeSymbol typeSymbol)
    {
        // Check if the class or any of its methods have Test attributes
        var hasTestAttribute = typeSymbol.GetAttributes().Any(attr => 
            attr.AttributeClass?.Name.Contains("Test") == true);
            
        if (hasTestAttribute)
        {
            return true;
        }

        // Check methods for test attributes
        foreach (var member in typeSymbol.GetMembers().OfType<IMethodSymbol>())
        {
            if (member.GetAttributes().Any(attr => attr.AttributeClass?.Name.Contains("Test") == true))
            {
                return true;
            }
        }
        
        return false;
    }

    private static bool HasComplexConstructorRequirements(INamedTypeSymbol typeSymbol)
    {
        // If there's no parameterless constructor and all constructors have parameters,
        // it's likely a complex type that we shouldn't generate helpers for
        var constructors = typeSymbol.Constructors.Where(c => !c.IsStatic).ToList();
        
        if (!constructors.Any())
        {
            return true; // No constructors available
        }

        // Check if there's a parameterless constructor
        var hasParameterlessConstructor = constructors.Any(c => c.Parameters.Length == 0);
        
        if (hasParameterlessConstructor)
        {
            return false; // We can use the parameterless constructor
        }

        // If all constructors require parameters, check if they're simple types we can handle
        foreach (var constructor in constructors)
        {
            if (constructor.Parameters.All(p => CanProvideDefaultValue(p.Type)))
            {
                return false; // We can provide default values for all parameters
            }
        }
        
        return true; // Too complex to handle
    }

    private static bool CanProvideDefaultValue(ITypeSymbol type)
    {
        // We can provide default values for simple types
        return type.SpecialType != SpecialType.None || 
               type.TypeKind == TypeKind.Enum ||
               type.CanBeReferencedByName;
    }

    private static void GenerateTypeSpecificHelpers(StringBuilder sb, TypeWithDataSourceProperties typeInfo)
    {
        var typeSymbol = typeInfo.TypeSymbol;
        var fullyQualifiedTypeName = typeSymbol.GloballyQualified();
        var safeName = fullyQualifiedTypeName.Replace("global::", "").Replace(".", "_").Replace("<", "_").Replace(">", "_").Replace(",", "_");

        // Separate data source properties into init-only and settable
        var initOnlyProperties = new global::System.Collections.Generic.List<PropertyWithDataSource>();
        var settableProperties = new global::System.Collections.Generic.List<PropertyWithDataSource>();
        var staticProperties = new global::System.Collections.Generic.List<PropertyWithDataSource>();
        
        foreach (var prop in typeInfo.Properties)
        {
            if (prop.Property.IsStatic)
            {
                staticProperties.Add(prop);
            }
            else if (prop.Property.SetMethod?.IsInitOnly == true)
            {
                initOnlyProperties.Add(prop);
            }
            else
            {
                settableProperties.Add(prop);
            }
        }

        // Generate CreateAndInitialize method
        sb.AppendLine("    /// <summary>");
        sb.AppendLine($"    /// Creates and initializes an instance of {typeSymbol.Name} with data source properties");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine($"    public static async Task<{fullyQualifiedTypeName}> CreateAndInitializeAsync_{safeName}(global::TUnit.Core.MethodMetadata testInformation, string testSessionId)");
        sb.AppendLine("    {");
        
        // Handle constructor requirements and init-only properties in object initializer
        var requiredProperties = RequiredPropertyHelper.GetAllRequiredProperties(typeSymbol).ToList();
        var hasInitOnlyDataSourceProps = initOnlyProperties.Any();
        
        // Check for constructor parameters
        var constructors = typeSymbol.Constructors.Where(c => !c.IsStatic).ToList();
        var parameterlessConstructor = constructors.FirstOrDefault(c => c.Parameters.Length == 0);
        var constructorWithDefaults = constructors.FirstOrDefault(c => c.Parameters.All(p => CanProvideDefaultValue(p.Type)));
        
        if (parameterlessConstructor != null)
        {
            // Use parameterless constructor
            if (requiredProperties.Any() || hasInitOnlyDataSourceProps)
            {
                sb.AppendLine($"        var instance = new {fullyQualifiedTypeName}()");
                sb.AppendLine("        {");
                
                // Get names of init-only data source properties to avoid duplicates
                var initOnlyPropertyNames = initOnlyProperties.Select(p => p.Property.Name).ToHashSet();
                
                // Add required properties (only those not handled by data source properties)
                foreach (var prop in requiredProperties)
                {
                    if (!initOnlyPropertyNames.Contains(prop.Name))
                    {
                        var defaultValue = RequiredPropertyHelper.GetDefaultValueForType(prop.Type);
                        sb.AppendLine($"            {prop.Name} = {defaultValue},");
                    }
                }
                
                // Add init-only data source properties
                foreach (var propInfo in initOnlyProperties)
                {
                    GenerateInitOnlyPropertyAssignment(sb, propInfo);
                }
                
                sb.AppendLine("        };");
            }
            else
            {
                sb.AppendLine($"        var instance = new {fullyQualifiedTypeName}();");
            }
        }
        else if (constructorWithDefaults != null)
        {
            // Use constructor with default values
            var constructorArgs = constructorWithDefaults.Parameters
                .Select(p => GetDefaultValueForType(p.Type))
                .ToList();
                
            if (requiredProperties.Any() || hasInitOnlyDataSourceProps)
            {
                sb.AppendLine($"        var instance = new {fullyQualifiedTypeName}({string.Join(", ", constructorArgs)})");
                sb.AppendLine("        {");
                
                // Get names of init-only data source properties to avoid duplicates
                var initOnlyPropertyNames = initOnlyProperties.Select(p => p.Property.Name).ToHashSet();
                
                // Add required properties (only those not handled by data source properties)
                foreach (var prop in requiredProperties)
                {
                    if (!initOnlyPropertyNames.Contains(prop.Name))
                    {
                        var defaultValue = RequiredPropertyHelper.GetDefaultValueForType(prop.Type);
                        sb.AppendLine($"            {prop.Name} = {defaultValue},");
                    }
                }
                
                // Add init-only data source properties
                foreach (var propInfo in initOnlyProperties)
                {
                    GenerateInitOnlyPropertyAssignment(sb, propInfo);
                }
                
                sb.AppendLine("        };");
            }
            else
            {
                sb.AppendLine($"        var instance = new {fullyQualifiedTypeName}({string.Join(", ", constructorArgs)});");
            }
        }
        else
        {
            // No suitable constructor found, use reflection or activator
            sb.AppendLine($"        var instance = ({fullyQualifiedTypeName})System.Activator.CreateInstance(typeof({fullyQualifiedTypeName}), true);");
            
            // Get names of init-only data source properties to avoid duplicates
            var initOnlyPropertyNames = initOnlyProperties.Select(p => p.Property.Name).ToHashSet();
            
            // Set required properties if needed (only those not handled by data source properties)
            foreach (var prop in requiredProperties)
            {
                if (!initOnlyPropertyNames.Contains(prop.Name))
                {
                    var defaultValue = RequiredPropertyHelper.GetDefaultValueForType(prop.Type);
                    sb.AppendLine($"        instance.{prop.Name} = {defaultValue};");
                }
            }
        }

        // Initialize settable data source properties
        sb.AppendLine($"        await InitializePropertiesAsync_{safeName}(instance, testInformation, testSessionId);");
        
        // Initialize static properties
        if (staticProperties.Any())
        {
            sb.AppendLine($"        await InitializeStaticPropertiesAsync_{safeName}(testInformation, testSessionId);");
        }
        
        sb.AppendLine("        return instance;");
        sb.AppendLine("    }");
        sb.AppendLine();

        // Generate InitializeProperties method for instance properties
        sb.AppendLine("    /// <summary>");
        sb.AppendLine($"    /// Initializes data source properties on an existing instance of {typeSymbol.Name}");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine($"    public static async Task InitializePropertiesAsync_{safeName}({fullyQualifiedTypeName} instance, global::TUnit.Core.MethodMetadata testInformation, string testSessionId)");
        sb.AppendLine("    {");

        foreach (var propInfo in settableProperties)
        {
            GeneratePropertyInitialization(sb, propInfo, safeName);
        }

        sb.AppendLine("    }");
        sb.AppendLine();
        
        // Generate InitializeStaticProperties method if needed
        if (staticProperties.Any())
        {
            sb.AppendLine("    /// <summary>");
            sb.AppendLine($"    /// Initializes static data source properties for {typeSymbol.Name}");
            sb.AppendLine("    /// </summary>");
            sb.AppendLine($"    public static async Task InitializeStaticPropertiesAsync_{safeName}(global::TUnit.Core.MethodMetadata testInformation, string testSessionId)");
            sb.AppendLine("    {");

            foreach (var propInfo in staticProperties)
            {
                GenerateStaticPropertyInitialization(sb, propInfo, fullyQualifiedTypeName);
            }

            sb.AppendLine("    }");
            sb.AppendLine();
        }
    }

    private static void GeneratePropertyInitialization(StringBuilder sb, PropertyWithDataSource propInfo, string typeSafeName)
    {
        var property = propInfo.Property;
        var attr = propInfo.DataSourceAttribute;
        var propertyName = property.Name;

        if (attr.AttributeClass == null)
        {
            return;
        }

        var fullyQualifiedName = attr.AttributeClass.GloballyQualifiedNonGeneric();

        sb.AppendLine($"        // Initialize {propertyName} property");
        
        if (attr.AttributeClass.IsOrInherits("global::TUnit.Core.AsyncDataSourceGeneratorAttribute") ||
            attr.AttributeClass.IsOrInherits("global::TUnit.Core.AsyncUntypedDataSourceGeneratorAttribute"))
        {
            GenerateAsyncDataSourcePropertyInit(sb, propInfo);
        }
        else if (fullyQualifiedName == "global::TUnit.Core.ArgumentsAttribute")
        {
            GenerateArgumentsPropertyInit(sb, propInfo);
        }
    }

    private static void GenerateAsyncDataSourcePropertyInit(StringBuilder sb, PropertyWithDataSource propInfo)
    {
        var property = propInfo.Property;
        var attr = propInfo.DataSourceAttribute;
        
        // For generic data source attributes, get the type from generic type argument
        if (attr.AttributeClass is { IsGenericType: true, TypeArguments.Length: > 0 })
        {
            var dataSourceType = attr.AttributeClass.TypeArguments[0];
            var fullyQualifiedType = dataSourceType.GloballyQualified();
            var safeName = fullyQualifiedType.Replace("global::", "").Replace(".", "_").Replace("<", "_").Replace(">", "_").Replace(",", "_");
            
            sb.AppendLine("        {");
            sb.AppendLine($"            var dataSourceInstance = await CreateAndInitializeAsync_{safeName}(testInformation, testSessionId);");
            sb.AppendLine($"            instance.{property.Name} = dataSourceInstance;");
            sb.AppendLine("        }");
        }
        // For non-generic data source attributes, get type from constructor arguments
        else if (attr.ConstructorArguments.Length > 0)
        {
            var firstArg = attr.ConstructorArguments[0];
            if (firstArg is { Kind: TypedConstantKind.Type, Value: ITypeSymbol dataSourceType })
            {
                var fullyQualifiedType = dataSourceType.GloballyQualified();
                var safeName = fullyQualifiedType.Replace("global::", "").Replace(".", "_").Replace("<", "_").Replace(">", "_").Replace(",", "_");
                
                sb.AppendLine("        {");
                sb.AppendLine($"            var dataSourceInstance = await CreateAndInitializeAsync_{safeName}(testInformation, testSessionId);");
                sb.AppendLine($"            instance.{property.Name} = dataSourceInstance;");
                sb.AppendLine("        }");
            }
        }
    }

    private static void GenerateArgumentsPropertyInit(StringBuilder sb, PropertyWithDataSource propInfo)
    {
        var property = propInfo.Property;
        var attr = propInfo.DataSourceAttribute;
        
        if (attr.ConstructorArguments.Length > 0)
        {
            if (attr.ConstructorArguments[0].Kind == TypedConstantKind.Array &&
                attr.ConstructorArguments[0].Values.Length > 0)
            {
                var value = FormatConstantValue(attr.ConstructorArguments[0].Values[0]);
                sb.AppendLine($"        instance.{property.Name} = {value};");
            }
            else if (attr.ConstructorArguments[0].Kind != TypedConstantKind.Array)
            {
                var value = FormatConstantValue(attr.ConstructorArguments[0]);
                sb.AppendLine($"        instance.{property.Name} = {value};");
            }
        }
    }


    private static void GenerateInitOnlyPropertyAssignment(StringBuilder sb, PropertyWithDataSource propInfo)
    {
        var property = propInfo.Property;
        var attr = propInfo.DataSourceAttribute;
        var propertyName = property.Name;

        if (attr.AttributeClass == null)
        {
            return;
        }

        var fullyQualifiedName = attr.AttributeClass.GloballyQualifiedNonGeneric();

        sb.AppendLine($"            // Initialize {propertyName} property (init-only)");
        
        if (attr.AttributeClass.IsOrInherits("global::TUnit.Core.AsyncDataSourceGeneratorAttribute") ||
            attr.AttributeClass.IsOrInherits("global::TUnit.Core.AsyncUntypedDataSourceGeneratorAttribute"))
        {
            // For async data sources, we need to generate a temporary value since we can't await in object initializer
            sb.AppendLine($"            {propertyName} = default!,");
        }
        else if (fullyQualifiedName == "global::TUnit.Core.ArgumentsAttribute")
        {
            GenerateArgumentsPropertyAssignment(sb, propInfo);
        }
        else
        {
            sb.AppendLine($"            {propertyName} = default!,");
        }
    }

    private static void GenerateArgumentsPropertyAssignment(StringBuilder sb, PropertyWithDataSource propInfo)
    {
        var property = propInfo.Property;
        var attr = propInfo.DataSourceAttribute;
        
        if (attr.ConstructorArguments.Length > 0)
        {
            if (attr.ConstructorArguments[0].Kind == TypedConstantKind.Array &&
                attr.ConstructorArguments[0].Values.Length > 0)
            {
                var value = FormatConstantValue(attr.ConstructorArguments[0].Values[0]);
                sb.AppendLine($"            {property.Name} = {value},");
            }
            else if (attr.ConstructorArguments[0].Kind != TypedConstantKind.Array)
            {
                var value = FormatConstantValue(attr.ConstructorArguments[0]);
                sb.AppendLine($"            {property.Name} = {value},");
            }
        }
    }

    private static void GenerateStaticPropertyInitialization(StringBuilder sb, PropertyWithDataSource propInfo, string fullyQualifiedTypeName)
    {
        var property = propInfo.Property;
        var attr = propInfo.DataSourceAttribute;
        var propertyName = property.Name;

        if (attr.AttributeClass == null)
        {
            return;
        }

        var fullyQualifiedName = attr.AttributeClass.GloballyQualifiedNonGeneric();

        sb.AppendLine($"        // Initialize static {propertyName} property");
        
        if (attr.AttributeClass.IsOrInherits("global::TUnit.Core.AsyncDataSourceGeneratorAttribute") ||
            attr.AttributeClass.IsOrInherits("global::TUnit.Core.AsyncUntypedDataSourceGeneratorAttribute"))
        {
            GenerateStaticAsyncDataSourcePropertyInit(sb, propInfo, fullyQualifiedTypeName);
        }
        else if (fullyQualifiedName == "global::TUnit.Core.ArgumentsAttribute")
        {
            GenerateStaticArgumentsPropertyInit(sb, propInfo, fullyQualifiedTypeName);
        }
    }

    private static void GenerateStaticAsyncDataSourcePropertyInit(StringBuilder sb, PropertyWithDataSource propInfo, string fullyQualifiedTypeName)
    {
        var property = propInfo.Property;
        var attr = propInfo.DataSourceAttribute;
        
        // For generic data source attributes, get the type from generic type argument
        if (attr.AttributeClass is { IsGenericType: true, TypeArguments.Length: > 0 })
        {
            var dataSourceType = attr.AttributeClass.TypeArguments[0];
            var fullyQualifiedType = dataSourceType.GloballyQualified();
            var safeName = fullyQualifiedType.Replace("global::", "").Replace(".", "_").Replace("<", "_").Replace(">", "_").Replace(",", "_");
            
            sb.AppendLine("        {");
            sb.AppendLine($"            var dataSourceInstance = await CreateAndInitializeAsync_{safeName}(testInformation, testSessionId);");
            sb.AppendLine($"            {fullyQualifiedTypeName}.{property.Name} = dataSourceInstance;");
            sb.AppendLine("        }");
        }
        // For non-generic data source attributes, get type from constructor arguments
        else if (attr.ConstructorArguments.Length > 0)
        {
            var firstArg = attr.ConstructorArguments[0];
            if (firstArg is { Kind: TypedConstantKind.Type, Value: ITypeSymbol dataSourceType })
            {
                var fullyQualifiedType = dataSourceType.GloballyQualified();
                var safeName = fullyQualifiedType.Replace("global::", "").Replace(".", "_").Replace("<", "_").Replace(">", "_").Replace(",", "_");
                
                sb.AppendLine("        {");
                sb.AppendLine($"            var dataSourceInstance = await CreateAndInitializeAsync_{safeName}(testInformation, testSessionId);");
                sb.AppendLine($"            {fullyQualifiedTypeName}.{property.Name} = dataSourceInstance;");
                sb.AppendLine("        }");
            }
        }
    }

    private static void GenerateStaticArgumentsPropertyInit(StringBuilder sb, PropertyWithDataSource propInfo, string fullyQualifiedTypeName)
    {
        var property = propInfo.Property;
        var attr = propInfo.DataSourceAttribute;
        
        if (attr.ConstructorArguments.Length > 0)
        {
            if (attr.ConstructorArguments[0].Kind == TypedConstantKind.Array &&
                attr.ConstructorArguments[0].Values.Length > 0)
            {
                var value = FormatConstantValue(attr.ConstructorArguments[0].Values[0]);
                sb.AppendLine($"        {fullyQualifiedTypeName}.{property.Name} = {value};");
            }
            else if (attr.ConstructorArguments[0].Kind != TypedConstantKind.Array)
            {
                var value = FormatConstantValue(attr.ConstructorArguments[0]);
                sb.AppendLine($"        {fullyQualifiedTypeName}.{property.Name} = {value};");
            }
        }
    }


    private static string GetDefaultValueForType(ITypeSymbol type)
    {
        return type.SpecialType switch
        {
            SpecialType.System_Boolean => "false",
            SpecialType.System_Byte => "(byte)0",
            SpecialType.System_SByte => "(sbyte)0",
            SpecialType.System_Int16 => "(short)0",
            SpecialType.System_UInt16 => "(ushort)0",
            SpecialType.System_Int32 => "0",
            SpecialType.System_UInt32 => "0U",
            SpecialType.System_Int64 => "0L",
            SpecialType.System_UInt64 => "0UL",
            SpecialType.System_Single => "0f",
            SpecialType.System_Double => "0d",
            SpecialType.System_Decimal => "0m",
            SpecialType.System_Char => "'\\0'",
            SpecialType.System_String => "\"\"",
            SpecialType.System_DateTime => "default(System.DateTime)",
            _ when type.TypeKind == TypeKind.Enum => $"default({type.GloballyQualified()})",
            _ when type.CanBeReferencedByName => $"default({type.GloballyQualified()})",
            _ => "null"
        };
    }

    private static string FormatConstantValue(TypedConstant constant)
    {
        return constant.Kind switch
        {
            TypedConstantKind.Primitive when constant.Value is string str => $"\"{str}\"",
            TypedConstantKind.Primitive when constant.Value is char ch => $"'{ch}'",
            TypedConstantKind.Primitive when constant.Value is bool b => b.ToString().ToLowerInvariant(),
            TypedConstantKind.Primitive => constant.Value?.ToString() ?? "null",
            TypedConstantKind.Enum => $"({constant.Type!.GloballyQualified()}){constant.Value}",
            TypedConstantKind.Type => $"typeof({((ITypeSymbol)constant.Value!).GloballyQualified()})",
            _ when constant.IsNull => "null",
            _ => "null"
        };
    }
}

public class TypeWithDataSourceProperties
{
    public required INamedTypeSymbol TypeSymbol { get; set; }
    public required List<PropertyWithDataSource> Properties { get; set; }
}