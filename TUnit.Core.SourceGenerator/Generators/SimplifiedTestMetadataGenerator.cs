using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using TUnit.Core.SourceGenerator.CodeGenerators.Writers;
using TUnit.Core.SourceGenerator.DataSourceGenerators;

namespace TUnit.Core.SourceGenerator.Generators;

/// <summary>
/// Simplified test metadata generator that emits one TestMetadata<T> per method
/// with a DataCombinationGenerator delegate for runtime data expansion.
/// </summary>
[Generator]
public sealed class SimplifiedTestMetadataGenerator : IIncrementalGenerator
{
    private const string GeneratedNamespace = "TUnit.Generated";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Register post-initialization output for base types
        context.RegisterPostInitializationOutput(GenerateBaseTypes);

        // Find all test methods using the more performant ForAttributeWithMetadataName
        var testMethodsProvider = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                "TUnit.Core.TestAttribute",
                predicate: static (node, _) => node is MethodDeclarationSyntax,
                transform: static (ctx, _) => GetTestMethodMetadata(ctx))
            .Where(static m => m is not null);

        // Generate one source file per test method
        context.RegisterSourceOutput(testMethodsProvider, static (context, testMethod) => GenerateTestMethodSource(context, testMethod));
    }

    private static void GenerateBaseTypes(IncrementalGeneratorPostInitializationContext context)
    {
        // Generate any base types needed for the simplified approach
        // For now, we'll keep this empty as we're using existing types
    }

    private static TestMethodMetadata? GetTestMethodMetadata(GeneratorAttributeSyntaxContext context)
    {
        var methodSyntax = (MethodDeclarationSyntax)context.TargetNode;
        var methodSymbol = context.TargetSymbol as IMethodSymbol;

        var containingType = methodSymbol?.ContainingType;

        if (containingType == null)
        {
            return null;
        }

        // Skip abstract classes (cannot be instantiated)
        if (containingType.IsAbstract)
        {
            return null;
        }

        // Skip generic types without explicit instantiation
        if (containingType is { IsGenericType: true, TypeParameters.Length: > 0 })
        {
            return null;
        }

        // Skip generic methods without explicit instantiation
        if (methodSymbol is { IsGenericMethod: true })
        {
            return null;
        }

        return new TestMethodMetadata
        {
            MethodSymbol = methodSymbol ?? throw new InvalidOperationException("Symbol is not a method"),
            TypeSymbol = containingType,
            MethodSyntax = methodSyntax
        };
    }

    private static void GenerateTestMethodSource(SourceProductionContext context, TestMethodMetadata? testMethod)
    {
        try
        {
            if (testMethod?.MethodSymbol == null || testMethod.TypeSymbol == null)
            {
                return;
            }

            var writer = new CodeWriter();
            GenerateFileHeader(writer);
            GenerateSimplifiedTestMetadata(writer, testMethod);

            var fileName = $"Simplified_{testMethod.TypeSymbol.Name}_{testMethod.MethodSymbol.Name}_{Guid.NewGuid():N}.g.cs";
            context.AddSource(fileName, SourceText.From(writer.ToString(), Encoding.UTF8));
        }
        catch (Exception ex)
        {
            var methodName = testMethod?.MethodSymbol?.Name ?? "Unknown";
            var className = testMethod?.TypeSymbol?.Name ?? "Unknown";
            
            context.ReportDiagnostic(Diagnostic.Create(
                new DiagnosticDescriptor(
                    "TUNIT0999", 
                    "Source Generation Error", 
                    "Failed to generate test metadata for {0}.{1}: {2}", 
                    "TUnit", 
                    DiagnosticSeverity.Error, 
                    true),
                Location.None,
                className,
                methodName,
                ex.Message));
        }
    }

    private static void GenerateFileHeader(CodeWriter writer)
    {
        writer.WriteLine("// <auto-generated/>");
        writer.WriteLine("#pragma warning disable");
        writer.WriteLine("#nullable enable");
        writer.WriteLine();
        writer.WriteLine("using System;");
        writer.WriteLine("using System.Collections.Generic;");
        writer.WriteLine("using System.Linq;");
        writer.WriteLine("using System.Threading;");
        writer.WriteLine("using System.Threading.Tasks;");
        writer.WriteLine("using global::TUnit.Core;");
        writer.WriteLine("using global::TUnit.Core.Interfaces.SourceGenerator;");
        writer.WriteLine();
        writer.WriteLine($"namespace {GeneratedNamespace};");
        writer.WriteLine();
    }

    private static void GenerateSimplifiedTestMetadata(CodeWriter writer, TestMethodMetadata testMethod)
    {
        var className = testMethod.TypeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        var methodName = testMethod.MethodSymbol.Name;
        var guid = Guid.NewGuid().ToString("N");

        writer.WriteLine($"internal sealed class {testMethod.TypeSymbol.Name}_{methodName}_TestSource_{guid} : ITestSource");
        writer.WriteLine("{");
        writer.Indent();

        writer.WriteLine("public async ValueTask<List<TestMetadata>> GetTestsAsync()");
        writer.WriteLine("{");
        writer.Indent();

        writer.WriteLine("var tests = new List<TestMetadata>();");
        writer.WriteLine();

        // Generate the TestMetadata<T> with DataCombinationGenerator
        GenerateTestMetadataInstance(writer, testMethod, className);

        writer.WriteLine("return tests;");
        writer.Outdent();
        writer.WriteLine("}");

        writer.Outdent();
        writer.WriteLine("}");

        // Generate module initializer
        GenerateModuleInitializer(writer, testMethod, guid);
    }

    private static void GenerateTestMetadataInstance(CodeWriter writer, TestMethodMetadata testMethod, string className)
    {
        var methodName = testMethod.MethodSymbol.Name;
        var testId = $"{className}.{methodName}";

        writer.WriteLine($"tests.Add(new TestMetadata<{className}>");
        writer.WriteLine("{");
        writer.Indent();

        writer.WriteLine($"TestId = \"{testId}\",");
        writer.WriteLine($"TestName = \"{methodName}\",");
        writer.WriteLine($"TestClassType = typeof({className}),");
        writer.WriteLine($"TestMethodName = \"{methodName}\",");
        
        // Add basic metadata
        GenerateBasicMetadata(writer, testMethod);

        // Generate the DataCombinationGenerator delegate
        GenerateDataCombinationGenerator(writer, testMethod);

        // Generate typed invokers and factory
        GenerateTypedInvokers(writer, testMethod, className);

        writer.Outdent();
        writer.WriteLine("});");
    }

    private static void GenerateBasicMetadata(CodeWriter writer, TestMethodMetadata testMethod)
    {
        var methodSymbol = testMethod.MethodSymbol;
        
        writer.WriteLine("Categories = Array.Empty<string>(),");
        writer.WriteLine("IsSkipped = false,");
        writer.WriteLine("SkipReason = null,");
        writer.WriteLine("TimeoutMs = null,");
        writer.WriteLine("RetryCount = 0,");
        writer.WriteLine("CanRunInParallel = true,");
        writer.WriteLine("Dependencies = Array.Empty<TestDependency>(),");
        writer.WriteLine("AttributeFactory = null,");
        
        // Legacy data sources (empty in new approach)
        writer.WriteLine("DataSources = Array.Empty<TestDataSource>(),");
        writer.WriteLine("ClassDataSources = Array.Empty<TestDataSource>(),");
        writer.WriteLine("PropertyDataSources = Array.Empty<PropertyDataSource>(),");
        
        // Parameter types
        writer.WriteLine("ParameterTypes = new Type[]");
        writer.WriteLine("{");
        writer.Indent();
        foreach (var param in methodSymbol.Parameters)
        {
            writer.WriteLine($"typeof({param.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)}),");
        }
        writer.Outdent();
        writer.WriteLine("},");
        
        // String parameter types
        writer.WriteLine("TestMethodParameterTypes = new string[]");
        writer.WriteLine("{");
        writer.Indent();
        foreach (var param in methodSymbol.Parameters)
        {
            writer.WriteLine($"\"{param.Type.ToDisplayString()}\",");
        }
        writer.Outdent();
        writer.WriteLine("},");
        
        // Empty hooks for now
        writer.WriteLine("Hooks = new TestHooks");
        writer.WriteLine("{");
        writer.Indent();
        writer.WriteLine("BeforeClass = Array.Empty<HookMetadata>(),");
        writer.WriteLine("AfterClass = Array.Empty<HookMetadata>(),");
        writer.WriteLine("BeforeTest = Array.Empty<HookMetadata>(),");
        writer.WriteLine("AfterTest = Array.Empty<HookMetadata>()");
        writer.Outdent();
        writer.WriteLine("},");
    }

    private static void GenerateDataCombinationGenerator(CodeWriter writer, TestMethodMetadata testMethod)
    {
        writer.WriteLine("DataCombinationGenerator = () =>");
        writer.WriteLine("{");
        writer.Indent();

        writer.WriteLine("var combinations = new List<TestDataCombination>();");
        
        // Get all data source attributes on method and class
        var methodAttributes = GetDataSourceAttributes(testMethod.MethodSymbol);
        var classAttributes = GetDataSourceAttributes(testMethod.TypeSymbol);

        if (!methodAttributes.Any() && !classAttributes.Any())
        {
            // No data sources - single empty combination
            writer.WriteLine("combinations.Add(new TestDataCombination());");
        }
        else
        {
            // Generate combinations from data source attributes
            GenerateDataSourceCombinations(writer, testMethod, methodAttributes, classAttributes);
        }

        writer.WriteLine("return combinations;");
        writer.Outdent();
        writer.WriteLine("},");
    }

    private static void GenerateDataSourceCombinations(CodeWriter writer, TestMethodMetadata testMethod, 
        IEnumerable<AttributeData> methodAttributes, IEnumerable<AttributeData> classAttributes)
    {
        writer.WriteLine("// Generate data combinations from attributes");
        writer.WriteLine("var methodCombinations = new List<TestDataCombination>();");
        writer.WriteLine("var classCombinations = new List<TestDataCombination>();");
        
        // Generate method data combinations
        var methodAttrs = methodAttributes.ToList();
        for (int i = 0; i < methodAttrs.Count; i++)
        {
            var attr = methodAttrs[i];
            GenerateAttributeDataCombinations(writer, attr, i, "methodCombinations", isClassLevel: false);
        }
        
        // Generate class data combinations  
        var classAttrs = classAttributes.ToList();
        for (int i = 0; i < classAttrs.Count; i++)
        {
            var attr = classAttrs[i];
            GenerateAttributeDataCombinations(writer, attr, i, "classCombinations", isClassLevel: true);
        }
        
        // Generate cartesian product
        writer.WriteLine();
        writer.WriteLine("// Generate cartesian product of class and method combinations");
        writer.WriteLine("if (classCombinations.Count == 0) classCombinations.Add(new TestDataCombination());");
        writer.WriteLine("if (methodCombinations.Count == 0) methodCombinations.Add(new TestDataCombination());");
        writer.WriteLine();
        writer.WriteLine("foreach (var classCombination in classCombinations)");
        writer.WriteLine("{");
        writer.Indent();
        writer.WriteLine("foreach (var methodCombination in methodCombinations)");
        writer.WriteLine("{");
        writer.Indent();
        writer.WriteLine("combinations.Add(new TestDataCombination");
        writer.WriteLine("{");
        writer.Indent();
        writer.WriteLine("ClassData = classCombination.ClassData,");
        writer.WriteLine("MethodData = methodCombination.MethodData,");
        writer.WriteLine("DataSourceIndices = classCombination.DataSourceIndices.Concat(methodCombination.DataSourceIndices).ToArray(),");
        writer.WriteLine("PropertyValues = classCombination.PropertyValues.Concat(methodCombination.PropertyValues).ToDictionary(kvp => kvp.Key, kvp => kvp.Value)");
        writer.Outdent();
        writer.WriteLine("});");
        writer.Outdent();
        writer.WriteLine("}");
        writer.Outdent();
        writer.WriteLine("}");
    }

    private static void GenerateAttributeDataCombinations(CodeWriter writer, AttributeData attr, int index, 
        string listName, bool isClassLevel)
    {
        var attributeClassName = attr.AttributeClass?.Name;
        
        if (attributeClassName == "ArgumentsAttribute")
        {
            // Generate Arguments combinations
            writer.WriteLine($"// ArgumentsAttribute {index}");
            if (attr.ConstructorArguments.Length > 0 && attr.ConstructorArguments[0].Values.Length > 0)
            {
                var values = attr.ConstructorArguments[0].Values;
                writer.WriteLine($"{listName}.Add(new TestDataCombination");
                writer.WriteLine("{");
                writer.Indent();
                
                if (isClassLevel)
                {
                    writer.WriteLine($"ClassData = new object?[] {{ {string.Join(", ", values.Select(FormatConstantValue))} }},");
                    writer.WriteLine("MethodData = Array.Empty<object?>(),");
                }
                else
                {
                    writer.WriteLine("ClassData = Array.Empty<object?>(),");
                    writer.WriteLine($"MethodData = new object?[] {{ {string.Join(", ", values.Select(FormatConstantValue))} }},");
                }
                
                writer.WriteLine($"DataSourceIndices = new[] {{ {index} }},");
                writer.WriteLine("PropertyValues = new Dictionary<string, object?>()");
                writer.Outdent();
                writer.WriteLine("});");
            }
        }
        else
        {
            // For now, add a placeholder for other attribute types
            writer.WriteLine($"// TODO: Handle {attributeClassName} - requires runtime processing");
            writer.WriteLine($"{listName}.Add(new TestDataCombination");
            writer.WriteLine("{");
            writer.Indent();
            writer.WriteLine("ClassData = Array.Empty<object?>(),");
            writer.WriteLine("MethodData = Array.Empty<object?>(),");
            writer.WriteLine($"DataSourceIndices = new[] {{ {index} }},");
            writer.WriteLine("PropertyValues = new Dictionary<string, object?>()");
            writer.Outdent();
            writer.WriteLine("});");
        }
    }

    private static string FormatConstantValue(TypedConstant constant)
    {
        if (constant.IsNull)
        {
            return "null";
        }
        
        if (constant.Value is string str)
        {
            return $"\"{str.Replace("\"", "\\\"")}\"";
        }
        
        if (constant.Value is char ch)
        {
            return $"'{ch}'";
        }
        
        return constant.Value?.ToString() ?? "null";
    }

    private static void GenerateTypedInvokers(CodeWriter writer, TestMethodMetadata testMethod, string className)
    {
        var methodName = testMethod.MethodSymbol.Name;
        var parameters = testMethod.MethodSymbol.Parameters;
        
        // Instance factory
        writer.WriteLine($"InstanceFactory = args => new {className}(),");
        
        // Test invoker
        writer.WriteLine("TestInvoker = async (instance, args) =>");
        writer.WriteLine("{");
        writer.Indent();
        writer.WriteLine($"var typedInstance = ({className})instance;");
        
        if (parameters.Length == 0)
        {
            writer.WriteLine($"await typedInstance.{methodName}();");
        }
        else
        {
            var paramCasts = parameters.Select((p, i) => 
                $"({p.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)})args[{i}]").ToArray();
            writer.WriteLine($"await typedInstance.{methodName}({string.Join(", ", paramCasts)});");
        }
        
        writer.Outdent();
        writer.WriteLine("},");
        
        // Property setters (empty for now)
        writer.WriteLine($"PropertySetters = new Dictionary<string, Action<{className}, object?>>(),");
        writer.WriteLine("PropertyInjections = Array.Empty<PropertyInjectionData>(),");
        
        // Typed invokers
        writer.WriteLine("CreateTypedInstance = null,");
        writer.WriteLine($"InvokeTypedTest = async (instance, args, cancellationToken) =>");
        writer.WriteLine("{");
        writer.Indent();
        
        if (parameters.Length == 0)
        {
            writer.WriteLine($"await instance.{methodName}();");
        }
        else
        {
            var paramCasts = parameters.Select((p, i) => 
                $"({p.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)})args[{i}]").ToArray();
            writer.WriteLine($"await instance.{methodName}({string.Join(", ", paramCasts)});");
        }
        
        writer.Outdent();
        writer.WriteLine("},");
        
        // CreateExecutableTest factory (null for now, will be handled by TestBuilder)
        writer.WriteLine("CreateExecutableTest = null");
    }

    private static IEnumerable<AttributeData> GetDataSourceAttributes(ISymbol symbol)
    {
        return symbol.GetAttributes().Where(a => 
            a.AttributeClass?.Name?.EndsWith("Attribute") == true &&
            (a.AttributeClass.Name.Contains("Arguments") ||
             a.AttributeClass.Name.Contains("DataSource")));
    }

    private static void GenerateModuleInitializer(CodeWriter writer, TestMethodMetadata testMethod, string guid)
    {
        writer.WriteLine();
        writer.WriteLine($"internal static class {testMethod.TypeSymbol.Name}_{testMethod.MethodSymbol.Name}_ModuleInitializer_{guid}");
        writer.WriteLine("{");
        writer.Indent();
        writer.WriteLine("[System.Runtime.CompilerServices.ModuleInitializer]");
        writer.WriteLine("public static void Initialize()");
        writer.WriteLine("{");
        writer.Indent();
        writer.WriteLine($"global::TUnit.Core.SourceRegistrar.Register(new {testMethod.TypeSymbol.Name}_{testMethod.MethodSymbol.Name}_TestSource_{guid}());");
        writer.Outdent();
        writer.WriteLine("}");
        writer.Outdent();
        writer.WriteLine("}");
    }
}

/// <summary>
/// Metadata for a test method during source generation
/// </summary>
public class TestMethodMetadata
{
    public required IMethodSymbol MethodSymbol { get; init; }
    public required INamedTypeSymbol TypeSymbol { get; init; }
    public required MethodDeclarationSyntax MethodSyntax { get; init; }
}