using Microsoft.CodeAnalysis;
using TUnit.Core.SourceGenerator.CodeGenerators;

namespace TUnit.Core.SourceGenerator.Generators;

/// <summary>
/// Generates the PropertyInjectionRegistry class to manage type-specific property injectors
/// </summary>
[Generator]
public sealed class PropertyInjectionRegistryGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var compilationProvider = context.CompilationProvider;
        
        context.RegisterSourceOutput(compilationProvider, GeneratePropertyInjectionRegistry);
    }

    private static void GeneratePropertyInjectionRegistry(SourceProductionContext context, Compilation compilation)
    {
        var writer = new CodeWriter();

        writer.AppendLine("// <auto-generated/>");
        writer.AppendLine("#pragma warning disable");
        writer.AppendLine("#nullable enable");
        writer.AppendLine();
        writer.AppendLine("using System;");
        writer.AppendLine("using System.Collections.Concurrent;");
        writer.AppendLine("using System.Collections.Generic;");
        writer.AppendLine("using System.Threading.Tasks;");
        writer.AppendLine();
        writer.AppendLine("namespace TUnit.Core;");
        writer.AppendLine();

        GeneratePropertyInjectionRegistryClass(writer);

        context.AddSource("PropertyInjectionRegistry.g.cs", writer.ToString());
    }

    private static void GeneratePropertyInjectionRegistryClass(CodeWriter writer)
    {
        writer.AppendLine("/// <summary>");
        writer.AppendLine("/// Registry for type-specific property injectors used in AOT scenarios");
        writer.AppendLine("/// </summary>");
        writer.AppendLine("public static class PropertyInjectionRegistry");
        writer.AppendLine("{");
        writer.Indent();

        writer.AppendLine("// Delegate type for property injectors");
        writer.AppendLine("public delegate Task PropertyInjectorDelegate<T>(T instance, Dictionary<string, object?> propertyValues, TestContext testContext) where T : notnull;");
        writer.AppendLine();

        writer.AppendLine("// Thread-safe storage for property injectors");
        writer.AppendLine("private static readonly ConcurrentDictionary<Type, object> _injectors = new();");
        writer.AppendLine();

        writer.AppendLine("/// <summary>");
        writer.AppendLine("/// Registers a strongly-typed property injector for the specified type");
        writer.AppendLine("/// </summary>");
        writer.AppendLine("public static void RegisterInjector<T>(PropertyInjectorDelegate<T> injector) where T : notnull");
        writer.AppendLine("{");
        writer.Indent();
        writer.AppendLine("_injectors[typeof(T)] = injector;");
        writer.Unindent();
        writer.AppendLine("}");
        writer.AppendLine();

        writer.AppendLine("/// <summary>");
        writer.AppendLine("/// Gets the registered property injector for the specified type");
        writer.AppendLine("/// </summary>");
        writer.AppendLine("public static PropertyInjectorDelegate<T>? GetInjector<T>() where T : notnull");
        writer.AppendLine("{");
        writer.Indent();
        writer.AppendLine("if (_injectors.TryGetValue(typeof(T), out var injector))");
        writer.AppendLine("{");
        writer.Indent();
        writer.AppendLine("return injector as PropertyInjectorDelegate<T>;");
        writer.Unindent();
        writer.AppendLine("}");
        writer.AppendLine("return null;");
        writer.Unindent();
        writer.AppendLine("}");
        writer.AppendLine();

        writer.AppendLine("/// <summary>");
        writer.AppendLine("/// Checks if an injector is registered for the specified type");
        writer.AppendLine("/// </summary>");
        writer.AppendLine("public static bool HasInjector<T>() where T : notnull");
        writer.AppendLine("{");
        writer.Indent();
        writer.AppendLine("return _injectors.ContainsKey(typeof(T));");
        writer.Unindent();
        writer.AppendLine("}");
        writer.AppendLine();

        writer.AppendLine("/// <summary>");
        writer.AppendLine("/// Checks if an injector is registered for the specified type");
        writer.AppendLine("/// </summary>");
        writer.AppendLine("public static bool HasInjector(Type type)");
        writer.AppendLine("{");
        writer.Indent();
        writer.AppendLine("return _injectors.ContainsKey(type);");
        writer.Unindent();
        writer.AppendLine("}");
        writer.AppendLine();

        writer.AppendLine("/// <summary>");
        writer.AppendLine("/// Gets all registered injector types");
        writer.AppendLine("/// </summary>");
        writer.AppendLine("public static IEnumerable<Type> GetRegisteredTypes()");
        writer.AppendLine("{");
        writer.Indent();
        writer.AppendLine("return _injectors.Keys;");
        writer.Unindent();
        writer.AppendLine("}");
        writer.AppendLine();

        writer.AppendLine("/// <summary>");
        writer.AppendLine("/// Clears all registered injectors (primarily for testing)");
        writer.AppendLine("/// </summary>");
        writer.AppendLine("public static void Clear()");
        writer.AppendLine("{");
        writer.Indent();
        writer.AppendLine("_injectors.Clear();");
        writer.Unindent();
        writer.AppendLine("}");

        writer.Unindent();
        writer.AppendLine("}");
    }
}