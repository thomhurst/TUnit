using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace TUnit.Core.SourceGenerator.Generators;

/// <summary>
/// Simplified test metadata generator that emits one TestMetadata<T> per method
/// with a DataCombinationGenerator delegate for runtime data expansion.
/// </summary>
[Generator]
public sealed class TestMetadataGenerator : IIncrementalGenerator
{
    private const string GeneratedNamespace = "TUnit.Generated";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Register post-initialization output for base types
        context.RegisterPostInitializationOutput(GenerateBaseTypes);

        // Find all test methods using the more performant ForAttributeWithMetadataName
        var testMethodsProvider = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                "TUnit.Core.TestAttribute",
                predicate: static (node, _) => node is MethodDeclarationSyntax,
                transform: static (ctx, _) => GetTestMethodMetadata(ctx))
            .Where(static m => m is not null);

        // Generate one source file per test method
        context.RegisterSourceOutput(testMethodsProvider, static (context, testMethod) => GenerateTestMethodSource(context, testMethod));
    }

    private static void GenerateBaseTypes(IncrementalGeneratorPostInitializationContext context)
    {
        // Generate any base types needed for the simplified approach
        // For now, we'll keep this empty as we're using existing types
    }

    private static TestMethodMetadata? GetTestMethodMetadata(GeneratorAttributeSyntaxContext context)
    {
        var methodSyntax = (MethodDeclarationSyntax)context.TargetNode;
        var methodSymbol = context.TargetSymbol as IMethodSymbol;

        var containingType = methodSymbol?.ContainingType;

        if (containingType == null)
        {
            return null;
        }

        // Skip abstract classes (cannot be instantiated)
        if (containingType.IsAbstract)
        {
            return null;
        }

        // Skip generic types without explicit instantiation
        if (containingType is { IsGenericType: true, TypeParameters.Length: > 0 })
        {
            return null;
        }

        // Skip generic methods without explicit instantiation
        if (methodSymbol is { IsGenericMethod: true })
        {
            return null;
        }

        return new TestMethodMetadata
        {
            MethodSymbol = methodSymbol ?? throw new InvalidOperationException("Symbol is not a method"),
            TypeSymbol = containingType,
            MethodSyntax = methodSyntax
        };
    }

    private static void GenerateTestMethodSource(SourceProductionContext context, TestMethodMetadata? testMethod)
    {
        try
        {
            if (testMethod?.MethodSymbol == null || testMethod.TypeSymbol == null)
            {
                return;
            }

            var writer = new CodeWriter();
            GenerateFileHeader(writer);
            GenerateSimplifiedTestMetadata(writer, testMethod);

            var fileName = $"Simplified_{testMethod.TypeSymbol.Name}_{testMethod.MethodSymbol.Name}_{Guid.NewGuid():N}.g.cs";
            context.AddSource(fileName, SourceText.From(writer.ToString(), Encoding.UTF8));
        }
        catch (Exception ex)
        {
            var methodName = testMethod?.MethodSymbol?.Name ?? "Unknown";
            var className = testMethod?.TypeSymbol?.Name ?? "Unknown";

            context.ReportDiagnostic(Diagnostic.Create(
                new DiagnosticDescriptor(
                    "TUNIT0999",
                    "Source Generation Error",
                    "Failed to generate test metadata for {0}.{1}: {2}",
                    "TUnit",
                    DiagnosticSeverity.Error,
                    true),
                Location.None,
                className,
                methodName,
                ex.Message));
        }
    }

    private static void GenerateFileHeader(CodeWriter writer)
    {
        writer.AppendLine("// <auto-generated/>");
        writer.AppendLine("#pragma warning disable");
        writer.AppendLine("#nullable enable");
        writer.AppendLine();
        writer.AppendLine("using System;");
        writer.AppendLine("using System.Collections.Generic;");
        writer.AppendLine("using System.Linq;");
        writer.AppendLine("using System.Threading;");
        writer.AppendLine("using System.Threading.Tasks;");
        writer.AppendLine("using global::TUnit.Core;");
        writer.AppendLine("using global::TUnit.Core.Interfaces.SourceGenerator;");
        writer.AppendLine();
        writer.AppendLine($"namespace {GeneratedNamespace};");
        writer.AppendLine();
    }

    private static void GenerateSimplifiedTestMetadata(CodeWriter writer, TestMethodMetadata testMethod)
    {
        var className = testMethod.TypeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        var methodName = testMethod.MethodSymbol.Name;
        var guid = Guid.NewGuid().ToString("N");

        writer.AppendLine($"internal sealed class {testMethod.TypeSymbol.Name}_{methodName}_TestSource_{guid} : ITestSource");
        writer.AppendLine("{");
        writer.Indent();

        writer.AppendLine("public async ValueTask<List<TestMetadata>> GetTestsAsync()");
        writer.AppendLine("{");
        writer.Indent();

        writer.AppendLine("var tests = new List<TestMetadata>();");
        writer.AppendLine();

        // Generate the TestMetadata<T> with DataCombinationGenerator
        GenerateTestMetadataInstance(writer, testMethod, className);

        writer.AppendLine("return tests;");
        writer.Unindent();
        writer.AppendLine("}");

        writer.Unindent();
        writer.AppendLine("}");

        // Generate module initializer
        GenerateModuleInitializer(writer, testMethod, guid);
    }

    private static void GenerateTestMetadataInstance(CodeWriter writer, TestMethodMetadata testMethod, string className)
    {
        var methodName = testMethod.MethodSymbol.Name;
        var testId = $"{className}.{methodName}";

        writer.AppendLine($"tests.Add(new TestMetadata<{className}>");
        writer.AppendLine("{");
        writer.Indent();

        writer.AppendLine($"TestId = \"{testId}\",");
        writer.AppendLine($"TestName = \"{methodName}\",");
        writer.AppendLine($"TestClassType = typeof({className}),");
        writer.AppendLine($"TestMethodName = \"{methodName}\",");

        // Add basic metadata
        GenerateBasicMetadata(writer, testMethod);

        // Generate the DataCombinationGenerator delegate
        GenerateDataCombinationGenerator(writer, testMethod);

        // Generate typed invokers and factory
        GenerateTypedInvokers(writer, testMethod, className);

        writer.Unindent();
        writer.AppendLine("});");
    }

    private static void GenerateBasicMetadata(CodeWriter writer, TestMethodMetadata testMethod)
    {
        var methodSymbol = testMethod.MethodSymbol;

        writer.AppendLine("Categories = Array.Empty<string>(),");
        writer.AppendLine("IsSkipped = false,");
        writer.AppendLine("SkipReason = null,");
        writer.AppendLine("TimeoutMs = null,");
        writer.AppendLine("RetryCount = 0,");
        writer.AppendLine("CanRunInParallel = true,");
        writer.AppendLine("Dependencies = Array.Empty<TestDependency>(),");
        writer.AppendLine("AttributeFactory = null,");

        // Legacy data sources (empty in new approach)
        writer.AppendLine("DataSources = Array.Empty<TestDataSource>(),");
        writer.AppendLine("ClassDataSources = Array.Empty<TestDataSource>(),");
        writer.AppendLine("PropertyDataSources = Array.Empty<PropertyDataSource>(),");

        // Parameter types
        writer.AppendLine("ParameterTypes = new Type[]");
        writer.AppendLine("{");
        writer.Indent();
        foreach (var param in methodSymbol.Parameters)
        {
            writer.AppendLine($"typeof({param.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)}),");
        }
        writer.Unindent();
        writer.AppendLine("},");

        // String parameter types
        writer.AppendLine("TestMethodParameterTypes = new string[]");
        writer.AppendLine("{");
        writer.Indent();
        foreach (var param in methodSymbol.Parameters)
        {
            writer.AppendLine($"\"{param.Type.ToDisplayString()}\",");
        }
        writer.Unindent();
        writer.AppendLine("},");

        // Empty hooks for now
        writer.AppendLine("Hooks = new TestHooks");
        writer.AppendLine("{");
        writer.Indent();
        writer.AppendLine("BeforeClass = Array.Empty<HookMetadata>(),");
        writer.AppendLine("AfterClass = Array.Empty<HookMetadata>(),");
        writer.AppendLine("BeforeTest = Array.Empty<HookMetadata>(),");
        writer.AppendLine("AfterTest = Array.Empty<HookMetadata>()");
        writer.Unindent();
        writer.AppendLine("},");
    }

    private static void GenerateDataCombinationGenerator(CodeWriter writer, TestMethodMetadata testMethod)
    {
        writer.AppendLine("DataCombinationGenerator = () =>");
        writer.AppendLine("{");
        writer.Indent();

        writer.AppendLine("var combinations = new List<TestDataCombination>();");

        // Get all data source attributes on method and class
        var methodAttributes = GetDataSourceAttributes(testMethod.MethodSymbol);
        var classAttributes = GetDataSourceAttributes(testMethod.TypeSymbol);

        if (!methodAttributes.Any() && !classAttributes.Any())
        {
            // No data sources - single empty combination
            writer.AppendLine("combinations.Add(new TestDataCombination());");
        }
        else
        {
            // Generate combinations from data source attributes
            GenerateDataSourceCombinations(writer, testMethod, methodAttributes, classAttributes);
        }

        writer.AppendLine("return combinations;");
        writer.Unindent();
        writer.AppendLine("},");
    }

    private static void GenerateDataSourceCombinations(CodeWriter writer, TestMethodMetadata testMethod,
        IEnumerable<AttributeData> methodAttributes, IEnumerable<AttributeData> classAttributes)
    {
        writer.AppendLine("// Generate data combinations from attributes");
        writer.AppendLine("var methodCombinations = new List<TestDataCombination>();");
        writer.AppendLine("var classCombinations = new List<TestDataCombination>();");

        // Generate method data combinations
        var methodAttrs = methodAttributes.ToList();
        for (int i = 0; i < methodAttrs.Count; i++)
        {
            var attr = methodAttrs[i];
            GenerateAttributeDataCombinations(writer, attr, i, "methodCombinations", isClassLevel: false);
        }

        // Generate class data combinations
        var classAttrs = classAttributes.ToList();
        for (int i = 0; i < classAttrs.Count; i++)
        {
            var attr = classAttrs[i];
            GenerateAttributeDataCombinations(writer, attr, i, "classCombinations", isClassLevel: true);
        }

        // Generate cartesian product
        writer.AppendLine();
        writer.AppendLine("// Generate cartesian product of class and method combinations");
        writer.AppendLine("if (classCombinations.Count == 0) classCombinations.Add(new TestDataCombination());");
        writer.AppendLine("if (methodCombinations.Count == 0) methodCombinations.Add(new TestDataCombination());");
        writer.AppendLine();
        writer.AppendLine("foreach (var classCombination in classCombinations)");
        writer.AppendLine("{");
        writer.Indent();
        writer.AppendLine("foreach (var methodCombination in methodCombinations)");
        writer.AppendLine("{");
        writer.Indent();
        writer.AppendLine("combinations.Add(new TestDataCombination");
        writer.AppendLine("{");
        writer.Indent();
        writer.AppendLine("ClassData = classCombination.ClassData,");
        writer.AppendLine("MethodData = methodCombination.MethodData,");
        writer.AppendLine("DataSourceIndices = classCombination.DataSourceIndices.Concat(methodCombination.DataSourceIndices).ToArray(),");
        writer.AppendLine("PropertyValues = classCombination.PropertyValues.Concat(methodCombination.PropertyValues).ToDictionary(kvp => kvp.Key, kvp => kvp.Value)");
        writer.Unindent();
        writer.AppendLine("});");
        writer.Unindent();
        writer.AppendLine("}");
        writer.Unindent();
        writer.AppendLine("}");
    }

    private static void GenerateAttributeDataCombinations(CodeWriter writer, AttributeData attr, int index,
        string listName, bool isClassLevel)
    {
        var attributeClassName = attr.AttributeClass?.Name;

        if (attributeClassName == "ArgumentsAttribute")
        {
            // Generate Arguments combinations
            writer.AppendLine($"// ArgumentsAttribute {index}");
            if (attr.ConstructorArguments.Length > 0 && attr.ConstructorArguments[0].Values.Length > 0)
            {
                var values = attr.ConstructorArguments[0].Values;
                writer.AppendLine($"{listName}.Add(new TestDataCombination");
                writer.AppendLine("{");
                writer.Indent();

                if (isClassLevel)
                {
                    writer.AppendLine($"ClassData = new object?[] {{ {string.Join(", ", values.Select(FormatConstantValue))} }},");
                    writer.AppendLine("MethodData = Array.Empty<object?>(),");
                }
                else
                {
                    writer.AppendLine("ClassData = Array.Empty<object?>(),");
                    writer.AppendLine($"MethodData = new object?[] {{ {string.Join(", ", values.Select(FormatConstantValue))} }},");
                }

                writer.AppendLine($"DataSourceIndices = new[] {{ {index} }},");
                writer.AppendLine("PropertyValues = new Dictionary<string, object?>()");
                writer.Unindent();
                writer.AppendLine("});");
            }
        }
        else
        {
            // For now, add a placeholder for other attribute types
            writer.AppendLine($"// TODO: Handle {attributeClassName} - requires runtime processing");
            writer.AppendLine($"{listName}.Add(new TestDataCombination");
            writer.AppendLine("{");
            writer.Indent();
            writer.AppendLine("ClassData = Array.Empty<object?>(),");
            writer.AppendLine("MethodData = Array.Empty<object?>(),");
            writer.AppendLine($"DataSourceIndices = new[] {{ {index} }},");
            writer.AppendLine("PropertyValues = new Dictionary<string, object?>()");
            writer.Unindent();
            writer.AppendLine("});");
        }
    }

    private static string FormatConstantValue(TypedConstant constant)
    {
        if (constant.IsNull)
        {
            return "null";
        }

        if (constant.Value is string str)
        {
            return $"\"{str.Replace("\"", "\\\"")}\"";
        }

        if (constant.Value is char ch)
        {
            return $"'{ch}'";
        }

        return constant.Value?.ToString() ?? "null";
    }

    private static void GenerateTypedInvokers(CodeWriter writer, TestMethodMetadata testMethod, string className)
    {
        var methodName = testMethod.MethodSymbol.Name;
        var parameters = testMethod.MethodSymbol.Parameters;

        // Instance factory
        writer.AppendLine($"InstanceFactory = args => new {className}(),");

        // Test invoker
        writer.AppendLine("TestInvoker = async (instance, args) =>");
        writer.AppendLine("{");
        writer.Indent();
        writer.AppendLine($"var typedInstance = ({className})instance;");

        if (parameters.Length == 0)
        {
            writer.AppendLine($"await typedInstance.{methodName}();");
        }
        else
        {
            var paramCasts = parameters.Select((p, i) =>
                $"({p.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)})args[{i}]").ToArray();
            writer.AppendLine($"await typedInstance.{methodName}({string.Join(", ", paramCasts)});");
        }

        writer.Unindent();
        writer.AppendLine("},");

        // Property setters (empty for now)
        writer.AppendLine($"PropertySetters = new Dictionary<string, Action<{className}, object?>>(),");
        writer.AppendLine("PropertyInjections = Array.Empty<PropertyInjectionData>(),");

        // Typed invokers
        writer.AppendLine("CreateTypedInstance = null,");
        writer.AppendLine($"InvokeTypedTest = async (instance, args, cancellationToken) =>");
        writer.AppendLine("{");
        writer.Indent();

        if (parameters.Length == 0)
        {
            writer.AppendLine($"await instance.{methodName}();");
        }
        else
        {
            var paramCasts = parameters.Select((p, i) =>
                $"({p.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)})args[{i}]").ToArray();
            writer.AppendLine($"await instance.{methodName}({string.Join(", ", paramCasts)});");
        }

        writer.Unindent();
        writer.AppendLine("},");

        // CreateExecutableTest factory (null for now, will be handled by TestBuilder)
        writer.AppendLine("CreateExecutableTest = null");
    }

    private static IEnumerable<AttributeData> GetDataSourceAttributes(ISymbol symbol)
    {
        return symbol.GetAttributes().Where(a =>
            a.AttributeClass?.Name?.EndsWith("Attribute") == true &&
            (a.AttributeClass.Name.Contains("Arguments") ||
             a.AttributeClass.Name.Contains("DataSource")));
    }

    private static void GenerateModuleInitializer(CodeWriter writer, TestMethodMetadata testMethod, string guid)
    {
        writer.AppendLine();
        writer.AppendLine($"internal static class {testMethod.TypeSymbol.Name}_{testMethod.MethodSymbol.Name}_ModuleInitializer_{guid}");
        writer.AppendLine("{");
        writer.Indent();
        writer.AppendLine("[System.Runtime.CompilerServices.ModuleInitializer]");
        writer.AppendLine("public static void Initialize()");
        writer.AppendLine("{");
        writer.Indent();
        writer.AppendLine($"global::TUnit.Core.SourceRegistrar.Register(new {testMethod.TypeSymbol.Name}_{testMethod.MethodSymbol.Name}_TestSource_{guid}());");
        writer.Unindent();
        writer.AppendLine("}");
        writer.Unindent();
        writer.AppendLine("}");
    }
}

/// <summary>
/// Metadata for a test method during source generation
/// </summary>
public class TestMethodMetadata
{
    public required IMethodSymbol MethodSymbol { get; init; }
    public required INamedTypeSymbol TypeSymbol { get; init; }
    public required MethodDeclarationSyntax MethodSyntax { get; init; }
}
