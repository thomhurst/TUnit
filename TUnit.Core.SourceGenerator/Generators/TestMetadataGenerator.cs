using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using TUnit.Core.SourceGenerator.CodeGenerators;
using TUnit.Core.SourceGenerator.CodeGenerators.Helpers;
using TUnit.Core.SourceGenerator.CodeGenerators.Writers;
using TUnit.Core.SourceGenerator.Extensions;

namespace TUnit.Core.SourceGenerator.Generators;

/// <summary>
/// Simplified test metadata generator that emits one TestMetadata<T> per method
/// with a DataCombinationGenerator delegate for runtime data expansion.
/// </summary>
[Generator]
public sealed class TestMetadataGenerator : IIncrementalGenerator
{
    private const string GeneratedNamespace = "TUnit.Generated";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Find all test methods using the more performant ForAttributeWithMetadataName
        var testMethodsProvider = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                "TUnit.Core.TestAttribute",
                predicate: static (node, _) => node is MethodDeclarationSyntax,
                transform: static (ctx, _) => GetTestMethodMetadata(ctx))
            .Where(static m => m is not null);

        // Find classes with [InheritsTests] attribute
        var inheritsTestsClassesProvider = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                "TUnit.Core.InheritsTestsAttribute",
                predicate: static (node, _) => node is ClassDeclarationSyntax,
                transform: static (ctx, _) => GetInheritsTestsClassMetadata(ctx))
            .Where(static m => m is not null);

        // Generate one source file per test method
        context.RegisterSourceOutput(testMethodsProvider.Combine(context.CompilationProvider),
            static (context, tuple) => GenerateTestMethodSource(context, tuple.Right, tuple.Left));

        // Generate test methods for inherited tests
        context.RegisterSourceOutput(inheritsTestsClassesProvider.Combine(context.CompilationProvider),
            static (context, tuple) => GenerateInheritedTestSources(context, tuple.Right, tuple.Left));
    }

    private static TestMethodMetadata? GetTestMethodMetadata(GeneratorAttributeSyntaxContext context)
    {
        var methodSyntax = (MethodDeclarationSyntax)context.TargetNode;
        var methodSymbol = context.TargetSymbol as IMethodSymbol;

        var containingType = methodSymbol?.ContainingType;

        if (containingType == null)
        {
            return null;
        }

        // Skip abstract classes (cannot be instantiated)
        if (containingType.IsAbstract)
        {
            return null;
        }

        // Skip generic types without explicit instantiation
        if (containingType is { IsGenericType: true, TypeParameters.Length: > 0 })
        {
            return null;
        }

        // Skip generic methods without explicit instantiation
        if (methodSymbol is { IsGenericMethod: true })
        {
            return null;
        }

        return new TestMethodMetadata
        {
            MethodSymbol = methodSymbol ?? throw new InvalidOperationException("Symbol is not a method"),
            TypeSymbol = containingType,
            MethodSyntax = methodSyntax
        };
    }

    private static void GenerateTestMethodSource(SourceProductionContext context, Compilation compilation, TestMethodMetadata? testMethod)
    {
        try
        {
            if (testMethod?.MethodSymbol == null || testMethod.TypeSymbol == null)
            {
                return;
            }

            var writer = new CodeWriter();
            GenerateFileHeader(writer);
            GenerateSimplifiedTestMetadata(writer, compilation, testMethod);

            var fileName = $"{testMethod.TypeSymbol.Name}_{testMethod.MethodSymbol.Name}_{Guid.NewGuid():N}.g.cs";
            context.AddSource(fileName, SourceText.From(writer.ToString(), Encoding.UTF8));
        }
        catch (Exception ex)
        {
            var methodName = testMethod?.MethodSymbol?.Name ?? "Unknown";
            var className = testMethod?.TypeSymbol?.Name ?? "Unknown";

            context.ReportDiagnostic(Diagnostic.Create(
                new DiagnosticDescriptor(
                    "TUNIT0999",
                    "Source Generation Error",
                    "Failed to generate test metadata for {0}.{1}: {2}",
                    "TUnit",
                    DiagnosticSeverity.Error,
                    true),
                Location.None,
                className,
                methodName,
                ex.ToString())); // Use ToString() to get full stack trace for debugging
        }
    }

    private static void GenerateFileHeader(CodeWriter writer)
    {
        writer.AppendLine("// <auto-generated/>");
        writer.AppendLine("#pragma warning disable");
        writer.AppendLine("#nullable enable");
        writer.AppendLine();
        writer.AppendLine("using System;");
        writer.AppendLine("using System.Collections.Generic;");
        writer.AppendLine("using System.Linq;");
        writer.AppendLine("using System.Reflection;");
        writer.AppendLine("using System.Threading;");
        writer.AppendLine("using System.Threading.Tasks;");
        writer.AppendLine("using global::TUnit.Core;");
        writer.AppendLine("using global::TUnit.Core.Enums;");
        writer.AppendLine("using global::TUnit.Core.Interfaces;");
        writer.AppendLine("using global::TUnit.Core.Interfaces.SourceGenerator;");
        writer.AppendLine();
        writer.AppendLine($"namespace {GeneratedNamespace};");
        writer.AppendLine();
    }

    private static void GenerateSimplifiedTestMetadata(CodeWriter writer, Compilation compilation, TestMethodMetadata testMethod)
    {
        var className = testMethod.TypeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        var methodName = testMethod.MethodSymbol.Name;
        var guid = Guid.NewGuid().ToString("N");
        var combinationGuid = Guid.NewGuid().ToString("N").Substring(0, 8);

        writer.AppendLine($"internal sealed class {testMethod.TypeSymbol.Name}_{methodName}_TestSource_{guid} : ITestSource");
        writer.AppendLine("{");
        writer.Indent();

        // Generate reflection-based field accessors for init-only properties with data source attributes
        GenerateReflectionFieldAccessors(writer, testMethod.TypeSymbol, className);

        writer.AppendLine("public async ValueTask<List<TestMetadata>> GetTestsAsync(string testSessionId)");
        writer.AppendLine("{");
        writer.Indent();

        writer.AppendLine("var tests = new List<TestMetadata>();");
        writer.AppendLine();

        // Generate the TestMetadata<T> with DataCombinationGenerator
        GenerateTestMetadataInstance(writer, compilation, testMethod, className, combinationGuid);

        writer.AppendLine("return tests;");
        writer.Unindent();
        writer.AppendLine("}");

        // Generate the data combination method inside the class
        writer.AppendLine();
        DataCombinationGeneratorEmitter.EmitDataCombinationGenerator(writer, testMethod.MethodSymbol, testMethod.TypeSymbol, combinationGuid);

        writer.Unindent();
        writer.AppendLine("}");

        // Generate module initializer
        GenerateModuleInitializer(writer, testMethod, guid);
    }

    private static void GenerateTestMetadataInstance(CodeWriter writer, Compilation compilation, TestMethodMetadata testMethod, string className, string combinationGuid)
    {
        var methodName = testMethod.MethodSymbol.Name;
        writer.AppendLine($"var metadata = new TestMetadata<{className}>");
        writer.AppendLine("{");
        writer.Indent();

        writer.AppendLine($"TestName = \"{methodName}\",");
        writer.AppendLine($"TestClassType = typeof({className}),");
        writer.AppendLine($"TestMethodName = \"{methodName}\",");

        // Add basic metadata
        GenerateBasicMetadata(writer, compilation, testMethod);

        // Generate typed invokers and factory
        GenerateTypedInvokers(writer, testMethod, className);

        writer.Unindent();
        writer.AppendLine("};");

        // Set the DataCombinationGenerator after construction
        writer.AppendLine($"metadata.SetDataCombinationGenerator(() => GenerateCombinations_{combinationGuid}(testSessionId));");


        writer.AppendLine("tests.Add(metadata);");
    }

    private static void GenerateBasicMetadata(CodeWriter writer, Compilation compilation, TestMethodMetadata testMethod)
    {
        var methodSymbol = testMethod.MethodSymbol;

        writer.AppendLine("Categories = Array.Empty<string>(),");
        writer.AppendLine("TimeoutMs = null,");
        writer.AppendLine("RetryCount = 0,");
        writer.AppendLine("CanRunInParallel = true,");

        // Generate dependencies
        GenerateDependencies(writer, compilation, methodSymbol);

        writer.AppendLine("AttributeFactory = () =>");
        writer.AppendLine("[");
        writer.Indent();

        var attributes = methodSymbol.GetAttributes()
            .Concat(testMethod.TypeSymbol.GetAttributes())
            .Concat(testMethod.TypeSymbol.ContainingAssembly.GetAttributes())
            .ToImmutableArray();

        AttributeWriter.WriteAttributes(writer, compilation, attributes);

        writer.Unindent();
        writer.AppendLine("],");

        // Legacy data sources (empty in new approach)
        writer.AppendLine("DataSources = Array.Empty<TestDataSource>(),");
        writer.AppendLine("ClassDataSources = Array.Empty<TestDataSource>(),");
        writer.AppendLine("PropertyDataSources = Array.Empty<PropertyDataSource>(),");

        // Parameter types
        writer.AppendLine("ParameterTypes = new Type[]");
        writer.AppendLine("{");
        writer.Indent();
        foreach (var param in methodSymbol.Parameters)
        {
            writer.AppendLine($"typeof({param.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)}),");
        }
        writer.Unindent();
        writer.AppendLine("},");

        // String parameter types
        writer.AppendLine("TestMethodParameterTypes = new string[]");
        writer.AppendLine("{");
        writer.Indent();
        foreach (var param in methodSymbol.Parameters)
        {
            writer.AppendLine($"\"{param.Type.ToDisplayString()}\",");
        }
        writer.Unindent();
        writer.AppendLine("},");

        // Method metadata
        writer.Append("MethodMetadata = ");
        SourceInformationWriter.GenerateMethodInformation(writer, compilation, testMethod.TypeSymbol, testMethod.MethodSymbol, null, ',');

        // Empty hooks for now
        writer.AppendLine("Hooks = new TestHooks");
        writer.AppendLine("{");
        writer.Indent();
        writer.AppendLine("BeforeClass = Array.Empty<HookMetadata>(),");
        writer.AppendLine("AfterClass = Array.Empty<HookMetadata>(),");
        writer.AppendLine("BeforeTest = Array.Empty<HookMetadata>(),");
        writer.AppendLine("AfterTest = Array.Empty<HookMetadata>()");
        writer.Unindent();
        writer.AppendLine("},");
    }


    private static void GeneratePropertyInjections(CodeWriter writer, INamedTypeSymbol typeSymbol, string className)
    {
        writer.AppendLine("PropertyInjections = new PropertyInjectionData[]");
        writer.AppendLine("{");
        writer.Indent();

        // Walk inheritance hierarchy to find properties with data source attributes
        var currentType = typeSymbol;
        var processedProperties = new HashSet<string>();

        while (currentType != null)
        {
            foreach (var member in currentType.GetMembers())
            {
                if (member is IPropertySymbol property &&
                    property.DeclaredAccessibility == Accessibility.Public &&
                    property.SetMethod?.DeclaredAccessibility == Accessibility.Public &&
                    !property.IsStatic &&
                    !processedProperties.Contains(property.Name))
                {
                    var dataSourceAttr = property.GetAttributes()
                        .FirstOrDefault(a => DataSourceAttributeHelper.IsDataSourceAttribute(a.AttributeClass));

                    if (dataSourceAttr != null)
                    {
                        processedProperties.Add(property.Name);
                        var propertyType = property.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

                        writer.AppendLine("new PropertyInjectionData");
                        writer.AppendLine("{");
                        writer.Indent();
                        writer.AppendLine($"PropertyName = \"{property.Name}\",");
                        writer.AppendLine($"PropertyType = typeof({propertyType}),");

                        // Generate appropriate setter based on whether property is init-only
                        if (property.SetMethod.IsInitOnly)
                        {
                            // For init-only properties, use reflection to set backing field
                            writer.AppendLine($"Setter = (instance, value) => {property.Name}BackingField.SetValue(instance, value),");
                        }
                        else
                        {
                            // For regular properties, use normal property assignment
                            writer.AppendLine($"Setter = (instance, value) => (({className})instance).{property.Name} = ({propertyType})value,");
                        }

                        // ValueFactory will be provided by the TestDataCombination at runtime
                        writer.AppendLine("ValueFactory = () => throw new InvalidOperationException(\"ValueFactory should be provided by TestDataCombination\")");

                        writer.Unindent();
                        writer.AppendLine("},");
                    }
                }
            }
            currentType = currentType.BaseType;
        }

        writer.Unindent();
        writer.AppendLine("},");
    }



    private static void GenerateTypedInvokers(CodeWriter writer, TestMethodMetadata testMethod, string className)
    {
        var methodName = testMethod.MethodSymbol.Name;
        var parameters = testMethod.MethodSymbol.Parameters;

        // Check if last parameter is CancellationToken (regardless of whether it has a default value)
        var hasCancellationToken = parameters.Length > 0 &&
            parameters.Last().Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) == "global::System.Threading.CancellationToken";

        // Parameters that come from args (excluding CancellationToken)
        var parametersFromArgs = hasCancellationToken
            ? parameters.Take(parameters.Length - 1).ToArray()
            : parameters.ToArray();

        // Use centralized instance factory generator
        InstanceFactoryGenerator.GenerateInstanceFactory(writer, testMethod.TypeSymbol);

        // Test invoker
        var isAsync = IsAsyncMethod(testMethod.MethodSymbol);
        writer.AppendLine("TestInvoker = async (instance, args) =>");
        writer.AppendLine("{");
        writer.Indent();
        writer.AppendLine($"var typedInstance = ({className})instance;");

        if (parametersFromArgs.Length == 0)
        {
            var methodCall = hasCancellationToken
                ? $"typedInstance.{methodName}(global::TUnit.Core.TestContext.Current?.CancellationToken ?? System.Threading.CancellationToken.None)"
                : $"typedInstance.{methodName}()";
            if (isAsync)
            {
                writer.AppendLine($"await {methodCall};");
            }
            else
            {
                writer.AppendLine($"{methodCall};");
                writer.AppendLine("await Task.CompletedTask;");
            }
        }
        else
        {
            // Count required parameters (those without default values, excluding CancellationToken)
            var requiredParamCount = parametersFromArgs.Count(p => !p.HasExplicitDefaultValue && !p.IsOptional);

            // Generate runtime logic to handle variable argument counts
            writer.AppendLine("// Invoke with only the arguments that were provided");
            writer.AppendLine("switch (args.Length)");
            writer.AppendLine("{");
            writer.Indent();

            // Generate cases for each valid argument count (from required params up to total params from args)
            for (var argCount = requiredParamCount; argCount <= parametersFromArgs.Length; argCount++)
            {
                writer.AppendLine($"case {argCount}:");
                writer.Indent();

                // Build the arguments to pass, including default values for optional parameters
                var argsToPass = new List<string>();
                for (var i = 0; i < parametersFromArgs.Length; i++)
                {
                    var param = parametersFromArgs[i];
                    if (i < argCount)
                    {
                        // Use tuple-aware argument access
                        var argumentExpressions = TupleArgumentHelper.GenerateArgumentAccess(param.Type, "args", i);
                        argsToPass.AddRange(argumentExpressions);
                    }
                    else if (param.HasExplicitDefaultValue)
                    {
                        // Use the default value
                        argsToPass.Add(GetDefaultValueString(param));
                    }
                    else
                    {
                        // This shouldn't happen if we set up requiredParamCount correctly
                        argsToPass.Add($"default({param.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)})");
                    }
                }

                // Add CancellationToken if present
                if (hasCancellationToken)
                {
                    argsToPass.Add("global::TUnit.Core.TestContext.Current?.CancellationToken ?? System.Threading.CancellationToken.None");
                }

                var methodCall = $"typedInstance.{methodName}({string.Join(", ", argsToPass)})";

                if (isAsync)
                {
                    writer.AppendLine($"await {methodCall};");
                }
                else
                {
                    writer.AppendLine($"{methodCall};");
                }
                writer.AppendLine("break;");
                writer.Unindent();
            }

            writer.AppendLine("default:");
            writer.Indent();
            if (requiredParamCount == parametersFromArgs.Length)
            {
                writer.AppendLine($"throw new ArgumentException($\"Expected exactly {parametersFromArgs.Length} argument{(parametersFromArgs.Length == 1 ? "" : "s")}, but got {{args.Length}}\");");
            }
            else
            {
                writer.AppendLine($"throw new ArgumentException($\"Expected between {requiredParamCount} and {parametersFromArgs.Length} arguments, but got {{args.Length}}\");");
            }
            writer.Unindent();

            writer.Unindent();
            writer.AppendLine("}");

            if (!isAsync)
            {
                writer.AppendLine("await Task.CompletedTask;");
            }
        }

        writer.Unindent();
        writer.AppendLine("},");

        // Property injections for properties with data source attributes
        GeneratePropertyInjections(writer, testMethod.TypeSymbol, className);

        // Typed invokers
        writer.AppendLine("CreateTypedInstance = null,");
        writer.AppendLine($"InvokeTypedTest = async (instance, args, cancellationToken) =>");
        writer.AppendLine("{");
        writer.Indent();

        if (parametersFromArgs.Length == 0)
        {
            var typedMethodCall = hasCancellationToken
                ? $"instance.{methodName}(cancellationToken)"
                : $"instance.{methodName}()";
            if (isAsync)
            {
                writer.AppendLine($"await {typedMethodCall};");
            }
            else
            {
                writer.AppendLine($"{typedMethodCall};");
                writer.AppendLine("await Task.CompletedTask;");
            }
        }
        else
        {
            // Count required parameters (those without default values, excluding CancellationToken)
            var requiredParamCount = parametersFromArgs.Count(p => !p.HasExplicitDefaultValue && !p.IsOptional);

            // Generate runtime logic to handle variable argument counts
            writer.AppendLine("// Invoke with only the arguments that were provided");
            writer.AppendLine("switch (args.Length)");
            writer.AppendLine("{");
            writer.Indent();

            // Generate cases for each valid argument count (from required params up to total params from args)
            for (var argCount = requiredParamCount; argCount <= parametersFromArgs.Length; argCount++)
            {
                writer.AppendLine($"case {argCount}:");
                writer.Indent();

                // Build the arguments to pass, including default values for optional parameters
                var argsToPass = new List<string>();
                for (var i = 0; i < parametersFromArgs.Length; i++)
                {
                    var param = parametersFromArgs[i];
                    if (i < argCount)
                    {
                        // Use tuple-aware argument access
                        var argumentExpressions = TupleArgumentHelper.GenerateArgumentAccess(param.Type, "args", i);
                        argsToPass.AddRange(argumentExpressions);
                    }
                    else if (param.HasExplicitDefaultValue)
                    {
                        // Use the default value
                        argsToPass.Add(GetDefaultValueString(param));
                    }
                    else
                    {
                        // This shouldn't happen if we set up requiredParamCount correctly
                        argsToPass.Add($"default({param.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)})");
                    }
                }

                // Add CancellationToken if present
                if (hasCancellationToken)
                {
                    argsToPass.Add("cancellationToken");
                }

                var typedMethodCall = $"instance.{methodName}({string.Join(", ", argsToPass)})";

                if (isAsync)
                {
                    writer.AppendLine($"await {typedMethodCall};");
                }
                else
                {
                    writer.AppendLine($"{typedMethodCall};");
                }
                writer.AppendLine("break;");
                writer.Unindent();
            }

            writer.AppendLine("default:");
            writer.Indent();
            if (requiredParamCount == parametersFromArgs.Length)
            {
                writer.AppendLine($"throw new ArgumentException($\"Expected exactly {parametersFromArgs.Length} argument{(parametersFromArgs.Length == 1 ? "" : "s")}, but got {{args.Length}}\");");
            }
            else
            {
                writer.AppendLine($"throw new ArgumentException($\"Expected between {requiredParamCount} and {parametersFromArgs.Length} arguments, but got {{args.Length}}\");");
            }
            writer.Unindent();

            writer.Unindent();
            writer.AppendLine("}");

            if (!isAsync)
            {
                writer.AppendLine("await Task.CompletedTask;");
            }
        }

        writer.Unindent();
        writer.AppendLine("},");

        // CreateExecutableTest factory to create strongly-typed ExecutableTest<T>
        writer.AppendLine($"CreateExecutableTest = (context, metadata) =>");
        writer.AppendLine("{");
        writer.Indent();
        writer.AppendLine($"var typedMetadata = (TestMetadata<{className}>)metadata;");
        writer.AppendLine($"return new global::TUnit.Core.ExecutableTest<{className}>");
        writer.AppendLine("{");
        writer.Indent();

        // Set all required properties from context
        writer.AppendLine("TestId = context.TestId,");
        writer.AppendLine("DisplayName = context.DisplayName,");
        writer.AppendLine("Arguments = context.Arguments,");
        writer.AppendLine("ClassArguments = context.ClassArguments,");
        writer.AppendLine("PropertyValues = context.PropertyValues,");
        writer.AppendLine("BeforeTestHooks = context.BeforeTestHooks,");
        writer.AppendLine("AfterTestHooks = context.AfterTestHooks,");
        writer.AppendLine("Context = context.Context,");

        // Set the metadata property (not TypedMetadata which is read-only)
        writer.AppendLine("Metadata = typedMetadata,");

        // Set typed properties
        writer.AppendLine($"CreateTypedInstance = async () =>");
        writer.AppendLine("{");
        writer.Indent();
        writer.AppendLine("if (typedMetadata.InstanceFactory == null)");
        writer.AppendLine("{");
        writer.Indent();
        writer.AppendLine("throw new InvalidOperationException(\"No instance factory\");");
        writer.Unindent();
        writer.AppendLine("}");
        writer.AppendLine($"var instance = ({className})typedMetadata.InstanceFactory(context.ClassArguments);");
        writer.AppendLine("await global::TUnit.Core.ObjectInitializer.InitializeAsync(instance);");
        writer.AppendLine("return instance;");
        writer.Unindent();
        writer.AppendLine("},");
        writer.AppendLine("InvokeTypedTest = typedMetadata.InvokeTypedTest ?? throw new InvalidOperationException(\"No typed test invoker\")");

        writer.Unindent();
        writer.AppendLine("};");
        writer.Unindent();
        writer.AppendLine("}");
    }


    private static void GenerateModuleInitializer(CodeWriter writer, TestMethodMetadata testMethod, string guid)
    {
        writer.AppendLine();
        writer.AppendLine($"internal static class {testMethod.TypeSymbol.Name}_{testMethod.MethodSymbol.Name}_ModuleInitializer_{guid}");
        writer.AppendLine("{");
        writer.Indent();
        writer.AppendLine("[System.Runtime.CompilerServices.ModuleInitializer]");
        writer.AppendLine("public static void Initialize()");
        writer.AppendLine("{");
        writer.Indent();
        writer.AppendLine($"global::TUnit.Core.SourceRegistrar.Register(new {testMethod.TypeSymbol.Name}_{testMethod.MethodSymbol.Name}_TestSource_{guid}());");
        writer.Unindent();
        writer.AppendLine("}");
        writer.Unindent();
        writer.AppendLine("}");
    }

    private static bool IsAsyncMethod(IMethodSymbol method)
    {
        var returnType = method.ReturnType;
        if (returnType == null)
        {
            return false;
        }

        var returnTypeName = returnType.ToDisplayString();
        return returnTypeName.StartsWith("System.Threading.Tasks.Task") ||
               returnTypeName.StartsWith("System.Threading.Tasks.ValueTask") ||
               returnTypeName.StartsWith("Task<") ||
               returnTypeName.StartsWith("ValueTask<");
    }

    private static bool IsNullableValueType(ITypeSymbol type)
    {
        return type is INamedTypeSymbol namedType &&
               namedType.IsGenericType &&
               namedType.ConstructedFrom.SpecialType == SpecialType.System_Nullable_T;
    }

    private static void GenerateDependencies(CodeWriter writer, Compilation compilation, IMethodSymbol methodSymbol)
    {
        var dependsOnAttributes = methodSymbol.GetAttributes()
            .Where(attr => attr.AttributeClass?.Name == "DependsOnAttribute" &&
                          attr.AttributeClass.ContainingNamespace?.ToDisplayString() == "TUnit.Core")
            .ToList();

        if (!dependsOnAttributes.Any())
        {
            writer.AppendLine("Dependencies = Array.Empty<TestDependency>(),");
            return;
        }

        writer.AppendLine("Dependencies = new TestDependency[]");
        writer.AppendLine("{");
        writer.Indent();

        for (var i = 0; i < dependsOnAttributes.Count; i++)
        {
            var attr = dependsOnAttributes[i];
            GenerateTestDependency(writer, compilation, attr);

            if (i < dependsOnAttributes.Count - 1)
            {
                writer.AppendLine(",");
            }
        }

        writer.Unindent();
        writer.AppendLine("},");
    }

    private static void GenerateTestDependency(CodeWriter writer, Compilation compilation, AttributeData attributeData)
    {
        var constructorArgs = attributeData.ConstructorArguments;

        // Handle the different constructor overloads of DependsOnAttribute
        if (constructorArgs.Length == 1)
        {
            var arg = constructorArgs[0];
            if (arg.Type?.Name == "String")
            {
                // DependsOnAttribute(string testName) - dependency on test in same class
                var testName = arg.Value?.ToString() ?? "";
                writer.AppendLine($"new TestDependency {{ MethodName = \"{testName}\" }}");
            }
            else if (arg.Type?.TypeKind == TypeKind.Class || arg.Type?.Name == "Type")
            {
                // DependsOnAttribute(Type testClass) - dependency on all tests in a class
                var classType = arg.Value as ITypeSymbol;
                if (classType != null)
                {
                    var className = classType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                    var genericArity = classType is INamedTypeSymbol namedType && namedType.IsGenericType
                        ? namedType.Arity
                        : 0;
                    writer.AppendLine($"new TestDependency {{ ClassType = typeof({className}), ClassGenericArity = {genericArity} }}");
                }
            }
        }
        else if (constructorArgs.Length == 2)
        {
            var firstArg = constructorArgs[0];
            var secondArg = constructorArgs[1];

            if (firstArg.Type?.Name == "String" && secondArg.Type is IArrayTypeSymbol)
            {
                // DependsOnAttribute(string testName, Type[] parameterTypes)
                var testName = firstArg.Value?.ToString() ?? "";
                writer.Append($"new TestDependency {{ MethodName = \"{testName}\"");

                // Handle parameter types
                if (secondArg.Values.Length > 0)
                {
                    writer.Append(", MethodParameters = new Type[] { ");
                    for (var i = 0; i < secondArg.Values.Length; i++)
                    {
                        if (secondArg.Values[i].Value is ITypeSymbol paramType)
                        {
                            writer.Append($"typeof({paramType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)})");
                            if (i < secondArg.Values.Length - 1)
                            {
                                writer.Append(", ");
                            }
                        }
                    }
                    writer.AppendLine(" }");
                }

                writer.AppendLine(" }");
            }
            else if (firstArg.Type?.TypeKind == TypeKind.Class || firstArg.Type?.Name == "Type")
            {
                // DependsOnAttribute(Type testClass, string testName)
                var classType = firstArg.Value as ITypeSymbol;
                var testName = secondArg.Value?.ToString() ?? "";

                if (classType != null)
                {
                    var className = classType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                    var genericArity = classType is INamedTypeSymbol namedType && namedType.IsGenericType
                        ? namedType.Arity
                        : 0;
                    writer.AppendLine($"new TestDependency {{ ClassType = typeof({className}), ClassGenericArity = {genericArity}, MethodName = \"{testName}\" }}");
                }
            }
        }
        else if (constructorArgs.Length == 3)
        {
            // DependsOnAttribute(Type testClass, string testName, Type[] parameterTypes)
            var classType = constructorArgs[0].Value as ITypeSymbol;
            var testName = constructorArgs[1].Value?.ToString() ?? "";

            if (classType != null)
            {
                var className = classType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                var genericArity = classType is INamedTypeSymbol namedType && namedType.IsGenericType
                    ? namedType.Arity
                    : 0;
                writer.Append($"new TestDependency {{ ClassType = typeof({className}), ClassGenericArity = {genericArity}, MethodName = \"{testName}\"");

                // Handle parameter types
                var paramTypesArg = constructorArgs[2];
                if (paramTypesArg.Values.Length > 0)
                {
                    writer.Append(", MethodParameters = new Type[] { ");
                    for (var i = 0; i < paramTypesArg.Values.Length; i++)
                    {
                        if (paramTypesArg.Values[i].Value is ITypeSymbol paramType)
                        {
                            writer.Append($"typeof({paramType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)})");
                            if (i < paramTypesArg.Values.Length - 1)
                            {
                                writer.Append(", ");
                            }
                        }
                    }
                    writer.AppendLine(" }");
                }

                writer.AppendLine(" }");
            }
        }
    }

    private static string GetDefaultValueString(IParameterSymbol parameter)
    {
        if (!parameter.HasExplicitDefaultValue)
        {
            return $"default({parameter.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)})";
        }

        var defaultValue = parameter.ExplicitDefaultValue;
        if (defaultValue == null)
        {
            return "null";
        }

        var type = parameter.Type;

        // Handle string
        if (type.SpecialType == SpecialType.System_String)
        {
            return $"\"{defaultValue.ToString().Replace("\\", "\\\\").Replace("\"", "\\\"")}\"";
        }

        // Handle char
        if (type.SpecialType == SpecialType.System_Char)
        {
            return $"'{defaultValue}'";
        }

        // Handle bool
        if (type.SpecialType == SpecialType.System_Boolean)
        {
            return defaultValue.ToString().ToLowerInvariant();
        }

        // Handle numeric types with proper suffixes
        if (type.SpecialType == SpecialType.System_Single)
        {
            return $"{defaultValue}f";
        }
        if (type.SpecialType == SpecialType.System_Double)
        {
            return $"{defaultValue}d";
        }
        if (type.SpecialType == SpecialType.System_Decimal)
        {
            return $"{defaultValue}m";
        }
        if (type.SpecialType == SpecialType.System_Int64)
        {
            return $"{defaultValue}L";
        }
        if (type.SpecialType == SpecialType.System_UInt32)
        {
            return $"{defaultValue}u";
        }
        if (type.SpecialType == SpecialType.System_UInt64)
        {
            return $"{defaultValue}ul";
        }

        // Default for other types
        return defaultValue.ToString();
    }

    private static InheritsTestsClassMetadata? GetInheritsTestsClassMetadata(GeneratorAttributeSyntaxContext context)
    {
        var classSyntax = (ClassDeclarationSyntax)context.TargetNode;
        var classSymbol = context.TargetSymbol as INamedTypeSymbol;

        if (classSymbol == null)
        {
            return null;
        }

        // Skip abstract classes
        if (classSymbol.IsAbstract)
        {
            return null;
        }

        // Skip generic types without explicit instantiation
        if (classSymbol is { IsGenericType: true, TypeParameters.Length: > 0 })
        {
            return null;
        }

        return new InheritsTestsClassMetadata
        {
            TypeSymbol = classSymbol,
            ClassSyntax = classSyntax
        };
    }

    private static void GenerateInheritedTestSources(SourceProductionContext context, Compilation compilation, InheritsTestsClassMetadata? classInfo)
    {
        if (classInfo?.TypeSymbol == null)
        {
            return;
        }

        // Find all test methods in base classes
        var inheritedTestMethods = new List<IMethodSymbol>();
        CollectInheritedTestMethods(classInfo.TypeSymbol, inheritedTestMethods);

        // Generate test metadata for each inherited test method
        foreach (var method in inheritedTestMethods)
        {
            var testMethodMetadata = new TestMethodMetadata
            {
                MethodSymbol = method,
                TypeSymbol = classInfo.TypeSymbol,
                MethodSyntax = null! // We don't have the syntax for inherited methods
            };

            GenerateTestMethodSource(context, compilation, testMethodMetadata);
        }
    }

    private static void CollectInheritedTestMethods(INamedTypeSymbol derivedClass, List<IMethodSymbol> testMethods)
    {
        var currentType = derivedClass.BaseType;

        while (currentType != null && currentType.SpecialType != SpecialType.System_Object)
        {
            // Skip if base type is an open generic type
            if (currentType.IsUnboundGenericType ||
                (currentType.IsGenericType && currentType.TypeArguments.Any(arg => arg.TypeKind == TypeKind.TypeParameter)))
            {
                currentType = currentType.BaseType;
                continue;
            }

            // Get all methods from the base class
            var methods = currentType.GetMembers()
                .OfType<IMethodSymbol>()
                .Where(m => !m.IsStatic && m.MethodKind == MethodKind.Ordinary);

            foreach (var method in methods)
            {
                // Skip generic methods - they can't be instantiated without concrete type arguments
                if (method.IsGenericMethod)
                {
                    continue;
                }

                // Check if method has Test attribute
                var hasTestAttribute = method.GetAttributes()
                    .Any(attr => attr.AttributeClass?.Name == "TestAttribute" &&
                                attr.AttributeClass.ContainingNamespace?.ToDisplayString() == "TUnit.Core");

                if (hasTestAttribute)
                {
                    testMethods.Add(method);
                }
            }

            currentType = currentType.BaseType;
        }
    }

    /// <summary>
    /// Generates reflection-based field accessors for init-only properties with data source attributes
    /// </summary>
    private static void GenerateReflectionFieldAccessors(CodeWriter writer, INamedTypeSymbol typeSymbol, string className)
    {
        // Find all init-only properties with data source attributes
        var initOnlyPropertiesWithDataSources = new List<IPropertySymbol>();

        var currentType = typeSymbol;
        while (currentType != null)
        {
            foreach (var member in currentType.GetMembers())
            {
                if (member is IPropertySymbol property &&
                    property.DeclaredAccessibility == Accessibility.Public &&
                    property.SetMethod?.DeclaredAccessibility == Accessibility.Public &&
                    !property.IsStatic &&
                    property.SetMethod.IsInitOnly)
                {
                    var dataSourceAttr = property.GetAttributes()
                        .FirstOrDefault(a => DataSourceAttributeHelper.IsDataSourceAttribute(a.AttributeClass));

                    if (dataSourceAttr != null)
                    {
                        initOnlyPropertiesWithDataSources.Add(property);
                    }
                }
            }
            currentType = currentType.BaseType;
        }

        // Generate cached FieldInfo static fields for each init-only property with data source
        foreach (var property in initOnlyPropertiesWithDataSources)
        {
            var backingFieldName = $"<{property.Name}>k__BackingField";

            writer.AppendLine($"/// <summary>");
            writer.AppendLine($"/// Cached FieldInfo for init-only property {property.Name} backing field");
            writer.AppendLine($"/// </summary>");
            writer.AppendLine($"[global::System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(global::System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicFields)]");
            writer.AppendLine($"private static readonly global::System.Reflection.FieldInfo {property.Name}BackingField = ");
            writer.Indent();
            writer.AppendLine($"typeof({className}).GetField(\"{backingFieldName}\", ");
            writer.AppendLine($"global::System.Reflection.BindingFlags.Instance | global::System.Reflection.BindingFlags.NonPublic)!;");
            writer.Unindent();
            writer.AppendLine();
        }
    }
}

/// <summary>
/// Metadata for a test method during source generation
/// </summary>
public class TestMethodMetadata
{
    public required IMethodSymbol MethodSymbol { get; init; }
    public required INamedTypeSymbol TypeSymbol { get; init; }
    public required MethodDeclarationSyntax MethodSyntax { get; init; }
}

/// <summary>
/// Metadata for a class with [InheritsTests] attribute
/// </summary>
public class InheritsTestsClassMetadata
{
    public required INamedTypeSymbol TypeSymbol { get; init; }
    public required ClassDeclarationSyntax ClassSyntax { get; init; }
}
