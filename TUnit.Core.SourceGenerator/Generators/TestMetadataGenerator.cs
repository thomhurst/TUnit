using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using TUnit.Core.SourceGenerator.CodeGenerators.Helpers;

namespace TUnit.Core.SourceGenerator.Generators;

/// <summary>
/// Simplified test metadata generator that emits one TestMetadata<T> per method
/// with a DataCombinationGenerator delegate for runtime data expansion.
/// </summary>
[Generator]
public sealed class TestMetadataGenerator : IIncrementalGenerator
{
    private const string GeneratedNamespace = "TUnit.Generated";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Register post-initialization output for base types
        context.RegisterPostInitializationOutput(GenerateBaseTypes);

        // Find all test methods using the more performant ForAttributeWithMetadataName
        var testMethodsProvider = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                "TUnit.Core.TestAttribute",
                predicate: static (node, _) => node is MethodDeclarationSyntax,
                transform: static (ctx, _) => GetTestMethodMetadata(ctx))
            .Where(static m => m is not null);

        // Find classes with [InheritsTests] attribute
        var inheritsTestsClassesProvider = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                "TUnit.Core.InheritsTestsAttribute",
                predicate: static (node, _) => node is ClassDeclarationSyntax,
                transform: static (ctx, _) => GetInheritsTestsClassMetadata(ctx))
            .Where(static m => m is not null);

        // Generate one source file per test method
        context.RegisterSourceOutput(testMethodsProvider, static (context, testMethod) => GenerateTestMethodSource(context, testMethod));
        
        // Generate test methods for inherited tests
        context.RegisterSourceOutput(inheritsTestsClassesProvider, static (context, classInfo) => GenerateInheritedTestSources(context, classInfo));
    }

    private static void GenerateBaseTypes(IncrementalGeneratorPostInitializationContext context)
    {
        // Generate any base types needed for the simplified approach
        // For now, we'll keep this empty as we're using existing types
    }

    private static TestMethodMetadata? GetTestMethodMetadata(GeneratorAttributeSyntaxContext context)
    {
        var methodSyntax = (MethodDeclarationSyntax)context.TargetNode;
        var methodSymbol = context.TargetSymbol as IMethodSymbol;

        var containingType = methodSymbol?.ContainingType;

        if (containingType == null)
        {
            return null;
        }

        // Skip abstract classes (cannot be instantiated)
        if (containingType.IsAbstract)
        {
            return null;
        }

        // Skip generic types without explicit instantiation
        if (containingType is { IsGenericType: true, TypeParameters.Length: > 0 })
        {
            return null;
        }

        // Skip generic methods without explicit instantiation
        if (methodSymbol is { IsGenericMethod: true })
        {
            return null;
        }

        return new TestMethodMetadata
        {
            MethodSymbol = methodSymbol ?? throw new InvalidOperationException("Symbol is not a method"),
            TypeSymbol = containingType,
            MethodSyntax = methodSyntax
        };
    }

    private static void GenerateTestMethodSource(SourceProductionContext context, TestMethodMetadata? testMethod)
    {
        try
        {
            if (testMethod?.MethodSymbol == null || testMethod.TypeSymbol == null)
            {
                return;
            }

            var writer = new CodeWriter();
            GenerateFileHeader(writer);
            GenerateSimplifiedTestMetadata(writer, testMethod);

            var fileName = $"Simplified_{testMethod.TypeSymbol.Name}_{testMethod.MethodSymbol.Name}_{Guid.NewGuid():N}.g.cs";
            context.AddSource(fileName, SourceText.From(writer.ToString(), Encoding.UTF8));
        }
        catch (Exception ex)
        {
            var methodName = testMethod?.MethodSymbol?.Name ?? "Unknown";
            var className = testMethod?.TypeSymbol?.Name ?? "Unknown";

            context.ReportDiagnostic(Diagnostic.Create(
                new DiagnosticDescriptor(
                    "TUNIT0999",
                    "Source Generation Error",
                    "Failed to generate test metadata for {0}.{1}: {2}",
                    "TUnit",
                    DiagnosticSeverity.Error,
                    true),
                Location.None,
                className,
                methodName,
                ex.ToString())); // Use ToString() to get full stack trace for debugging
        }
    }

    private static void GenerateFileHeader(CodeWriter writer)
    {
        writer.AppendLine("// <auto-generated/>");
        writer.AppendLine("#pragma warning disable");
        writer.AppendLine("#nullable enable");
        writer.AppendLine();
        writer.AppendLine("using System;");
        writer.AppendLine("using System.Collections.Generic;");
        writer.AppendLine("using System.Linq;");
        writer.AppendLine("using System.Threading;");
        writer.AppendLine("using System.Threading.Tasks;");
        writer.AppendLine("using global::TUnit.Core;");
        writer.AppendLine("using global::TUnit.Core.Interfaces.SourceGenerator;");
        writer.AppendLine();
        writer.AppendLine($"namespace {GeneratedNamespace};");
        writer.AppendLine();
    }

    private static void GenerateSimplifiedTestMetadata(CodeWriter writer, TestMethodMetadata testMethod)
    {
        var className = testMethod.TypeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        var methodName = testMethod.MethodSymbol.Name;
        var guid = Guid.NewGuid().ToString("N");
        var combinationGuid = Guid.NewGuid().ToString("N").Substring(0, 8);

        writer.AppendLine($"internal sealed class {testMethod.TypeSymbol.Name}_{methodName}_TestSource_{guid} : ITestSource");
        writer.AppendLine("{");
        writer.Indent();

        writer.AppendLine("public async ValueTask<List<TestMetadata>> GetTestsAsync()");
        writer.AppendLine("{");
        writer.Indent();

        writer.AppendLine("var tests = new List<TestMetadata>();");
        writer.AppendLine();

        // Generate the TestMetadata<T> with DataCombinationGenerator
        GenerateTestMetadataInstance(writer, testMethod, className, combinationGuid);

        writer.AppendLine("return tests;");
        writer.Unindent();
        writer.AppendLine("}");

        // Generate the data combination method inside the class
        writer.AppendLine();
        GenerateDataCombinationMethod(writer, testMethod, combinationGuid);

        writer.Unindent();
        writer.AppendLine("}");

        // Generate module initializer
        GenerateModuleInitializer(writer, testMethod, guid);
    }

    private static void GenerateTestMetadataInstance(CodeWriter writer, TestMethodMetadata testMethod, string className, string combinationGuid)
    {
        var methodName = testMethod.MethodSymbol.Name;
        var testId = $"{className}.{methodName}";

        writer.AppendLine($"var metadata = new TestMetadata<{className}>");
        writer.AppendLine("{");
        writer.Indent();

        writer.AppendLine($"TestId = \"{testId}\",");
        writer.AppendLine($"TestName = \"{methodName}\",");
        writer.AppendLine($"TestClassType = typeof({className}),");
        writer.AppendLine($"TestMethodName = \"{methodName}\",");

        // Add basic metadata
        GenerateBasicMetadata(writer, testMethod);

        // Generate typed invokers and factory
        GenerateTypedInvokers(writer, testMethod, className);

        writer.Unindent();
        writer.AppendLine("};");
        
        // Set the DataCombinationGenerator after construction
        writer.AppendLine($"metadata.SetDataCombinationGenerator(() => GenerateCombinations_{combinationGuid}());");
        writer.AppendLine("tests.Add(metadata);");
    }

    private static void GenerateBasicMetadata(CodeWriter writer, TestMethodMetadata testMethod)
    {
        var methodSymbol = testMethod.MethodSymbol;

        writer.AppendLine("Categories = Array.Empty<string>(),");
        writer.AppendLine("IsSkipped = false,");
        writer.AppendLine("SkipReason = null,");
        writer.AppendLine("TimeoutMs = null,");
        writer.AppendLine("RetryCount = 0,");
        writer.AppendLine("CanRunInParallel = true,");
        writer.AppendLine("Dependencies = Array.Empty<TestDependency>(),");
        writer.AppendLine("AttributeFactory = null,");

        // Legacy data sources (empty in new approach)
        writer.AppendLine("DataSources = Array.Empty<TestDataSource>(),");
        writer.AppendLine("ClassDataSources = Array.Empty<TestDataSource>(),");
        writer.AppendLine("PropertyDataSources = Array.Empty<PropertyDataSource>(),");

        // Parameter types
        writer.AppendLine("ParameterTypes = new Type[]");
        writer.AppendLine("{");
        writer.Indent();
        foreach (var param in methodSymbol.Parameters)
        {
            writer.AppendLine($"typeof({param.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)}),");
        }
        writer.Unindent();
        writer.AppendLine("},");

        // String parameter types
        writer.AppendLine("TestMethodParameterTypes = new string[]");
        writer.AppendLine("{");
        writer.Indent();
        foreach (var param in methodSymbol.Parameters)
        {
            writer.AppendLine($"\"{param.Type.ToDisplayString()}\",");
        }
        writer.Unindent();
        writer.AppendLine("},");

        // Empty hooks for now
        writer.AppendLine("Hooks = new TestHooks");
        writer.AppendLine("{");
        writer.Indent();
        writer.AppendLine("BeforeClass = Array.Empty<HookMetadata>(),");
        writer.AppendLine("AfterClass = Array.Empty<HookMetadata>(),");
        writer.AppendLine("BeforeTest = Array.Empty<HookMetadata>(),");
        writer.AppendLine("AfterTest = Array.Empty<HookMetadata>()");
        writer.Unindent();
        writer.AppendLine("},");
    }


    private static void GenerateDataCombinationMethod(CodeWriter writer, TestMethodMetadata testMethod, string guid)
    {
        writer.AppendLine($"private static async IAsyncEnumerable<TestDataCombination> GenerateCombinations_{guid}()");
        writer.AppendLine("{");
        writer.Indent();

        writer.AppendLine("var combinations = new List<TestDataCombination>();");

        // Get all data source attributes on method and class
        var methodAttributes = GetDataSourceAttributes(testMethod.MethodSymbol);
        var classAttributes = GetDataSourceAttributes(testMethod.TypeSymbol);

        if (!methodAttributes.Any() && !classAttributes.Any())
        {
            // No data sources - single empty combination
            writer.AppendLine("combinations.Add(new TestDataCombination());");
        }
        else
        {
            // Generate combinations from data source attributes
            GenerateDataSourceCombinations(writer, testMethod, methodAttributes, classAttributes);
        }

        writer.AppendLine("foreach (var combination in combinations)");
        writer.AppendLine("{");
        writer.Indent();
        writer.AppendLine("yield return combination;");
        writer.Unindent();
        writer.AppendLine("}");
        writer.Unindent();
        writer.AppendLine("}");
    }

    private static void GenerateDataSourceCombinations(CodeWriter writer, TestMethodMetadata testMethod,
        IEnumerable<AttributeData> methodAttributes, IEnumerable<AttributeData> classAttributes)
    {
        writer.AppendLine("try");
        writer.AppendLine("{");
        writer.Indent();
        
        writer.AppendLine("// Generate data combinations from attributes");
        writer.AppendLine("var methodCombinations = new List<TestDataCombination>();");
        writer.AppendLine("var classCombinations = new List<TestDataCombination>();");

        // Generate method data combinations
        var methodAttrs = methodAttributes.ToList();
        for (int i = 0; i < methodAttrs.Count; i++)
        {
            var attr = methodAttrs[i];
            GenerateAttributeDataCombinations(writer, attr, i, "methodCombinations", isClassLevel: false);
        }

        // Generate class data combinations
        var classAttrs = classAttributes.ToList();
        for (int i = 0; i < classAttrs.Count; i++)
        {
            var attr = classAttrs[i];
            GenerateAttributeDataCombinations(writer, attr, i, "classCombinations", isClassLevel: true);
        }

        // Generate cartesian product
        writer.AppendLine();
        writer.AppendLine("// Generate cartesian product of class and method combinations");
        writer.AppendLine("if (classCombinations.Count == 0) classCombinations.Add(new TestDataCombination());");
        writer.AppendLine("if (methodCombinations.Count == 0) methodCombinations.Add(new TestDataCombination());");
        writer.AppendLine();
        writer.AppendLine("foreach (var classCombination in classCombinations)");
        writer.AppendLine("{");
        writer.Indent();
        writer.AppendLine("foreach (var methodCombination in methodCombinations)");
        writer.AppendLine("{");
        writer.Indent();
        writer.AppendLine("combinations.Add(new TestDataCombination");
        writer.AppendLine("{");
        writer.Indent();
        writer.AppendLine("ClassData = classCombination.ClassData,");
        writer.AppendLine("MethodData = methodCombination.MethodData,");
        writer.AppendLine("DataSourceIndices = classCombination.DataSourceIndices.Concat(methodCombination.DataSourceIndices).ToArray(),");
        writer.AppendLine("PropertyValues = classCombination.PropertyValues.Concat(methodCombination.PropertyValues).ToDictionary(kvp => kvp.Key, kvp => kvp.Value)");
        writer.Unindent();
        writer.AppendLine("});");
        writer.Unindent();
        writer.AppendLine("}");
        writer.Unindent();
        writer.AppendLine("}");
        
        writer.Unindent();
        writer.AppendLine("}");
        writer.AppendLine("catch (Exception ex)");
        writer.AppendLine("{");
        writer.Indent();
        writer.AppendLine("// If combination generation fails, add a single empty combination");
        writer.AppendLine("combinations.Add(new TestDataCombination());");
        writer.Unindent();
        writer.AppendLine("}");
    }

    private static void GenerateAttributeDataCombinations(CodeWriter writer, AttributeData attr, int index,
        string listName, bool isClassLevel)
    {
        var attributeClassName = attr.AttributeClass?.Name;

        if (attributeClassName == "ArgumentsAttribute")
        {
            // Generate Arguments combinations
            writer.AppendLine($"// ArgumentsAttribute {index}");
            if (attr.ConstructorArguments.Length > 0)
            {
                try
                {
                    List<string> formattedArgs = new List<string>();
                    
                    // ArgumentsAttribute typically has a params object[] constructor
                    // So all arguments come through as a single array TypedConstant
                    if (attr.ConstructorArguments.Length == 1 && attr.ConstructorArguments[0].Kind == TypedConstantKind.Array)
                    {
                        // Unwrap the params array
                        foreach (var value in attr.ConstructorArguments[0].Values)
                        {
                            formattedArgs.Add(FormatConstantValue(value));
                        }
                    }
                    else
                    {
                        // Handle non-params case (shouldn't normally happen with ArgumentsAttribute)
                        formattedArgs = attr.ConstructorArguments
                            .Select(FormatConstantValue)
                            .ToList();
                    }

                    writer.AppendLine($"{listName}.Add(new TestDataCombination");
                    writer.AppendLine("{");
                    writer.Indent();

                    if (isClassLevel)
                    {
                        writer.AppendLine($"ClassData = new object?[] {{ {string.Join(", ", formattedArgs)} }},");
                        writer.AppendLine("MethodData = Array.Empty<object?>(),");
                    }
                    else
                    {
                        writer.AppendLine("ClassData = Array.Empty<object?>(),");
                        writer.AppendLine($"MethodData = new object?[] {{ {string.Join(", ", formattedArgs)} }},");
                    }

                    writer.AppendLine($"DataSourceIndices = new[] {{ {index} }},");
                    writer.AppendLine("PropertyValues = new Dictionary<string, object?>()");
                    writer.Unindent();
                    writer.AppendLine("});");
                }
                catch (Exception ex)
                {
                    // If we can't process the arguments, generate an empty combination with a comment
                    writer.AppendLine($"// Error processing ArgumentsAttribute at index {index}: {ex.Message}");
                    writer.AppendLine($"{listName}.Add(new TestDataCombination");
                    writer.AppendLine("{");
                    writer.Indent();
                    writer.AppendLine("ClassData = Array.Empty<object?>(),");
                    writer.AppendLine("MethodData = Array.Empty<object?>(),");
                    writer.AppendLine($"DataSourceIndices = new[] {{ {index} }},");
                    writer.AppendLine("PropertyValues = new Dictionary<string, object?>()");
                    writer.Unindent();
                    writer.AppendLine("});");
                }
            }
        }
        else
        {
            // For now, add a placeholder for other attribute types
            writer.AppendLine($"// TODO: Handle {attributeClassName} - requires runtime processing");
            writer.AppendLine($"{listName}.Add(new TestDataCombination");
            writer.AppendLine("{");
            writer.Indent();
            writer.AppendLine("ClassData = Array.Empty<object?>(),");
            writer.AppendLine("MethodData = Array.Empty<object?>(),");
            writer.AppendLine($"DataSourceIndices = new[] {{ {index} }},");
            writer.AppendLine("PropertyValues = new Dictionary<string, object?>()");
            writer.Unindent();
            writer.AppendLine("});");
        }
    }

    private static string FormatConstantValue(TypedConstant constant)
    {
        if (constant.IsNull || constant.Value == null)
        {
            return "null";
        }

        if (constant.Kind == TypedConstantKind.Array)
        {
            var elementType = constant.Type is IArrayTypeSymbol arrayType 
                ? arrayType.ElementType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)
                : "object";
            var values = constant.Values.Select(FormatConstantValue);
            return $"new {elementType}[] {{ {string.Join(", ", values)} }}";
        }

        if (constant.Kind == TypedConstantKind.Type && constant.Value is ITypeSymbol typeSymbol)
        {
            return $"typeof({typeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)})";
        }

        if (constant.Value is string str)
        {
            return $"\"{str.Replace("\\", "\\\\").Replace("\"", "\\\"").Replace("\r", "\\r").Replace("\n", "\\n").Replace("\t", "\\t")}\"";
        }

        if (constant.Value is char ch)
        {
            return $"'{ch}'";
        }

        if (constant.Value is bool b)
        {
            return b ? "true" : "false";
        }

        if (constant.Value is float f)
        {
            return $"{f}f";
        }

        if (constant.Value is double d)
        {
            return $"{d}d";
        }

        if (constant.Value is decimal dec)
        {
            return $"{dec}m";
        }

        if (constant.Value is long l)
        {
            return $"{l}L";
        }

        if (constant.Value is uint u)
        {
            return $"{u}u";
        }

        if (constant.Value is ulong ul)
        {
            return $"{ul}ul";
        }

        return constant.Value?.ToString() ?? "null";
    }

    private static void GenerateTypedInvokers(CodeWriter writer, TestMethodMetadata testMethod, string className)
    {
        var methodName = testMethod.MethodSymbol.Name;
        var parameters = testMethod.MethodSymbol.Parameters;

        // Use centralized instance factory generator
        InstanceFactoryGenerator.GenerateInstanceFactory(writer, testMethod.TypeSymbol);

        // Test invoker
        var isAsync = IsAsyncMethod(testMethod.MethodSymbol);
        writer.AppendLine("TestInvoker = async (instance, args) =>");
        writer.AppendLine("{");
        writer.Indent();
        writer.AppendLine($"var typedInstance = ({className})instance;");

        var methodCall = parameters.Length == 0
            ? $"typedInstance.{methodName}()"
            : $"typedInstance.{methodName}({string.Join(", ", parameters.Select((p, i) => $"({p.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)})args[{i}]"))})";

        if (isAsync)
        {
            writer.AppendLine($"await {methodCall};");
        }
        else
        {
            writer.AppendLine($"{methodCall};");
            writer.AppendLine("await Task.CompletedTask;");
        }

        writer.Unindent();
        writer.AppendLine("},");

        // Property setters (empty for now)
        writer.AppendLine($"PropertySetters = new Dictionary<string, Action<{className}, object?>>(),");
        writer.AppendLine("PropertyInjections = Array.Empty<PropertyInjectionData>(),");

        // Typed invokers
        writer.AppendLine("CreateTypedInstance = null,");
        writer.AppendLine($"InvokeTypedTest = async (instance, args, cancellationToken) =>");
        writer.AppendLine("{");
        writer.Indent();

        var typedMethodCall = parameters.Length == 0
            ? $"instance.{methodName}()"
            : $"instance.{methodName}({string.Join(", ", parameters.Select((p, i) => $"({p.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)})args[{i}]"))})";

        if (isAsync)
        {
            writer.AppendLine($"await {typedMethodCall};");
        }
        else
        {
            writer.AppendLine($"{typedMethodCall};");
            writer.AppendLine("await Task.CompletedTask;");
        }

        writer.Unindent();
        writer.AppendLine("},");

        // CreateExecutableTest factory to create strongly-typed ExecutableTest<T>
        writer.AppendLine($"CreateExecutableTest = (context, metadata) =>");
        writer.AppendLine("{");
        writer.Indent();
        writer.AppendLine($"var typedMetadata = (TestMetadata<{className}>)metadata;");
        writer.AppendLine($"return new global::TUnit.Engine.ExecutableTest<{className}>");
        writer.AppendLine("{");
        writer.Indent();
        
        // Set all required properties from context
        writer.AppendLine("TestId = context.TestId,");
        writer.AppendLine("DisplayName = context.DisplayName,");
        writer.AppendLine("Arguments = context.Arguments,");
        writer.AppendLine("ClassArguments = context.ClassArguments,");
        writer.AppendLine("PropertyValues = context.PropertyValues,");
        writer.AppendLine("BeforeTestHooks = context.BeforeTestHooks,");
        writer.AppendLine("AfterTestHooks = context.AfterTestHooks,");
        writer.AppendLine("Context = context.Context,");
        
        // Set the metadata property (not TypedMetadata which is read-only)
        writer.AppendLine("Metadata = typedMetadata,");
        
        // Set typed properties
        writer.AppendLine($"CreateTypedInstance = async () => typedMetadata.InstanceFactory == null ? throw new InvalidOperationException(\"No instance factory\") : await Task.FromResult(({className})typedMetadata.InstanceFactory(context.ClassArguments)),");
        writer.AppendLine("InvokeTypedTest = typedMetadata.InvokeTypedTest ?? throw new InvalidOperationException(\"No typed test invoker\"),");
        writer.AppendLine("TypedPropertySetters = typedMetadata.PropertySetters");
        
        writer.Unindent();
        writer.AppendLine("};");
        writer.Unindent();
        writer.AppendLine("}");
    }

    private static IEnumerable<AttributeData> GetDataSourceAttributes(ISymbol symbol)
    {
        return symbol.GetAttributes().Where(a =>
            a.AttributeClass?.Name?.EndsWith("Attribute") == true &&
            (a.AttributeClass.Name.Contains("Arguments") ||
             a.AttributeClass.Name.Contains("DataSource")));
    }

    private static void GenerateModuleInitializer(CodeWriter writer, TestMethodMetadata testMethod, string guid)
    {
        writer.AppendLine();
        writer.AppendLine($"internal static class {testMethod.TypeSymbol.Name}_{testMethod.MethodSymbol.Name}_ModuleInitializer_{guid}");
        writer.AppendLine("{");
        writer.Indent();
        writer.AppendLine("[System.Runtime.CompilerServices.ModuleInitializer]");
        writer.AppendLine("public static void Initialize()");
        writer.AppendLine("{");
        writer.Indent();
        writer.AppendLine($"global::TUnit.Core.SourceRegistrar.Register(new {testMethod.TypeSymbol.Name}_{testMethod.MethodSymbol.Name}_TestSource_{guid}());");
        writer.Unindent();
        writer.AppendLine("}");
        writer.Unindent();
        writer.AppendLine("}");
    }

    private static bool IsAsyncMethod(IMethodSymbol method)
    {
        var returnType = method.ReturnType;
        if (returnType == null)
        {
            return false;
        }

        var returnTypeName = returnType.ToDisplayString();
        return returnTypeName.StartsWith("System.Threading.Tasks.Task") ||
               returnTypeName.StartsWith("System.Threading.Tasks.ValueTask") ||
               returnTypeName.StartsWith("Task<") ||
               returnTypeName.StartsWith("ValueTask<");
    }

    private static bool IsNullableValueType(ITypeSymbol type)
    {
        return type is INamedTypeSymbol namedType &&
               namedType.IsGenericType &&
               namedType.ConstructedFrom.SpecialType == SpecialType.System_Nullable_T;
    }

    private static InheritsTestsClassMetadata? GetInheritsTestsClassMetadata(GeneratorAttributeSyntaxContext context)
    {
        var classSyntax = (ClassDeclarationSyntax)context.TargetNode;
        var classSymbol = context.TargetSymbol as INamedTypeSymbol;

        if (classSymbol == null)
        {
            return null;
        }

        // Skip abstract classes
        if (classSymbol.IsAbstract)
        {
            return null;
        }

        // Skip generic types without explicit instantiation
        if (classSymbol is { IsGenericType: true, TypeParameters.Length: > 0 })
        {
            return null;
        }

        return new InheritsTestsClassMetadata
        {
            TypeSymbol = classSymbol,
            ClassSyntax = classSyntax
        };
    }

    private static void GenerateInheritedTestSources(SourceProductionContext context, InheritsTestsClassMetadata? classInfo)
    {
        if (classInfo?.TypeSymbol == null)
        {
            return;
        }

        // Find all test methods in base classes
        var inheritedTestMethods = new List<IMethodSymbol>();
        CollectInheritedTestMethods(classInfo.TypeSymbol, inheritedTestMethods);

        // Generate test metadata for each inherited test method
        foreach (var method in inheritedTestMethods)
        {
            var testMethodMetadata = new TestMethodMetadata
            {
                MethodSymbol = method,
                TypeSymbol = classInfo.TypeSymbol,
                MethodSyntax = null! // We don't have the syntax for inherited methods
            };

            GenerateTestMethodSource(context, testMethodMetadata);
        }
    }

    private static void CollectInheritedTestMethods(INamedTypeSymbol derivedClass, List<IMethodSymbol> testMethods)
    {
        var currentType = derivedClass.BaseType;

        while (currentType != null && currentType.SpecialType != SpecialType.System_Object)
        {
            // Skip if base type is an open generic type
            if (currentType.IsUnboundGenericType ||
                (currentType.IsGenericType && currentType.TypeArguments.Any(arg => arg.TypeKind == TypeKind.TypeParameter)))
            {
                currentType = currentType.BaseType;
                continue;
            }

            // Get all methods from the base class
            var methods = currentType.GetMembers()
                .OfType<IMethodSymbol>()
                .Where(m => !m.IsStatic && m.MethodKind == MethodKind.Ordinary);

            foreach (var method in methods)
            {
                // Skip generic methods - they can't be instantiated without concrete type arguments
                if (method.IsGenericMethod)
                {
                    continue;
                }
                
                // Check if method has Test attribute
                var hasTestAttribute = method.GetAttributes()
                    .Any(attr => attr.AttributeClass?.Name == "TestAttribute" &&
                                attr.AttributeClass.ContainingNamespace?.ToDisplayString() == "TUnit.Core");

                if (hasTestAttribute)
                {
                    testMethods.Add(method);
                }
            }

            currentType = currentType.BaseType;
        }
    }
}

/// <summary>
/// Metadata for a test method during source generation
/// </summary>
public class TestMethodMetadata
{
    public required IMethodSymbol MethodSymbol { get; init; }
    public required INamedTypeSymbol TypeSymbol { get; init; }
    public required MethodDeclarationSyntax MethodSyntax { get; init; }
}

/// <summary>
/// Metadata for a class with [InheritsTests] attribute
/// </summary>
public class InheritsTestsClassMetadata
{
    public required INamedTypeSymbol TypeSymbol { get; init; }
    public required ClassDeclarationSyntax ClassSyntax { get; init; }
}
