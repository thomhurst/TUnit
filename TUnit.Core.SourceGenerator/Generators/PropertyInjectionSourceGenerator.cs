using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using TUnit.Core.SourceGenerator.Extensions;
using TUnit.Core.SourceGenerator.Helpers;

namespace TUnit.Core.SourceGenerator.Generators;

// [Generator] - Temporarily disabled
public sealed class PropertyInjectionSourceGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Find all classes that have properties with data source attributes
        var classesWithPropertyInjection = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: (node, _) => IsClassWithPropertyDataSources(node),
                transform: (ctx, _) => GetClassWithPropertyInjection(ctx))
            .Where(x => x is not null)
            .Select((x, _) => x!);

        // Collect all discovered classes
        var collectedClasses = classesWithPropertyInjection.Collect();

        // Generate IPropertySource implementations
        context.RegisterSourceOutput(collectedClasses, GeneratePropertyInjectionSources);
    }

    private static bool IsClassWithPropertyDataSources(SyntaxNode node)
    {
        if (node is not ClassDeclarationSyntax classDecl)
            return false;

        // Look for properties with potential data source attributes
        return classDecl.Members
            .OfType<PropertyDeclarationSyntax>()
            .Any(prop => prop.AttributeLists
                .SelectMany(al => al.Attributes)
                .Any(attr => attr.Name.ToString().Contains("DataSource") || 
                           attr.Name.ToString().Contains("Arguments")));
    }

    private static PropertyInjectionClassInfo? GetClassWithPropertyInjection(GeneratorSyntaxContext context)
    {
        var classDecl = (ClassDeclarationSyntax)context.Node;
        var semanticModel = context.SemanticModel;
        
        var typeSymbol = semanticModel.GetDeclaredSymbol(classDecl) as INamedTypeSymbol;
        if (typeSymbol == null || typeSymbol.IsAbstract)
            return null;

        // Find properties with data source attributes
        var injectableProperties = new List<PropertyInjectionInfo>();
        
        foreach (var member in typeSymbol.GetMembers())
        {
            if (member is IPropertySymbol property && 
                (property.SetMethod != null || HasBackingField(property)))
            {
                var dataSourceAttr = property.GetAttributes()
                    .FirstOrDefault(a => IsDataSourceAttribute(a.AttributeClass));
                
                if (dataSourceAttr != null)
                {
                    injectableProperties.Add(new PropertyInjectionInfo
                    {
                        Property = property,
                        DataSourceAttribute = dataSourceAttr
                    });
                }
            }
        }

        if (injectableProperties.Count == 0)
            return null;

        return new PropertyInjectionClassInfo
        {
            TypeSymbol = typeSymbol,
            InjectableProperties = injectableProperties.ToImmutableArray()
        };
    }

    private static bool IsDataSourceAttribute(INamedTypeSymbol? attributeType)
    {
        if (attributeType == null)
            return false;

        // Check if it implements IDataSourceAttribute
        return attributeType.AllInterfaces.Any(i => 
            i.ToDisplayString().Contains("TUnit.Core.IDataSourceAttribute"));
    }

    private static bool HasBackingField(IPropertySymbol property)
    {
        // Check for init-only properties that need backing field access
        return property.SetMethod?.IsInitOnly == true;
    }

    private static void GeneratePropertyInjectionSources(SourceProductionContext context, ImmutableArray<PropertyInjectionClassInfo> classes)
    {
        if (classes.IsEmpty)
            return;

        var sourceBuilder = new StringBuilder();
        
        sourceBuilder.AppendLine("// <auto-generated />");
        sourceBuilder.AppendLine("using System;");
        sourceBuilder.AppendLine("using System.Threading.Tasks;");
        sourceBuilder.AppendLine("using TUnit.Core;");
        sourceBuilder.AppendLine("using TUnit.Core.Interfaces.SourceGenerator;");
        sourceBuilder.AppendLine("using TUnit.Core.ReferenceTracking;");
        sourceBuilder.AppendLine();

        foreach (var classInfo in classes)
        {
            GeneratePropertyInjectionSource(sourceBuilder, classInfo);
        }

        // Generate module initializer
        GenerateModuleInitializer(sourceBuilder, classes);

        context.AddSource("PropertyInjectionSources.g.cs", sourceBuilder.ToString());
    }

    private static void GeneratePropertyInjectionSource(StringBuilder sourceBuilder, PropertyInjectionClassInfo classInfo)
    {
        var typeName = classInfo.TypeSymbol.ToDisplayString().Replace(".", "_").Replace("<", "_").Replace(">", "_");
        var sourceClassName = $"{typeName}_PropertyInjectionSource";

        sourceBuilder.AppendLine($"internal sealed class {sourceClassName} : IPropertySource");
        sourceBuilder.AppendLine("{");
        sourceBuilder.AppendLine($"    public Type Type => typeof({classInfo.TypeSymbol.ToDisplayString()});");
        sourceBuilder.AppendLine($"    public string PropertyName => \"{string.Join(", ", classInfo.InjectableProperties.Select(p => p.Property.Name))}\";");
        sourceBuilder.AppendLine("    public bool ShouldInitialize => true;");
        sourceBuilder.AppendLine();

        // Generate UnsafeAccessor methods for init-only properties
        foreach (var propInfo in classInfo.InjectableProperties.Where(p => p.Property.SetMethod?.IsInitOnly == true))
        {
            var propertyType = propInfo.Property.Type.ToDisplayString();
            var backingFieldName = $"<{propInfo.Property.Name}>k__BackingField";
            
            sourceBuilder.AppendLine("#if NET8_0_OR_GREATER");
            sourceBuilder.AppendLine($"    [System.Runtime.CompilerServices.UnsafeAccessor(System.Runtime.CompilerServices.UnsafeAccessorKind.Field, Name = \"{backingFieldName}\")]");
            sourceBuilder.AppendLine($"    private static extern ref {propertyType} Get{propInfo.Property.Name}BackingField({classInfo.TypeSymbol.ToDisplayString()} instance);");
            sourceBuilder.AppendLine("#endif");
            sourceBuilder.AppendLine();
        }

        // Generate InitializeAsync method
        sourceBuilder.AppendLine("    public async Task InitializeAsync(object instance)");
        sourceBuilder.AppendLine("    {");
        sourceBuilder.AppendLine($"        var typedInstance = ({classInfo.TypeSymbol.ToDisplayString()})instance;");
        sourceBuilder.AppendLine("        var testContext = TestContext.Current;");
        sourceBuilder.AppendLine("        if (testContext == null) return;");
        sourceBuilder.AppendLine();

        sourceBuilder.AppendLine("        var dataGeneratorMetadata = new DataGeneratorMetadata");
        sourceBuilder.AppendLine("        {");
        sourceBuilder.AppendLine("            TestBuilderContext = new TestBuilderContextAccessor(TestBuilderContext.Current ?? new TestBuilderContext()),");
        sourceBuilder.AppendLine("            MembersToGenerate = Array.Empty<MemberMetadata>(),");
        sourceBuilder.AppendLine("            TestInformation = testContext.TestDetails.MethodMetadata,");
        sourceBuilder.AppendLine("            Type = DataGeneratorType.Property,");
        sourceBuilder.AppendLine("            TestSessionId = testContext.TestDetails.TestId,");
        sourceBuilder.AppendLine("            TestClassInstance = instance,");
        sourceBuilder.AppendLine("            ClassInstanceArguments = testContext.TestDetails.TestClassArguments");
        sourceBuilder.AppendLine("        };");
        sourceBuilder.AppendLine();

        // Generate property injection code for each property
        foreach (var propInfo in classInfo.InjectableProperties)
        {
            GeneratePropertyInjection(sourceBuilder, propInfo, classInfo.TypeSymbol);
        }

        sourceBuilder.AppendLine("    }");
        sourceBuilder.AppendLine("}");
        sourceBuilder.AppendLine();
    }

    private static void GeneratePropertyInjection(StringBuilder sourceBuilder, PropertyInjectionInfo propInfo, INamedTypeSymbol classType)
    {
        var propertyName = propInfo.Property.Name;
        var propertyType = propInfo.Property.Type.ToDisplayString();
        var attributeType = propInfo.DataSourceAttribute.AttributeClass!.ToDisplayString();

        sourceBuilder.AppendLine($"        // Inject {propertyName} property");
        sourceBuilder.AppendLine("        {");
        
        // Create attribute instance
        var constructorArgs = string.Join(", ", propInfo.DataSourceAttribute.ConstructorArguments.Select(arg => 
            FormatTypedConstant(arg)));
        
        sourceBuilder.AppendLine($"            var dataSource = new {attributeType}({constructorArgs});");
        sourceBuilder.AppendLine("            var dataRows = dataSource.GetDataRowsAsync(dataGeneratorMetadata);");
        sourceBuilder.AppendLine();
        sourceBuilder.AppendLine("            await foreach (var factory in dataRows)");
        sourceBuilder.AppendLine("            {");
        sourceBuilder.AppendLine("                var args = await factory();");
        sourceBuilder.AppendLine("                var value = args?.FirstOrDefault();");
        sourceBuilder.AppendLine();
        sourceBuilder.AppendLine("                // Resolve Func<T> values to their actual values");
        sourceBuilder.AppendLine("                value = await ResolveTestDataValueAsync(value);");
        sourceBuilder.AppendLine();
        sourceBuilder.AppendLine($"                if (value is {propertyType} typedValue)");
        sourceBuilder.AppendLine("                {");
        
        // Set property value
        if (propInfo.Property.SetMethod?.IsInitOnly == true)
        {
            sourceBuilder.AppendLine("#if NET8_0_OR_GREATER");
            sourceBuilder.AppendLine($"                    Get{propertyName}BackingField(typedInstance) = typedValue;");
            sourceBuilder.AppendLine("#else");
            sourceBuilder.AppendLine($"                    // Fallback for init-only property in older .NET versions");
            sourceBuilder.AppendLine($"                    var backingField = typeof({classType.ToDisplayString()}).GetField(\"<{propertyName}>k__BackingField\", System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.NonPublic);");
            sourceBuilder.AppendLine("                    backingField?.SetValue(typedInstance, typedValue);");
            sourceBuilder.AppendLine("#endif");
        }
        else
        {
            sourceBuilder.AppendLine($"                    typedInstance.{propertyName} = typedValue;");
        }

        sourceBuilder.AppendLine();
        sourceBuilder.AppendLine("                    var trackedValue = DataSourceReferenceTrackerProvider.TrackDataSourceObject(typedValue);");
        sourceBuilder.AppendLine($"                    typedInstance.{propertyName} = ({propertyType})trackedValue;");
        sourceBuilder.AppendLine();
        
        // Recursive property injection for complex objects
        if (propInfo.Property.Type.TypeKind == TypeKind.Class && 
            !propInfo.Property.Type.SpecialType.ToString().Contains("String"))
        {
            sourceBuilder.AppendLine("                    // Recursively inject nested properties");
            var nestedTypeName = propInfo.Property.Type.ToDisplayString().Replace(".", "_").Replace("<", "_").Replace(">", "_");
            sourceBuilder.AppendLine($"                    var nestedInjectionSource = Sources.PropertySources.FirstOrDefault(s => s.Type == typeof({propertyType}));");
            sourceBuilder.AppendLine("                    if (nestedInjectionSource != null)");
            sourceBuilder.AppendLine("                    {");
            sourceBuilder.AppendLine("                        await nestedInjectionSource.InitializeAsync(typedValue);");
            sourceBuilder.AppendLine("                    }");
        }

        sourceBuilder.AppendLine();
        sourceBuilder.AppendLine("                    break;");
        sourceBuilder.AppendLine("                }");
        sourceBuilder.AppendLine("            }");
        sourceBuilder.AppendLine("        }");
        sourceBuilder.AppendLine();
    }

    private static void GenerateModuleInitializer(StringBuilder sourceBuilder, ImmutableArray<PropertyInjectionClassInfo> classes)
    {
        sourceBuilder.AppendLine("// Module initializer to register property injection sources");
        sourceBuilder.AppendLine("[System.Runtime.CompilerServices.ModuleInitializer]");
        sourceBuilder.AppendLine("public static void InitializePropertyInjectionSources()");
        sourceBuilder.AppendLine("{");
        
        foreach (var classInfo in classes)
        {
            var typeName = classInfo.TypeSymbol.ToDisplayString().Replace(".", "_").Replace("<", "_").Replace(">", "_");
            var sourceClassName = $"{typeName}_PropertyInjectionSource";
            sourceBuilder.AppendLine($"    SourceRegistrar.RegisterProperty(new {sourceClassName}());");
        }
        
        sourceBuilder.AppendLine("}");
        sourceBuilder.AppendLine();
        
        // Add the Func<T> resolver method
        GenerateResolverMethod(sourceBuilder);
    }

    private static void GenerateResolverMethod(StringBuilder sourceBuilder)
    {
        sourceBuilder.AppendLine("// Helper method to resolve Func<T> values");
        sourceBuilder.AppendLine("private static async Task<object?> ResolveTestDataValueAsync(object? value)");
        sourceBuilder.AppendLine("{");
        sourceBuilder.AppendLine("    if (value == null) return null;");
        sourceBuilder.AppendLine();
        sourceBuilder.AppendLine("    var type = value.GetType();");
        sourceBuilder.AppendLine();
        sourceBuilder.AppendLine("    // Check if it's a Func<T>");
        sourceBuilder.AppendLine("    if (type.IsGenericType && type.GetGenericTypeDefinition() == typeof(Func<>))");
        sourceBuilder.AppendLine("    {");
        sourceBuilder.AppendLine("        var invokeMethod = type.GetMethod(\"Invoke\");");
        sourceBuilder.AppendLine("        var result = invokeMethod!.Invoke(value, null);");
        sourceBuilder.AppendLine("        return result;");
        sourceBuilder.AppendLine("    }");
        sourceBuilder.AppendLine();
        sourceBuilder.AppendLine("    return value;");
        sourceBuilder.AppendLine("}");
    }

    private static string FormatTypedConstant(TypedConstant constant)
    {
        switch (constant.Kind)
        {
            case TypedConstantKind.Primitive:
                if (constant.Value is string str)
                    return $"\"{str}\"";
                return constant.Value?.ToString() ?? "null";

            case TypedConstantKind.Enum:
                return constant.Value?.ToString() ?? "null";

            case TypedConstantKind.Type:
                return $"typeof({constant.Value})";

            case TypedConstantKind.Array:
                var elements = constant.Values.Select(FormatTypedConstant);
                return $"new object[] {{ {string.Join(", ", elements)} }}";

            default:
                return constant.Value?.ToString() ?? "null";
        }
    }
}

// Supporting classes
internal sealed class PropertyInjectionClassInfo
{
    public required INamedTypeSymbol TypeSymbol { get; init; }
    public required ImmutableArray<PropertyInjectionInfo> InjectableProperties { get; init; }
}

internal sealed class PropertyInjectionInfo
{
    public required IPropertySymbol Property { get; init; }
    public required AttributeData DataSourceAttribute { get; init; }
}