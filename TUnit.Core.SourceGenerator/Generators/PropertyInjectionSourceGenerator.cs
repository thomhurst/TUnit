using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using TUnit.Core.SourceGenerator.Extensions;
using TUnit.Core.SourceGenerator.Helpers;

namespace TUnit.Core.SourceGenerator.Generators;

[Generator]
public sealed class PropertyInjectionSourceGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var classesWithPropertyInjection = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: (node, _) => IsClassWithDataSourceProperties(node),
                transform: (ctx, _) => GetClassWithDataSourceProperties(ctx))
            .Where(x => x != null)
            .Select((x, _) => x!);

        var collectedClasses = classesWithPropertyInjection.Collect();

        context.RegisterSourceOutput(collectedClasses, GeneratePropertyInjectionSources);
    }

    private static bool IsClassWithDataSourceProperties(SyntaxNode node)
    {
        if (node is not TypeDeclarationSyntax typeDecl)
        {
            return false;
        }

        return typeDecl.Members
            .OfType<PropertyDeclarationSyntax>()
            .Any(prop => prop.AttributeLists.Count > 0);
    }

    private static ClassWithDataSourceProperties? GetClassWithDataSourceProperties(GeneratorSyntaxContext context)
    {
        var typeDecl = (TypeDeclarationSyntax)context.Node;
        var semanticModel = context.SemanticModel;

        var typeSymbol = semanticModel.GetDeclaredSymbol(typeDecl) as INamedTypeSymbol;
        if (typeSymbol == null || typeSymbol.IsAbstract)
        {
            return null;
        }

        var propertiesWithDataSources = new List<PropertyWithDataSourceAttribute>();
        var dataSourceInterface = semanticModel.Compilation.GetTypeByMetadataName("TUnit.Core.IDataSourceAttribute");

        if (dataSourceInterface == null)
        {
            return null;
        }

        var currentType = typeSymbol;
        var processedProperties = new HashSet<string>();

        while (currentType != null)
        {
            foreach (var member in currentType.GetMembers())
            {
                if (member is IPropertySymbol property && CanSetProperty(property))
                {
                    if (!processedProperties.Add(property.Name))
                    {
                        continue;
                    }

                    foreach (var attr in property.GetAttributes())
                    {
                        if (attr.AttributeClass != null &&
                            (attr.AttributeClass.IsOrInherits(dataSourceInterface) ||
                             attr.AttributeClass.AllInterfaces.Contains(dataSourceInterface, SymbolEqualityComparer.Default)))
                        {
                            propertiesWithDataSources.Add(new PropertyWithDataSourceAttribute
                            {
                                Property = property,
                                DataSourceAttribute = attr
                            });
                            break; // Only one data source per property
                        }
                    }
                }
            }

            currentType = currentType.BaseType;

            if (currentType?.SpecialType == SpecialType.System_Object)
            {
                break;
            }
        }

        if (propertiesWithDataSources.Count == 0)
        {
            return null;
        }

        return new ClassWithDataSourceProperties
        {
            ClassSymbol = typeSymbol,
            Properties = propertiesWithDataSources.ToImmutableArray()
        };
    }

    private static bool CanSetProperty(IPropertySymbol property)
    {
        return property.SetMethod != null || property.SetMethod?.IsInitOnly == true;
    }

    private static void GeneratePropertyInjectionSources(SourceProductionContext context, ImmutableArray<ClassWithDataSourceProperties> classes)
    {
        if (classes.IsEmpty)
        {
            return;
        }

        var sourceBuilder = new StringBuilder();

        WriteFileHeader(sourceBuilder);

        GenerateModuleInitializer(sourceBuilder, classes);

        foreach (var classInfo in classes)
        {
            GeneratePropertySource(sourceBuilder, classInfo);
        }


        context.AddSource("PropertyInjectionSources.g.cs", sourceBuilder.ToString());
    }

    private static void WriteFileHeader(StringBuilder sb)
    {
        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("using System.Threading.Tasks;");
        sb.AppendLine("using TUnit.Core;");
        sb.AppendLine("using TUnit.Core.Interfaces.SourceGenerator;");
        sb.AppendLine("using TUnit.Core.Tracking;");
        sb.AppendLine("using TUnit.Core.Enums;");
        sb.AppendLine("using System.Linq;");
        sb.AppendLine();
        sb.AppendLine("namespace TUnit.Core;");
        sb.AppendLine();
    }

    private static void GenerateModuleInitializer(StringBuilder sb, ImmutableArray<ClassWithDataSourceProperties> classes)
    {
        sb.AppendLine("internal static class PropertyInjectionInitializer");
        sb.AppendLine("{");
        sb.AppendLine("    // Module initializer to register property injection sources");
        sb.AppendLine("    [System.Runtime.CompilerServices.ModuleInitializer]");
        sb.AppendLine("    public static void InitializePropertyInjectionSources()");
        sb.AppendLine("    {");

        foreach (var classInfo in classes)
        {
            var sourceClassName = GetPropertySourceClassName(classInfo.ClassSymbol);
            sb.AppendLine($"        PropertySourceRegistry.Register(typeof({classInfo.ClassSymbol.ToDisplayString()}), new {sourceClassName}());");
        }

        sb.AppendLine("    }");
        sb.AppendLine();

        GenerateHelperMethods(sb);
        sb.AppendLine("}");
        sb.AppendLine();
    }

    private static void GeneratePropertySource(StringBuilder sb, ClassWithDataSourceProperties classInfo)
    {
        var sourceClassName = GetPropertySourceClassName(classInfo.ClassSymbol);
        var classTypeName = classInfo.ClassSymbol.ToDisplayString();

        sb.AppendLine($"internal sealed class {sourceClassName} : IPropertySource");
        sb.AppendLine("{");
        sb.AppendLine($"    public Type Type => typeof({classTypeName});");
        sb.AppendLine($"    public string PropertyName => \"{string.Join(", ", classInfo.Properties.Select(p => p.Property.Name))}\";");
        sb.AppendLine("    public bool ShouldInitialize => true;");
        sb.AppendLine();

        GenerateUnsafeAccessorMethods(sb, classInfo);

        GenerateInjectAsync(sb, classInfo, classTypeName);

        sb.AppendLine("}");
        sb.AppendLine();
    }

    private static void GenerateUnsafeAccessorMethods(StringBuilder sb, ClassWithDataSourceProperties classInfo)
    {
        foreach (var propInfo in classInfo.Properties)
        {
            if (propInfo.Property.SetMethod?.IsInitOnly == true)
            {
                var propertyType = propInfo.Property.Type.ToDisplayString();
                var backingFieldName = $"<{propInfo.Property.Name}>k__BackingField";

                sb.AppendLine("#if NET8_0_OR_GREATER");
                sb.AppendLine($"    [System.Runtime.CompilerServices.UnsafeAccessor(System.Runtime.CompilerServices.UnsafeAccessorKind.Field, Name = \"{backingFieldName}\")]");
                sb.AppendLine($"    private static extern ref {propertyType} Get{propInfo.Property.Name}BackingField({classInfo.ClassSymbol.ToDisplayString()} instance);");
                sb.AppendLine("#endif");
                sb.AppendLine();
            }
        }
    }

    private static void GenerateInjectAsync(StringBuilder sb, ClassWithDataSourceProperties classInfo, string classTypeName)
    {
        sb.AppendLine("    public async Task<Dictionary<string, object?>> InjectAsync(object instance)");
        sb.AppendLine("    {");
        sb.AppendLine($"        var typedInstance = ({classTypeName})instance;");
        sb.AppendLine("        var testContext = TestContext.Current;");
        sb.AppendLine("        if (testContext == null) return new Dictionary<string, object?>();");
        sb.AppendLine();
        sb.AppendLine("        var results = new Dictionary<string, object?>();");
        sb.AppendLine();

        sb.AppendLine("        var dataGeneratorMetadata = new DataGeneratorMetadata");
        sb.AppendLine("        {");
        sb.AppendLine("            TestBuilderContext = new TestBuilderContextAccessor(TestBuilderContext.Current ?? new TestBuilderContext()),");
        sb.AppendLine("            MembersToGenerate = Array.Empty<MemberMetadata>(),");
        sb.AppendLine("            TestInformation = testContext.TestDetails.MethodMetadata,");
        sb.AppendLine("            Type = DataGeneratorType.Property,");
        sb.AppendLine("            TestSessionId = testContext.TestDetails.TestId,");
        sb.AppendLine("            TestClassInstance = instance,");
        sb.AppendLine("            ClassInstanceArguments = testContext.TestDetails.TestClassArguments");
        sb.AppendLine("        };");
        sb.AppendLine();

        foreach (var propInfo in classInfo.Properties)
        {
            GeneratePropertyInjectionCode(sb, propInfo, classInfo.ClassSymbol);
        }

        sb.AppendLine("        return results;");
        sb.AppendLine("    }");
    }

    private static void GeneratePropertyInjectionCode(StringBuilder sb, PropertyWithDataSourceAttribute propInfo, INamedTypeSymbol classSymbol)
    {
        var propertyName = propInfo.Property.Name;
        var propertyType = propInfo.Property.Type.ToDisplayString();
        var attributeTypeName = propInfo.DataSourceAttribute.AttributeClass!.ToDisplayString();

        sb.AppendLine($"        // Inject {propertyName} property");
        sb.AppendLine("        {");

        GenerateAttributeInstantiation(sb, propInfo.DataSourceAttribute, attributeTypeName);

        sb.AppendLine("            var dataRows = dataSource.GetDataRowsAsync(dataGeneratorMetadata);");
        sb.AppendLine();
        sb.AppendLine("            await foreach (var factory in dataRows)");
        sb.AppendLine("            {");
        sb.AppendLine("                var args = await factory();");
        sb.AppendLine("                var value = args?.FirstOrDefault();");
        sb.AppendLine();
        sb.AppendLine("                value = await PropertyInjectionInitializer.ResolveTestDataValueAsync(value);");
        sb.AppendLine();
        sb.AppendLine($"                if (value != null)");
        sb.AppendLine("                {");

        if (propInfo.Property.IsStatic)
        {
            GenerateStaticPropertySetting(sb, propInfo, propertyType);
        }
        else
        {
            GeneratePropertySetting(sb, propInfo, propertyType);
        }

        if (propInfo.Property.IsStatic)
        {
        }
        else
        {
            sb.AppendLine($"                    results[\"{propertyName}\"] = value;");
        }

        sb.AppendLine("                    break;");
        sb.AppendLine("                }");
        sb.AppendLine("            }");
        sb.AppendLine("        }");
        sb.AppendLine();
    }

    private static void GenerateAttributeInstantiation(StringBuilder sb, AttributeData attributeData, string attributeTypeName)
    {
        var constructorArgs = string.Join(", ", attributeData.ConstructorArguments.Select(FormatTypedConstant));

        sb.AppendLine($"            var dataSource = new {attributeTypeName}({constructorArgs});");

        foreach (var namedArg in attributeData.NamedArguments)
        {
            var value = FormatTypedConstant(namedArg.Value);
            sb.AppendLine($"            dataSource.{namedArg.Key} = {value};");
        }
    }

    private static void GeneratePropertySetting(StringBuilder sb, PropertyWithDataSourceAttribute propInfo, string propertyType)
    {
        if (propInfo.Property.SetMethod?.IsInitOnly == true)
        {
            sb.AppendLine("#if NET8_0_OR_GREATER");
            sb.AppendLine($"                    Get{propInfo.Property.Name}BackingField(typedInstance) = ({propertyType})value;");
            sb.AppendLine("#else");
            sb.AppendLine($"                    // Fallback for init-only properties in older .NET");
            sb.AppendLine($"                    var backingField = typeof({propInfo.Property.ContainingType.ToDisplayString()}).GetField(\"<{propInfo.Property.Name}>k__BackingField\",");
            sb.AppendLine("                        System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.NonPublic);");
            sb.AppendLine("                    backingField?.SetValue(typedInstance, value);");
            sb.AppendLine("#endif");
        }
        else
        {
            sb.AppendLine($"                    typedInstance.{propInfo.Property.Name} = ({propertyType})value;");
        }
    }

    private static void GenerateStaticPropertySetting(StringBuilder sb, PropertyWithDataSourceAttribute propInfo, string propertyType)
    {
        var className = propInfo.Property.ContainingType.ToDisplayString();
        sb.AppendLine($"                    {className}.{propInfo.Property.Name} = ({propertyType})value;");
    }

    private static void GenerateHelperMethods(StringBuilder sb)
    {
        sb.AppendLine("    // Helper method to resolve Func<T> values");
        sb.AppendLine("    public static async Task<object?> ResolveTestDataValueAsync(object? value)");
        sb.AppendLine("    {");
        sb.AppendLine("        if (value == null) return null;");
        sb.AppendLine();
        sb.AppendLine("        var type = value.GetType();");
        sb.AppendLine();
        sb.AppendLine("        // Check if it's a Func<T>");
        sb.AppendLine("        if (type.IsGenericType && type.GetGenericTypeDefinition() == typeof(Func<>))");
        sb.AppendLine("        {");
        sb.AppendLine("            var invokeMethod = type.GetMethod(\"Invoke\");");
        sb.AppendLine("            var result = invokeMethod!.Invoke(value, null);");
        sb.AppendLine("            return result;");
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine("        return value;");
        sb.AppendLine("    }");
    }

    private static string GetPropertySourceClassName(INamedTypeSymbol classSymbol)
    {
        var typeName = classSymbol.ToDisplayString().Replace(".", "_").Replace("<", "_").Replace(">", "_").Replace("+", "_");
        var hash = Math.Abs(typeName.GetHashCode()).ToString("x8");
        return $"{typeName}_PropertyInjectionSource_{hash}";
    }

    private static string FormatTypedConstant(TypedConstant constant)
    {
        return constant.Kind switch
        {
            TypedConstantKind.Primitive when constant.Value is string str => $"\"{str}\"",
            TypedConstantKind.Primitive => constant.Value?.ToString() ?? "null",
            TypedConstantKind.Enum => FormatEnumConstant(constant),
            TypedConstantKind.Type => FormatTypeConstant(constant),
            TypedConstantKind.Array => $"new object[] {{ {string.Join(", ", constant.Values.Select(FormatTypedConstant))} }}",
            _ => constant.Value?.ToString() ?? "null"
        };
    }

    private static string FormatEnumConstant(TypedConstant constant)
    {
        if (constant.Type != null && constant.Value != null)
        {
            var enumTypeName = constant.Type.ToDisplayString();
            return $"({enumTypeName}){constant.Value}";
        }
        return constant.Value?.ToString() ?? "null";
    }

    private static string FormatTypeConstant(TypedConstant constant)
    {
        if (constant.Value is ITypeSymbol typeSymbol)
        {
            var displayString = GetNonNullableTypeString(typeSymbol);
            return $"typeof({displayString})";
        }

        return $"typeof({constant.Value})";
    }

    private static string GetNonNullableTypeString(ITypeSymbol typeSymbol)
    {
        if (typeSymbol.NullableAnnotation == NullableAnnotation.Annotated)
        {
            if (typeSymbol is INamedTypeSymbol { IsReferenceType: true })
            {
                return typeSymbol.WithNullableAnnotation(NullableAnnotation.NotAnnotated).ToDisplayString();
            }
        }

        if (typeSymbol is INamedTypeSymbol namedType &&
            namedType.IsGenericType &&
            namedType.ConstructedFrom.SpecialType == SpecialType.System_Nullable_T)
        {
            return namedType.TypeArguments[0].ToDisplayString();
        }

        var displayString = typeSymbol.ToDisplayString();

        if (displayString.EndsWith("?"))
        {
            displayString = displayString.TrimEnd('?');
        }

        return displayString;
    }
}

internal sealed class ClassWithDataSourceProperties
{
    public required INamedTypeSymbol ClassSymbol { get; init; }
    public required ImmutableArray<PropertyWithDataSourceAttribute> Properties { get; init; }
}

internal sealed class PropertyWithDataSourceAttribute
{
    public required IPropertySymbol Property { get; init; }
    public required AttributeData DataSourceAttribute { get; init; }
}
