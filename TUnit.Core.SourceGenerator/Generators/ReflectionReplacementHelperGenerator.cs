using Microsoft.CodeAnalysis;
using TUnit.Core.SourceGenerator.CodeGenerators;

namespace TUnit.Core.SourceGenerator.Generators;

/// <summary>
/// Generates the ReflectionReplacements helper class in TUnit.Core namespace
/// to provide the registration system for AOT-safe replacements
/// </summary>
[Generator]
public sealed class ReflectionReplacementHelperGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var compilationProvider = context.CompilationProvider;
        
        context.RegisterSourceOutput(compilationProvider, GenerateReflectionReplacementHelper);
    }

    private static void GenerateReflectionReplacementHelper(SourceProductionContext context, Compilation compilation)
    {
        var writer = new CodeWriter();

        writer.AppendLine("// <auto-generated/>");
        writer.AppendLine("#pragma warning disable");
        writer.AppendLine("#nullable enable");
        writer.AppendLine();
        writer.AppendLine("using System;");
        writer.AppendLine("using System.Collections.Generic;");
        writer.AppendLine("using System.Threading.Tasks;");
        writer.AppendLine("using TUnit.Core;");
        writer.AppendLine();
        writer.AppendLine("namespace TUnit.Core.Helpers;");
        writer.AppendLine();

        GenerateReflectionReplacementsClass(writer);

        context.AddSource("ReflectionReplacements.g.cs", writer.ToString());
    }

    private static void GenerateReflectionReplacementsClass(CodeWriter writer)
    {
        writer.AppendLine("/// <summary>");
        writer.AppendLine("/// Registry for AOT-safe replacements of reflection-based operations");
        writer.AppendLine("/// </summary>");
        writer.AppendLine("public static class ReflectionReplacements");
        writer.AppendLine("{");
        writer.Indent();

        // Generate delegate types
        GenerateDelegateTypes(writer);

        // Generate static fields for registered replacements
        GenerateReplacementFields(writer);

        // Generate registration methods
        GenerateRegistrationMethods(writer);

        // Generate helper methods to use the replacements
        GenerateHelperMethods(writer);

        writer.Unindent();
        writer.AppendLine("}");
    }

    private static void GenerateDelegateTypes(CodeWriter writer)
    {
        writer.AppendLine("// Delegate types for AOT-safe replacements");
        writer.AppendLine("public delegate Type? TypeResolverDelegate(string assemblyQualifiedName);");
        writer.AppendLine("public delegate Type? GenericTypeFactoryDelegate(Type genericDefinition, Type[] typeArguments);");
        writer.AppendLine("public delegate Task<object?> MethodInvokerDelegate(string methodKey, object? instance, object?[]? parameters);");
        writer.AppendLine("public delegate bool TupleTypeCheckerDelegate(Type type);");
        writer.AppendLine("public delegate object?[]? TupleConverterDelegate(object tuple);");
        writer.AppendLine("public delegate Task PropertyInjectorDelegate<T>(T instance, Dictionary<string, object?> propertyValues, TestContext testContext) where T : notnull;");
        writer.AppendLine();
    }

    private static void GenerateReplacementFields(CodeWriter writer)
    {
        writer.AppendLine("// Static fields to hold the registered replacements");
        writer.AppendLine("private static TypeResolverDelegate? _typeResolver;");
        writer.AppendLine("private static GenericTypeFactoryDelegate? _genericTypeFactory;");
        writer.AppendLine("private static MethodInvokerDelegate? _methodInvoker;");
        writer.AppendLine("private static TupleTypeCheckerDelegate? _tupleTypeChecker;");
        writer.AppendLine("private static TupleConverterDelegate? _tupleConverter;");
        writer.AppendLine("private static object? _propertyInjector;");
        writer.AppendLine();
    }

    private static void GenerateRegistrationMethods(CodeWriter writer)
    {
        writer.AppendLine("// Registration methods called by module initializer");
        
        writer.AppendLine("public static void RegisterTypeResolver(TypeResolverDelegate typeResolver)");
        writer.AppendLine("{");
        writer.Indent();
        writer.AppendLine("_typeResolver = typeResolver;");
        writer.Unindent();
        writer.AppendLine("}");
        writer.AppendLine();

        writer.AppendLine("public static void RegisterGenericTypeFactory(GenericTypeFactoryDelegate genericTypeFactory)");
        writer.AppendLine("{");
        writer.Indent();
        writer.AppendLine("_genericTypeFactory = genericTypeFactory;");
        writer.Unindent();
        writer.AppendLine("}");
        writer.AppendLine();

        writer.AppendLine("public static void RegisterMethodInvoker(MethodInvokerDelegate methodInvoker)");
        writer.AppendLine("{");
        writer.Indent();
        writer.AppendLine("_methodInvoker = methodInvoker;");
        writer.Unindent();
        writer.AppendLine("}");
        writer.AppendLine();

        writer.AppendLine("public static void RegisterTupleTypeChecker(TupleTypeCheckerDelegate tupleTypeChecker)");
        writer.AppendLine("{");
        writer.Indent();
        writer.AppendLine("_tupleTypeChecker = tupleTypeChecker;");
        writer.Unindent();
        writer.AppendLine("}");
        writer.AppendLine();

        writer.AppendLine("public static void RegisterTupleConverter(TupleConverterDelegate tupleConverter)");
        writer.AppendLine("{");
        writer.Indent();
        writer.AppendLine("_tupleConverter = tupleConverter;");
        writer.Unindent();
        writer.AppendLine("}");
        writer.AppendLine();

        writer.AppendLine("public static void RegisterPropertyInjector<T>(PropertyInjectorDelegate<T> propertyInjector) where T : notnull");
        writer.AppendLine("{");
        writer.Indent();
        writer.AppendLine("_propertyInjector = propertyInjector;");
        writer.Unindent();
        writer.AppendLine("}");
        writer.AppendLine();
    }

    private static void GenerateHelperMethods(CodeWriter writer)
    {
        writer.AppendLine("// Helper methods to use registered replacements with fallback to reflection");
        
        writer.AppendLine("public static Type? ResolveType(string assemblyQualifiedName)");
        writer.AppendLine("{");
        writer.Indent();
        writer.AppendLine("if (_typeResolver != null)");
        writer.AppendLine("{");
        writer.Indent();
        writer.AppendLine("var result = _typeResolver(assemblyQualifiedName);");
        writer.AppendLine("if (result != null) return result;");
        writer.Unindent();
        writer.AppendLine("}");
        writer.AppendLine();
        writer.AppendLine("// Fallback to reflection (not AOT-safe)");
        writer.AppendLine("#pragma warning disable IL2057");
        writer.AppendLine("return Type.GetType(assemblyQualifiedName);");
        writer.AppendLine("#pragma warning restore IL2057");
        writer.Unindent();
        writer.AppendLine("}");
        writer.AppendLine();

        writer.AppendLine("public static Type? MakeGenericType(Type genericDefinition, params Type[] typeArguments)");
        writer.AppendLine("{");
        writer.Indent();
        writer.AppendLine("if (_genericTypeFactory != null)");
        writer.AppendLine("{");
        writer.Indent();
        writer.AppendLine("var result = _genericTypeFactory(genericDefinition, typeArguments);");
        writer.AppendLine("if (result != null) return result;");
        writer.Unindent();
        writer.AppendLine("}");
        writer.AppendLine();
        writer.AppendLine("// Fallback to reflection (not AOT-safe)");
        writer.AppendLine("#pragma warning disable IL2055");
        writer.AppendLine("return genericDefinition.MakeGenericType(typeArguments);");
        writer.AppendLine("#pragma warning restore IL2055");
        writer.Unindent();
        writer.AppendLine("}");
        writer.AppendLine();

        writer.AppendLine("public static async Task<object?> InvokeMethodAsync(string methodKey, object? instance, params object?[]? parameters)");
        writer.AppendLine("{");
        writer.Indent();
        writer.AppendLine("if (_methodInvoker != null)");
        writer.AppendLine("{");
        writer.Indent();
        writer.AppendLine("return await _methodInvoker(methodKey, instance, parameters);");
        writer.Unindent();
        writer.AppendLine("}");
        writer.AppendLine();
        writer.AppendLine("throw new NotSupportedException(\"Method invocation not supported in AOT mode without source generation.\");");
        writer.Unindent();
        writer.AppendLine("}");
        writer.AppendLine();

        writer.AppendLine("public static bool IsTupleType(Type type)");
        writer.AppendLine("{");
        writer.Indent();
        writer.AppendLine("if (_tupleTypeChecker != null)");
        writer.AppendLine("{");
        writer.Indent();
        writer.AppendLine("return _tupleTypeChecker(type);");
        writer.Unindent();
        writer.AppendLine("}");
        writer.AppendLine();
        writer.AppendLine("// Fallback to basic tuple type check");
        writer.AppendLine("return type.Name.StartsWith(\"ValueTuple`\") || type.Name.StartsWith(\"Tuple`\");");
        writer.Unindent();
        writer.AppendLine("}");
        writer.AppendLine();

        writer.AppendLine("public static object?[]? ConvertTupleToArray(object tuple)");
        writer.AppendLine("{");
        writer.Indent();
        writer.AppendLine("if (_tupleConverter != null)");
        writer.AppendLine("{");
        writer.Indent();
        writer.AppendLine("return _tupleConverter(tuple);");
        writer.Unindent();
        writer.AppendLine("}");
        writer.AppendLine();
        writer.AppendLine("// Fallback - requires AOT-safe replacement");
        writer.AppendLine("throw new NotSupportedException(\"Tuple conversion requires AOT-safe replacement to be registered.\");");
        writer.Unindent();
        writer.AppendLine("}");
        writer.AppendLine();

        writer.AppendLine("public static bool IsAotMode => _typeResolver != null || _methodInvoker != null || _tupleTypeChecker != null;");
        writer.AppendLine();
    }
}