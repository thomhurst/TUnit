using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using TUnit.Core.SourceGenerator.CodeGenerators;
using TUnit.Core.SourceGenerator.Extensions;

namespace TUnit.Core.SourceGenerator.Generators;

[Generator]
public sealed class DataSourcePropertyInjectionGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Find all data source attribute types that have properties with data source attributes
        var dataSourceTypes = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: (node, _) => IsDataSourceAttributeClass(node),
                transform: (ctx, _) => GetDataSourceTypeWithProperties(ctx))
            .Where(x => x is not null)
            .Select((x, _) => x!);

        // Collect all discovered data source types
        var collectedTypes = dataSourceTypes.Collect();

        // Generate registration code
        context.RegisterSourceOutput(collectedTypes, GenerateRegistrationCode);
    }

    private static bool IsDataSourceAttributeClass(SyntaxNode node)
    {
        // Look for class declarations that might be data source attributes
        if (node is not ClassDeclarationSyntax classDecl)
        {
            return false;
        }

        // Must implement IDataSourceAttribute
        if (classDecl.BaseList == null)
        {
            return false;
        }

        return classDecl.BaseList.Types.Any(t => 
            t.ToString().Contains("IDataSourceAttribute") || 
            t.ToString().Contains("DataSourceAttribute"));
    }

    private static DataSourceTypeInfo? GetDataSourceTypeWithProperties(GeneratorSyntaxContext context)
    {
        var classDecl = (ClassDeclarationSyntax)context.Node;
        var semanticModel = context.SemanticModel;

        if (semanticModel.GetDeclaredSymbol(classDecl) is not INamedTypeSymbol typeSymbol)
        {
            return null;
        }

        // Check if it implements IDataSourceAttribute
        var dataSourceInterface = semanticModel.Compilation.GetTypeByMetadataName("TUnit.Core.IDataSourceAttribute");
        if (dataSourceInterface == null || !typeSymbol.AllInterfaces.Contains(dataSourceInterface))
        {
            return null;
        }

        // Find properties with data source attributes
        var propertiesWithDataSources = new List<PropertyWithDataSourceInfo>();
        
        foreach (var member in typeSymbol.GetMembers())
        {
            if (member is IPropertySymbol { DeclaredAccessibility: Accessibility.Public, IsStatic: false, SetMethod: not null } property)
            {
                var dataSourceAttr = property.GetAttributes()
                    .FirstOrDefault(a => IsDataSourceAttribute(a.AttributeClass));
                
                if (dataSourceAttr != null)
                {
                    propertiesWithDataSources.Add(new PropertyWithDataSourceInfo
                    {
                        Property = property,
                        DataSourceAttribute = dataSourceAttr
                    });
                }
            }
        }

        if (propertiesWithDataSources.Count == 0)
        {
            return null;
        }

        return new DataSourceTypeInfo
        {
            TypeSymbol = typeSymbol,
            PropertiesWithDataSources = propertiesWithDataSources.ToImmutableArray()
        };
    }

    private static void GenerateRegistrationCode(SourceProductionContext context, ImmutableArray<DataSourceTypeInfo> dataSourceTypes)
    {
        if (dataSourceTypes.IsEmpty)
        {
            return;
        }

        var writer = new CodeWriter();
        
        writer.AppendLine("// <auto-generated/>");
        writer.AppendLine("#pragma warning disable");
        writer.AppendLine("#nullable enable");
        writer.AppendLine();
        // No using statements - use globally qualified types
        writer.AppendLine();
        writer.AppendLine("namespace TUnit.Generated;");
        writer.AppendLine();
        writer.AppendLine("internal static class DataSourcePropertyInjectionRegistration");
        writer.AppendLine("{");
        writer.Indent();
        
        writer.AppendLine("[global::System.Runtime.CompilerServices.ModuleInitializer]");
        writer.AppendLine("public static void Register()");
        writer.AppendLine("{");
        writer.Indent();

        foreach (var dataSourceType in dataSourceTypes)
        {
            GenerateRegistrationForType(writer, dataSourceType);
        }

        writer.Unindent();
        writer.AppendLine("}");
        
        // Generate helper methods for each data source type
        foreach (var dataSourceType in dataSourceTypes)
        {
            GeneratePropertySettersForType(writer, dataSourceType);
        }
        
        writer.Unindent();
        writer.AppendLine("}");

        context.AddSource("DataSourcePropertyInjectionRegistration.g.cs", writer.ToString());
    }

    private static void GenerateRegistrationForType(CodeWriter writer, DataSourceTypeInfo dataSourceType)
    {
        var typeName = dataSourceType.TypeSymbol.GloballyQualified();
        var safeTypeName = GetSafeTypeName(dataSourceType.TypeSymbol);
        
        writer.AppendLine($"// Registration for {typeName}");
        writer.AppendLine("{");
        writer.Indent();
        
        // Generate property data sources array
        writer.AppendLine("var propertyDataSources = new global::TUnit.Core.PropertyDataSource[]");
        writer.AppendLine("{");
        writer.Indent();
        
        foreach (var propInfo in dataSourceType.PropertiesWithDataSources)
        {
            writer.AppendLine("new global::TUnit.Core.PropertyDataSource");
            writer.AppendLine("{");
            writer.Indent();
            writer.AppendLine($"PropertyName = \"{propInfo.Property.Name}\",");
            writer.AppendLine($"PropertyType = typeof({propInfo.Property.Type.GloballyQualified()}),");
            
            // Generate the data source attribute instantiation
            writer.Append("DataSource = ");
            GenerateAttributeInstantiation(writer, propInfo.DataSourceAttribute);
            
            writer.Unindent();
            writer.AppendLine("},");
        }
        
        writer.Unindent();
        writer.AppendLine("};");
        writer.AppendLine();
        
        // Generate property injection data array
        writer.AppendLine("var injectionData = new global::TUnit.Core.PropertyInjectionData[]");
        writer.AppendLine("{");
        writer.Indent();
        
        foreach (var propInfo in dataSourceType.PropertiesWithDataSources)
        {
            var property = propInfo.Property;
            writer.AppendLine("new global::TUnit.Core.PropertyInjectionData");
            writer.AppendLine("{");
            writer.Indent();
            writer.AppendLine($"PropertyName = \"{property.Name}\",");
            writer.AppendLine($"PropertyType = typeof({property.Type.GloballyQualified()}),");
            
            // Generate setter
            if (property.SetMethod.IsInitOnly)
            {
                writer.AppendLine("#if NET8_0_OR_GREATER");
                writer.AppendLine($"Setter = (instance, value) => {safeTypeName}_Set{property.Name}(({typeName})instance, value),");
                writer.AppendLine("#else");
                writer.AppendLine("Setter = (instance, value) => throw new global::System.NotSupportedException(\"Setting init-only properties requires .NET 8 or later\"),");
                writer.AppendLine("#endif");
            }
            else
            {
                writer.AppendLine($"Setter = (instance, value) => (({typeName})instance).{property.Name} = ({property.Type.GloballyQualified()})value,");
            }
            
            writer.AppendLine("ValueFactory = () => throw new global::System.InvalidOperationException(\"Should not be called\"),");
            writer.AppendLine("NestedPropertyInjections = global::System.Array.Empty<global::TUnit.Core.PropertyInjectionData>(),");
            writer.AppendLine("NestedPropertyValueFactory = obj => new global::System.Collections.Generic.Dictionary<string, object?>()");
            
            writer.Unindent();
            writer.AppendLine("},");
        }
        
        writer.Unindent();
        writer.AppendLine("};");
        writer.AppendLine();
        
        writer.AppendLine($"global::TUnit.Core.DataSourcePropertyInjectionRegistry.Register(typeof({typeName}), injectionData, propertyDataSources);");
        
        writer.Unindent();
        writer.AppendLine("}");
        writer.AppendLine();
    }

    private static void GeneratePropertySettersForType(CodeWriter writer, DataSourceTypeInfo dataSourceType)
    {
        var typeName = dataSourceType.TypeSymbol.GloballyQualified();
        var safeTypeName = GetSafeTypeName(dataSourceType.TypeSymbol);
        
        // Generate UnsafeAccessor methods for init-only properties
        writer.AppendLine("#if NET8_0_OR_GREATER");
        
        foreach (var propInfo in dataSourceType.PropertiesWithDataSources)
        {
            var property = propInfo.Property;
            if (property.SetMethod.IsInitOnly)
            {
                var propertyType = property.Type.GloballyQualified();
                
                writer.AppendLine($"[global::System.Runtime.CompilerServices.UnsafeAccessor(global::System.Runtime.CompilerServices.UnsafeAccessorKind.Field, Name = \"<{property.Name}>k__BackingField\")]");
                writer.AppendLine($"private static extern ref {propertyType} {safeTypeName}_Get{property.Name}BackingField({typeName} instance);");
                writer.AppendLine();
                writer.AppendLine($"private static void {safeTypeName}_Set{property.Name}({typeName} instance, object? value)");
                writer.AppendLine("{");
                writer.Indent();
                writer.AppendLine($"{safeTypeName}_Get{property.Name}BackingField(instance) = ({propertyType})value!;");
                writer.Unindent();
                writer.AppendLine("}");
                writer.AppendLine();
            }
        }
        
        writer.AppendLine("#endif");
        writer.AppendLine();
    }

    private static string GetSafeTypeName(ITypeSymbol typeSymbol)
    {
        return typeSymbol.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat)
            .Replace(".", "_")
            .Replace("<", "_")
            .Replace(">", "_")
            .Replace(",", "_")
            .Replace(" ", "");
    }

    private sealed class DataSourceTypeInfo
    {
        public required INamedTypeSymbol TypeSymbol { get; init; }
        public required ImmutableArray<PropertyWithDataSourceInfo> PropertiesWithDataSources { get; init; }
    }

    private sealed class PropertyWithDataSourceInfo
    {
        public required IPropertySymbol Property { get; init; }
        public required AttributeData DataSourceAttribute { get; init; }
    }

    private static bool IsDataSourceAttribute(INamedTypeSymbol? attributeClass)
    {
        if (attributeClass == null)
        {
            return false;
        }

        // Check if it implements IDataSourceAttribute interface
        return attributeClass.AllInterfaces.Any(i => 
            i.Name == "IDataSourceAttribute" && 
            i.ContainingNamespace?.ToDisplayString() == "TUnit.Core");
    }

    private static void GenerateAttributeInstantiation(CodeWriter writer, AttributeData attribute)
    {
        var attributeClass = attribute.AttributeClass;
        if (attributeClass == null)
        {
            writer.Append("null");
            return;
        }

        writer.Append($"new {attributeClass.GloballyQualified()}(");

        // Add constructor arguments
        var constructorArgs = attribute.ConstructorArguments;
        for (int i = 0; i < constructorArgs.Length; i++)
        {
            if (i > 0)
            {
                writer.Append(", ");
            }
            WriteArgumentValue(writer, constructorArgs[i]);
        }

        writer.Append(")");

        // Add named arguments
        var namedArgs = attribute.NamedArguments;
        if (namedArgs.Length > 0)
        {
            writer.Append(" { ");
            for (int i = 0; i < namedArgs.Length; i++)
            {
                if (i > 0)
                {
                    writer.Append(", ");
                }
                writer.Append($"{namedArgs[i].Key} = ");
                WriteArgumentValue(writer, namedArgs[i].Value);
            }
            writer.Append(" }");
        }

        writer.AppendLine();
    }

    private static void WriteArgumentValue(CodeWriter writer, TypedConstant value)
    {
        switch (value.Kind)
        {
            case TypedConstantKind.Primitive:
                if (value.Value == null)
                {
                    writer.Append("null");
                }
                else if (value.Type?.SpecialType == SpecialType.System_String)
                {
                    writer.Append($"\"{value.Value}\"");
                }
                else if (value.Type?.SpecialType == SpecialType.System_Boolean)
                {
                    writer.Append(value.Value.ToString()?.ToLowerInvariant() ?? "false");
                }
                else
                {
                    writer.Append(value.Value.ToString() ?? "null");
                }
                break;
            case TypedConstantKind.Type:
                writer.Append($"typeof({((ITypeSymbol)value.Value!).GloballyQualified()})");
                break;
            case TypedConstantKind.Array:
                writer.Append("new[] { ");
                for (int i = 0; i < value.Values.Length; i++)
                {
                    if (i > 0)
                    {
                        writer.Append(", ");
                    }
                    WriteArgumentValue(writer, value.Values[i]);
                }
                writer.Append(" }");
                break;
            default:
                writer.Append("null");
                break;
        }
    }
}