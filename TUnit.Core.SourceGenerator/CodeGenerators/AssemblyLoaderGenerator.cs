using System.Collections.Immutable;
using Microsoft.CodeAnalysis;
using TUnit.Core.SourceGenerator.CodeGenerators.Equality;

namespace TUnit.Core.SourceGenerator.CodeGenerators;

[Generator]
public class AssemblyLoaderGenerator : IIncrementalGenerator
{
    private static readonly string[] _excludedAssemblies =
    [
        "b77a5c561934e089",
        "b03f5f7f11d50a3a",
        "31bf3856ad364e35",
        "cc7b13ffcd2ddd51",
        "7cec85d7bea7798e",
        
    ];
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var provider = context.CompilationProvider
            .WithComparer(new PreventCompilationTriggerOnEveryKeystrokeComparer());
        
        context.RegisterSourceOutput(provider, (sourceProductionContext, source) => GenerateCode(sourceProductionContext, source));
    }

    private void GenerateCode(SourceProductionContext context, Compilation compilation)
    {
        var assemblyReferences = compilation.References
            .Where(x => x.Properties.Kind == MetadataImageKind.Assembly)
            .Where(x => !string.IsNullOrEmpty(x.Display));

        var assemblySymbols = assemblyReferences
            .Select(compilation.GetAssemblyOrModuleSymbol)
            .OfType<IAssemblySymbol>()
            .Distinct(SymbolEqualityComparer.Default)
            .OfType<IAssemblySymbol>()
            .ToArray();
        
        var sourceBuilder = new SourceCodeWriter();

        sourceBuilder.WriteLine("// <auto-generated/>");
        sourceBuilder.WriteLine("#pragma warning disable");

        sourceBuilder.WriteLine("file static class AssemblyLoader" + Guid.NewGuid().ToString("N"));
        sourceBuilder.WriteLine("{");
        sourceBuilder.WriteLine("[global::System.Runtime.CompilerServices.ModuleInitializer]");
        sourceBuilder.WriteLine("public static void Initialize()");
        sourceBuilder.WriteLine("{");

        var visitedAssemblies = new HashSet<IAssemblySymbol>(SymbolEqualityComparer.Default);
        foreach (var assembly in assemblySymbols)
        {
            WriteAssemblyLoad(sourceBuilder, assembly, visitedAssemblies);
        }

        sourceBuilder.WriteLine("}");
        sourceBuilder.WriteLine("}");

        context.AddSource("AssemblyLoader.g.cs", sourceBuilder.ToString());
    }

    private static void WriteAssemblyLoad(SourceCodeWriter sourceBuilder, IAssemblySymbol assembly, HashSet<IAssemblySymbol> visitedAssemblies)
    {
        if (!visitedAssemblies.Add(assembly) || IsSystemAssembly(assembly))
        {
            return;
        }
        
        sourceBuilder.WriteLine($"global::TUnit.Core.SourceRegistrar.RegisterAssembly(() => global::System.Reflection.Assembly.Load(\"{GetAssemblyFullName(assembly)}\"));");

        foreach (var innerAssembly in assembly.Modules.SelectMany(x => x.ReferencedAssemblySymbols))
        {
            WriteAssemblyLoad(sourceBuilder, innerAssembly, visitedAssemblies);
        }
    }
    
    private static bool IsSystemAssembly(IAssemblySymbol assemblySymbol)
    {
        if (assemblySymbol.Identity.PublicKeyToken.IsDefaultOrEmpty)
        {
            return false;
        }
        
        var stringPublicTokenKey = BitConverter.ToString(assemblySymbol.Identity.PublicKeyToken.ToArray())
            .Replace("-", "")
            .ToLowerInvariant();
      
        return _excludedAssemblies.Contains(stringPublicTokenKey);
    }
    
    private static string GetAssemblyFullName(IAssemblySymbol assemblySymbol)
    {
        var identity = assemblySymbol.Identity;
        return $"{identity.Name}, Version={identity.Version}, Culture={(string.IsNullOrEmpty(identity.CultureName) ? "neutral" : identity.CultureName)}, PublicKeyToken={(identity.PublicKeyToken.Length > 0 ? BitConverter.ToString(identity.PublicKeyToken.ToArray()).Replace("-", "").ToLowerInvariant() : "null")}";
    }
}