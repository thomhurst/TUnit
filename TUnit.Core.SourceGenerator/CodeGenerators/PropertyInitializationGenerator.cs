using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using TUnit.Core.SourceGenerator.Extensions;

namespace TUnit.Core.SourceGenerator.CodeGenerators;

[Generator]
public class PropertyInitializationGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var classDataSourceClasses = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (node, _) => node is AttributeSyntax,
                transform: GetClassesWithDataSourceProperties)
            .Where(static m => m is not null)
            .WithComparer(SymbolEqualityComparer.Default);

        context.RegisterSourceOutput(classDataSourceClasses, GeneratePropertyInitializer!);
    }

    private static INamedTypeSymbol? GetClassesWithDataSourceProperties(GeneratorSyntaxContext context, CancellationToken cancellationToken)
    {
        if (context.Node is not AttributeSyntax attributeSyntax)
        {
            return null;
        }

        var semanticModel = context.SemanticModel;

        if(semanticModel.GetSymbolInfo(attributeSyntax).Symbol is not IMethodSymbol attributeConstructorSymbol)
        {
            return null;
        }

        var attributeClass = attributeConstructorSymbol.ContainingType;

        if (attributeClass == null)
        {
            return null;
        }

        if (IsDataSourceGeneratorAttribute(attributeClass, out var attributeBaseType))
        {
            return attributeBaseType;
        }

        return null;
    }

    private static void CollectProperties(INamedTypeSymbol? attributeBaseType)
    {
        throw new NotImplementedException();
    }

    private static bool IsDataSourceGeneratorAttribute(INamedTypeSymbol? attributeClass, out INamedTypeSymbol? attributeBaseType)
    {
        if (attributeClass == null)
        {
            attributeBaseType = null;
            return false;
        }

        foreach (var type in attributeClass.GetSelfAndBaseTypes())
        {
            if(type.Interfaces.Any(i =>
                i.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) == "global::TUnit.Core.IDataSourceGeneratorAttribute"))
            {
                attributeBaseType = type;
                return true;
            }
        }

        attributeBaseType = null;
        return false;
    }

    private static Dictionary<string, object?> ExtractAttributeArguments(AttributeData attributeData)
    {
        var arguments = new Dictionary<string, object?>();

        // Extract constructor arguments
        for (int i = 0; i < attributeData.ConstructorArguments.Length; i++)
        {
            arguments[$"ConstructorArg{i}"] = attributeData.ConstructorArguments[i].Value;
        }

        // Extract named arguments
        foreach (var namedArg in attributeData.NamedArguments)
        {
            arguments[namedArg.Key] = namedArg.Value.Value;
        }        return arguments;
    }

    private static string ExtractSharedType(AttributeData attributeData)
    {
        // Look for Shared property in named arguments
        var sharedArg = attributeData.NamedArguments.FirstOrDefault(arg => arg.Key == "Shared");
        if (sharedArg.Key != null && sharedArg.Value.Value != null)
        {
            // Return the fully qualified enum value
            return $"global::TUnit.Core.Enums.SharedType.{sharedArg.Value.Value}";
        }

        // Default to None
        return "global::TUnit.Core.Enums.SharedType.None";
    }

    private static string? ExtractKey(AttributeData attributeData)
    {
        // Look for Key property in named arguments
        var keyArg = attributeData.NamedArguments.FirstOrDefault(arg => arg.Key == "Key");
        if (keyArg.Key != null && keyArg.Value.Value != null)
        {
            return $"\"{keyArg.Value.Value}\"";
        }

        return "null";
    }

    private void GeneratePropertyInitializer(SourceProductionContext context, INamedTypeSymbol type)
    {
        try
        {
            using var sourceBuilder = new SourceCodeWriter();

            sourceBuilder.WriteLine("// <auto-generated/>");
            sourceBuilder.WriteLine("#pragma warning disable");
            sourceBuilder.WriteLine("using global::System;");
            sourceBuilder.WriteLine("using global::System.Collections.Generic;");
            sourceBuilder.WriteLine("using global::TUnit.Core;");
            sourceBuilder.WriteLine();

            var initializerClassName = $"{type.Name}PropertyInitializer_{Guid.NewGuid():N}";

            sourceBuilder.WriteLine("namespace TUnit.SourceGenerated;");
            sourceBuilder.WriteLine();
            sourceBuilder.WriteLine("[global::System.Diagnostics.StackTraceHidden]");
            sourceBuilder.WriteLine("[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]");
            sourceBuilder.WriteLine($"file static class {initializerClassName}");
            sourceBuilder.WriteLine("{");

            // Generate the initialization method
            sourceBuilder.WriteLine("[global::System.Runtime.CompilerServices.ModuleInitializer]");
            sourceBuilder.WriteLine("public static void InitializeProperties()");
            sourceBuilder.WriteLine("{");

            RegisterProperty(type, sourceBuilder);

            sourceBuilder.WriteLine("}");
            sourceBuilder.WriteLine("}");

            context.AddSource($"PropertyInitializer_{initializerClassName}.g.cs", sourceBuilder.ToString());
        }
        catch (Exception ex)
        {
            var descriptor = new DiagnosticDescriptor(
                id: "TUNIT_PROP_001",
                title: "Error generating property initializer",
                messageFormat: "Failed to generate property initializer: {0}",
                category: "SourceGenerator",
                DiagnosticSeverity.Warning,
                isEnabledByDefault: true);

            context.ReportDiagnostic(Diagnostic.Create(descriptor, null, ex.ToString()));
        }
    }

    private static void RegisterProperty(INamedTypeSymbol type, SourceCodeWriter sourceBuilder)
    {
        foreach (var propertySymbol in type.GetSelfAndBaseTypes().SelectMany(x => x.GetMembers()).OfType<IPropertySymbol>())
        {
            if (!propertySymbol.GetAttributes().Any(x => IsDataSourceGeneratorAttribute(x.AttributeClass, out _)))
            {
                continue;
            }

            sourceBuilder.WriteLine($"global::TUnit.Core.Registry.RegisterProperty<{type.GloballyQualified()}>();");

            if (propertySymbol.Type is INamedTypeSymbol namedTypePropertySymbol)
            {
                RegisterProperty(namedTypePropertySymbol, sourceBuilder);
            }
        }
    }
}

public class PropertyInitializationModel
{
    public required string ClassName { get; init; }
    public required string FullyQualifiedClassName { get; init; }
    public required List<PropertyDataSourceInfo> Properties { get; init; }
}

public class PropertyDataSourceInfo
{
    public required string PropertyName { get; init; }
    public required string PropertyType { get; init; }
    public required string AttributeType { get; init; }
    public required Dictionary<string, object?> AttributeArguments { get; init; }
    public required string Shared { get; init; }
    public required string? Key { get; init; }
}
