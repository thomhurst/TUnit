using System.CodeDom.Compiler;
using System.Diagnostics.CodeAnalysis;
using System.Text;

namespace TUnit.Core.SourceGenerator;

public class SourceCodeWriter : IDisposable
{
    public int TabLevel
    {
        get;
        private set;
    }

    private readonly StringBuilder _stringBuilder = new();
    private bool _shouldIndent = true;
    private bool _appendLineOnNextWrite;

    public SourceCodeWriter(int tabLevel = 0)
    {
        TabLevel = tabLevel;

        if (tabLevel is 0)
        {
            _stringBuilder.AppendLine("// <auto-generated/>");
            _stringBuilder.AppendLine("#pragma warning disable");
        }
        else
        {
            _shouldIndent = false;
        }
    }

    private static readonly char[] _startOfStringTabLevelIncreasingChars = ['{', '['];
    private static readonly char[] _tabLevelDecreasingChars = ['}', ']'];

    private static readonly char[] _endOfStringNewLineTriggerringChars = [',', ';', ']'];
    private static readonly string[] _startOfStringNewLineTriggerringStrings = ["#pragma", "}"];

    public void WriteLine()
    {
        _stringBuilder.AppendLine();
    }

    public void Write([StringSyntax("c#")] string value)
    {
        if (string.IsNullOrWhiteSpace(value))
        {
            return;
        }

        var firstChar = value.Trim()[0];

        if (_appendLineOnNextWrite && firstChar != ';')
        {
            _stringBuilder.AppendLine();

            _appendLineOnNextWrite = false;
        }

        var tempTabCount = 0;
        if (value.Length > 0 && firstChar == '\t')
        {
            tempTabCount = value.TakeWhile(c => c == '\t').Count();
        }

        TabLevel -= tempTabCount;
        if (_tabLevelDecreasingChars.Contains(firstChar))
        {
            TabLevel--;
        }

        // Add newline before opening braces/brackets if not already on a new line
        if (_startOfStringTabLevelIncreasingChars.Contains(firstChar))
        {
            if(_stringBuilder.Length > 0
               && _stringBuilder[^1] != '\n')
            {
                if(!_endOfStringNewLineTriggerringChars.Contains(value[^1]))
                {
                    _stringBuilder.AppendLine();
                }
            }

            if (_stringBuilder.Length > 0
                && _stringBuilder[^1] != '\n')
            {
                _shouldIndent = false;
            }
            else
            {
                _shouldIndent = true;
            }
        }

        if (_tabLevelDecreasingChars.Contains(firstChar))
        {
            _shouldIndent = true;

            if (_stringBuilder[^1] != '\n')
            {
                _stringBuilder.AppendLine();
            }
        }

        if (firstChar == ';')
        {
            _shouldIndent = false;
        }

        for (var i = 0; i < TabLevel; i++)
        {
            if(_shouldIndent)
            {
                _stringBuilder.Append('\t');
            }
        }

        _stringBuilder.Append(value);

        if (ShouldAppendNewLineAfterWritingValue(value))
        {
            _appendLineOnNextWrite = true;
            _shouldIndent = true;
        }
        else
        {
            _shouldIndent = false;
        }

        if (_startOfStringTabLevelIncreasingChars.Contains(firstChar)
            && !_tabLevelDecreasingChars.Any(value.Contains))
        {
            TabLevel++;
        }

        TabLevel += tempTabCount;
    }

    private static bool ShouldAppendNewLineAfterWritingValue(string value)
    {
        if (_endOfStringNewLineTriggerringChars.Contains(value[^1]))
        {
            return true;
        }

        if (_startOfStringTabLevelIncreasingChars.Contains(value[^1]))
        {
            return true;
        }

        return _startOfStringNewLineTriggerringStrings.Any(x => value.StartsWith(x, StringComparison.Ordinal));
    }

    public override string ToString()
    {
        return _stringBuilder.ToString();
    }

    public void Dispose()
    {
        _stringBuilder.Clear();
    }
}
