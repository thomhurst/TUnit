using System.Diagnostics.CodeAnalysis;
using System.Text;

namespace TUnit.Core.SourceGenerator;

public class SourceCodeWriter : IDisposable
{
    public int TabLevel
    {
        get;
        private set;
    }

    private readonly StringBuilder _stringBuilder = new();
    private bool _shouldIndent = true;

    public SourceCodeWriter(int tabLevel = 0)
    {
        TabLevel = tabLevel;

        if (tabLevel is 0)
        {
            _stringBuilder.AppendLine("// <auto-generated/>");
            _stringBuilder.AppendLine("#pragma warning disable");
        }
        else
        {
            _shouldIndent = false;
        }
    }

    private static readonly char[] _startOfStringTabLevelIncreasingChars = ['{', '['];
    private static readonly char[] _tabLevelDecreasingChars = ['}', ']'];

    private static readonly char[] _endOfStringNewLineTriggerringChars = [',', ';', ']'];
    private static readonly string[] _startOfStringNewLineTriggerringStrings = ["#pragma", "}"];

    public void WriteLine()
    {
        _stringBuilder.AppendLine();
    }

    public void Write([StringSyntax("c#")] string value)
    {
        if (string.IsNullOrEmpty(value))
        {
            return;
        }

        var tempTabCount = 0;
        if (value.Length > 0 && value[0] == '\t')
        {
            tempTabCount = value.TakeWhile(c => c == '\t').Count();
        }

        TabLevel -= tempTabCount;
        if (_tabLevelDecreasingChars.Contains(value[0]))
        {
            TabLevel--;
        }

        // Add newline before opening braces/brackets if not already on a new line
        if (_startOfStringTabLevelIncreasingChars.Contains(value[0]))
        {
            if(_stringBuilder.Length > 0
               && _stringBuilder[^1] != '\n'
               && !_endOfStringNewLineTriggerringChars.Contains(value[^1]))
            {
                _stringBuilder.AppendLine();
            }

            if (_stringBuilder.Length > 0
                && _stringBuilder[^1] != '\n')
            {
                _shouldIndent = false;
            }
            else
            {
                _shouldIndent = true;
            }
        }

        if (_tabLevelDecreasingChars.Contains(value[0]))
        {
            _shouldIndent = true;
        }

        for (var i = 0; i < TabLevel; i++)
        {
            if(_shouldIndent)
            {
                _stringBuilder.Append('\t');
            }
        }

        _stringBuilder.Append(value);

        if (ShouldAppendNewLineAfterWritingValue(value))
        {
            _stringBuilder.AppendLine();
            _shouldIndent = true;
        }
        else
        {
            _shouldIndent = false;
        }

        if (_startOfStringTabLevelIncreasingChars.Contains(value[0])
            && !_tabLevelDecreasingChars.Contains(value[^1]))
        {
            TabLevel++;
        }

        TabLevel += tempTabCount;

        if (value is ['}'])
        {
            // Append new line again after block to space methods apart
            _stringBuilder.AppendLine();
        }
    }

    private static bool ShouldAppendNewLineAfterWritingValue(string value)
    {
        if (_endOfStringNewLineTriggerringChars.Contains(value[^1]))
        {
            return true;
        }

        if (_startOfStringTabLevelIncreasingChars.Contains(value[^1]))
        {
            return true;
        }

        return _startOfStringNewLineTriggerringStrings.Any(x => value.StartsWith(x, StringComparison.Ordinal));
    }

    public override string ToString()
    {
        return _stringBuilder.ToString();
    }

    public void Dispose()
    {
        _stringBuilder.Clear();
    }
}
