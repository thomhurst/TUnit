# TUnit

> Welcome to TUnit Testing

This file contains all documentation content in a single document following the llmstxt.org standard.

## Exception Handling


TUnit provides a comprehensive exception hierarchy to help you understand and handle different types of failures that can occur during test execution. Understanding these exceptions is crucial for debugging test failures and implementing custom error handling.

## Exception Hierarchy

All TUnit-specific exceptions inherit from `TUnitException`, which extends `Exception`. This allows you to catch all TUnit-related exceptions with a single catch block if needed.

```
Exception
└── TUnitException
    ├── Hook Exceptions
    │   ├── BeforeTestException
    │   ├── AfterTestException
    │   ├── BeforeClassException
    │   ├── AfterClassException
    │   ├── BeforeAssemblyException
    │   ├── AfterAssemblyException
    │   ├── BeforeTestSessionException
    │   └── AfterTestSessionException
    ├── Framework Exceptions
    │   ├── TestFailedInitializationException
    │   ├── DependencyConflictException
    │   ├── InconclusiveTestException
    │   └── TestNotFoundException
    └── Execution Exceptions
        ├── TimeoutException
        ├── SkipTestException
        └── TestExecutionException
```

## Common Exception Types

### Hook Exceptions

Hook exceptions are thrown when setup or cleanup operations fail. Each hook type has its own exception to help identify where in the test lifecycle the failure occurred.

#### BeforeTestException / AfterTestException

Thrown when a `[Before(HookType.Test)]` or `[After(HookType.Test)]` hook fails.

```csharp
[Before(HookType.Test)]
public async Task TestSetup()
{
    // If this throws, it will be wrapped in BeforeTestException
    await DatabaseConnection.OpenAsync();
}

[Test]
public async Task MyTest()
{
    try
    {
        // Test code
    }
    catch (BeforeTestException ex)
    {
        // The setup failed
        _logger.LogError($"Test setup failed: {ex.InnerException?.Message}");
        throw;
    }
}
```

#### BeforeClassException / AfterClassException

Thrown when class-level hooks fail. These affect all tests in the class.

```csharp
[Before(HookType.Class)]
public static async Task ClassSetup()
{
    // If this fails, all tests in the class will be marked as failed
    // with a BeforeClassException
}
```

### Framework Exceptions

These exceptions indicate problems with test configuration or framework usage.

#### TestFailedInitializationException

Thrown when a test cannot be initialized properly, often due to constructor failures or missing dependencies.

```csharp
public class MyTests
{
    private readonly IService _service;
    
    public MyTests(IService service)
    {
        _service = service ?? throw new ArgumentNullException(nameof(service));
        // If DI fails to provide service, TestFailedInitializationException is thrown
    }
}
```

#### DependencyConflictException

Thrown when there are circular dependencies or conflicting test dependencies.

```csharp
[Test]
[DependsOn(nameof(Test2))]
public void Test1() { }

[Test]
[DependsOn(nameof(Test1))] // Circular dependency!
public void Test2() { }
// Results in DependencyConflictException
```

#### InconclusiveTestException

Used to mark a test as inconclusive when it cannot determine pass/fail status.

```csharp
[Test]
public async Task CheckExternalService()
{
    var service = await GetExternalServiceStatus();
    
    if (service.IsInMaintenanceMode)
    {
        throw new InconclusiveTestException(
            "Cannot test: service is in maintenance mode");
    }
    
    // Continue with actual test
}
```

### Execution Exceptions

These exceptions relate to test execution behavior.

#### TimeoutException

Thrown when a test exceeds its timeout limit.

```csharp
[Test]
[Timeout(1000)] // 1 second timeout
public async Task LongRunningTest()
{
    await Task.Delay(2000); // Will throw TimeoutException
}
```

#### SkipTestException

Used to dynamically skip a test during execution.

```csharp
[Test]
public async Task ConditionalTest()
{
    if (!await CheckPreconditions())
    {
        throw new SkipTestException("Preconditions not met");
    }
    
    // Test logic
}
```

## Exception Properties and Information

TUnit exceptions provide rich information to help diagnose issues:

### Stack Trace Enhancement

Many TUnit exceptions enhance stack traces to provide more relevant information:

```csharp
public class TUnitException : Exception
{
    public override string? StackTrace => 
        EnhancedStackTrace ?? base.StackTrace;
        
    protected string? EnhancedStackTrace { get; set; }
}
```

### Context Information

Exceptions often include test context information:

```csharp
catch (BeforeTestException ex)
{
    Console.WriteLine($"Hook failed for test: {ex.TestContext.TestName}");
    Console.WriteLine($"In class: {ex.TestContext.TestClass.FullName}");
    Console.WriteLine($"Hook method: {ex.HookMethod.Name}");
}
```

## Handling Exceptions in Custom Extensions

When implementing custom test executors or hook executors, proper exception handling is crucial:

### Test Executor Exception Handling

```csharp
public class SafeTestExecutor : ITestExecutor
{
    public async Task ExecuteAsync(TestContext context, Func<Task> testBody)
    {
        try
        {
            await testBody();
        }
        catch (TUnitException)
        {
            // TUnit exceptions should generally be rethrown
            throw;
        }
        catch (AssertionException)
        {
            // Assertion failures should be rethrown
            throw;
        }
        catch (Exception ex)
        {
            // Wrap other exceptions with context
            throw new TestExecutionException(
                $"Test '{context.TestName}' failed with unexpected exception",
                ex);
        }
    }
}
```

### Hook Executor Exception Handling

```csharp
public class LoggingHookExecutor : IHookExecutor
{
    private readonly ILogger _logger;
    
    public async Task ExecuteAsync(HookContext context, Func<Task> hookBody)
    {
        try
        {
            await hookBody();
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, 
                "Hook {HookType} failed for test {TestName}", 
                context.HookType, 
                context.TestContext.TestName);
                
            // Wrap in appropriate hook exception
            throw context.HookType switch
            {
                HookType.BeforeTest => new BeforeTestException(ex),
                HookType.AfterTest => new AfterTestException(ex),
                HookType.BeforeClass => new BeforeClassException(ex),
                HookType.AfterClass => new AfterClassException(ex),
                _ => ex
            };
        }
    }
}
```

## Best Practices for Exception Handling

### 1. Use Specific Exceptions

Throw the most specific exception type for your scenario:

```csharp
// Good
if (resource == null)
{
    throw new TestFailedInitializationException(
        "Required resource not available");
}

// Less specific
if (resource == null)
{
    throw new Exception("Required resource not available");
}
```

### 2. Preserve Inner Exceptions

Always preserve the original exception as an inner exception:

```csharp
try
{
    await DatabaseSetup();
}
catch (SqlException ex)
{
    throw new BeforeTestException(
        "Database setup failed", 
        ex); // Preserve original exception
}
```

### 3. Add Contextual Information

Include relevant context in exception messages:

```csharp
throw new TestNotFoundException(
    $"Test method '{methodName}' with parameters " +
    $"[{string.Join(", ", parameterTypes)}] not found in class '{className}'");
```

### 4. Handle Async Exceptions Properly

Be careful with async exception handling:

```csharp
[Test]
public async Task AsyncExceptionTest()
{
    try
    {
        await AsyncOperation();
    }
    catch (AggregateException ae)
    {
        // Handle aggregate exceptions from parallel operations
        foreach (var inner in ae.InnerExceptions)
        {
            _logger.LogError(inner, "Parallel operation failed");
        }
        throw;
    }
}
```

### 5. Use Exception Filters When Appropriate

```csharp
try
{
    await TestOperation();
}
catch (TUnitException ex) when (ex.InnerException is SqlException)
{
    // Handle database-related test failures specifically
    await CleanupDatabaseState();
    throw;
}
```

## Creating Custom Exceptions

If you need to create custom exceptions for your test extensions:

```csharp
public class CustomTestException : TUnitException
{
    public string TestCategory { get; }
    public int ErrorCode { get; }
    
    public CustomTestException(
        string message, 
        string testCategory, 
        int errorCode, 
        Exception? innerException = null) 
        : base(message, innerException)
    {
        TestCategory = testCategory;
        ErrorCode = errorCode;
    }
    
    public override string ToString()
    {
        return $"{base.ToString()}\n" +
               $"Category: {TestCategory}\n" +
               $"Error Code: {ErrorCode}";
    }
}
```

## Exception Handling in Test Results

Understanding how exceptions affect test results:

```csharp
[Test]
public async Task ExceptionResultTest()
{
    try
    {
        await RiskyOperation();
    }
    catch (Exception ex)
    {
        // You can access the exception in hooks or event receivers
        // via TestContext.Result.Exception
        
        // The test will be marked as Failed
        // unless it's a SkipTestException (→ Skipped)
        // or InconclusiveTestException (→ Inconclusive)
        throw;
    }
}

[After(HookType.Test)]
public async Task LogTestExceptions()
{
    var result = TestContext.Current?.Result;
    if (result?.Exception != null)
    {
        await LogException(result.Exception);
    }
}
```

## Common Scenarios and Solutions

### Scenario: Flaky External Service

```csharp
[Test]
[Retry(3)]
public async Task ExternalServiceTest()
{
    try
    {
        await CallExternalService();
    }
    catch (HttpRequestException ex) when (IsTransient(ex))
    {
        // Will be retried automatically due to [Retry] attribute
        throw;
    }
    catch (HttpRequestException ex)
    {
        // Non-transient failure - skip instead of fail
        throw new SkipTestException(
            $"External service unavailable: {ex.Message}");
    }
}
```

### Scenario: Resource Cleanup on Failure

```csharp
[Test]
public async Task ResourceTest()
{
    IResource? resource = null;
    try
    {
        resource = await AcquireResource();
        await UseResource(resource);
    }
    catch (Exception ex)
    {
        // Log the exception with context
        _logger.LogError(ex, 
            "Test failed with resource {ResourceId}", 
            resource?.Id);
        throw;
    }
    finally
    {
        // Ensure cleanup happens even on exception
        if (resource != null)
        {
            await ReleaseResource(resource);
        }
    }
}
```

### Scenario: Conditional Test Execution

```csharp
[Before(HookType.Test)]
public async Task CheckEnvironment()
{
    if (!IsCorrectEnvironment())
    {
        throw new SkipTestException(
            "Test requires production-like environment");
    }
    
    if (!await CheckDependencies())
    {
        throw new TestFailedInitializationException(
            "Required dependencies not available");
    }
}
```

## Summary

TUnit's exception hierarchy provides clear, specific exception types for different failure scenarios. By understanding and properly using these exceptions, you can:

- Write more maintainable tests with clear failure reasons
- Implement robust error handling in custom extensions
- Provide better debugging information when tests fail
- Handle different types of failures appropriately

Remember to always preserve context, use specific exception types, and handle async exceptions properly for the best testing experience.

---

## Extension Points


TUnit provides several extension points that allow you to customize and extend the framework's behavior. These interfaces enable you to implement custom test execution logic, hook into the test lifecycle, and control parallel execution.

## ITestExecutor

The `ITestExecutor` interface allows you to customize how tests are executed. This is useful for scenarios like:
- Adding custom logging or telemetry
- Implementing custom retry logic
- Wrapping test execution with special context
- Implementing custom timeout behavior

### Interface Definition

```csharp
public interface ITestExecutor
{
    ValueTask ExecuteTest(TestContext context, Func<ValueTask> action);
}
```

### Example Implementation

```csharp
public class TimingTestExecutor : ITestExecutor
{
    public async ValueTask ExecuteTest(TestContext context, Func<ValueTask> action)
    {
        var stopwatch = Stopwatch.StartNew();

        try
        {
            await action();
        }
        finally
        {
            stopwatch.Stop();
            context.WriteLine($"Test execution took: {stopwatch.ElapsedMilliseconds}ms");

            // You could also send this to telemetry
            TelemetryClient.TrackMetric("TestDuration", stopwatch.ElapsedMilliseconds);
        }
    }
}
```

### Registering a Test Executor

To use your custom test executor, apply the `TestExecutorAttribute` at the assembly, class, or method level:

```csharp
// Assembly-level (applies to all tests in the assembly)
[assembly: TestExecutor<TimingTestExecutor>]

// Or use the non-generic version
[assembly: TestExecutor(typeof(TimingTestExecutor))]

// Class-level (applies to all tests in the class)
[TestExecutor<TimingTestExecutor>]
public class MyTestClass
{
    [Test]
    public async Task MyTest()
    {
        // Test logic here
    }
}

// Method-level (applies to specific test)
[Test]
[TestExecutor<TimingTestExecutor>]
public async Task MyTest()
{
    // Test logic here
}
```

## IHookExecutor

The `IHookExecutor` interface allows you to customize how setup and cleanup hooks are executed. This is useful for:
- Adding error handling around hooks
- Implementing hook-specific logging
- Managing shared resources during hooks

### Interface Definition

```csharp
public interface IHookExecutor
{
    ValueTask ExecuteBeforeTestDiscoveryHook(MethodMetadata hookMethodInfo, BeforeTestDiscoveryContext context, Func<ValueTask> action);
    ValueTask ExecuteBeforeTestSessionHook(MethodMetadata hookMethodInfo, TestSessionContext context, Func<ValueTask> action);
    ValueTask ExecuteBeforeAssemblyHook(MethodMetadata hookMethodInfo, AssemblyHookContext context, Func<ValueTask> action);
    ValueTask ExecuteBeforeClassHook(MethodMetadata hookMethodInfo, ClassHookContext context, Func<ValueTask> action);
    ValueTask ExecuteBeforeTestHook(MethodMetadata hookMethodInfo, TestContext context, Func<ValueTask> action);

    ValueTask ExecuteAfterTestDiscoveryHook(MethodMetadata hookMethodInfo, TestDiscoveryContext context, Func<ValueTask> action);
    ValueTask ExecuteAfterTestSessionHook(MethodMetadata hookMethodInfo, TestSessionContext context, Func<ValueTask> action);
    ValueTask ExecuteAfterAssemblyHook(MethodMetadata hookMethodInfo, AssemblyHookContext context, Func<ValueTask> action);
    ValueTask ExecuteAfterClassHook(MethodMetadata hookMethodInfo, ClassHookContext context, Func<ValueTask> action);
    ValueTask ExecuteAfterTestHook(MethodMetadata hookMethodInfo, TestContext context, Func<ValueTask> action);
}
```

**Note**: This interface has specific methods for each hook type (Before/After × TestDiscovery/TestSession/Assembly/Class/Test). Each method receives:
- `MethodMetadata hookMethodInfo`: Information about the hook method being executed
- A context object specific to the hook type
- The `action` to execute (the actual hook logic)

### Example Implementation

```csharp
public class LoggingHookExecutor : IHookExecutor
{
    public async ValueTask ExecuteBeforeTestDiscoveryHook(MethodMetadata hookMethodInfo, BeforeTestDiscoveryContext context, Func<ValueTask> action)
    {
        Console.WriteLine($"Before test discovery hook: {hookMethodInfo.MethodName}");
        await action();
    }

    public async ValueTask ExecuteBeforeTestSessionHook(MethodMetadata hookMethodInfo, TestSessionContext context, Func<ValueTask> action)
    {
        Console.WriteLine($"Before test session hook: {hookMethodInfo.MethodName}");
        await action();
    }

    public async ValueTask ExecuteBeforeAssemblyHook(MethodMetadata hookMethodInfo, AssemblyHookContext context, Func<ValueTask> action)
    {
        Console.WriteLine($"Before assembly hook: {hookMethodInfo.MethodName}");
        await action();
    }

    public async ValueTask ExecuteBeforeClassHook(MethodMetadata hookMethodInfo, ClassHookContext context, Func<ValueTask> action)
    {
        Console.WriteLine($"Before class hook: {hookMethodInfo.MethodName} for class {context.TestClassType.Name}");

        try
        {
            await action();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Hook failed: {ex.Message}");
            throw;
        }
    }

    public async ValueTask ExecuteBeforeTestHook(MethodMetadata hookMethodInfo, TestContext context, Func<ValueTask> action)
    {
        Console.WriteLine($"Before test hook: {hookMethodInfo.MethodName} for test {context.Metadata.TestName}");
        await action();
    }

    public async ValueTask ExecuteAfterTestDiscoveryHook(MethodMetadata hookMethodInfo, TestDiscoveryContext context, Func<ValueTask> action)
    {
        await action();
        Console.WriteLine($"After test discovery hook: {hookMethodInfo.MethodName}");
    }

    public async ValueTask ExecuteAfterTestSessionHook(MethodMetadata hookMethodInfo, TestSessionContext context, Func<ValueTask> action)
    {
        await action();
        Console.WriteLine($"After test session hook: {hookMethodInfo.MethodName}");
    }

    public async ValueTask ExecuteAfterAssemblyHook(MethodMetadata hookMethodInfo, AssemblyHookContext context, Func<ValueTask> action)
    {
        await action();
        Console.WriteLine($"After assembly hook: {hookMethodInfo.MethodName}");
    }

    public async ValueTask ExecuteAfterClassHook(MethodMetadata hookMethodInfo, ClassHookContext context, Func<ValueTask> action)
    {
        await action();
        Console.WriteLine($"After class hook: {hookMethodInfo.MethodName} for class {context.TestClassType.Name}");
    }

    public async ValueTask ExecuteAfterTestHook(MethodMetadata hookMethodInfo, TestContext context, Func<ValueTask> action)
    {
        await action();
        Console.WriteLine($"After test hook: {hookMethodInfo.MethodName} for test {context.Metadata.TestName}");
    }
}
```

## Event Receivers

TUnit provides several event receiver interfaces that allow you to hook into different stages of the test lifecycle:

### ITestDiscoveryEventReceiver

Notified when a test is discovered during the discovery phase.

```csharp
public interface ITestDiscoveryEventReceiver
{
    ValueTask OnTestDiscovered(DiscoveredTestContext context);
}
```

### ITestRegisteredEventReceiver

Notified when a test is registered with the test engine.

```csharp
public interface ITestRegisteredEventReceiver
{
    ValueTask OnTestRegistered(TestRegisteredContext context);
}
```

### ITestStartEventReceiver

Notified when a test starts execution.

```csharp
public interface ITestStartEventReceiver
{
    ValueTask OnTestStart(TestContext context);
}
```

### ITestEndEventReceiver

Notified when a test completes execution.

```csharp
public interface ITestEndEventReceiver
{
    ValueTask OnTestEnd(TestContext context);
}
```

### ITestRetryEventReceiver

Notified when a test is retried.

```csharp
public interface ITestRetryEventReceiver
{
    ValueTask OnTestRetry(TestContext context, int retryAttempt);
}
```

### Example Event Receiver Implementation

```csharp
[AttributeUsage(AttributeTargets.Assembly | AttributeTargets.Class | AttributeTargets.Method)]
public class TestReporterAttribute : Attribute, ITestStartEventReceiver, ITestEndEventReceiver
{
    public int Order => 0;

    public async ValueTask OnTestStart(TestContext context)
    {
        await ReportingService.ReportTestStarted(
            context.GetDisplayName(),
            context.Metadata.TestDetails.TestClass?.FullName,
            context.Metadata.TestDetails.TestMethodArguments
        );
    }

    public async ValueTask OnTestEnd(TestContext context)
    {
        await ReportingService.ReportTestCompleted(
            context.GetDisplayName(),
            context.Execution.Result?.State,
            context.Execution.Result?.Duration,
            context.Execution.Result?.Exception?.Message
        );
    }
}
```

### Registering Event Receivers

Event receivers are registered by implementing the interfaces in an attribute class, then applying that attribute at the assembly, class, or method level:

```csharp
// Create an attribute that implements the event receiver interfaces
[AttributeUsage(AttributeTargets.Assembly | AttributeTargets.Class | AttributeTargets.Method)]
public class CustomEventReceiverAttribute : Attribute, ITestStartEventReceiver, ITestEndEventReceiver
{
    public int Order => 0;
    
    public ValueTask OnTestStart(TestContext context)
    {
        Console.WriteLine($"Test starting: {context.GetDisplayName()}");
        return default;
    }
    
    public ValueTask OnTestEnd(TestContext context)
    {
        Console.WriteLine($"Test ended: {context.GetDisplayName()} - {context.Execution.Result?.State}");
        return default;
    }
}

// Apply at assembly level
[assembly: CustomEventReceiver]

// Or at class level
[CustomEventReceiver]
public class MyTestClass
{
    [Test]
    public async Task MyTest() { }
}

// Or at method level
[Test]
[CustomEventReceiver]
public async Task MyTest() { }
```

## Parallel Execution Control

### IParallelLimit

Controls the maximum degree of parallelism for tests.

```csharp
public interface IParallelLimit
{
    int Limit { get; }
}
```

Example:

```csharp
public class DatabaseParallelLimit : IParallelLimit
{
    public int Limit => 5; // Max 5 database tests in parallel
}

[ParallelLimiter<DatabaseParallelLimit>]
public class DatabaseTests
{
    // All tests in this class will be limited to 5 parallel executions
}
```

### IParallelConstraint

Defines constraints for parallel execution. This is a marker interface with no members - it's used to identify types that represent parallel execution constraints.

```csharp
public interface IParallelConstraint
{
}
```

**Note**: `IParallelConstraint` is a marker interface. The actual constraint logic is handled by TUnit's built-in constraint implementations like `NotInParallelConstraint` and `ParallelGroupConstraint`.

Example:

```csharp
public class FileAccessTests
{
    [Test]
    [NotInParallel("SharedFile")]
    public async Task Test1()
    {
        // This test won't run in parallel with other tests
        // that have the same constraint key "SharedFile"
        await File.WriteAllTextAsync("shared.txt", "test1");
    }

    [Test]
    [NotInParallel("SharedFile")]
    public async Task Test2()
    {
        // This test won't run in parallel with Test1
        // because they share the same constraint key
        await File.WriteAllTextAsync("shared.txt", "test2");
    }

    [Test]
    [NotInParallel("Database")]
    public async Task Test3()
    {
        // This test can run in parallel with Test1 and Test2
        // because it has a different constraint key
        await Database.ExecuteAsync("UPDATE users SET status = 'active'");
    }
}
```

You can also use the `NotInParallel` attribute without arguments to ensure tests don't run in parallel with any other tests:

```csharp
[Test]
[NotInParallel]
public async Task GloballySerializedTest()
{
    // This test won't run in parallel with any other tests
    // marked with [NotInParallel] (no constraint key)
}
```

## IAsyncInitializer

Provides async initialization support for test classes.

```csharp
public interface IAsyncInitializer
{
    Task InitializeAsync();
}
```

Example:

```csharp
public class DatabaseTests : IAsyncInitializer
{
    private DatabaseConnection _connection;

    public async Task InitializeAsync()
    {
        _connection = await DatabaseConnection.CreateAsync();
        await _connection.MigrateAsync();
    }

    [Test]
    public async Task TestDatabaseOperation()
    {
        // _connection is guaranteed to be initialized
        await _connection.ExecuteAsync("SELECT 1");
    }
}
```

## IAsyncDiscoveryInitializer

For scenarios requiring initialization during test discovery rather than execution, implement `IAsyncDiscoveryInitializer`:

```csharp
namespace TUnit.Core.Interfaces;

/// <summary>
/// Initializes during test discovery phase, before test enumeration.
/// Use when data sources need access to initialized data during discovery.
/// </summary>
public interface IAsyncDiscoveryInitializer : IAsyncInitializer;
```

**When to use:**
- `InstanceMethodDataSource` accessing dynamically loaded data
- Test case enumeration depends on async-loaded fixtures
- Discovery-time data generation

**Performance consideration:** Discovery runs frequently (IDE reloads, `--list-tests`, CI enumeration), so avoid expensive operations when possible. Prefer predefined data over discovery-time initialization when feasible.

Example:

```csharp
// Fixture that loads test cases during discovery
public class TestCaseFixture : IAsyncDiscoveryInitializer, IAsyncDisposable
{
    private List<string> _testCases = [];

    public async Task InitializeAsync()
    {
        // This runs during DISCOVERY, not just execution
        _testCases = await LoadTestCasesFromDatabaseAsync();
    }

    public IEnumerable<string> GetTestCases() => _testCases;

    public async ValueTask DisposeAsync()
    {
        _testCases.Clear();
    }
}

public class MyTests
{
    [ClassDataSource<TestCaseFixture>(Shared = SharedType.PerClass)]
    public required TestCaseFixture Fixture { get; init; }

    public IEnumerable<string> TestCases => Fixture.GetTestCases();

    [Test]
    [InstanceMethodDataSource(nameof(TestCases))]
    public async Task MyTest(string testCase)
    {
        // Tests are generated during discovery with initialized data
        await Assert.That(testCase).IsNotNullOrEmpty();
    }
}
```

See [Property Injection - Discovery Phase Initialization](../test-lifecycle/property-injection.md#discovery-phase-initialization) for detailed guidance and best practices.

## Best Practices

1. **Keep Extensions Focused**: Each extension should have a single, clear responsibility.

2. **Handle Exceptions Gracefully**: Always wrap the execution of the original body in try-catch blocks.

3. **Avoid State**: Extensions should be stateless when possible. If state is needed, ensure it's thread-safe.

4. **Document Behavior**: Clearly document what your extension does and any side effects.

5. **Test Your Extensions**: Write tests for your custom extensions to ensure they behave correctly.

6. **Consider Performance**: Extensions run for every test, so keep them lightweight.

## Common Use Cases

### Cross-Cutting Concerns
- Logging and telemetry
- Performance monitoring
- Resource management
- Security context setup

### Integration Testing
- Database transaction management
- HTTP client configuration
- Mock server setup/teardown
- Container orchestration

### Compliance and Auditing
- Test execution auditing
- Compliance logging
- Screenshot capture for UI tests
- Result archival

## Example: Database Transaction Extension

Here's a complete example that wraps each test in a database transaction:

```csharp
public class TransactionalTestExecutor : ITestExecutor
{
    public async ValueTask ExecuteTest(TestContext context, Func<ValueTask> action)
    {
        // Get the database connection from DI
        var dbContext = context.GetService<ApplicationDbContext>();

        using var transaction = await dbContext.Database.BeginTransactionAsync();

        try
        {
            await action();

            // Rollback instead of commit to keep tests isolated
            await transaction.RollbackAsync();
        }
        catch
        {
            await transaction.RollbackAsync();
            throw;
        }
    }
}

[TestExecutor<TransactionalTestExecutor>]
public class DatabaseTests
{
    private readonly ApplicationDbContext _dbContext;

    public DatabaseTests(ApplicationDbContext dbContext)
    {
        _dbContext = dbContext;
    }

    [Test]
    public async Task CreateUser_ShouldAddToDatabase()
    {
        // This test runs in a transaction that's rolled back
        var user = new User { Name = "Test User" };
        _dbContext.Users.Add(user);
        await _dbContext.SaveChangesAsync();

        var count = await _dbContext.Users.CountAsync();
        await Assert.That(count).IsEqualTo(1);
    }
}
```

This ensures that each test runs in isolation without affecting the database state.

---

## Performance Best Practices


This guide provides recommendations for optimizing test performance and ensuring your TUnit test suite runs efficiently.

:::performance
Want to see how fast TUnit can be? Check out the [performance benchmarks](/docs/benchmarks) showing real-world speed comparisons.
:::

## Test Discovery Performance

### Use AOT Mode

TUnit's AOT (Ahead-of-Time) compilation mode provides the best performance for test discovery:

```xml
<PropertyGroup>
    <IsAotCompatible>true</IsAotCompatible>
    <EnableTrimAnalyzer>true</EnableTrimAnalyzer>
</PropertyGroup>
```

:::performance Native AOT Performance
TUnit with Native AOT compilation delivers significant speed improvements compared to regular JIT. See the [benchmarks](/docs/benchmarks) for detailed measurements.
:::

Benefits:
- Faster test discovery
- Lower memory usage
- Better performance in CI/CD pipelines

### Optimize Data Sources

#### Keep Data Generation Lightweight

```csharp
// ❌ Bad: Heavy computation during discovery
public static IEnumerable<User> GetTestUsers()
{
    // This runs during test discovery!
    var users = DatabaseQuery.GetAllUsers();
    return users.Where(u => u.IsActive);
}

// ✅ Good: Lightweight data generation
public static IEnumerable<User> GetTestUsers()
{
    yield return new User { Id = 1, Name = "Test User 1" };
    yield return new User { Id = 2, Name = "Test User 2" };
}
```

#### Use Lazy Data Loading

```csharp
// ✅ Good: Defer expensive operations until test execution
[Test]
[MethodDataSource<LazyDataProvider>(nameof(LazyDataProvider.GetIds))]
public async Task TestWithLazyData(int id)
{
    // Load full data only during test execution
    var user = await LoadUserAsync(id);
    await Assert.That(user).IsNotNull();
}

public class LazyDataProvider
{
    public static IEnumerable<int> GetIds()
    {
        // Return only IDs during discovery
        yield return 1;
        yield return 2;
        yield return 3;
    }
}
```

### Limit Matrix Test Combinations

```csharp
// ❌ Bad: Exponential test explosion
[Test]
[Arguments(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)]
[Arguments("a", "b", "c", "d", "e")]
[Arguments(true, false)]
// Creates 10 × 5 × 2 = 100 tests!

// ✅ Good: Targeted test combinations
[Test]
[Arguments(1, "a", true)]
[Arguments(5, "c", false)]
[Arguments(10, "e", true)]
// Only 3 specific test cases
```

## Test Execution Performance

### Optimize Parallel Execution

#### Configure Appropriate Parallelism

```csharp
using TUnit.Core;
using TUnit.Core.Interfaces;

// Set maximum parallel test execution using an assembly-level parallel limiter
[assembly: ParallelLimiter<ProcessorCountLimit>]

public class ProcessorCountLimit : IParallelLimit
{
    public int Limit => Environment.ProcessorCount;
}
```

Alternatively, use the command line flag:
```bash
dotnet test -- --maximum-parallel-tests 8
```

Or set an environment variable:
```bash
export TUNIT_MAX_PARALLEL_TESTS=8
```

#### Group Related Tests

```csharp
// Tests in the same group run sequentially but different groups run in parallel
[ParallelGroup("DatabaseTests")]
public class UserRepositoryTests
{
    // These tests share database resources
}

[ParallelGroup("DatabaseTests")]
public class OrderRepositoryTests
{
    // These also share database resources
}

[ParallelGroup("ApiTests")]
public class ApiIntegrationTests
{
    // These can run in parallel with database tests
}
```

#### Use Parallel Limiters Wisely

```csharp
public class DatabaseConnectionLimit : IParallelLimit
{
    public int Limit => 5; // Max 5 concurrent database connections
}

[ParallelLimiter<DatabaseConnectionLimit>]
public class DatabaseIntegrationTests
{
    // All tests here respect the connection limit
}
```

### Minimize Test Setup Overhead

#### Share Expensive Setup

```csharp
// ❌ Bad: Expensive setup per test
public class ExpensiveTests
{
    [Before(HookType.Test)]
    public async Task SetupEachTest()
    {
        await StartDatabaseContainer();
        await MigrateDatabase();
    }
}

// ✅ Good: Share setup across tests
public class EfficientTests
{
    private static DatabaseContainer? _container;
    
    [Before(HookType.Class)]
    public static async Task SetupOnce()
    {
        _container = await StartDatabaseContainer();
        await MigrateDatabase();
    }
    
    [After(HookType.Class)]
    public static async Task CleanupOnce()
    {
        if (_container != null)
        {
            await _container.DisposeAsync();
        }
    }
}
```

#### Use Lazy Initialization

```csharp
public class PerformantTests
{
    private static readonly Lazy<ExpensiveResource> _resource = 
        new(() => new ExpensiveResource(), LazyThreadSafetyMode.ExecutionAndPublication);
    
    [Test]
    public async Task TestUsingResource()
    {
        var resource = _resource.Value; // Only created on first access
        await resource.DoSomethingAsync();
    }
}
```

### Optimize Assertions

#### Avoid Expensive Operations in Assertions

```csharp
// ❌ Bad: Expensive operation in assertion
await Assert.That(await GetAllUsersFromDatabase())
    .Count()
    .IsEqualTo(1000);

// ✅ Good: Use efficient queries
var userCount = await GetUserCountFromDatabase();
await Assert.That(userCount).IsEqualTo(1000);
```

#### Use Early Exit Patterns

```csharp
[Test]
public async Task EfficientValidation()
{
    var result = await GetResultAsync();
    
    // Quick checks first
    if (result == null)
    {
        await Assert.That(result).IsNotNull();
        return; // Exit early
    }
    
    // More expensive validations only if needed
    await Assert.That(result.Items).Count().IsGreaterThan(0);
}
```

## Memory Management

### Dispose Resources Properly

```csharp
public class MemoryEfficientTests : IAsyncDisposable
{
    private readonly List<IDisposable> _disposables = new();
    
    [Test]
    public async Task TestWithResources()
    {
        var resource = new LargeResource();
        _disposables.Add(resource);
        
        // Use resource
        await resource.ProcessAsync();
    }
    
    public async ValueTask DisposeAsync()
    {
        foreach (var disposable in _disposables)
        {
            disposable.Dispose();
        }
        _disposables.Clear();
        
        // Force garbage collection if needed
        GC.Collect();
        GC.WaitForPendingFinalizers();
    }
}
```

### Avoid Memory Leaks in Static Fields

```csharp
// ❌ Bad: Static collections that grow indefinitely
public class LeakyTests
{
    private static readonly List<TestResult> _allResults = new();
    
    [After(HookType.Test)]
    public void StoreResult()
    {
        _allResults.Add(GetCurrentResult()); // Memory leak!
    }
}

// ✅ Good: Proper cleanup or bounded collections
public class EfficientTests
{
    private static readonly Queue<TestResult> _recentResults = new();
    private const int MaxResults = 100;
    
    [After(HookType.Test)]
    public void StoreResult()
    {
        _recentResults.Enqueue(GetCurrentResult());
        
        while (_recentResults.Count > MaxResults)
        {
            _recentResults.Dequeue();
        }
    }
}
```

### Use ValueTask for High-Frequency Operations

```csharp
// For operations called many times, use ValueTask to reduce allocations
public async ValueTask<bool> FastCheckAsync(int id)
{
    if (_cache.TryGetValue(id, out var cached))
    {
        return cached; // No allocation for cached path
    }
    
    var result = await LoadFromDatabaseAsync(id);
    _cache[id] = result;
    return result;
}

[Test]
[Arguments(1, 2, 3, 4, 5)] // Many invocations
public async Task HighFrequencyTest(int id)
{
    var result = await FastCheckAsync(id);
    await Assert.That(result).IsTrue();
}
```

## I/O Performance

### Batch Operations

```csharp
// ❌ Bad: Individual operations
[Test]
public async Task SlowIOTest()
{
    foreach (var id in Enumerable.Range(1, 100))
    {
        await SaveUserAsync(new User { Id = id });
    }
}

// ✅ Good: Batch operations
[Test]
public async Task FastIOTest()
{
    var users = Enumerable.Range(1, 100)
        .Select(id => new User { Id = id })
        .ToList();
    
    await SaveUsersBatchAsync(users);
}
```

### Use Async I/O

```csharp
// ❌ Bad: Synchronous I/O
[Test]
public void SyncIOTest()
{
    var content = File.ReadAllText("large-file.txt");
    ProcessContent(content);
}

// ✅ Good: Asynchronous I/O
[Test]
public async Task AsyncIOTest()
{
    var content = await File.ReadAllTextAsync("large-file.txt");
    await ProcessContentAsync(content);
}
```

### Cache File Contents

```csharp
public class FileTestsWithCache
{
    private static readonly ConcurrentDictionary<string, string> _fileCache = new();
    
    private async Task<string> GetFileContentAsync(string path)
    {
        return await _fileCache.GetOrAddAsync(path, 
            async p => await File.ReadAllTextAsync(p));
    }
    
    [Test]
    [Arguments("config1.json")]
    [Arguments("config2.json")]
    public async Task TestWithCachedFiles(string filename)
    {
        var content = await GetFileContentAsync(filename);
        await Assert.That(content).IsNotEmpty();
    }
}
```

## Database Testing Performance

### Use Transaction Rollback

```csharp
public class FastDatabaseTests
{
    [Test]
    public async Task TransactionalTest()
    {
        using var transaction = await BeginTransactionAsync();
        
        try
        {
            // Perform database operations
            await CreateUserAsync("test@example.com");
            
            // Verify
            var user = await GetUserAsync("test@example.com");
            await Assert.That(user).IsNotNull();
            
            // Rollback instead of cleanup
            await transaction.RollbackAsync();
        }
        catch
        {
            await transaction.RollbackAsync();
            throw;
        }
    }
}
```

### Use In-Memory Databases for Unit Tests

```csharp
public class InMemoryDatabaseTests
{
    private DbContext CreateInMemoryContext()
    {
        var options = new DbContextOptionsBuilder<AppDbContext>()
            .UseInMemoryDatabase(Guid.NewGuid().ToString())
            .Options;
            
        return new AppDbContext(options);
    }
    
    [Test]
    public async Task FastDatabaseTest()
    {
        using var context = CreateInMemoryContext();
        
        // Test runs entirely in memory
        context.Users.Add(new User { Name = "Test" });
        await context.SaveChangesAsync();
        
        var count = await context.Users.CountAsync();
        await Assert.That(count).IsEqualTo(1);
    }
}
```

## CI/CD Optimization

### Split Test Suites

```bash
# Run fast unit tests first
dotnet test --no-build -- --treenode-filter "/*/*/*/*[Category=Unit]"

# Run slower integration tests separately
dotnet test --no-build -- --treenode-filter "/*/*/*/*[Category=Integration]"

# Run expensive E2E tests last
dotnet test --no-build -- --treenode-filter "/*/*/*/*[Category=E2E]"
```

> **Note**: With .NET 10 SDK or newer, you can use the simpler syntax:
> ```bash
> dotnet test --no-build --treenode-filter "/**[Category=Unit]"
> ```

### Use Test Result Caching

```xml
<!-- Cache test results in CI -->
<PropertyGroup>
    <TUnitCacheTestResults>true</TUnitCacheTestResults>
    <TUnitTestResultsCachePath>$(Build.StagingDirectory)/testcache</TUnitTestResultsCachePath>
</PropertyGroup>
```

### Fail Fast in CI

```bash
# Stop on first failure to save CI time
dotnet test -- --fail-fast
```

## Monitoring and Profiling

### Add Performance Logging

```csharp
public class PerformanceAwareExecutor : ITestExecutor
{
    private readonly ILogger<PerformanceAwareExecutor> _logger;
    
    public async Task ExecuteAsync(TestContext context, Func<Task> testBody)
    {
        var stopwatch = Stopwatch.StartNew();
        
        try
        {
            await testBody();
        }
        finally
        {
            stopwatch.Stop();
            
            if (stopwatch.ElapsedMilliseconds > 1000)
            {
                _logger.LogWarning(
                    "Slow test detected: {TestName} took {ElapsedMs}ms",
                    context.Metadata.TestName,
                    stopwatch.ElapsedMilliseconds);
            }
        }
    }
}
```

### Track Test Metrics

```csharp
[After(HookType.Test)]
public static void RecordTestMetrics()
{
    var context = TestContext.Current;
    if (context?.Execution.Result != null)
    {
        TelemetryClient.TrackMetric(
            "TestDuration",
            context.Execution.Result.Duration.TotalMilliseconds,
            new Dictionary<string, string>
            {
                ["TestName"] = context.Metadata.TestName,
                ["TestClass"] = context.Metadata.TestDetails.TestClass,
                ["Result"] = context.Execution.Result.State.ToString()
            });
    }
}
```

## Summary

Key performance principles:

1. **Optimize Discovery**: Keep data sources lightweight and limit test combinations
2. **Parallelize Wisely**: Use appropriate parallel limits and grouping
3. **Manage Resources**: Dispose properly and avoid memory leaks
4. **Cache Aggressively**: Cache expensive operations and file I/O
5. **Batch Operations**: Group database and I/O operations
6. **Monitor Performance**: Track and alert on slow tests
7. **Use AOT Mode**: Enable AOT for best performance
8. **Fail Fast**: Stop early on failures in CI

By following these practices, you can maintain a fast, efficient test suite that scales with your codebase.

---

## Test Variants


Test variants enable you to dynamically create additional test cases during test execution based on runtime results. This powerful feature unlocks advanced testing patterns like property-based testing shrinking, mutation testing, adaptive stress testing, and intelligent retry strategies.

## What Are Test Variants?

Test variants are tests that are created **during the execution** of a parent test, inheriting the parent's test method template but potentially using different arguments, properties, or display names. They appear as distinct tests in the test explorer and can have their own outcomes.

### Test Variants vs Dynamic Tests

| Feature | Test Variants (`CreateTestVariant`) | Dynamic Tests (`AddDynamicTest`) |
|---------|-------------------------------------|----------------------------------|
| **Created** | During test execution | During test discovery |
| **Parent** | Always has a parent test | Standalone tests |
| **Template** | Reuses parent's test method | Requires explicit method definition |
| **Use Case** | Runtime adaptation (shrinking, mutation, stress) | Pre-generation of test cases |
| **AOT Compatible** | No (requires reflection) | Yes (with source generators) |

## Core Concepts

### TestRelationship Enum

The `TestRelationship` enum categorizes how a variant relates to its parent, informing the test runner about execution semantics:

```csharp
public enum TestRelationship
{
    None,       // Independent test (no parent)
    Retry,      // Identical re-run after failure
    Generated,  // Pre-execution exploration (e.g., initial PBT cases)
    Derived     // Post-execution analysis (e.g., shrinking, mutation)
}
```

**When to use each:**
- **`Retry`**: For identical re-runs, typically handled by `[Retry]` attribute
- **`Generated`**: For upfront test case generation before execution
- **`Derived`**: For runtime analysis based on parent results (most common for variants)

### DisplayName Parameter

The optional `displayName` parameter provides user-facing labels in test explorers and reports. While the `TestRelationship` informs the framework about execution semantics, `displayName` communicates intent to humans:

```csharp
await context.CreateTestVariant(
    arguments: new object[] { smallerInput },
    relationship: TestRelationship.Derived,
    displayName: "Shrink Attempt #3"  // Shows in test explorer
);
```

### Properties Dictionary

Store metadata for filtering, reporting, or variant logic:

```csharp
await context.CreateTestVariant(
    arguments: new object[] { mutatedValue },
    properties: new Dictionary<string, object?>
    {
        { "AttemptNumber", 3 },
        { "ShrinkStrategy", "Binary" },
        { "OriginalValue", originalInput }
    },
    relationship: TestRelationship.Derived,
    displayName: "Shrink #3 (Binary)"
);
```

## Use Cases

### 1. Property-Based Testing (PBT) - Shrinking

When a property-based test fails with a complex input, create variants with progressively simpler inputs to find the minimal failing case. Use a custom attribute implementing `ITestEndEventReceiver` to automatically shrink on failure:

```csharp
// Custom attribute that shrinks inputs on test failure
public class ShrinkOnFailureAttribute : Attribute, ITestEndEventReceiver
{
    private readonly int _maxAttempts;

    public ShrinkOnFailureAttribute(int maxAttempts = 5)
    {
        _maxAttempts = maxAttempts;
    }

    public async ValueTask OnTestEnd(TestContext testContext)
    {
        // Only shrink if test failed and it's not already a shrink attempt
        if (testContext.Execution.Result?.State != TestState.Failed)
            return;

        if (testContext.Relationship == TestRelationship.Derived)
            return; // Don't shrink shrink attempts

        // Get the test's numeric argument to shrink
        var args = testContext.Metadata.TestDetails.TestMethodArguments;
        if (args.Length == 0 || args[0] is not int size)
            return;

        if (size <= 1)
            return; // Can't shrink further

        // Create shrink variants
        var shrinkSize = size / 2;
        for (int attempt = 1; attempt <= _maxAttempts && shrinkSize > 0; attempt++)
        {
            await testContext.CreateTestVariant(
                arguments: new object[] { shrinkSize },
                properties: new Dictionary<string, object?>
                {
                    { "AttemptNumber", attempt },
                    { "OriginalSize", size },
                    { "ShrinkStrategy", "Binary" }
                },
                relationship: TestRelationship.Derived,
                displayName: $"Shrink #{attempt} (size={shrinkSize})"
            );

            shrinkSize /= 2;
        }
    }
}

// Usage: Just add the attribute - shrinking happens automatically on failure
[Test]
[ShrinkOnFailure(maxAttempts: 5)]
[Arguments(1000)]
[Arguments(500)]
[Arguments(100)]
public async Task PropertyTest_ListReversal(int size)
{
    var list = Enumerable.Range(0, size).ToList();

    // Property: reversing twice should return original
    var reversed = list.Reverse().Reverse().ToList();
    await Assert.That(reversed).IsEquivalentTo(list);

    // If this fails, the attribute automatically creates shrink variants
}
```

**Why this pattern is better:**
- **Separation of concerns**: Test logic stays clean, shrinking is in the attribute
- **Reusable**: Apply `[ShrinkOnFailure]` to any test with numeric inputs
- **Declarative**: Intent is clear from the attribute
- **Automatic**: No try-catch or manual failure detection needed

### 2. Mutation Testing

Create variants that test your test's ability to catch bugs by introducing controlled mutations:

```csharp
[Test]
[Arguments(5, 10)]
public async Task CalculatorTest_Addition(int a, int b)
{
    var context = TestContext.Current!;
    var calculator = new Calculator();

    var result = calculator.Add(a, b);
    await Assert.That(result).IsEqualTo(a + b);

    // After test passes, create mutants to verify test quality
    var mutations = new[]
    {
        (a + 1, b, "Mutant: Boundary +1 on first arg"),
        (a, b + 1, "Mutant: Boundary +1 on second arg"),
        (a - 1, b, "Mutant: Boundary -1 on first arg"),
        (0, 0, "Mutant: Zero case")
    };

    foreach (var (mutA, mutB, name) in mutations)
    {
        await context.CreateTestVariant(
            arguments: new object[] { mutA, mutB },
            relationship: TestRelationship.Derived,
            displayName: name
        );
    }
}
```

### 3. Adaptive Stress Testing

Progressively increase load based on system performance:

```csharp
[Test]
[Arguments(10)] // Start with low load
public async Task LoadTest_ApiEndpoint(int concurrentUsers)
{
    var context = TestContext.Current!;
    var stopwatch = Stopwatch.StartNew();

    // Simulate load
    var tasks = Enumerable.Range(0, concurrentUsers)
        .Select(_ => CallApiAsync())
        .ToArray();

    await Task.WhenAll(tasks);
    stopwatch.Stop();

    var avgResponseTime = stopwatch.ElapsedMilliseconds / (double)concurrentUsers;
    context.WriteLine($"Users: {concurrentUsers}, Avg response: {avgResponseTime}ms");

    // If system handled load well, increase it
    if (avgResponseTime < 200 && concurrentUsers < 1000)
    {
        var nextLoad = concurrentUsers * 2;
        await context.CreateTestVariant(
            arguments: new object[] { nextLoad },
            properties: new Dictionary<string, object?>
            {
                { "PreviousLoad", concurrentUsers },
                { "PreviousAvgResponseTime", avgResponseTime }
            },
            relationship: TestRelationship.Derived,
            displayName: $"Load Test ({nextLoad} users)"
        );
    }

    await Assert.That(avgResponseTime).IsLessThan(500);
}
```

### 4. Exploratory Fuzzing

Generate additional test cases when edge cases are discovered:

```csharp
[Test]
[Arguments("normal text")]
public async Task InputValidation_SpecialCharacters(string input)
{
    var context = TestContext.Current!;
    var validator = new InputValidator();

    var result = validator.Validate(input);
    await Assert.That(result.IsValid).IsTrue();

    // If we haven't tested special characters yet, generate variants
    if (!context.StateBag.ContainsKey("TestedSpecialChars"))
    {
        context.StateBag["TestedSpecialChars"] = true;

        var specialInputs = new[]
        {
            "<script>alert('xss')</script>",
            "'; DROP TABLE users; --",
            "../../../etc/passwd",
            "\0\0\0null bytes\0",
            new string('A', 10000) // Buffer overflow attempt
        };

        foreach (var specialInput in specialInputs)
        {
            await context.CreateTestVariant(
                arguments: new object[] { specialInput },
                relationship: TestRelationship.Derived,
                displayName: $"Fuzz: {specialInput.Substring(0, Math.Min(30, specialInput.Length))}"
            );
        }
    }
}
```

### 5. Smart Retry with Parameter Adjustment

Retry failed tests with adjusted parameters to differentiate transient failures from persistent bugs:

```csharp
[Test]
[Arguments(TimeSpan.FromSeconds(5))]
public async Task ExternalService_WithTimeout(TimeSpan timeout)
{
    var context = TestContext.Current!;

    try
    {
        using var cts = new CancellationTokenSource(timeout);
        var result = await _externalService.FetchDataAsync(cts.Token);
        await Assert.That(result).IsNotNull();
    }
    catch (TimeoutException ex)
    {
        // If timeout, try with longer timeout to see if it's a transient issue
        if (timeout < TimeSpan.FromSeconds(30))
        {
            var longerTimeout = timeout.Add(TimeSpan.FromSeconds(5));

            await context.CreateTestVariant(
                arguments: new object[] { longerTimeout },
                properties: new Dictionary<string, object?>
                {
                    { "OriginalTimeout", timeout },
                    { "RetryReason", "Timeout" }
                },
                relationship: TestRelationship.Derived,
                displayName: $"Retry with {longerTimeout.TotalSeconds}s timeout"
            );
        }

        throw;
    }
}
```

### 6. Chaos Engineering

Inject faults and verify system resilience:

```csharp
[Test]
public async Task Resilience_DatabaseFailover()
{
    var context = TestContext.Current!;
    var system = new DistributedSystem();

    // Normal operation test
    var result = await system.ProcessRequestAsync();
    await Assert.That(result.Success).IsTrue();

    // Create chaos variants
    var chaosScenarios = new[]
    {
        ("primary-db-down", "Primary DB Failure"),
        ("network-latency-500ms", "High Network Latency"),
        ("replica-lag-10s", "Replica Lag"),
        ("cascading-failure", "Cascading Failure")
    };

    foreach (var (faultType, displayName) in chaosScenarios)
    {
        await context.CreateTestVariant(
            arguments: new object[] { faultType },
            properties: new Dictionary<string, object?>
            {
                { "ChaosType", faultType },
                { "InjectionPoint", "AfterSuccess" }
            },
            relationship: TestRelationship.Derived,
            displayName: $"Chaos: {displayName}"
        );
    }
}
```

## API Reference

### Method Signature

```csharp
public static async Task CreateTestVariant(
    this TestContext context,
    object?[]? arguments = null,
    Dictionary<string, object?>? properties = null,
    TestRelationship relationship = TestRelationship.Derived,
    string? displayName = null)
```

### Parameters

| Parameter | Type | Required | Default | Description |
|-----------|------|----------|---------|-------------|
| `context` | `TestContext` | Yes | - | The current test context |
| `arguments` | `object?[]?` | No | `null` | Method arguments for the variant. If `null`, reuses parent's arguments |
| `properties` | `Dictionary<string, object?>?` | No | `null` | Custom metadata stored in the variant's `TestContext.StateBag` |
| `relationship` | `TestRelationship` | No | `Derived` | Categorizes the variant's relationship to its parent |
| `displayName` | `string?` | No | `null` | User-facing label shown in test explorers. If `null`, uses default format |

### Return Value

Returns `Task` that completes when the variant has been queued for execution.

### Exceptions

- `InvalidOperationException`: Thrown if `TestContext.Current` is null
- `InvalidOperationException`: Thrown if the test method cannot be resolved

## Best Practices

### 1. Choose Appropriate TestRelationship

```csharp
// ✅ Good: Derived for post-execution analysis
await context.CreateTestVariant(
    arguments: [smallerInput],
    relationship: TestRelationship.Derived,
    displayName: "Shrink Attempt"
);

// ❌ Bad: Using None loses parent relationship
await context.CreateTestVariant(
    arguments: [smallerInput],
    relationship: TestRelationship.None  // Parent link lost!
);
```

### 2. Provide Descriptive Display Names

```csharp
// ✅ Good: Clear, specific, actionable
displayName: "Shrink #3 (Binary Search, size=125)"

// ⚠️ Okay: Somewhat clear
displayName: "Shrink Attempt 3"

// ❌ Bad: Vague, unhelpful
displayName: "Variant"
```

### 3. Avoid Infinite Recursion

```csharp
[Test]
public async Task RecursiveVariant()
{
    var context = TestContext.Current!;

    // ✅ Good: Check depth
    var depth = context.StateBag.TryGetValue("Depth", out var d) ? (int)d : 0;
    if (depth < 5)
    {
        await context.CreateTestVariant(
            properties: new Dictionary<string, object?> { { "Depth", depth + 1 } },
            relationship: TestRelationship.Derived
        );
    }

    // ❌ Bad: Infinite loop!
    // await context.CreateTestVariant(relationship: TestRelationship.Derived);
}
```

### 4. Use Properties for Metadata

```csharp
// ✅ Good: Structured metadata
properties: new Dictionary<string, object?>
{
    { "AttemptNumber", 3 },
    { "Strategy", "BinarySearch" },
    { "OriginalValue", largeInput },
    { "Timestamp", DateTime.UtcNow }
}

// ❌ Bad: Encoding metadata in displayName
displayName: "Attempt=3,Strategy=Binary,Original=1000,Time=2024-01-01"
```

### 5. Consider Performance

Creating many variants has overhead. Be strategic:

```csharp
// ✅ Good: Limited, strategic variants
if (shouldShrink && attemptCount < 10)
{
    await context.CreateTestVariant(...);
}

// ❌ Bad: Explosion of variants
for (int i = 0; i < 10000; i++)  // Creates 10,000 tests!
{
    await context.CreateTestVariant(...);
}
```

## Limitations

- **Not AOT Compatible**: Test variants require runtime reflection and expression compilation
- **Requires Reflection Mode**: Must run with reflection-based discovery (not source-generated)
- **Performance Overhead**: Each variant is a full test execution with its own lifecycle
- **No Source Generator Support**: Cannot be used in AOT-compiled scenarios

## See Also

- [Test Context](../test-lifecycle/test-context.md) - Understanding TestContext and StateBag
- [Dynamic Tests](../experimental/dynamic-tests.md) - Pre-execution test generation
- [Retrying](../execution/retrying.md) - Built-in retry mechanism comparison
- [Properties](../test-lifecycle/properties.md) - Test metadata and custom properties
- [Event Subscribing](../test-lifecycle/event-subscribing.md) - Test lifecycle event receivers

---

## And Conditions


TUnit can chain assertions together, using the `And` property. This reads very much like English, and aims to keep the test easy to read and understand, and doesn't require you repeat boilerplate code such as `Assert.That` over and over.

Every condition must pass when using `And`s:

```csharp
    [Test]
    public async Task MyTest()
    {
        var result = Add(1, 2);
        
        await Assert.That(result)
            .IsNotNull()
            .And.IsPositive()
            .And.IsEqualTo(3);
    }
```

---

## Assertion Groups


Mixing 'Or' & 'And' conditions within `Assert.That(...)` statements may result in unexpected logic. 

```csharp
var value = "CD";

await Assert.That(value)
    .Contains('C').And.Contains('D')
    .Or
    .Contains('A').And.Contains('B');
```

It might look like `(C && D) || (A && B)` but it's actually `C && (D || A) && B`

Instead, if you want to combine complex assertion logic into a single assertion, assertion groups can be used to more clearly show a group of logic.

For example:

```csharp
var value = "CD";

var cd = AssertionGroup.For(value)
    .WithAssertion(assert => assert.Contains('C'))
    .And(assert => assert.Contains('D'));

var ab = AssertionGroup.ForSameValueAs(cd)
    .WithAssertion(assert => assert.Contains('A'))
    .And(assert => assert.Contains('B'));

await AssertionGroup.Assert(cd).Or(ab);
```

While more verbose, it's clearer how the logic will evaluate.

---

## Awaiting


In TUnit you `await` your assertions, and this serves two purposes:
- the `await` keyword is responsible for performing the assertion, before you call await we're building a chain of assertion rules.
- it allows executing and asserting on `async` delegates without performing sync-over-async

Because of this, your tests should be `async` and return a `Task`.

Don't worry about forgetting to `await` - There's an analyzer built in that will notify you if you've missed any!  
If you forget to `await`, your assertion will not actually be executed, and your test may pass when it should fail.

This will error:

```csharp
    [Test]
    public void MyTest()
    {
        var result = Add(1, 2);

        Assert.That(result).IsEqualTo(3);
    }
```

This won't: 

```csharp
    [Test]
    public async Task MyTest()
    {
        var result = Add(1, 2);

        await Assert.That(result).IsEqualTo(3);
    }
```

TUnit is able to take in asynchronous delegates. To be able to assert on these, we need to execute the code. We want to avoid sync-over-async, as this can cause problems and block the thread pool, slowing down your test suite.
And with how fast .NET has become, the overhead of `Task`s and `async` methods shouldn't be noticeable.

## Using Return Values from Awaited Assertions

When you `await` an assertion in TUnit, it returns a reference to the subject that was asserted on. This allows you to capture the validated value and use it in subsequent operations or assertions, creating a fluent and readable test flow.

### Type Casting with Confidence

```csharp
[Test]
public async Task CastAndUseSpecificType()
{
    object shape = new Circle { Radius = 5.0 };
    
    // Assert type and capture strongly-typed reference
    var circle = await Assert.That(shape).IsTypeOf<Circle>();
    
    // Now you can use circle-specific properties without casting
    await Assert.That(circle.Radius).IsEqualTo(5.0);
    
    var area = Math.PI * circle.Radius * circle.Radius;
    await Assert.That(area).IsEqualTo(Math.PI * 25).Within(0.0001);
}
```

## Complex Assertion Examples

### Chaining Multiple Assertions

You can chain multiple assertions together for more complex validations:

```csharp
[Test]
public async Task ComplexObjectValidation()
{
    var user = await GetUserAsync("john.doe");

    // Chain multiple member assertions
    await Assert.That(user)
        .IsNotNull()
        .And.Member(u => u.Email, email => email.IsEqualTo("john.doe@example.com"))
        .And.Member(u => u.Age, age => age.IsGreaterThan(18))
        .And.Member(u => u.Roles, roles => roles.Contains("Admin"));
}
```

### Collection Assertions with Complex Conditions

```csharp
[Test]
public async Task ComplexCollectionAssertions()
{
    var orders = await GetOrdersAsync();

    // Assert multiple conditions on a collection
    await Assert.That(orders)
        .Count().IsGreaterThan(0)
        .And.Contains(o => o.Status == OrderStatus.Completed)
        .And.DoesNotContain(o => o.Total < 0)
        .And.HasDistinctItems();

    // Assert on filtered subset
    var completedOrders = orders.Where(o => o.Status == OrderStatus.Completed);
    await Assert.That(completedOrders)
        .All(o => o.CompletedDate != null)
        .And.Any(o => o.Total > 1000);
}
```

### Async Operation Assertions

```csharp
[Test]
public async Task AsyncOperationAssertions()
{
    // Assert that async operation completes within time limit
    await Assert.That(async () => await LongRunningOperationAsync())
        .CompletesWithin(TimeSpan.FromSeconds(5));

    // Assert that async operation throws specific exception
    await Assert.That(async () => await RiskyOperationAsync())
        .Throws<InvalidOperationException>()
        .WithMessageContaining("connection failed");

    // Assert on result of async operation
    var result = await CalculateAsync(10, 20);
    await Assert.That(result).IsEqualTo(30);
}
```

### Exception Assertions with Details

```csharp
[Test]
public async Task DetailedExceptionAssertions()
{
    var invalidData = new { Id = -1, Name = "" };

    // Assert exception with specific message
    await Assert.That(() => ProcessDataAsync(invalidData))
        .Throws<ValidationException>()
        .WithMessage("Validation failed");

    // Assert ArgumentException with parameter name
    await Assert.That(() => ProcessInvalidData(null))
        .Throws<ArgumentException>()
        .WithParameterName("data");

    // Assert aggregate exception
    var exception = await Assert.That(() => ParallelOperationAsync())
        .Throws<AggregateException>();

    await Assert.That(exception.InnerExceptions).Count().IsEqualTo(3);
    await Assert.That(exception.InnerExceptions).All(e => e is TaskCanceledException);
}
```

### Custom Assertion Conditions

```csharp
[Test]
public async Task CustomAssertionConditions()
{
    var measurements = await GetMeasurementsAsync();
    
    // Use custom conditions for complex validations
    await Assert.That(measurements)
        .Satisfies(m => {
            var average = m.Average();
            var stdDev = CalculateStandardDeviation(m);
            return stdDev < average * 0.1; // Less than 10% deviation
        }, "Measurements should have low standard deviation");
    
    // Combine built-in and custom assertions
    await Assert.That(measurements)
        .Count().IsGreaterThan(100)
        .And.All(m => m > 0)
        .And.Satisfies(IsNormallyDistributed, "Data should be normally distributed");
}
```

### DateTime and TimeSpan Assertions

```csharp
[Test]
public async Task DateTimeAssertions()
{
    var order = await CreateOrderAsync();

    // Complex datetime assertions
    await Assert.That(order.CreatedAt)
        .IsGreaterThan(DateTime.UtcNow.AddMinutes(-1))
        .And.IsLessThan(DateTime.UtcNow.AddMinutes(1));

    // TimeSpan assertions
    var processingTime = order.CompletedAt - order.CreatedAt;
    await Assert.That(processingTime)
        .IsLessThan(TimeSpan.FromMinutes(5))
        .And.IsGreaterThan(TimeSpan.Zero);
}
```

### Floating Point Comparisons

```csharp
[Test]
public async Task FloatingPointAssertions()
{
    var calculations = await PerformComplexCalculationsAsync();

    // Use tolerance for floating point comparisons
    await Assert.That(calculations.Pi)
        .IsEqualTo(Math.PI).Within(0.0001);

    // Assert on collections of floating point numbers
    await Assert.That(calculations.Results)
        .All(r => Math.Abs(r) < 1000000); // No overflow

    // Check for approximate value in collection
    var hasApproximate42 = calculations.Results.Any(r => Math.Abs(r - 42.0) < 0.1);
    await Assert.That(hasApproximate42).IsTrue();

    // Assert on sum with tolerance
    var sum = calculations.Results.Sum();
    await Assert.That(sum).IsEqualTo(expectedSum).Within(0.01);
}
```

### String Pattern Matching

```csharp
[Test]
public async Task StringPatternAssertions()
{
    var logs = await GetLogEntriesAsync();

    // Complex string assertions
    await Assert.That(logs)
        .All(log => Regex.IsMatch(log, @"^\[\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}\]"))
        .And.Any(log => log.Contains("ERROR"))
        .And.DoesNotContain(log => log.Contains("SENSITIVE_DATA"));

    // Assert on formatted output
    var report = await GenerateReportAsync();
    await Assert.That(report)
        .StartsWith("Report Generated:")
        .And.Contains("Total Items:")
        .And.DoesNotContain("null")
        .And.Length().IsBetween(1000, 5000);
}
```

### Combining Or and And Conditions

```csharp
[Test]
public async Task ComplexLogicalConditions()
{
    var product = await GetProductAsync();

    // Complex logical combinations
    await Assert.That(product.Status)
        .IsEqualTo(ProductStatus.Active)
        .Or.IsEqualTo(ProductStatus.Pending);

    await Assert.That(product.Price)
        .IsGreaterThan(0)
        .And.IsLessThan(10000);

    // Category-based conditional checks
    if (product.Category == "Electronics")
    {
        await Assert.That(product.Warranty).IsNotNull();
    }
    else if (product.Category == "Books")
    {
        await Assert.That(product.ISBN).IsNotNull();
    }
}
```

### Performance Assertions

```csharp
[Test]
public async Task PerformanceAssertions()
{
    var stopwatch = Stopwatch.StartNew();
    var results = new List<long>();
    
    // Measure multiple operations
    for (int i = 0; i < 100; i++)
    {
        var start = stopwatch.ElapsedMilliseconds;
        await PerformOperationAsync();
        results.Add(stopwatch.ElapsedMilliseconds - start);
    }
    
    // Assert on performance metrics
    await Assert.That(results.Average())
        .IsLessThan(100); // Average under 100ms
    
    await Assert.That(results.Max())
        .IsLessThan(500); // No operation over 500ms
    
    await Assert.That(results.Where(r => r > 200).Count())
        .IsLessThan(5); // Less than 5% over 200ms
}
```

### State Machine Assertions

```csharp
[Test]
public async Task StateMachineAssertions()
{
    var workflow = new OrderWorkflow();

    // Initial state
    await Assert.That(workflow.State).IsEqualTo(OrderState.New);

    // State transition assertions
    await workflow.StartProcessing();
    await Assert.That(workflow.State).IsEqualTo(OrderState.Processing);
    await Assert.That(workflow.CanTransitionTo(OrderState.Completed)).IsTrue();
    await Assert.That(workflow.CanTransitionTo(OrderState.New)).IsFalse();

    // Complex workflow validation
    await workflow.Complete();
    await Assert.That(workflow.State).IsEqualTo(OrderState.Completed);
    await Assert.That(workflow.CompletedAt).IsNotNull();
    await Assert.That(workflow.History).Contains(h => h.State == OrderState.Processing);
}
```

These examples demonstrate the power and flexibility of TUnit's assertion system, showing how you can build complex, readable assertions for various testing scenarios.

---

## Boolean Assertions


TUnit provides simple, expressive assertions for testing boolean values. These assertions work with both `bool` and `bool?` (nullable boolean) types.

## Basic Boolean Assertions

### IsTrue

Tests that a boolean value is `true`:

```csharp
[Test]
public async Task Value_Is_True()
{
    var isValid = ValidateInput("test@example.com");
    await Assert.That(isValid).IsTrue();

    var hasPermission = user.HasPermission("write");
    await Assert.That(hasPermission).IsTrue();
}
```

### IsFalse

Tests that a boolean value is `false`:

```csharp
[Test]
public async Task Value_Is_False()
{
    var isExpired = CheckIfExpired(futureDate);
    await Assert.That(isExpired).IsFalse();

    var isEmpty = list.Count == 0;
    await Assert.That(isEmpty).IsFalse();
}
```

## Alternative: Using IsEqualTo

You can also use `IsEqualTo()` for boolean comparisons:

```csharp
[Test]
public async Task Using_IsEqualTo()
{
    var result = PerformCheck();

    await Assert.That(result).IsEqualTo(true);
    // Same as: await Assert.That(result).IsTrue();

    await Assert.That(result).IsEqualTo(false);
    // Same as: await Assert.That(result).IsFalse();
}
```

However, `IsTrue()` and `IsFalse()` are more expressive and recommended for boolean values.

## Nullable Booleans

Both assertions work with nullable booleans (`bool?`):

```csharp
[Test]
public async Task Nullable_Boolean_True()
{
    bool? result = GetOptionalFlag();

    await Assert.That(result).IsTrue();
    // This asserts both:
    // 1. result is not null
    // 2. result.Value is true
}

[Test]
public async Task Nullable_Boolean_False()
{
    bool? result = GetOptionalFlag();

    await Assert.That(result).IsFalse();
    // This asserts both:
    // 1. result is not null
    // 2. result.Value is false
}
```

### Null Nullable Booleans

If a nullable boolean is `null`, both `IsTrue()` and `IsFalse()` will fail:

```csharp
[Test]
public async Task Nullable_Boolean_Null()
{
    bool? result = null;

    // These will both fail:
    // await Assert.That(result).IsTrue();  // ❌ Fails - null is not true
    // await Assert.That(result).IsFalse(); // ❌ Fails - null is not false

    // Check for null first:
    await Assert.That(result).IsNull();
}
```

## Chaining Boolean Assertions

Boolean assertions can be chained with other assertions:

```csharp
[Test]
public async Task Chained_With_Other_Assertions()
{
    bool? flag = GetFlag();

    await Assert.That(flag)
        .IsNotNull()
        .And.IsTrue();
}
```

## Practical Examples

### Validation Results

```csharp
[Test]
public async Task Email_Validation()
{
    var isValid = EmailValidator.Validate("test@example.com");
    await Assert.That(isValid).IsTrue();

    var isInvalid = EmailValidator.Validate("not-an-email");
    await Assert.That(isInvalid).IsFalse();
}
```

### Permission Checks

```csharp
[Test]
public async Task User_Permissions()
{
    var user = await GetUserAsync("alice");

    await Assert.That(user.CanRead).IsTrue();
    await Assert.That(user.CanWrite).IsTrue();
    await Assert.That(user.CanDelete).IsFalse();
}
```

### State Flags

```csharp
[Test]
public async Task Service_State()
{
    var service = new BackgroundService();

    await Assert.That(service.IsRunning).IsFalse();

    await service.StartAsync();

    await Assert.That(service.IsRunning).IsTrue();
}
```

### Feature Flags

```csharp
[Test]
public async Task Feature_Toggles()
{
    var config = LoadConfiguration();

    await Assert.That(config.EnableNewFeature).IsTrue();
    await Assert.That(config.EnableBetaFeature).IsFalse();
}
```

## Testing Conditional Logic

### Logical AND

```csharp
[Test]
public async Task Logical_AND()
{
    var isAdult = age >= 18;
    var hasLicense = CheckLicense(userId);
    var canDrive = isAdult && hasLicense;

    await Assert.That(canDrive).IsTrue();
}
```

### Logical OR

```csharp
[Test]
public async Task Logical_OR()
{
    var isWeekend = dayOfWeek is DayOfWeek.Saturday or DayOfWeek.Sunday;
    var isHoliday = CheckIfHoliday(date);
    var isDayOff = isWeekend || isHoliday;

    await Assert.That(isDayOff).IsTrue();
}
```

### Logical NOT

```csharp
[Test]
public async Task Logical_NOT()
{
    var isExpired = CheckExpiration(token);
    var isValid = !isExpired;

    await Assert.That(isValid).IsTrue();
}
```

## Complex Boolean Expressions

```csharp
[Test]
public async Task Complex_Expression()
{
    var user = GetUser();
    var canAccess = user.IsActive &&
                    !user.IsBanned &&
                    (user.IsPremium || user.HasFreeTrial);

    await Assert.That(canAccess).IsTrue();
}
```

You can also break this down for clarity:

```csharp
[Test]
public async Task Complex_Expression_Broken_Down()
{
    var user = GetUser();

    using (Assert.Multiple())
    {
        await Assert.That(user.IsActive).IsTrue();
        await Assert.That(user.IsBanned).IsFalse();
        await Assert.That(user.IsPremium || user.HasFreeTrial).IsTrue();
    }
}
```

## Comparison with Other Values

When testing boolean results of comparisons, you can often simplify:

```csharp
[Test]
public async Task Comparison_Simplified()
{
    var count = GetCount();

    // Less clear:
    await Assert.That(count > 0).IsTrue();

    // More clear and expressive:
    await Assert.That(count).IsGreaterThan(0);
}
```

Similarly for equality:

```csharp
[Test]
public async Task Equality_Simplified()
{
    var name = GetName();

    // Less clear:
    await Assert.That(name == "Alice").IsTrue();

    // More clear:
    await Assert.That(name).IsEqualTo("Alice");
}
```

Use boolean assertions for actual boolean values and flags, not for comparisons.

## Testing LINQ Queries

```csharp
[Test]
public async Task LINQ_Any()
{
    var numbers = new[] { 1, 2, 3, 4, 5 };

    var hasEven = numbers.Any(n => n % 2 == 0);
    await Assert.That(hasEven).IsTrue();

    var hasNegative = numbers.Any(n => n < 0);
    await Assert.That(hasNegative).IsFalse();
}

[Test]
public async Task LINQ_All()
{
    var numbers = new[] { 2, 4, 6, 8 };

    var allEven = numbers.All(n => n % 2 == 0);
    await Assert.That(allEven).IsTrue();

    var allPositive = numbers.All(n => n > 0);
    await Assert.That(allPositive).IsTrue();
}
```

Note: TUnit provides specialized collection assertions for these patterns:

```csharp
[Test]
public async Task Using_Collection_Assertions()
{
    var numbers = new[] { 2, 4, 6, 8 };

    // Instead of .All(n => n % 2 == 0):
    await Assert.That(numbers).All(n => n % 2 == 0);

    // Instead of .Any(n => n > 5):
    await Assert.That(numbers).Any(n => n > 5);
}
```

## String Boolean Methods

Many string methods return booleans:

```csharp
[Test]
public async Task String_Boolean_Methods()
{
    var text = "Hello World";

    await Assert.That(text.StartsWith("Hello")).IsTrue();
    await Assert.That(text.EndsWith("World")).IsTrue();
    await Assert.That(text.Contains("lo Wo")).IsTrue();
    await Assert.That(string.IsNullOrEmpty(text)).IsFalse();
}
```

But TUnit has more expressive string assertions:

```csharp
[Test]
public async Task Using_String_Assertions()
{
    var text = "Hello World";

    // More expressive:
    await Assert.That(text).StartsWith("Hello");
    await Assert.That(text).EndsWith("World");
    await Assert.That(text).Contains("lo Wo");
    await Assert.That(text).IsNotEmpty();
}
```

## Type Checking Booleans

```csharp
[Test]
public async Task Type_Checking()
{
    var obj = GetObject();

    await Assert.That(obj is string).IsTrue();
    await Assert.That(obj is not null).IsTrue();
}
```

Or use type assertions:

```csharp
[Test]
public async Task Using_Type_Assertions()
{
    var obj = GetObject();

    await Assert.That(obj).IsTypeOf<string>();
    await Assert.That(obj).IsNotNull();
}
```

## Common Patterns

### Toggle Testing

```csharp
[Test]
public async Task Toggle_State()
{
    var toggle = new Toggle();

    await Assert.That(toggle.IsOn).IsFalse();

    toggle.TurnOn();
    await Assert.That(toggle.IsOn).IsTrue();

    toggle.TurnOff();
    await Assert.That(toggle.IsOn).IsFalse();
}
```

### Authentication State

```csharp
[Test]
public async Task Authentication_State()
{
    var authService = new AuthenticationService();

    await Assert.That(authService.IsAuthenticated).IsFalse();

    await authService.LoginAsync("user", "password");

    await Assert.That(authService.IsAuthenticated).IsTrue();
}
```

### Validation Scenarios

```csharp
[Test]
public async Task Multiple_Validations()
{
    var form = new RegistrationForm
    {
        Email = "test@example.com",
        Password = "SecurePass123!",
        Age = 25
    };

    using (Assert.Multiple())
    {
        await Assert.That(form.IsEmailValid()).IsTrue();
        await Assert.That(form.IsPasswordStrong()).IsTrue();
        await Assert.That(form.IsAgeValid()).IsTrue();
        await Assert.That(form.IsComplete()).IsTrue();
    }
}
```

## See Also

- [Equality & Comparison](equality-and-comparison.md) - General equality testing
- [Null & Default](null-and-default.md) - Testing for null values
- [Collections](collections.md) - Collection-specific boolean tests (All, Any)
- [Type Assertions](types.md) - Type checking instead of `is` checks

---

## Collection Assertions


TUnit provides comprehensive assertions for testing collections, including membership, count, ordering, and equivalency checks. These assertions work with any `IEnumerable<T>`.

## Membership Assertions

### Contains (Item)

Tests that a collection contains a specific item:

```csharp
[Test]
public async Task Collection_Contains_Item()
{
    var numbers = new[] { 1, 2, 3, 4, 5 };

    await Assert.That(numbers).Contains(3);
    await Assert.That(numbers).Contains(1);
}
```

Works with any collection type:

```csharp
[Test]
public async Task Various_Collection_Types()
{
    var list = new List<string> { "apple", "banana", "cherry" };
    await Assert.That(list).Contains("banana");

    var hashSet = new HashSet<int> { 10, 20, 30 };
    await Assert.That(hashSet).Contains(20);

    var queue = new Queue<string>(new[] { "first", "second" });
    await Assert.That(queue).Contains("first");
}
```

### Contains (Predicate)

Tests that a collection contains an item matching a predicate, and returns that item:

```csharp
[Test]
public async Task Collection_Contains_Matching_Item()
{
    var users = new[]
    {
        new User { Name = "Alice", Age = 30 },
        new User { Name = "Bob", Age = 25 }
    };

    // Returns the found item
    var user = await Assert.That(users).Contains(u => u.Name == "Alice");

    // Can assert on the returned item
    await Assert.That(user.Age).IsEqualTo(30);
}
```

### DoesNotContain (Item)

Tests that a collection does not contain a specific item:

```csharp
[Test]
public async Task Collection_Does_Not_Contain()
{
    var numbers = new[] { 1, 2, 3, 4, 5 };

    await Assert.That(numbers).DoesNotContain(10);
    await Assert.That(numbers).DoesNotContain(0);
}
```

### DoesNotContain (Predicate)

Tests that no items match the predicate:

```csharp
[Test]
public async Task Collection_Does_Not_Contain_Matching()
{
    var users = new[]
    {
        new User { Name = "Alice", Age = 30 },
        new User { Name = "Bob", Age = 25 }
    };

    await Assert.That(users).DoesNotContain(u => u.Age > 50);
    await Assert.That(users).DoesNotContain(u => u.Name == "Charlie");
}
```

## Count Assertions

### Count

Tests that a collection has an exact count:

```csharp
[Test]
public async Task Collection_Has_Count()
{
    var numbers = new[] { 1, 2, 3, 4, 5 };

    await Assert.That(numbers).Count().IsEqualTo(5);
}
```

### Count with Comparison

Get the count for further assertions:

```csharp
[Test]
public async Task Count_With_Comparison()
{
    var numbers = new[] { 1, 2, 3, 4, 5 };

    await Assert.That(numbers)
        .Count().IsEqualTo(5);

    await Assert.That(numbers)
        .Count().IsGreaterThan(3)
        .And.Count().IsLessThan(10);
}
```

### Count with Inner Assertion

Count items that satisfy an assertion, allowing you to reuse existing assertion methods:

```csharp
[Test]
public async Task Count_With_Inner_Assertion()
{
    var numbers = new[] { 1, 2, 3, 4, 5, 6 };

    // Count numbers greater than 3 using assertion builder
    await Assert.That(numbers)
        .Count(item => item.IsGreaterThan(3))
        .IsEqualTo(3);

    // Count numbers between 2 and 5
    await Assert.That(numbers)
        .Count(item => item.IsBetween(2, 5))
        .IsEqualTo(4);
}

[Test]
public async Task Count_Strings_With_Inner_Assertion()
{
    var names = new[] { "Alice", "Bob", "Andrew", "Charlie" };

    // Count names starting with "A"
    await Assert.That(names)
        .Count(item => item.StartsWith("A"))
        .IsEqualTo(2);
}
```

### Count with Collection Chaining

Count assertions preserve the collection type, allowing you to chain additional collection assertions:

```csharp
[Test]
public async Task Count_With_Chaining()
{
    var numbers = new[] { 1, 2, 3, 4, 5 };

    // Assert count and then chain with other collection assertions
    await Assert.That(numbers)
        .Count().IsEqualTo(5)
        .And.Contains(3)
        .And.IsInOrder();

    // Count with item filter assertion, then chain
    await Assert.That(numbers)
        .Count(item => item.IsGreaterThan(2)).IsEqualTo(3)
        .And.Contains(5)
        .And.All(x => x > 0);

    // For non-int collections, you can also use inline count assertions
    var names = new[] { "Alice", "Bob", "Charlie" };
    await Assert.That(names)
        .Count(c => c.IsEqualTo(3))
        .And.Contains("Bob");
}
```

### IsEmpty

Tests that a collection has no items:

```csharp
[Test]
public async Task Collection_Is_Empty()
{
    var empty = new List<int>();

    await Assert.That(empty).IsEmpty();
    await Assert.That(empty).Count().IsEqualTo(0);
}
```

### IsNotEmpty

Tests that a collection has at least one item:

```csharp
[Test]
public async Task Collection_Is_Not_Empty()
{
    var numbers = new[] { 1 };

    await Assert.That(numbers).IsNotEmpty();
}
```

### HasSingleItem

Tests that a collection has exactly one item, and returns that item:

```csharp
[Test]
public async Task Collection_Has_Single_Item()
{
    var users = new[] { new User { Name = "Alice", Age = 30 } };

    var user = await Assert.That(users).HasSingleItem();

    await Assert.That(user.Name).IsEqualTo("Alice");
}
```

## Ordering Assertions

### IsInOrder

Tests that a collection is sorted in ascending order:

```csharp
[Test]
public async Task Collection_In_Ascending_Order()
{
    var numbers = new[] { 1, 2, 3, 4, 5 };

    await Assert.That(numbers).IsInOrder();
}
```

```csharp
[Test]
public async Task Strings_In_Order()
{
    var names = new[] { "Alice", "Bob", "Charlie" };

    await Assert.That(names).IsInOrder();
}
```

### IsInDescendingOrder

Tests that a collection is sorted in descending order:

```csharp
[Test]
public async Task Collection_In_Descending_Order()
{
    var numbers = new[] { 5, 4, 3, 2, 1 };

    await Assert.That(numbers).IsInDescendingOrder();
}
```

### IsOrderedBy

Tests that a collection is ordered by a specific property:

```csharp
[Test]
public async Task Ordered_By_Property()
{
    var users = new[]
    {
        new User { Name = "Alice", Age = 25 },
        new User { Name = "Bob", Age = 30 },
        new User { Name = "Charlie", Age = 35 }
    };

    await Assert.That(users).IsOrderedBy(u => u.Age);
}
```

### IsOrderedByDescending

Tests that a collection is ordered by a property in descending order:

```csharp
[Test]
public async Task Ordered_By_Descending()
{
    var users = new[]
    {
        new User { Name = "Charlie", Age = 35 },
        new User { Name = "Bob", Age = 30 },
        new User { Name = "Alice", Age = 25 }
    };

    await Assert.That(users).IsOrderedByDescending(u => u.Age);
}
```

## Predicate-Based Assertions

### All

Tests that all items satisfy a condition:

```csharp
[Test]
public async Task All_Items_Match()
{
    var numbers = new[] { 2, 4, 6, 8 };

    await Assert.That(numbers).All(n => n % 2 == 0);
}
```

#### With Satisfy

The single parameter overload will match T from `IEnumerable<T>` - Giving you the relevant assertions for that type.

```csharp
[Test]
public async Task All_Satisfy_With_Property()
{
    var users = new[]
    {
        new User { Name = "Alice", Age = 25 },
        new User { Name = "Bob", Age = 30 }
    };

    // Use the mapper overload to access item properties
    await Assert.That(users)
        .All()
        .Satisfy(user => user.IsNotNull());
}
```

You can also map to other types by accessing properties an such - And then assert on those specific values:

```csharp
[Test]
public async Task All_Satisfy_With_Mapper()
{
    var users = new[]
    {
        new User { Name = "Alice", Age = 25 },
        new User { Name = "Bob", Age = 30 }
    };

    await Assert.That(users)
        .All()
        .Satisfy(
            u => u.Age,
            age => age.IsGreaterThan(18)
        );
}
```

### Any

Tests that at least one item satisfies a condition:

```csharp
[Test]
public async Task Any_Item_Matches()
{
    var numbers = new[] { 1, 3, 5, 6, 7 };

    await Assert.That(numbers).Any(n => n % 2 == 0);
}
```

## Equivalency Assertions

Collection equivalency checks whether two collections contain the same elements. By default, **order is ignored** - only the presence and count of elements matter. To require matching order, use the `CollectionOrdering.Matching` parameter.

### IsEquivalentTo

Tests that two collections contain the same items. By default, order is ignored (use `CollectionOrdering.Matching` to require matching order):

```csharp
[Test]
public async Task Collections_Are_Equivalent()
{
    var actual = new[] { 1, 2, 3, 4, 5 };
    var expected = new[] { 5, 4, 3, 2, 1 };

    await Assert.That(actual).IsEquivalentTo(expected);
}
```

Different collection types:

```csharp
[Test]
public async Task Different_Collection_Types()
{
    var list = new List<int> { 1, 2, 3 };
    var array = new[] { 3, 2, 1 };

    await Assert.That(list).IsEquivalentTo(array);
}
```

#### With Custom Comparer

```csharp
[Test]
public async Task Equivalent_With_Comparer()
{
    var actual = new[] { "apple", "banana", "cherry" };
    var expected = new[] { "APPLE", "BANANA", "CHERRY" };

    await Assert.That(actual)
        .IsEquivalentTo(expected)
        .Using(StringComparer.OrdinalIgnoreCase);
}
```

#### With Custom Equality Predicate

```csharp
[Test]
public async Task Equivalent_With_Predicate()
{
    var users1 = new[]
    {
        new User { Name = "Alice", Age = 30 },
        new User { Name = "Bob", Age = 25 }
    };

    var users2 = new[]
    {
        new User { Name = "Bob", Age = 25 },
        new User { Name = "Alice", Age = 30 }
    };

    await Assert.That(users1)
        .IsEquivalentTo(users2)
        .Using((u1, u2) => u1.Name == u2.Name && u1.Age == u2.Age);
}
```

#### Order-Independent Comparison (Default)

By default, `IsEquivalentTo` ignores the order of elements:

```csharp
[Test]
public async Task Equivalent_Ignoring_Order()
{
    var actual = new[] { 1, 2, 3 };
    var expected = new[] { 3, 2, 1 };

    // Order is ignored by default
    await Assert.That(actual).IsEquivalentTo(expected);
}
```

#### Requiring Matching Order

To require elements to be in the same order, pass `CollectionOrdering.Matching`:

```csharp
[Test]
public async Task Equivalent_With_Matching_Order()
{
    var actual = new[] { 1, 2, 3 };
    var expected = new[] { 1, 2, 3 };

    await Assert.That(actual).IsEquivalentTo(expected, CollectionOrdering.Matching);
}
```

This will fail if elements are in different positions:

```csharp
[Test]
public async Task Not_Equivalent_Different_Order()
{
    var actual = new[] { 1, 2, 3 };
    var expected = new[] { 3, 2, 1 };

    // This will fail when requiring matching order
    // await Assert.That(actual).IsEquivalentTo(expected, CollectionOrdering.Matching);
}
```

### IsNotEquivalentTo

Tests that collections are not equivalent:

```csharp
[Test]
public async Task Collections_Not_Equivalent()
{
    var actual = new[] { 1, 2, 3 };
    var different = new[] { 4, 5, 6 };

    await Assert.That(actual).IsNotEquivalentTo(different);
}
```

### Practical Tips for Collection Ordering

#### When to Use `CollectionOrdering.Any` (Default)

The default behavior (ignoring order) is ideal for:
- Testing set operations and results
- Verifying database query results where order isn't guaranteed
- Checking API responses where element order doesn't matter
- Testing collection transformations that may reorder elements

```csharp
[Test]
public async Task Database_Query_Results()
{
    var results = await database.GetActiveUsersAsync();

    // Order doesn't matter for this assertion
    await Assert.That(results)
        .IsEquivalentTo(new[] { user1, user2, user3 });
}
```

#### When to Use `CollectionOrdering.Matching`

Use order-sensitive comparison when:
- Testing sorting algorithms
- Verifying ordered results (e.g., ORDER BY queries)
- Checking sequences where position matters
- Testing priority queues or ordered data structures

```csharp
[Test]
public async Task Sorted_Query_Results()
{
    var results = await database.GetUsersSortedByNameAsync();

    // Order matters here
    await Assert.That(results)
        .IsEquivalentTo(
            new[] { alice, bob, charlie },
            CollectionOrdering.Matching
        );
}
```

#### Multiple Assertions with Same Ordering

If you need multiple order-sensitive assertions in the same test, consider extracting a helper or being explicit:

```csharp
[Test]
public async Task Multiple_Order_Sensitive_Checks()
{
    var list1 = GetSortedList1();
    var list2 = GetSortedList2();

    // Be explicit about ordering requirements
    await Assert.That(list1).IsEquivalentTo(expected1, CollectionOrdering.Matching);
    await Assert.That(list2).IsEquivalentTo(expected2, CollectionOrdering.Matching);
}
```

For ordered comparisons, you can also use `IsInOrder()`:

```csharp
[Test]
public async Task Verify_Ordering_Separately()
{
    var actual = new[] { 1, 2, 3 };

    // Check both equivalency and ordering
    await Assert.That(actual).IsEquivalentTo(new[] { 1, 2, 3 });
    await Assert.That(actual).IsInOrder();
}
```

## Structural Equivalency

### IsStructurallyEqualTo

Deep comparison of collections including nested objects:

```csharp
[Test]
public async Task Structurally_Equal()
{
    var actual = new[]
    {
        new { Name = "Alice", Address = new { City = "Seattle" } },
        new { Name = "Bob", Address = new { City = "Portland" } }
    };

    var expected = new[]
    {
        new { Name = "Alice", Address = new { City = "Seattle" } },
        new { Name = "Bob", Address = new { City = "Portland" } }
    };

    await Assert.That(actual).IsStructurallyEqualTo(expected);
}
```

### IsNotStructurallyEqualTo

```csharp
[Test]
public async Task Not_Structurally_Equal()
{
    var actual = new[]
    {
        new { Name = "Alice", Age = 30 }
    };

    var different = new[]
    {
        new { Name = "Alice", Age = 31 }
    };

    await Assert.That(actual).IsNotStructurallyEqualTo(different);
}
```

## Distinctness

### HasDistinctItems

Tests that all items in a collection are unique:

```csharp
[Test]
public async Task All_Items_Distinct()
{
    var numbers = new[] { 1, 2, 3, 4, 5 };

    await Assert.That(numbers).HasDistinctItems();
}
```

Fails if duplicates exist:

```csharp
[Test]
public async Task Duplicates_Fail()
{
    var numbers = new[] { 1, 2, 2, 3 };

    // This will fail
    // await Assert.That(numbers).HasDistinctItems();
}
```

## Practical Examples

### Filtering Results

```csharp
[Test]
public async Task Filter_And_Assert()
{
    var numbers = new[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
    var evens = numbers.Where(n => n % 2 == 0).ToArray();

    await Assert.That(evens)
        .Count().IsEqualTo(5)
        .And.All(n => n % 2 == 0);
}
```

### LINQ Query Results

```csharp
[Test]
public async Task LINQ_Query_Results()
{
    var users = new[]
    {
        new User { Name = "Alice", Age = 25 },
        new User { Name = "Bob", Age = 30 },
        new User { Name = "Charlie", Age = 35 }
    };

    var adults = users.Where(u => u.Age >= 18).ToArray();

    await Assert.That(adults)
        .Count().IsEqualTo(3)
        .And.All(u => u.Age >= 18);
}
```

### Sorting Validation

```csharp
[Test]
public async Task Verify_Sorting()
{
    var unsorted = new[] { 5, 2, 8, 1, 9 };
    var sorted = unsorted.OrderBy(x => x).ToArray();

    await Assert.That(sorted).IsInOrder();
    await Assert.That(sorted).IsEquivalentTo(unsorted);
}
```

### API Response Validation

```csharp
[Test]
public async Task API_Returns_Expected_Items()
{
    var response = await _api.GetUsersAsync();

    await Assert.That(response)
        .IsNotEmpty()
        .And.All(u => u.Id > 0)
        .And.All(u => !string.IsNullOrEmpty(u.Name));
}
```

### Collection Transformation

```csharp
[Test]
public async Task Map_And_Verify()
{
    var users = new[]
    {
        new User { Name = "Alice", Age = 25 },
        new User { Name = "Bob", Age = 30 }
    };

    var names = users.Select(u => u.Name).ToArray();

    await Assert.That(names)
        .Count().IsEqualTo(2)
        .And.Contains("Alice")
        .And.Contains("Bob")
        .And.All(name => !string.IsNullOrEmpty(name));
}
```

## Empty vs Null Collections

```csharp
[Test]
public async Task Empty_vs_Null()
{
    List<int>? nullList = null;
    List<int> emptyList = new();
    List<int> populated = new() { 1, 2, 3 };

    await Assert.That(nullList).IsNull();
    await Assert.That(emptyList).IsNotNull();
    await Assert.That(emptyList).IsEmpty();
    await Assert.That(populated).IsNotEmpty();
}
```

## Nested Collections

```csharp
[Test]
public async Task Nested_Collections()
{
    var matrix = new[]
    {
        new[] { 1, 2, 3 },
        new[] { 4, 5, 6 },
        new[] { 7, 8, 9 }
    };

    await Assert.That(matrix).Count().IsEqualTo(3);
    await Assert.That(matrix).All(row => row.Length == 3);

    // Flatten and assert
    var flattened = matrix.SelectMany(x => x).ToArray();
    await Assert.That(flattened).Count().IsEqualTo(9);
}
```

## Collection of Collections

```csharp
[Test]
public async Task Collection_Of_Collections()
{
    var groups = new List<List<int>>
    {
        new() { 1, 2 },
        new() { 3, 4, 5 },
        new() { 6 }
    };

    await Assert.That(groups)
        .Count().IsEqualTo(3)
        .And.All(group => group.Count > 0);
}
```

## Chaining Collection Assertions

```csharp
[Test]
public async Task Chained_Collection_Assertions()
{
    var numbers = new[] { 1, 2, 3, 4, 5 };

    await Assert.That(numbers)
        .IsNotEmpty()
        .And.Count().IsEqualTo(5)
        .And.Contains(3)
        .And.DoesNotContain(10)
        .And.IsInOrder()
        .And.All(n => n > 0)
        .And.Any(n => n == 5);
}
```

## Performance Considerations

### Materialize IEnumerable

```csharp
[Test]
public async Task Materialize_Before_Multiple_Assertions()
{
    // This query is deferred
    IEnumerable<int> query = Enumerable.Range(1, 1000000)
        .Where(n => n % 2 == 0);

    // Materialize once to avoid re-execution
    var materialized = query.ToArray();

    await Assert.That(materialized).Count().IsGreaterThan(1000);
    await Assert.That(materialized).Contains(100);
    await Assert.That(materialized).All(n => n % 2 == 0);
}
```

## Working with HashSet and SortedSet

```csharp
[Test]
public async Task HashSet_Assertions()
{
    var set = new HashSet<int> { 1, 2, 3, 4, 5 };

    await Assert.That(set)
        .Count().IsEqualTo(5)
        .And.Contains(3)
        .And.HasDistinctItems();
}

[Test]
public async Task SortedSet_Assertions()
{
    var sorted = new SortedSet<int> { 5, 2, 8, 1, 9 };

    await Assert.That(sorted)
        .IsInOrder()
        .And.HasDistinctItems();
}
```

## Common Patterns

### Validate All Items

```csharp
[Test]
public async Task Validate_Each_Item()
{
    var users = GetUsers();

    using (Assert.Multiple())
    {
        foreach (var user in users)
        {
            await Assert.That(user.Name).IsNotEmpty();
            await Assert.That(user.Age).IsGreaterThan(0);
        }
    }
}
```

Or more elegantly:

```csharp
[Test]
public async Task Validate_All_With_Assertion()
{
    var users = GetUsers();

    await Assert.That(users).All(u =>
        !string.IsNullOrEmpty(u.Name) && u.Age > 0
    );
}
```

### Find and Assert

```csharp
[Test]
public async Task Find_And_Assert()
{
    var users = GetUsers();

    var admin = await Assert.That(users)
        .Contains(u => u.Role == "Admin");

    await Assert.That(admin.Permissions).IsNotEmpty();
}
```

## See Also

- [Dictionaries](dictionaries.md) - Dictionary-specific assertions
- [Strings](string.md) - String collections
- [Equality & Comparison](equality-and-comparison.md) - Item comparison

---

## DateTime and Time Assertions


TUnit provides comprehensive assertions for date and time types, including `DateTime`, `DateTimeOffset`, `DateOnly`, `TimeOnly`, and `TimeSpan`, with support for tolerance-based comparisons and specialized checks.

## DateTime Equality with Tolerance

DateTime comparisons often need tolerance to account for timing variations:

```csharp
[Test]
public async Task DateTime_With_Tolerance()
{
    var now = DateTime.Now;
    var almostNow = now.AddMilliseconds(50);

    // Without tolerance - might fail
    // await Assert.That(almostNow).IsEqualTo(now);

    // With tolerance - passes
    await Assert.That(almostNow).IsEqualTo(now).Within(TimeSpan.FromSeconds(1));
}
```

### Tolerance Examples

```csharp
[Test]
public async Task Various_Tolerance_Values()
{
    var baseTime = new DateTime(2024, 1, 15, 10, 30, 0);

    // Millisecond tolerance
    var time1 = baseTime.AddMilliseconds(100);
    await Assert.That(time1).IsEqualTo(baseTime).Within(TimeSpan.FromMilliseconds(500));

    // Second tolerance
    var time2 = baseTime.AddSeconds(5);
    await Assert.That(time2).IsEqualTo(baseTime).Within(TimeSpan.FromSeconds(10));

    // Minute tolerance
    var time3 = baseTime.AddMinutes(2);
    await Assert.That(time3).IsEqualTo(baseTime).Within(TimeSpan.FromMinutes(5));
}
```

## DateTime Comparison

Standard comparison operators work with DateTime:

```csharp
[Test]
public async Task DateTime_Comparison()
{
    var past = DateTime.Now.AddDays(-1);
    var now = DateTime.Now;
    var future = DateTime.Now.AddDays(1);

    await Assert.That(now).IsGreaterThan(past);
    await Assert.That(now).IsLessThan(future);
    await Assert.That(past).IsLessThan(future);
}
```

## DateTime-Specific Assertions

### IsToday / IsNotToday

```csharp
[Test]
public async Task DateTime_Is_Today()
{
    var today = DateTime.Now;
    await Assert.That(today).IsToday();

    var yesterday = DateTime.Now.AddDays(-1);
    await Assert.That(yesterday).IsNotToday();

    var tomorrow = DateTime.Now.AddDays(1);
    await Assert.That(tomorrow).IsNotToday();
}
```

### IsUtc / IsNotUtc

```csharp
[Test]
public async Task DateTime_Kind()
{
    var utc = DateTime.UtcNow;
    await Assert.That(utc).IsUtc();

    var local = DateTime.Now;
    await Assert.That(local).IsNotUtc();

    var unspecified = new DateTime(2024, 1, 15);
    await Assert.That(unspecified).IsNotUtc();
}
```

### IsLeapYear / IsNotLeapYear

```csharp
[Test]
public async Task Leap_Year_Check()
{
    var leapYear = new DateTime(2024, 1, 1);
    await Assert.That(leapYear).IsLeapYear();

    var nonLeapYear = new DateTime(2023, 1, 1);
    await Assert.That(nonLeapYear).IsNotLeapYear();
}
```

### IsInFuture / IsInPast

Compares against local time:

```csharp
[Test]
public async Task Future_and_Past()
{
    var future = DateTime.Now.AddHours(1);
    await Assert.That(future).IsInFuture();

    var past = DateTime.Now.AddHours(-1);
    await Assert.That(past).IsInPast();
}
```

### IsInFutureUtc / IsInPastUtc

Compares against UTC time:

```csharp
[Test]
public async Task Future_and_Past_UTC()
{
    var futureUtc = DateTime.UtcNow.AddHours(1);
    await Assert.That(futureUtc).IsInFutureUtc();

    var pastUtc = DateTime.UtcNow.AddHours(-1);
    await Assert.That(pastUtc).IsInPastUtc();
}
```

### IsOnWeekend / IsOnWeekday

```csharp
[Test]
public async Task Weekend_Check()
{
    var saturday = new DateTime(2024, 1, 6); // Saturday
    await Assert.That(saturday).IsOnWeekend();

    var monday = new DateTime(2024, 1, 8); // Monday
    await Assert.That(monday).IsOnWeekday();
    await Assert.That(monday).IsNotOnWeekend();
}
```

### IsDaylightSavingTime / IsNotDaylightSavingTime

```csharp
[Test]
public async Task Daylight_Saving_Time()
{
    var summer = new DateTime(2024, 7, 1); // Summer in Northern Hemisphere
    var winter = new DateTime(2024, 1, 1); // Winter

    // Results depend on timezone
    if (TimeZoneInfo.Local.IsDaylightSavingTime(summer))
    {
        await Assert.That(summer).IsDaylightSavingTime();
    }
}
```

## DateTimeOffset

DateTimeOffset includes timezone information:

```csharp
[Test]
public async Task DateTimeOffset_With_Tolerance()
{
    var now = DateTimeOffset.Now;
    var almostNow = now.AddSeconds(1);

    await Assert.That(almostNow).IsEqualTo(now).Within(TimeSpan.FromSeconds(5));
}
```

```csharp
[Test]
public async Task DateTimeOffset_Comparison()
{
    var earlier = new DateTimeOffset(2024, 1, 1, 12, 0, 0, TimeSpan.FromHours(-8));
    var later = new DateTimeOffset(2024, 1, 1, 12, 0, 0, TimeSpan.FromHours(0));

    // Same local time, but different UTC times
    await Assert.That(later).IsGreaterThan(earlier);
}
```

## DateOnly (.NET 6+)

DateOnly represents just a date without time:

```csharp
[Test]
public async Task DateOnly_Assertions()
{
    var date1 = new DateOnly(2024, 1, 15);
    var date2 = new DateOnly(2024, 1, 15);

    await Assert.That(date1).IsEqualTo(date2);
}
```

### DateOnly with Days Tolerance

```csharp
[Test]
public async Task DateOnly_With_Tolerance()
{
    var date1 = new DateOnly(2024, 1, 15);
    var date2 = new DateOnly(2024, 1, 17);

    await Assert.That(date2).IsEqualTo(date1, daysTolerance: 5);
}
```

### DateOnly Comparison

```csharp
[Test]
public async Task DateOnly_Comparison()
{
    var earlier = new DateOnly(2024, 1, 1);
    var later = new DateOnly(2024, 12, 31);

    await Assert.That(later).IsGreaterThan(earlier);
    await Assert.That(earlier).IsLessThan(later);
}
```

## TimeOnly (.NET 6+)

TimeOnly represents just time without a date:

```csharp
[Test]
public async Task TimeOnly_Assertions()
{
    var morning = new TimeOnly(9, 30, 0);
    var evening = new TimeOnly(17, 45, 0);

    await Assert.That(evening).IsGreaterThan(morning);
}
```

### TimeOnly with Tolerance

```csharp
[Test]
public async Task TimeOnly_With_Tolerance()
{
    var time1 = new TimeOnly(10, 30, 0);
    var time2 = new TimeOnly(10, 30, 5);

    await Assert.That(time2).IsEqualTo(time1).Within(TimeSpan.FromSeconds(10));
}
```

## TimeSpan

TimeSpan represents a duration:

```csharp
[Test]
public async Task TimeSpan_Assertions()
{
    var duration1 = TimeSpan.FromMinutes(30);
    var duration2 = TimeSpan.FromMinutes(30);

    await Assert.That(duration1).IsEqualTo(duration2);
}
```

### TimeSpan Comparison

```csharp
[Test]
public async Task TimeSpan_Comparison()
{
    var short_duration = TimeSpan.FromMinutes(5);
    var long_duration = TimeSpan.FromHours(1);

    await Assert.That(long_duration).IsGreaterThan(short_duration);
    await Assert.That(short_duration).IsLessThan(long_duration);
}
```

### TimeSpan Sign Checks

```csharp
[Test]
public async Task TimeSpan_Sign()
{
    var positive = TimeSpan.FromHours(1);
    await Assert.That(positive).IsPositive();

    var negative = TimeSpan.FromHours(-1);
    await Assert.That(negative).IsNegative();
}
```

## Practical Examples

### Expiration Checks

```csharp
[Test]
public async Task Check_Token_Expiration()
{
    var token = CreateToken();
    var expiresAt = token.ExpiresAt;

    await Assert.That(expiresAt).IsInFuture();

    // Or check if expired
    var expiredToken = CreateExpiredToken();
    await Assert.That(expiredToken.ExpiresAt).IsInPast();
}
```

### Age Calculation

```csharp
[Test]
public async Task Calculate_Age()
{
    var birthDate = new DateTime(1990, 1, 1);
    var age = DateTime.Now.Year - birthDate.Year;

    if (DateTime.Now.DayOfYear < birthDate.DayOfYear)
    {
        age--;
    }

    await Assert.That(age).IsGreaterThanOrEqualTo(0);
    await Assert.That(age).IsLessThan(150); // Reasonable max age
}
```

### Business Days

```csharp
[Test]
public async Task Is_Business_Day()
{
    var monday = new DateTime(2024, 1, 8);

    await Assert.That(monday).IsOnWeekday();
    await Assert.That(monday.DayOfWeek).IsNotEqualTo(DayOfWeek.Saturday);
    await Assert.That(monday.DayOfWeek).IsNotEqualTo(DayOfWeek.Sunday);
}
```

### Scheduling

```csharp
[Test]
public async Task Scheduled_Time()
{
    var scheduledTime = new DateTime(2024, 12, 25, 9, 0, 0);

    await Assert.That(scheduledTime.Month).IsEqualTo(12);
    await Assert.That(scheduledTime.Day).IsEqualTo(25);
    await Assert.That(scheduledTime.Hour).IsEqualTo(9);
}
```

### Performance Timing

```csharp
[Test]
public async Task Operation_Duration()
{
    var start = DateTime.Now;
    await PerformOperationAsync();
    var end = DateTime.Now;

    var duration = end - start;

    await Assert.That(duration).IsLessThan(TimeSpan.FromSeconds(5));
    await Assert.That(duration).IsPositive();
}
```

### Date Range Validation

```csharp
[Test]
public async Task Date_Within_Range()
{
    var startDate = new DateTime(2024, 1, 1);
    var endDate = new DateTime(2024, 12, 31);
    var checkDate = new DateTime(2024, 6, 15);

    await Assert.That(checkDate).IsGreaterThan(startDate);
    await Assert.That(checkDate).IsLessThan(endDate);
}
```

### Timestamp Validation

```csharp
[Test]
public async Task Record_Created_Recently()
{
    var record = await CreateRecordAsync();
    var createdAt = record.CreatedAt;
    var now = DateTime.UtcNow;

    // Created within last minute
    await Assert.That(createdAt).IsEqualTo(now).Within(TimeSpan.FromMinutes(1));
    await Assert.That(createdAt).IsInPastUtc();
}
```

### Time Zone Conversions

```csharp
[Test]
public async Task Time_Zone_Conversion()
{
    var utcTime = DateTime.UtcNow;
    var localTime = utcTime.ToLocalTime();

    await Assert.That(utcTime).IsUtc();
    await Assert.That(localTime).IsNotUtc();

    var offset = localTime - utcTime;
    await Assert.That(Math.Abs(offset.TotalHours)).IsLessThan(24);
}
```

## Working with Date Components

```csharp
[Test]
public async Task Date_Components()
{
    var date = new DateTime(2024, 7, 15, 14, 30, 45);

    await Assert.That(date.Year).IsEqualTo(2024);
    await Assert.That(date.Month).IsEqualTo(7);
    await Assert.That(date.Day).IsEqualTo(15);
    await Assert.That(date.Hour).IsEqualTo(14);
    await Assert.That(date.Minute).IsEqualTo(30);
    await Assert.That(date.Second).IsEqualTo(45);
}
```

## First and Last Day of Month

```csharp
[Test]
public async Task First_Day_Of_Month()
{
    var date = new DateTime(2024, 3, 15);
    var firstDay = new DateTime(date.Year, date.Month, 1);

    await Assert.That(firstDay.Day).IsEqualTo(1);
}

[Test]
public async Task Last_Day_Of_Month()
{
    var date = new DateTime(2024, 2, 15);
    var daysInMonth = DateTime.DaysInMonth(date.Year, date.Month);
    var lastDay = new DateTime(date.Year, date.Month, daysInMonth);

    await Assert.That(lastDay.Day).IsEqualTo(29); // 2024 is a leap year
}
```

## Quarter Calculation

```csharp
[Test]
public async Task Date_Quarter()
{
    var q1 = new DateTime(2024, 2, 1);
    var quarter1 = (q1.Month - 1) / 3 + 1;
    await Assert.That(quarter1).IsEqualTo(1);

    var q3 = new DateTime(2024, 8, 1);
    var quarter3 = (q3.Month - 1) / 3 + 1;
    await Assert.That(quarter3).IsEqualTo(3);
}
```

## DayOfWeek Assertions

DayOfWeek has its own assertions:

```csharp
[Test]
public async Task Day_Of_Week_Checks()
{
    var dayOfWeek = DateTime.Now.DayOfWeek;

    if (dayOfWeek is DayOfWeek.Saturday or DayOfWeek.Sunday)
    {
        await Assert.That(dayOfWeek).IsWeekend();
    }
    else
    {
        await Assert.That(dayOfWeek).IsWeekday();
    }
}
```

## Chaining DateTime Assertions

```csharp
[Test]
public async Task Chained_DateTime_Assertions()
{
    var date = DateTime.Now;

    await Assert.That(date)
        .IsToday()
        .And.IsGreaterThan(DateTime.MinValue)
        .And.IsLessThan(DateTime.MaxValue);
}
```

## Common Patterns

### Birthday Validation

```csharp
[Test]
public async Task Validate_Birthday()
{
    var birthday = new DateTime(1990, 5, 15);

    await Assert.That(birthday).IsInPast();
    await Assert.That(birthday).IsGreaterThan(new DateTime(1900, 1, 1));
}
```

### Meeting Scheduler

```csharp
[Test]
public async Task Schedule_Meeting()
{
    var meetingTime = new DateTime(2024, 1, 15, 14, 0, 0);

    await Assert.That(meetingTime).IsInFuture();
    await Assert.That(meetingTime).IsOnWeekday();
    await Assert.That(meetingTime.Hour).IsBetween(9, 17); // Business hours
}
```

### Relative Time Checks

```csharp
[Test]
public async Task Within_Last_Hour()
{
    var timestamp = DateTime.Now.AddMinutes(-30);
    var hourAgo = DateTime.Now.AddHours(-1);

    await Assert.That(timestamp).IsGreaterThan(hourAgo);
}
```

## See Also

- [Equality & Comparison](equality-and-comparison.md) - General comparison with tolerance
- [Numeric Assertions](numeric.md) - Numeric components of dates
- [Specialized Types](specialized-types.md) - Other time-related types

---

## Delegates


TUnit can execute your delegates for you, and this allows you to assert on the data returned (if any was) - Or on any exceptions thrown:

```csharp
    [Test]
    public async Task MyTest()
    {
        await Assert.That(() =>
        {
            // Do something here
        }).ThrowsNothing();
    }

    // or

    [Test]
    public async Task MyTest()
    {
        await Assert.That(() =>
        {
            // Do something here
        }).Throws<ArgumentNullException>();
    }

    // or 

    [Test]
    public async Task MyTest()
    {
        var argumentNullException = await Assert.ThrowsAsync<ArgumentNullException>(() =>
        {
            // Do something here
            return Task.CompletedTask;
        });
    }
```

---

## Dictionary Assertions


TUnit provides specialized assertions for testing dictionaries (`IReadOnlyDictionary<TKey, TValue>`), including key and value membership checks. Dictionaries also inherit all collection assertions.

## Key Assertions

### ContainsKey

Tests that a dictionary contains a specific key:

```csharp
[Test]
public async Task Dictionary_Contains_Key()
{
    var dict = new Dictionary<string, int>
    {
        ["apple"] = 1,
        ["banana"] = 2,
        ["cherry"] = 3
    };

    await Assert.That(dict).ContainsKey("apple");
    await Assert.That(dict).ContainsKey("banana");
}
```

#### With Custom Comparer

```csharp
[Test]
public async Task Contains_Key_With_Comparer()
{
    var dict = new Dictionary<string, int>
    {
        ["Apple"] = 1,
        ["Banana"] = 2
    };

    await Assert.That(dict)
        .ContainsKey("apple")
        .Using(StringComparer.OrdinalIgnoreCase);
}
```

### DoesNotContainKey

Tests that a dictionary does not contain a specific key:

```csharp
[Test]
public async Task Dictionary_Does_Not_Contain_Key()
{
    var dict = new Dictionary<string, int>
    {
        ["apple"] = 1,
        ["banana"] = 2
    };

    await Assert.That(dict).DoesNotContainKey("cherry");
    await Assert.That(dict).DoesNotContainKey("orange");
}
```

## Value Assertions

### ContainsValue

Tests that a dictionary contains a specific value:

```csharp
[Test]
public async Task Dictionary_Contains_Value()
{
    var dict = new Dictionary<string, int>
    {
        ["apple"] = 1,
        ["banana"] = 2,
        ["cherry"] = 3
    };

    await Assert.That(dict).ContainsValue(2);
    await Assert.That(dict).ContainsValue(3);
}
```

## Collection Assertions on Dictionaries

Dictionaries inherit all collection assertions since they implement `IEnumerable<KeyValuePair<TKey, TValue>>`:

### Count

```csharp
[Test]
public async Task Dictionary_Count()
{
    var dict = new Dictionary<string, int>
    {
        ["a"] = 1,
        ["b"] = 2,
        ["c"] = 3
    };

    await Assert.That(dict).Count().IsEqualTo(3);
}
```

### IsEmpty / IsNotEmpty

```csharp
[Test]
public async Task Dictionary_Empty()
{
    var empty = new Dictionary<string, int>();
    var populated = new Dictionary<string, int> { ["key"] = 1 };

    await Assert.That(empty).IsEmpty();
    await Assert.That(populated).IsNotEmpty();
}
```

### Contains (KeyValuePair)

```csharp
[Test]
public async Task Dictionary_Contains_Pair()
{
    var dict = new Dictionary<string, int>
    {
        ["apple"] = 1,
        ["banana"] = 2
    };

    await Assert.That(dict).Contains(new KeyValuePair<string, int>("apple", 1));
}
```

### All Pairs Match Condition

```csharp
[Test]
public async Task All_Values_Positive()
{
    var dict = new Dictionary<string, int>
    {
        ["a"] = 1,
        ["b"] = 2,
        ["c"] = 3
    };

    await Assert.That(dict).All(kvp => kvp.Value > 0);
}
```

### Any Pair Matches Condition

```csharp
[Test]
public async Task Any_Key_Starts_With()
{
    var dict = new Dictionary<string, int>
    {
        ["apple"] = 1,
        ["banana"] = 2,
        ["cherry"] = 3
    };

    await Assert.That(dict).Any(kvp => kvp.Key.StartsWith("b"));
}
```

## Practical Examples

### Configuration Validation

```csharp
[Test]
public async Task Configuration_Has_Required_Keys()
{
    var config = LoadConfiguration();

    using (Assert.Multiple())
    {
        await Assert.That(config).ContainsKey("DatabaseConnection");
        await Assert.That(config).ContainsKey("ApiKey");
        await Assert.That(config).ContainsKey("Environment");
    }
}
```

### HTTP Headers Validation

```csharp
[Test]
public async Task Response_Headers()
{
    var headers = new Dictionary<string, string>
    {
        ["Content-Type"] = "application/json",
        ["Cache-Control"] = "no-cache"
    };

    await Assert.That(headers)
        .ContainsKey("Content-Type")
        .And.ContainsValue("application/json");
}
```

### Lookup Table Validation

```csharp
[Test]
public async Task Lookup_Table()
{
    var statusCodes = new Dictionary<int, string>
    {
        [200] = "OK",
        [404] = "Not Found",
        [500] = "Internal Server Error"
    };

    await Assert.That(statusCodes)
        .Count().IsEqualTo(3)
        .And.ContainsKey(200)
        .And.ContainsValue("OK");
}
```

### Cache Validation

```csharp
[Test]
public async Task Cache_Contains_Entry()
{
    var cache = new Dictionary<string, object>
    {
        ["user:123"] = new User { Id = 123 },
        ["user:456"] = new User { Id = 456 }
    };

    await Assert.That(cache)
        .ContainsKey("user:123")
        .And.Count().IsEqualTo(2)
        .And.IsNotEmpty();
}
```

## Dictionary Key/Value Operations

### Accessing Values After Key Check

```csharp
[Test]
public async Task Get_Value_After_Key_Check()
{
    var dict = new Dictionary<string, User>
    {
        ["alice"] = new User { Name = "Alice", Age = 30 }
    };

    // First verify key exists
    await Assert.That(dict).ContainsKey("alice");

    // Then safely access
    var user = dict["alice"];
    await Assert.That(user.Age).IsEqualTo(30);
}
```

### TryGetValue Pattern

```csharp
[Test]
public async Task TryGetValue_Pattern()
{
    var dict = new Dictionary<string, int>
    {
        ["count"] = 42
    };

    var found = dict.TryGetValue("count", out var value);

    await Assert.That(found).IsTrue();
    await Assert.That(value).IsEqualTo(42);
}
```

## Working with Dictionary Keys and Values

### Keys Collection

```csharp
[Test]
public async Task Dictionary_Keys()
{
    var dict = new Dictionary<string, int>
    {
        ["a"] = 1,
        ["b"] = 2,
        ["c"] = 3
    };

    var keys = dict.Keys;

    await Assert.That(keys)
        .Count().IsEqualTo(3)
        .And.Contains("a")
        .And.Contains("b")
        .And.Contains("c");
}
```

### Values Collection

```csharp
[Test]
public async Task Dictionary_Values()
{
    var dict = new Dictionary<string, int>
    {
        ["a"] = 1,
        ["b"] = 2,
        ["c"] = 3
    };

    var values = dict.Values;

    await Assert.That(values)
        .Count().IsEqualTo(3)
        .And.Contains(1)
        .And.Contains(2)
        .And.All(v => v > 0);
}
```

## Equivalency Checks

### Same Key-Value Pairs

```csharp
[Test]
public async Task Dictionaries_Are_Equivalent()
{
    var dict1 = new Dictionary<string, int>
    {
        ["a"] = 1,
        ["b"] = 2
    };

    var dict2 = new Dictionary<string, int>
    {
        ["b"] = 2,
        ["a"] = 1
    };

    // Dictionaries are equivalent (same pairs, order doesn't matter)
    await Assert.That(dict1).IsEquivalentTo(dict2);
}
```

## Chaining Dictionary Assertions

```csharp
[Test]
public async Task Chained_Dictionary_Assertions()
{
    var dict = new Dictionary<string, int>
    {
        ["apple"] = 1,
        ["banana"] = 2,
        ["cherry"] = 3
    };

    await Assert.That(dict)
        .IsNotEmpty()
        .And.Count().IsEqualTo(3)
        .And.ContainsKey("apple")
        .And.ContainsKey("banana")
        .And.ContainsValue(2)
        .And.All(kvp => kvp.Value > 0);
}
```

## Specialized Dictionary Types

### ConcurrentDictionary

```csharp
[Test]
public async Task Concurrent_Dictionary()
{
    var concurrent = new ConcurrentDictionary<string, int>();
    concurrent.TryAdd("a", 1);
    concurrent.TryAdd("b", 2);

    await Assert.That(concurrent)
        .Count().IsEqualTo(2)
        .And.ContainsKey("a");
}
```

### ReadOnlyDictionary

```csharp
[Test]
public async Task ReadOnly_Dictionary()
{
    var dict = new Dictionary<string, int> { ["a"] = 1 };
    var readOnly = new ReadOnlyDictionary<string, int>(dict);

    await Assert.That(readOnly)
        .Count().IsEqualTo(1)
        .And.ContainsKey("a");
}
```

### SortedDictionary

```csharp
[Test]
public async Task Sorted_Dictionary()
{
    var sorted = new SortedDictionary<int, string>
    {
        [3] = "three",
        [1] = "one",
        [2] = "two"
    };

    var keys = sorted.Keys.ToArray();

    await Assert.That(keys).IsInOrder();
}
```

## Null Checks

### Null Dictionary

```csharp
[Test]
public async Task Null_Dictionary()
{
    Dictionary<string, int>? dict = null;

    await Assert.That(dict).IsNull();
}
```

### Empty vs Null

```csharp
[Test]
public async Task Empty_vs_Null_Dictionary()
{
    Dictionary<string, int>? nullDict = null;
    var emptyDict = new Dictionary<string, int>();

    await Assert.That(nullDict).IsNull();
    await Assert.That(emptyDict).IsNotNull();
    await Assert.That(emptyDict).IsEmpty();
}
```

## Common Patterns

### Required Configuration Keys

```csharp
[Test]
public async Task All_Required_Keys_Present()
{
    var config = LoadConfiguration();
    var requiredKeys = new[] { "ApiKey", "Database", "Environment" };

    foreach (var key in requiredKeys)
    {
        await Assert.That(config).ContainsKey(key);
    }
}
```

Or with `Assert.Multiple`:

```csharp
[Test]
public async Task All_Required_Keys_Present_Multiple()
{
    var config = LoadConfiguration();
    var requiredKeys = new[] { "ApiKey", "Database", "Environment" };

    using (Assert.Multiple())
    {
        foreach (var key in requiredKeys)
        {
            await Assert.That(config).ContainsKey(key);
        }
    }
}
```

### Metadata Validation

```csharp
[Test]
public async Task Validate_Metadata()
{
    var metadata = GetFileMetadata();

    await Assert.That(metadata)
        .ContainsKey("ContentType")
        .And.ContainsKey("Size")
        .And.ContainsKey("LastModified")
        .And.All(kvp => kvp.Value != null);
}
```

### Feature Flags

```csharp
[Test]
public async Task Feature_Flags()
{
    var features = new Dictionary<string, bool>
    {
        ["NewUI"] = true,
        ["BetaFeature"] = false,
        ["ExperimentalApi"] = true
    };

    await Assert.That(features)
        .ContainsKey("NewUI")
        .And.ContainsValue(true);

    var newUiEnabled = features["NewUI"];
    await Assert.That(newUiEnabled).IsTrue();
}
```

## See Also

- [Collections](collections.md) - General collection assertions
- [Equality & Comparison](equality-and-comparison.md) - Comparing dictionary values
- [Strings](string.md) - String key comparisons

---

## Equality and Comparison Assertions


TUnit provides comprehensive assertions for testing equality and comparing values. These assertions work with any type that implements the appropriate comparison interfaces.

## Basic Equality

### IsEqualTo

Tests that two values are equal using the type's `Equals()` method or `==` operator:

```csharp
[Test]
public async Task Basic_Equality()
{
    var result = 5 + 5;
    await Assert.That(result).IsEqualTo(10);

    var name = "Alice";
    await Assert.That(name).IsEqualTo("Alice");

    var isValid = true;
    await Assert.That(isValid).IsEqualTo(true);
}
```

### IsNotEqualTo

Tests that two values are not equal:

```csharp
[Test]
public async Task Not_Equal()
{
    var actual = CalculateResult();
    await Assert.That(actual).IsNotEqualTo(0);

    var username = GetUsername();
    await Assert.That(username).IsNotEqualTo("admin");
}
```

### EqualTo (Alias)

`EqualTo()` is an alias for `IsEqualTo()` for more natural chaining:

```csharp
[Test]
public async Task Using_EqualTo_Alias()
{
    var numbers = new[] { 1, 2, 3 };

    await Assert.That(numbers)
        .Count().IsEqualTo(3)
        .And.Contains(2);
}
```

## Reference Equality

### IsSameReferenceAs

Tests that two references point to the exact same object instance:

```csharp
[Test]
public async Task Same_Reference()
{
    var original = new Person { Name = "Alice" };
    var reference = original;

    await Assert.That(reference).IsSameReferenceAs(original);
}
```

### IsNotSameReferenceAs

Tests that two references point to different object instances:

```csharp
[Test]
public async Task Different_References()
{
    var person1 = new Person { Name = "Alice" };
    var person2 = new Person { Name = "Alice" };

    // Same values, different instances
    await Assert.That(person1).IsNotSameReferenceAs(person2);
    await Assert.That(person1).IsEqualTo(person2); // If equality is overridden
}
```

## Comparison Assertions

All comparison assertions work with types that implement `IComparable<T>` or `IComparable`.

### IsGreaterThan

```csharp
[Test]
public async Task Greater_Than()
{
    var score = 85;
    await Assert.That(score).IsGreaterThan(70);

    var temperature = 25.5;
    await Assert.That(temperature).IsGreaterThan(20.0);

    var date = DateTime.Now;
    await Assert.That(date).IsGreaterThan(DateTime.Now.AddDays(-1));
}
```

### IsGreaterThanOrEqualTo

```csharp
[Test]
public async Task Greater_Than_Or_Equal()
{
    var passingGrade = 60;
    await Assert.That(passingGrade).IsGreaterThanOrEqualTo(60);

    var age = 18;
    await Assert.That(age).IsGreaterThanOrEqualTo(18); // Exactly 18 passes
}
```

### IsLessThan

```csharp
[Test]
public async Task Less_Than()
{
    var response_time = 150; // milliseconds
    await Assert.That(response_time).IsLessThan(200);

    var price = 49.99m;
    await Assert.That(price).IsLessThan(50.00m);
}
```

### IsLessThanOrEqualTo

```csharp
[Test]
public async Task Less_Than_Or_Equal()
{
    var maxRetries = 3;
    var actualRetries = 3;
    await Assert.That(actualRetries).IsLessThanOrEqualTo(maxRetries);
}
```

## Range Assertions

### IsBetween

Tests that a value falls within a range (inclusive):

```csharp
[Test]
public async Task Between_Values()
{
    var percentage = 75;
    await Assert.That(percentage).IsBetween(0, 100);

    var temperature = 22.5;
    await Assert.That(temperature).IsBetween(20.0, 25.0);

    var age = 30;
    await Assert.That(age).IsBetween(18, 65);
}
```

Boundary values are included:

```csharp
[Test]
public async Task Between_Includes_Boundaries()
{
    await Assert.That(0).IsBetween(0, 10);    // ✅ Passes
    await Assert.That(10).IsBetween(0, 10);   // ✅ Passes
    await Assert.That(5).IsBetween(0, 10);    // ✅ Passes
}
```

## Numeric-Specific Assertions

### IsPositive

Tests that a numeric value is greater than zero:

```csharp
[Test]
public async Task Positive_Numbers()
{
    var profit = 1500.50m;
    await Assert.That(profit).IsPositive();

    var count = 5;
    await Assert.That(count).IsPositive();

    // Works with all numeric types
    await Assert.That(1.5).IsPositive();      // double
    await Assert.That(1.5f).IsPositive();     // float
    await Assert.That(1.5m).IsPositive();     // decimal
    await Assert.That((byte)1).IsPositive();  // byte
    await Assert.That((short)1).IsPositive(); // short
    await Assert.That(1L).IsPositive();       // long
}
```

### IsNegative

Tests that a numeric value is less than zero:

```csharp
[Test]
public async Task Negative_Numbers()
{
    var loss = -500.25m;
    await Assert.That(loss).IsNegative();

    var temperature = -5;
    await Assert.That(temperature).IsNegative();
}
```

## Tolerance for Floating-Point Numbers

When comparing floating-point numbers, you can specify a tolerance to account for rounding errors:

### Double Tolerance

```csharp
[Test]
public async Task Double_With_Tolerance()
{
    var actual = 1.0 / 3.0; // 0.333333...
    var expected = 0.333;

    // Without tolerance - might fail due to precision
    // await Assert.That(actual).IsEqualTo(expected);

    // With tolerance - passes
    await Assert.That(actual).IsEqualTo(expected).Within(0.001);
}
```

### Float Tolerance

```csharp
[Test]
public async Task Float_With_Tolerance()
{
    float actual = 3.14159f;
    float expected = 3.14f;

    await Assert.That(actual).IsEqualTo(expected).Within(0.01f);
}
```

### Decimal Tolerance

```csharp
[Test]
public async Task Decimal_With_Tolerance()
{
    decimal price = 19.995m;
    decimal expected = 20.00m;

    await Assert.That(price).IsEqualTo(expected).Within(0.01m);
}
```

### Long Tolerance

```csharp
[Test]
public async Task Long_With_Tolerance()
{
    long timestamp = DateTimeOffset.UtcNow.ToUnixTimeMilliseconds();
    long expected = DateTimeOffset.UtcNow.ToUnixTimeMilliseconds();

    // Allow 100ms difference
    await Assert.That(timestamp).IsEqualTo(expected).Within(100L);
}
```

## Chaining Comparisons

Combine multiple comparison assertions:

```csharp
[Test]
public async Task Chained_Comparisons()
{
    var score = 85;

    await Assert.That(score)
        .IsGreaterThan(0)
        .And.IsLessThan(100)
        .And.IsGreaterThanOrEqualTo(80);
}
```

Or use `IsBetween` for simpler range checks:

```csharp
[Test]
public async Task Range_Check_Simplified()
{
    var score = 85;

    // Instead of chaining IsGreaterThan and IsLessThan:
    await Assert.That(score).IsBetween(0, 100);
}
```

## Custom Equality Comparers

You can provide custom equality comparers for collections and complex types:

```csharp
[Test]
public async Task Custom_Comparer()
{
    var people1 = new[] { new Person("Alice"), new Person("Bob") };
    var people2 = new[] { new Person("ALICE"), new Person("BOB") };

    // Case-insensitive name comparison
    var comparer = new PersonNameComparer();

    await Assert.That(people1)
        .IsEquivalentTo(people2)
        .Using(comparer);
}

public class PersonNameComparer : IEqualityComparer<Person>
{
    public bool Equals(Person? x, Person? y) =>
        string.Equals(x?.Name, y?.Name, StringComparison.OrdinalIgnoreCase);

    public int GetHashCode(Person obj) =>
        obj.Name?.ToLowerInvariant().GetHashCode() ?? 0;
}
```

Or use a predicate:

```csharp
[Test]
public async Task Custom_Equality_Predicate()
{
    var people1 = new[] { new Person("Alice"), new Person("Bob") };
    var people2 = new[] { new Person("ALICE"), new Person("BOB") };

    await Assert.That(people1)
        .IsEquivalentTo(people2)
        .Using((p1, p2) => string.Equals(p1.Name, p2.Name,
                          StringComparison.OrdinalIgnoreCase));
}
```

## Working with Value Types and Records

Equality works naturally with value types and records:

```csharp
public record Point(int X, int Y);

[Test]
public async Task Record_Equality()
{
    var point1 = new Point(10, 20);
    var point2 = new Point(10, 20);

    // Records have built-in value equality
    await Assert.That(point1).IsEqualTo(point2);
    await Assert.That(point1).IsNotSameReferenceAs(point2);
}
```

```csharp
public struct Coordinate
{
    public double Latitude { get; init; }
    public double Longitude { get; init; }
}

[Test]
public async Task Struct_Equality()
{
    var coord1 = new Coordinate { Latitude = 47.6, Longitude = -122.3 };
    var coord2 = new Coordinate { Latitude = 47.6, Longitude = -122.3 };

    await Assert.That(coord1).IsEqualTo(coord2);
}
```

## Practical Examples

### Validating Calculation Results

```csharp
[Test]
public async Task Calculate_Discount()
{
    var originalPrice = 100m;
    var discount = 0.20m; // 20%

    var finalPrice = originalPrice * (1 - discount);

    await Assert.That(finalPrice).IsEqualTo(80m);
    await Assert.That(finalPrice).IsLessThan(originalPrice);
    await Assert.That(finalPrice).IsGreaterThan(0);
}
```

### Validating Ranges

```csharp
[Test]
public async Task Temperature_In_Valid_Range()
{
    var roomTemperature = GetRoomTemperature();

    await Assert.That(roomTemperature)
        .IsBetween(18, 26) // Comfortable range in Celsius
        .And.IsPositive();
}
```

### Comparing with Mathematical Constants

```csharp
[Test]
public async Task Mathematical_Constants()
{
    var calculatedPi = CalculatePiUsingLeibniz(10000);

    await Assert.That(calculatedPi).IsEqualTo(Math.PI).Within(0.0001);
}
```

### API Response Validation

```csharp
[Test]
public async Task API_Response_Time()
{
    var stopwatch = Stopwatch.StartNew();
    await CallApiEndpoint();
    stopwatch.Stop();

    await Assert.That(stopwatch.ElapsedMilliseconds)
        .IsLessThan(500) // Must respond within 500ms
        .And.IsGreaterThan(0);
}
```

## Common Patterns

### Validating User Input

```csharp
[Test]
public async Task Username_Length()
{
    var username = GetUserInput();

    await Assert.That(username.Length)
        .IsBetween(3, 20)
        .And.IsGreaterThan(0);
}
```

### Percentage Validation

```csharp
[Test]
public async Task Percentage_Valid()
{
    var successRate = CalculateSuccessRate();

    await Assert.That(successRate)
        .IsBetween(0, 100)
        .And.IsGreaterThanOrEqualTo(0);
}
```

## See Also

- [Numeric Assertions](numeric.md) - Additional numeric-specific assertions
- [DateTime Assertions](datetime.md) - Time-based comparisons with tolerance
- [Collections](collections.md) - Comparing collections
- [Strings](string.md) - String equality with options

---

## Exception Assertions


TUnit provides comprehensive assertions for testing that code throws (or doesn't throw) exceptions, with rich support for validating exception types, messages, and properties.

## Basic Exception Assertions

### Throws&lt;TException&gt;

Tests that a delegate throws a specific exception type (or a subclass):

```csharp
[Test]
public async Task Code_Throws_Exception()
{
    await Assert.That(() => int.Parse("not a number"))
        .Throws<FormatException>();
}
```

Works with any exception type:

```csharp
[Test]
public async Task Various_Exception_Types()
{
    await Assert.That(() => throw new InvalidOperationException())
        .Throws<InvalidOperationException>();

    await Assert.That(() => throw new ArgumentNullException())
        .Throws<ArgumentNullException>();

    await Assert.That(() => File.ReadAllText("nonexistent.txt"))
        .Throws<FileNotFoundException>();
}
```

### ThrowsExactly&lt;TException&gt;

Tests that a delegate throws the exact exception type (not a subclass):

```csharp
[Test]
public async Task Throws_Exact_Type()
{
    await Assert.That(() => throw new ArgumentNullException())
        .ThrowsExactly<ArgumentNullException>();

    // This would fail - ArgumentNullException is a subclass of ArgumentException
    // await Assert.That(() => throw new ArgumentNullException())
    //     .ThrowsExactly<ArgumentException>();
}
```

### Throws (Runtime Type)

Use when the exception type is only known at runtime:

```csharp
[Test]
public async Task Throws_Runtime_Type()
{
    Type exceptionType = typeof(InvalidOperationException);

    await Assert.That(() => throw new InvalidOperationException())
        .Throws(exceptionType);
}
```

### ThrowsNothing

Tests that code does not throw any exception:

```csharp
[Test]
public async Task Code_Does_Not_Throw()
{
    await Assert.That(() => int.Parse("42"))
        .ThrowsNothing();

    await Assert.That(() => ValidateInput("valid"))
        .ThrowsNothing();
}
```

## Async Exception Assertions

For async operations, use async delegates:

```csharp
[Test]
public async Task Async_Throws_Exception()
{
    await Assert.That(async () => await FailingOperationAsync())
        .Throws<HttpRequestException>();
}
```

```csharp
[Test]
public async Task Async_Does_Not_Throw()
{
    await Assert.That(async () => await SuccessfulOperationAsync())
        .ThrowsNothing();
}
```

## Exception Message Assertions

### WithMessage

Tests that the exception has an exact message:

```csharp
[Test]
public async Task Exception_With_Exact_Message()
{
    await Assert.That(() => throw new InvalidOperationException("Operation failed"))
        .Throws<InvalidOperationException>()
        .WithMessage("Operation failed");
}
```

### WithMessageContaining

Tests that the exception message contains a substring:

```csharp
[Test]
public async Task Exception_Message_Contains()
{
    await Assert.That(() => throw new ArgumentException("The parameter 'userId' is invalid"))
        .Throws<ArgumentException>()
        .WithMessageContaining("userId");
}
```

#### Case-Insensitive

```csharp
[Test]
public async Task Message_Contains_Ignoring_Case()
{
    await Assert.That(() => throw new Exception("ERROR: Failed"))
        .Throws<Exception>()
        .WithMessageContaining("error")
        .IgnoringCase();
}
```

### WithMessageNotContaining

Tests that the exception message does not contain a substring:

```csharp
[Test]
public async Task Message_Does_Not_Contain()
{
    await Assert.That(() => throw new Exception("User error"))
        .Throws<Exception>()
        .WithMessageNotContaining("system");
}
```

### WithMessageMatching

Tests that the exception message matches a pattern:

```csharp
[Test]
public async Task Message_Matches_Pattern()
{
    await Assert.That(() => throw new Exception("Error code: 12345"))
        .Throws<Exception>()
        .WithMessageMatching("Error code: *");
}
```

Or with a `StringMatcher`:

```csharp
[Test]
public async Task Message_Matches_With_Matcher()
{
    var matcher = new StringMatcher("Error * occurred", caseSensitive: false);

    await Assert.That(() => throw new Exception("Error 500 occurred"))
        .Throws<Exception>()
        .WithMessageMatching(matcher);
}
```

## ArgumentException Specific

### WithParameterName

For `ArgumentException` and its subclasses, you can assert on the parameter name:

```csharp
[Test]
public async Task ArgumentException_With_Parameter_Name()
{
    await Assert.That(() => ValidateUser(null!))
        .Throws<ArgumentNullException>()
        .WithParameterName("user");
}

void ValidateUser(User user)
{
    if (user == null)
        throw new ArgumentNullException(nameof(user));
}
```

Combine with message assertions:

```csharp
[Test]
public async Task ArgumentException_Parameter_And_Message()
{
    await Assert.That(() => SetAge(-1))
        .Throws<ArgumentOutOfRangeException>()
        .WithParameterName("age")
        .WithMessageContaining("must be positive");
}

void SetAge(int age)
{
    if (age < 0)
        throw new ArgumentOutOfRangeException(nameof(age), "Age must be positive");
}
```

## Inner Exception Assertions

### WithInnerException

Assert on the inner exception:

```csharp
[Test]
public async Task Exception_With_Inner_Exception()
{
    await Assert.That(() => {
        try
        {
            int.Parse("not a number");
        }
        catch (Exception ex)
        {
            throw new InvalidOperationException("Processing failed", ex);
        }
    })
    .Throws<InvalidOperationException>()
    .WithInnerException();
}
```

Chain to assert on the inner exception type:

```csharp
[Test]
public async Task Inner_Exception_Type()
{
    await Assert.That(() => ThrowWithInner())
        .Throws<InvalidOperationException>()
        .WithInnerException()
        .Throws<FormatException>();
}

void ThrowWithInner()
{
    try
    {
        int.Parse("abc");
    }
    catch (Exception ex)
    {
        throw new InvalidOperationException("Outer", ex);
    }
}
```

## Practical Examples

### Validation Exceptions

```csharp
[Test]
public async Task Validate_Email_Throws()
{
    await Assert.That(() => ValidateEmail("invalid-email"))
        .Throws<ArgumentException>()
        .WithParameterName("email")
        .WithMessageContaining("valid email");
}
```

### Null Argument Checks

```csharp
[Test]
public async Task Null_Argument_Throws()
{
    await Assert.That(() => ProcessData(null!))
        .Throws<ArgumentNullException>()
        .WithParameterName("data");
}
```

### File Operations

```csharp
[Test]
public async Task File_Not_Found()
{
    await Assert.That(() => File.ReadAllText("nonexistent.txt"))
        .Throws<FileNotFoundException>()
        .WithMessageContaining("nonexistent.txt");
}
```

### Network Operations

```csharp
[Test]
public async Task HTTP_Request_Fails()
{
    await Assert.That(async () => await _client.GetAsync("http://invalid-url"))
        .Throws<HttpRequestException>();
}
```

### Database Operations

```csharp
[Test]
public async Task Duplicate_Key_Violation()
{
    await Assert.That(async () => await InsertDuplicateAsync())
        .Throws<DbUpdateException>()
        .WithMessageContaining("duplicate key");
}
```

### Division by Zero

```csharp
[Test]
public async Task Division_By_Zero()
{
    await Assert.That(() => {
        int a = 10;
        int b = 0;
        return a / b;
    })
    .Throws<DivideByZeroException>();
}
```

### Index Out of Range

```csharp
[Test]
public async Task Array_Index_Out_Of_Range()
{
    var array = new[] { 1, 2, 3 };

    await Assert.That(() => array[10])
        .Throws<IndexOutOfRangeException>();
}
```

### Invalid Cast

```csharp
[Test]
public async Task Invalid_Cast()
{
    object obj = "string";

    await Assert.That(() => (int)obj)
        .Throws<InvalidCastException>();
}
```

### Custom Exceptions

```csharp
public class BusinessRuleException : Exception
{
    public string RuleCode { get; }

    public BusinessRuleException(string ruleCode, string message)
        : base(message)
    {
        RuleCode = ruleCode;
    }
}

[Test]
public async Task Custom_Exception_With_Properties()
{
    var exception = await Assert.That(() =>
        throw new BusinessRuleException("BR001", "Business rule violated"))
        .Throws<BusinessRuleException>();

    // Can't directly assert on exception properties yet, but you can access them
    await Assert.That(exception.RuleCode).IsEqualTo("BR001");
    await Assert.That(exception.Message).Contains("Business rule");
}
```

## Testing Multiple Operations

### Using Assert.Multiple

```csharp
[Test]
public async Task Multiple_Exception_Scenarios()
{
    using (Assert.Multiple())
    {
        await Assert.That(() => int.Parse("abc"))
            .Throws<FormatException>();

        await Assert.That(() => int.Parse("999999999999999999999"))
            .Throws<OverflowException>();

        await Assert.That(() => int.Parse("42"))
            .ThrowsNothing();
    }
}
```

## Exception Inheritance

When using `Throws<T>()`, subclasses are accepted:

```csharp
[Test]
public async Task Exception_Inheritance()
{
    // ArgumentNullException inherits from ArgumentException
    await Assert.That(() => throw new ArgumentNullException())
        .Throws<ArgumentException>(); // ✅ Passes

    await Assert.That(() => throw new ArgumentNullException())
        .Throws<ArgumentNullException>(); // ✅ Also passes
}
```

Use `ThrowsExactly<T>()` if you need the exact type:

```csharp
[Test]
public async Task Exact_Exception_Type()
{
    // This fails - ArgumentNullException is not exactly ArgumentException
    // await Assert.That(() => throw new ArgumentNullException())
    //     .ThrowsExactly<ArgumentException>();

    await Assert.That(() => throw new ArgumentException())
        .ThrowsExactly<ArgumentException>(); // ✅ Passes
}
```

## Aggregate Exceptions

```csharp
[Test]
public async Task Aggregate_Exception()
{
    await Assert.That(() => {
        var task1 = Task.Run(() => throw new InvalidOperationException());
        var task2 = Task.Run(() => throw new ArgumentException());
        Task.WaitAll(task1, task2);
    })
    .Throws<AggregateException>();
}
```

## Chaining Exception Assertions

```csharp
[Test]
public async Task Chained_Exception_Assertions()
{
    await Assert.That(() => ValidateInput(""))
        .Throws<ArgumentException>()
        .WithParameterName("input")
        .WithMessageContaining("cannot be empty")
        .WithMessageNotContaining("null");
}
```

## Testing that No Exception is Thrown

### ThrowsNothing vs Try-Catch

```csharp
[Test]
public async Task Explicit_No_Exception()
{
    // Using ThrowsNothing
    await Assert.That(() => SafeOperation())
        .ThrowsNothing();

    // Alternative: just call it
    SafeOperation(); // If it throws, the test fails
}
```

## Common Patterns

### Expected Failures

```csharp
[Test]
public async Task Expected_Validation_Failure()
{
    var invalidUser = new User { Age = -1 };

    await Assert.That(() => ValidateUser(invalidUser))
        .Throws<ValidationException>()
        .WithMessageContaining("Age");
}
```

### Defensive Programming

```csharp
[Test]
public async Task Guard_Clause_Validation()
{
    await Assert.That(() => new Service(null!))
        .Throws<ArgumentNullException>()
        .WithParameterName("dependency");
}
```

### State Validation

```csharp
[Test]
public async Task Invalid_State_Operation()
{
    var connection = new Connection();
    // Don't connect

    await Assert.That(() => connection.SendData("test"))
        .Throws<InvalidOperationException>()
        .WithMessageContaining("not connected");
}
```

### Configuration Errors

```csharp
[Test]
public async Task Missing_Configuration()
{
    await Assert.That(() => LoadConfiguration("invalid.json"))
        .Throws<ConfigurationException>()
        .WithMessageContaining("invalid.json");
}
```

## Timeout Exceptions

```csharp
[Test]
public async Task Operation_Timeout()
{
    using var cts = new CancellationTokenSource(TimeSpan.FromMilliseconds(100));

    await Assert.That(async () => await LongRunningOperationAsync(cts.Token))
        .Throws<TaskCanceledException>();
}
```

## Re-throwing Exceptions

```csharp
[Test]
public async Task Wrapper_Exception()
{
    await Assert.That(() => {
        try
        {
            RiskyOperation();
        }
        catch (Exception ex)
        {
            throw new ApplicationException("Operation failed", ex);
        }
    })
    .Throws<ApplicationException>()
    .WithInnerException();
}
```

## Exception Assertions with Async/Await

```csharp
[Test]
public async Task Async_Exception_Handling()
{
    await Assert.That(async () => {
        await Task.Delay(10);
        throw new InvalidOperationException("Async failure");
    })
    .Throws<InvalidOperationException>()
    .WithMessageContaining("Async failure");
}
```

## See Also

- [Tasks & Async](tasks-and-async.md) - Testing async operations and task state
- [Types](types.md) - Type checking for exception types
- [Strings](string.md) - String assertions for exception messages

---

## Custom Assertions


The TUnit Assertions can be easily extended so that you can create your own assertions.

## Creating a Custom Assertion

To create a custom assertion, you need to:

1. **Create an Assertion Class** that inherits from `Assertion<TValue>`
2. **Implement the required methods**
3. **Create an extension method** on `IAssertionSource<T>`

### Step 1: Create an Assertion Class

Your assertion class should inherit from `Assertion<TValue>` where `TValue` is the type being asserted.

```csharp
using TUnit.Assertions.Core;

public class StringContainsAssertion : Assertion<string>
{
    private readonly string _expected;
    private readonly StringComparison _comparison;

    public StringContainsAssertion(
        AssertionContext<string> context,
        string expected,
        StringComparison comparison = StringComparison.Ordinal)
        : base(context)
    {
        _expected = expected ?? throw new ArgumentNullException(nameof(expected));
        _comparison = comparison;
    }

    protected override Task<AssertionResult> CheckAsync(EvaluationMetadata<string> metadata)
    {
        var value = metadata.Value;
        var exception = metadata.Exception;

        if (exception != null)
            return Task.FromResult(AssertionResult.Failed($"threw {exception.GetType().Name}"));

        if (value == null)
            return Task.FromResult(AssertionResult.Failed("value was null"));

        if (value.Contains(_expected, _comparison))
            return Task.FromResult(AssertionResult.Passed);

        return Task.FromResult(AssertionResult.Failed($"'{value}' does not contain '{_expected}'"));
    }

    protected override string GetExpectation()
        => $"to contain \"{_expected}\"";
}
```

### Step 2: Create an Extension Method

Create an extension method on `IAssertionSource<T>` that returns your custom assertion:

```csharp
using System.Runtime.CompilerServices;
using TUnit.Assertions.Core;

public static class StringAssertionExtensions
{
    public static StringContainsAssertion ContainsIgnoreCase(
        this IAssertionSource<string> source,
        string expected,
        [CallerArgumentExpression(nameof(expected))] string? expression = null)
    {
        source.Context.ExpressionBuilder.Append($".ContainsIgnoreCase({expression})");
        return new StringContainsAssertion(
            source.Context,
            expected,
            StringComparison.OrdinalIgnoreCase);
    }
}
```

### Step 3: Use Your Custom Assertion

```csharp
await Assert.That("Hello World")
    .ContainsIgnoreCase("WORLD");  // Uses your custom assertion!
```

## Chaining with And/Or

Because your assertion returns an `Assertion<T>` type, it automatically supports chaining with `.And` and `.Or`:

```csharp
await Assert.That("Hello World")
    .ContainsIgnoreCase("WORLD")
    .And
    .ContainsIgnoreCase("HELLO");
```

## Key Points

- **Extension target**: Always extend `IAssertionSource<T>` so your method works on assertions, And, and Or continuations
- **Append expression**: Call `source.Context.ExpressionBuilder.Append(...)` to build helpful error messages
- **Return your assertion**: Return a new instance of your custom `Assertion<T>` subclass
- **Context sharing**: Pass `source.Context` to your assertion constructor (it contains the evaluation context and expression builder)
- **CheckAsync parameter**: Use `EvaluationMetadata<TValue> metadata` which contains both `Value` and `Exception` properties
- **CallerArgumentExpression**: Use this attribute to capture parameter expressions for better error messages

---

## Chaining and Converting


TUnit allows you to chain assertions that change the type being asserted, enabling fluent and expressive test code.
This is useful when an assertion transforms the value (e.g., parsing a response), and you want to continue asserting on the new type.

Chaining is especially helpful when you want to perform multiple assertions on a value that is transformed by a previous assertion, without having to create intermediate variables.

For example:

```csharp
        HttpResponseMessage response = ...;

        await Assert.That(response)
            .IsProblemDetails()
            .And
            .HasTitle("Invalid Authentication Token")
            .And
            .HasDetail("No token provided");
```

The `response` object initially passed in is a `HttpResponseMessage`, but then after we assert it's a `ProblemDetails` object, the chain has changed to that type so that we can further assert with methods specific to `ProblemDetails` instead of `HttpResponseMessage`.

## How to Implement Type Conversion Assertions

Creating a type-converting assertion involves two main steps:

### 1. Create the Assertion Class

Create a custom assertion class that extends `Assertion<TTo>` where `TTo` is the target type. The constructor should take `AssertionContext<TFrom>` (the source type) and use `.Map<TTo>(...)` to transform the value.

In the example above, that'd look like:

```csharp
public class IsProblemDetailsAssertion : Assertion<ProblemDetails>
{
    public IsProblemDetailsAssertion(AssertionContext<HttpResponseMessage> context)
        : base(context.Map<ProblemDetails>(async response =>
        {
            var content = await response.Content.ReadFromJsonAsync<ProblemDetails>();

            if (content is null)
            {
                throw new InvalidOperationException("Response body is not Problem Details");
            }

            return content;
        }))
    {
    }

    protected override Task<AssertionResult> CheckAsync(EvaluationMetadata<ProblemDetails> metadata)
    {
        // The transformation already happened in the Map function
        // If we got here without exception, the conversion succeeded
        if (metadata.Exception != null)
        {
            return Task.FromResult(AssertionResult.Failed(metadata.Exception.Message));
        }

        return Task.FromResult(AssertionResult.Passed);
    }

    protected override string GetExpectation()
    {
        return "HTTP response to be in the format of a Problem Details object";
    }
}
```

The `.Map<TTo>(...)` method handles the type conversion. If the conversion fails, throw an exception which will be captured and reported as an assertion failure.

**Note:** The `Map` method supports both synchronous and asynchronous transformations:
- **Synchronous**: `context.Map<TTo>(value => transformedValue)`
- **Asynchronous**: `context.Map<TTo>(async value => await transformedValueAsync)`

In both cases, the Task is automatically unwrapped, allowing you to chain assertions directly on the result type.

### 2. Create the Extension Method

Create an extension method on `IAssertionSource<TFrom>` that returns your assertion class:

```csharp
public static class HttpResponseAssertionExtensions
{
    public static IsProblemDetailsAssertion IsProblemDetails(
        this IAssertionSource<HttpResponseMessage> source)
    {
        source.Context.ExpressionBuilder.Append(".IsProblemDetails()");
        return new IsProblemDetailsAssertion(source.Context);
    }
}
```

That's it!

Now any assertions built for the `ProblemDetails` type will work off of that same chain.

### 3. Create Assertions for the Target Type

You can then create standard assertions for the target type (`ProblemDetails` in this case):

```csharp
public static class ProblemDetailsAssertionExtensions
{
    public static HasTitleAssertion HasTitle(
        this IAssertionSource<ProblemDetails> source,
        string expectedTitle,
        [CallerArgumentExpression(nameof(expectedTitle))] string? expression = null)
    {
        source.Context.ExpressionBuilder.Append($".HasTitle({expression})");
        return new HasTitleAssertion(source.Context, expectedTitle);
    }

    public static HasDetailAssertion HasDetail(
        this IAssertionSource<ProblemDetails> source,
        string expectedDetail,
        [CallerArgumentExpression(nameof(expectedDetail))] string? expression = null)
    {
        source.Context.ExpressionBuilder.Append($".HasDetail({expression})");
        return new HasDetailAssertion(source.Context, expectedDetail);
    }
}

public class HasTitleAssertion : Assertion<ProblemDetails>
{
    private readonly string _expectedTitle;

    public HasTitleAssertion(AssertionContext<ProblemDetails> context, string expectedTitle)
        : base(context)
    {
        _expectedTitle = expectedTitle;
    }

    protected override Task<AssertionResult> CheckAsync(EvaluationMetadata<ProblemDetails> metadata)
    {
        if (metadata.Exception != null)
        {
            return Task.FromResult(AssertionResult.Failed("ProblemDetails is null"));
        }

        if (metadata.Value?.Title != _expectedTitle)
        {
            return Task.FromResult(AssertionResult.Failed(
                $"Expected title '{_expectedTitle}' but was '{metadata.Value?.Title}'"));
        }

        return Task.FromResult(AssertionResult.Passed);
    }

    protected override string GetExpectation() => $"to have title '{_expectedTitle}'";
}

public class HasDetailAssertion : Assertion<ProblemDetails>
{
    private readonly string _expectedDetail;

    public HasDetailAssertion(AssertionContext<ProblemDetails> context, string expectedDetail)
        : base(context)
    {
        _expectedDetail = expectedDetail;
    }

    protected override Task<AssertionResult> CheckAsync(EvaluationMetadata<ProblemDetails> metadata)
    {
        if (metadata.Exception != null)
        {
            return Task.FromResult(AssertionResult.Failed("ProblemDetails is null"));
        }

        if (metadata.Value?.Detail != _expectedDetail)
        {
            return Task.FromResult(AssertionResult.Failed(
                $"Expected detail '{_expectedDetail}' but was '{metadata.Value?.Detail}'"));
        }

        return Task.FromResult(AssertionResult.Passed);
    }

    protected override string GetExpectation() => $"to have detail '{_expectedDetail}'";
}
```

## Built-in Examples

TUnit includes several built-in examples of type conversion assertions:

- `WhenParsedInto<T>()` - Converts a string to a parsed type (e.g., `await Assert.That("123").WhenParsedInto<int>().IsEqualTo(123)`)
- `IsTypeOf<T>()` - Converts to a specific type (e.g., `await Assert.That(obj).IsTypeOf<StringBuilder>().Length().IsEqualTo(5)`)

---

## Returning Data via `await`


Sometimes, you may want your assertion to return a value, such as an item found in a collection, so you can use it in further assertions or logic.
TUnit supports this by allowing your assertion to return a value when awaited.

This is useful for scenarios where you want to extract a value from an assertion and use it in subsequent test logic, reducing the need for manual extraction or casting.

For example, `await Assert.That(collection).Contains(item => item.Price < 0.99)` can return the first item that meets the criteria.

## How to Return Values from Assertions

The key to returning values is to make your assertion class extend `Assertion<TReturn>` where `TReturn` is the type you want to return when awaited. The value is returned by transforming the input using `context.Map<TReturn>(...)`.

### Example: Contains with Predicate

Let's say we want to create a `Contains` assertion that returns the found item:

```csharp
public class CollectionContainsPredicateAssertion<TCollection, TItem> : Assertion<TItem>
    where TCollection : IEnumerable<TItem>
{
    private readonly Func<TItem, bool> _predicate;

    public CollectionContainsPredicateAssertion(
        AssertionContext<TCollection> context,
        Func<TItem, bool> predicate)
        : base(context.Map<TItem>(collection =>
        {
            if (collection == null)
            {
                throw new ArgumentNullException(nameof(collection), "collection was null");
            }

            foreach (var item in collection)
            {
                if (predicate(item))
                {
                    // Return the found item - this becomes the value when awaited
                    return item;
                }
            }

            // Throw an exception if not found - this will be captured as a failure
            throw new InvalidOperationException("no item matching predicate found in collection");
        }))
    {
        _predicate = predicate;
    }

    protected override Task<AssertionResult> CheckAsync(EvaluationMetadata<TItem> metadata)
    {
        // The transformation already happened in the Map function
        // If we got here without exception, the item was found
        if (metadata.Exception != null)
        {
            return Task.FromResult(AssertionResult.Failed(metadata.Exception.Message));
        }

        return Task.FromResult(AssertionResult.Passed);
    }

    protected override string GetExpectation() => "to contain item matching predicate";
}
```

### How It Works

1. **Extend `Assertion<TReturn>`**: Your assertion class extends `Assertion<TItem>` where `TItem` is what you want to return
2. **Use `context.Map<TReturn>(...)`**: In the constructor, call `context.Map<TReturn>(...)` to transform the input value
3. **Return the value**: Inside the Map function, return the value you want to make available when the assertion is awaited
4. **Throw on failure**: If you can't find/produce the value, throw an exception - this will be captured as an assertion failure

### Extension Method

The extension method is straightforward - just return your assertion class:

```csharp
public static class CollectionAssertionExtensions
{
    public static CollectionContainsPredicateAssertion<TCollection, TItem> Contains<TCollection, TItem>(
        this IAssertionSource<TCollection> source,
        Func<TItem, bool> predicate,
        [CallerArgumentExpression(nameof(predicate))] string? expression = null)
        where TCollection : IEnumerable<TItem>
    {
        source.Context.ExpressionBuilder.Append($".Contains({expression})");
        return new CollectionContainsPredicateAssertion<TCollection, TItem>(source.Context, predicate);
    }
}
```

### Usage

You can now use the assertion and get the found item:

```csharp
// Returns the first item with price < 0.99
Product cheapProduct = await Assert.That(products).Contains(p => p.Price < 0.99);

// Use the returned value in further assertions
await Assert.That(cheapProduct.Name).IsNotNull();
await Assert.That(cheapProduct.Category).IsEqualTo("Bargain");
```

## Built-in Examples

TUnit includes several built-in examples of assertions that return values:

- `Contains(predicate)` - Returns the first item matching the predicate
- `WhenParsedInto<T>()` - Returns the parsed value (e.g., `int value = await Assert.That("123").WhenParsedInto<int>()`)
- `IsTypeOf<T>()` - Returns the casted value (e.g., `StringBuilder sb = await Assert.That(obj).IsTypeOf<StringBuilder>()`)

---

## Source Generator Assertions


TUnit provides source generators to simplify creating custom assertions. Instead of manually writing assertion classes and extension methods, you can decorate your methods with attributes and let the generator do the work.

## Overview

There are two ways to create assertions with source generators:

1. **`[GenerateAssertion]`** - Decorate your own methods to generate assertions
2. **`[AssertionFrom<T>]`** - Generate assertions from existing library methods

---

## Method-Level Generation: `[GenerateAssertion]`

The `[GenerateAssertion]` attribute allows you to turn any method into a full assertion with minimal code.

### Basic Example

```csharp
using System.ComponentModel;
using TUnit.Assertions.Attributes;

public static partial class IntAssertionExtensions
{
    [EditorBrowsable(EditorBrowsableState.Never)]
    [GenerateAssertion(ExpectationMessage = "to be positive")]
    public static bool IsPositive(this int value)
    {
        return value > 0;
    }
}

// Usage in tests:
await Assert.That(5).IsPositive();  // ✅ Passes
await Assert.That(-3).IsPositive(); // ❌ Fails: "Expected to be positive but found -3"
```

**Note:** The `[EditorBrowsable(EditorBrowsableState.Never)]` attribute hides the helper method from IntelliSense. Users will only see the generated assertion extension method `IsPositive()` on `Assert.That(...)`, not the underlying helper method on `int` values.

### What Gets Generated

The generator creates:
1. An `Assertion<T>` class containing your logic
2. An extension method on `IAssertionSource<T>`
3. Full support for chaining with `.And` and `.Or`

```csharp
// Generated code (simplified):
public sealed class IsPositive_Assertion : Assertion<int>
{
    protected override async Task<AssertionResult> CheckAsync(EvaluationMetadata<int> metadata)
    {
        var result = metadata.Value.IsPositive();
        return result ? AssertionResult.Passed : AssertionResult.Failed($"found {metadata.Value}");
    }

    protected override string GetExpectation() => "to be positive";
}

public static IsPositive_Assertion IsPositive(this IAssertionSource<int> source)
{
    source.Context.ExpressionBuilder.Append(".IsPositive()");
    return new IsPositive_Assertion(source.Context);
}
```

---

## Custom Expectation Messages

Use the `ExpectationMessage` property to provide clear, readable error messages:

```csharp
[EditorBrowsable(EditorBrowsableState.Never)]
[GenerateAssertion(ExpectationMessage = "to be positive")]
public static bool IsPositive(this int value) => value > 0;

// Error message: "Expected to be positive but found -3"
```

### Using Parameters in Messages

You can reference method parameters in your expectation message using `{paramName}`:

```csharp
[EditorBrowsable(EditorBrowsableState.Never)]
[GenerateAssertion(ExpectationMessage = "to be between {min} and {max}")]
public static bool IsBetween(this int value, int min, int max)
{
    return value >= min && value <= max;
}

// Error message: "Expected to be between 1 and 10 but found 15"
```

**Without ExpectationMessage:**
- Default: `"Expected to satisfy IsBetween but found 15"`

**With ExpectationMessage:**
- Clear: `"Expected to be between 1 and 10 but found 15"`

---

## Supported Return Types

### 1. `bool` - Simple Pass/Fail

```csharp
[EditorBrowsable(EditorBrowsableState.Never)]
[GenerateAssertion(ExpectationMessage = "to be even")]
public static bool IsEven(this int value)
{
    return value % 2 == 0;
}

// Usage:
await Assert.That(4).IsEven();  // ✅ Passes
await Assert.That(3).IsEven();  // ❌ Fails: "Expected to be even but found 3"
```

### 2. `AssertionResult` - Custom Messages

When you need more control over error messages, return `AssertionResult`:

```csharp
[EditorBrowsable(EditorBrowsableState.Never)]
[GenerateAssertion(ExpectationMessage = "to be prime")]
public static AssertionResult IsPrime(this int value)
{
    if (value < 2)
        return AssertionResult.Failed($"{value} is less than 2");

    for (int i = 2; i <= Math.Sqrt(value); i++)
    {
        if (value % i == 0)
            return AssertionResult.Failed($"{value} is divisible by {i}");
    }

    return AssertionResult.Passed;
}

// Usage:
await Assert.That(17).IsPrime();  // ✅ Passes
await Assert.That(15).IsPrime();  // ❌ Fails: "Expected to be prime but 15 is divisible by 3"
```

### 3. `Task<bool>` - Async Operations

```csharp
[EditorBrowsable(EditorBrowsableState.Never)]
[GenerateAssertion(ExpectationMessage = "to exist in database")]
public static async Task<bool> ExistsInDatabaseAsync(this int userId, DbContext db)
{
    return await db.Users.AnyAsync(u => u.Id == userId);
}

// Usage:
await Assert.That(userId).ExistsInDatabaseAsync(dbContext);
// If fails: "Expected to exist in database but found 123"
```

### 4. `Task<AssertionResult>` - Async with Custom Messages

```csharp
[EditorBrowsable(EditorBrowsableState.Never)]
[GenerateAssertion(ExpectationMessage = "to have valid email")]
public static async Task<AssertionResult> HasValidEmailAsync(this int userId, DbContext db)
{
    var user = await db.Users.FindAsync(userId);

    if (user == null)
        return AssertionResult.Failed($"User {userId} not found");

    if (!user.Email.Contains("@"))
        return AssertionResult.Failed($"Email '{user.Email}' is invalid");

    return AssertionResult.Passed;
}

// Usage:
await Assert.That(123).HasValidEmailAsync(dbContext);
// If fails: "Expected to have valid email but User 123 not found"
```

---

## Methods with Parameters

Add parameters to make your assertions flexible:

```csharp
[EditorBrowsable(EditorBrowsableState.Never)]
[GenerateAssertion(ExpectationMessage = "to be greater than {threshold}")]
public static bool IsGreaterThan(this int value, int threshold)
{
    return value > threshold;
}

[EditorBrowsable(EditorBrowsableState.Never)]
[GenerateAssertion(ExpectationMessage = "to be between {min} and {max}")]
public static bool IsBetween(this int value, int min, int max)
{
    return value >= min && value <= max;
}

// Usage:
await Assert.That(10).IsGreaterThan(5);  // ✅ Passes
await Assert.That(3).IsGreaterThan(5);   // ❌ Fails: "Expected to be greater than 5 but found 3"

await Assert.That(7).IsBetween(1, 10);   // ✅ Passes
await Assert.That(15).IsBetween(1, 10);  // ❌ Fails: "Expected to be between 1 and 10 but found 15"
```

**Benefits:**
- Use `{paramName}` in `ExpectationMessage` to include parameter values
- Parameters automatically get `[CallerArgumentExpression]` for great error messages
- Each parameter becomes part of the extension method signature
- Error messages show actual values with clear context

---

## Class-Level Generation: `[AssertionFrom]`

Use `[AssertionFrom]` to create assertions from existing methods in libraries or your codebase.

### Basic Usage

```csharp
using TUnit.Assertions.Attributes;

[AssertionFrom<string>(nameof(string.IsNullOrEmpty), ExpectationMessage = "to be null or empty")]
[AssertionFrom<string>(nameof(string.StartsWith), ExpectationMessage = "to start with {value}")]
[AssertionFrom<string>(nameof(string.EndsWith), ExpectationMessage = "to end with {value}")]
public static partial class StringAssertionExtensions
{
}

// Usage:
await Assert.That(myString).IsNullOrEmpty();
// If fails: "Expected to be null or empty but found 'test'"

await Assert.That("hello").StartsWith("he");
// If fails: "Expected to start with 'he' but found 'hello'"
```

### With Custom Names

```csharp
[AssertionFrom<string>(nameof(string.Contains), CustomName = "Has", ExpectationMessage = "to have '{value}'")]
public static partial class StringAssertionExtensions
{
}

// Usage:
await Assert.That("hello world").Has("world");  // ✅ Passes
await Assert.That("hello").Has("world");        // ❌ Fails: "Expected to have 'world' but found 'hello'"
```

### Negation Support

For `bool`-returning methods, you can generate negated versions:

```csharp
[AssertionFrom<string>(nameof(string.Contains), CustomName = "DoesNotContain", NegateLogic = true, ExpectationMessage = "to not contain '{value}'")]
public static partial class StringAssertionExtensions
{
}

// Usage:
await Assert.That("hello").DoesNotContain("xyz");  // ✅ Passes
await Assert.That("hello").DoesNotContain("ell");  // ❌ Fails: "Expected to not contain 'ell' but found 'hello'"
```

**Note:** Negation only works with `bool`-returning methods. `AssertionResult` methods determine their own pass/fail logic.

### Referencing Methods on Different Types

```csharp
// Reference static methods from another type
[AssertionFrom<string>(typeof(StringHelper), nameof(StringHelper.IsValidEmail), ExpectationMessage = "to be a valid email")]
public static partial class StringAssertionExtensions
{
}

// Where StringHelper is:
public static class StringHelper
{
    public static bool IsValidEmail(string value)
    {
        return value.Contains("@");
    }
}

// Usage:
await Assert.That("user@example.com").IsValidEmail();  // ✅ Passes
await Assert.That("invalid-email").IsValidEmail();     // ❌ Fails: "Expected to be a valid email but found 'invalid-email'"
```

---

## Method Body Inlining (Advanced)

For cleaner code and better IntelliSense, you can use method body inlining with file-scoped classes. This eliminates the need for `[EditorBrowsable]` attributes entirely.

### Using `InlineMethodBody`

Set `InlineMethodBody = true` to have the generator inline your method body instead of calling it:

```csharp
using TUnit.Assertions.Attributes;

// File-scoped class - only visible in this file
file static class BoolAssertions
{
    [GenerateAssertion(ExpectationMessage = "to be true", InlineMethodBody = true)]
    public static bool IsTrue(this bool value) => value == true;

    [GenerateAssertion(ExpectationMessage = "to be false", InlineMethodBody = true)]
    public static bool IsFalse(this bool value) => value == false;
}

// Usage in tests:
await Assert.That(myBool).IsTrue();   // ✅ Clean API, no IntelliSense pollution
```

### What Gets Generated with Inlining

Instead of calling your method, the generator inlines the expression directly:

```csharp
// WITHOUT InlineMethodBody (calls the method):
protected override Task<AssertionResult> CheckAsync(EvaluationMetadata<bool> metadata)
{
    var value = metadata.Value;
    var result = value!.IsTrue();  // Method call
    return Task.FromResult(result ? AssertionResult.Passed : AssertionResult.Failed($"found {value}"));
}

// WITH InlineMethodBody (inlines the expression):
protected override Task<AssertionResult> CheckAsync(EvaluationMetadata<bool> metadata)
{
    var value = metadata.Value;
    var result = value == true;  // Inlined!
    return Task.FromResult(result ? AssertionResult.Passed : AssertionResult.Failed($"found {value}"));
}
```

### Benefits of Inlining

✅ **No `[EditorBrowsable]` needed** - The helper methods are in a file-scoped class
✅ **Cleaner IntelliSense** - Helper methods don't appear anywhere in IntelliSense
✅ **Type-safe** - The generator fully qualifies all type references automatically
✅ **Works with parameters** - Parameters are automatically substituted

### Example with Parameters

```csharp
file static class IntAssertions
{
    [GenerateAssertion(ExpectationMessage = "to be positive", InlineMethodBody = true)]
    public static bool IsPositive(this int value) => value > 0;

    [GenerateAssertion(ExpectationMessage = "to be greater than {threshold}", InlineMethodBody = true)]
    public static bool IsGreaterThan(this int value, int threshold) => value > threshold;
}

// Generated code inlines with proper parameter substitution:
// var result = value > 0;
// var result = value > _threshold;  // Parameter renamed to field
```

### When to Use Inlining

Use `InlineMethodBody = true` when:
- You want cleaner code without `[EditorBrowsable]` attributes
- You're using file-scoped classes (C# 11+)
- Your assertion logic is simple (expression-bodied or single return statement)
- You want the cleanest possible API surface

**Note:** Inlining only works with:
- Expression-bodied methods: `=> expression`
- Simple block methods with a single return statement: `{ return expression; }`

---

## Requirements and Best Practices

### Method Requirements

For `[GenerateAssertion]`, your method must:
- Be `static`
- Have at least one parameter (the value to assert)
- Return `bool`, `AssertionResult`, `Task<bool>`, or `Task<AssertionResult>`

### Hiding Helper Methods from IntelliSense

**Important:** Always use `[EditorBrowsable(EditorBrowsableState.Never)]` on your `[GenerateAssertion]` methods to prevent IntelliSense pollution.

```csharp
using System.ComponentModel;
using TUnit.Assertions.Attributes;

public static partial class StringAssertionExtensions
{
    // ✅ GOOD: Hidden from IntelliSense
    [EditorBrowsable(EditorBrowsableState.Never)]
    [GenerateAssertion]
    public static bool IsEmptyString(this string value) => value.Length == 0;

    // ❌ BAD: Will appear in IntelliSense when typing on string values
    [GenerateAssertion]
    public static bool IsEmptyString(this string value) => value.Length == 0;
}
```

**Why?** Without `[EditorBrowsable]`, the helper method appears in IntelliSense when users type on the actual type (e.g., `myString.`). With the attribute, users only see the proper assertion method on `Assert.That(myString).`, which is cleaner and less confusing.

### Recommended Patterns

✅ **DO:**
- **Always** use `[EditorBrowsable(EditorBrowsableState.Never)]` on `[GenerateAssertion]` methods
- **Always** use `ExpectationMessage` to provide clear error messages
- Use `{paramName}` in expectation messages to include parameter values
- Use extension methods for cleaner syntax
- Return `AssertionResult` when you need custom error messages
- Use async when performing I/O or database operations
- Keep assertion logic simple and focused
- Use descriptive method names

❌ **DON'T:**
- Put complex business logic in assertions
- Make assertions with side effects
- Use `AssertionResult` with negation (it won't work as expected)
- Forget to make the containing class `partial`
- Skip the `[EditorBrowsable]` attribute (causes IntelliSense clutter)

---

## Chaining and Composition

All generated assertions support chaining:

```csharp
[EditorBrowsable(EditorBrowsableState.Never)]
[GenerateAssertion(ExpectationMessage = "to be positive")]
public static bool IsPositive(this int value) => value > 0;

[EditorBrowsable(EditorBrowsableState.Never)]
[GenerateAssertion(ExpectationMessage = "to be even")]
public static bool IsEven(this int value) => value % 2 == 0;

// Usage:
await Assert.That(10)
    .IsPositive()
    .And.IsEven();

// Or:
await Assert.That(number)
    .IsEven()
    .Or.IsPositive();
```

---

## Complete Example

Here's a comprehensive example showing all features:

```csharp
using System.ComponentModel;
using TUnit.Assertions.Attributes;
using TUnit.Assertions.Core;

public static partial class UserAssertionExtensions
{
    // Simple bool
    [EditorBrowsable(EditorBrowsableState.Never)]
    [GenerateAssertion(ExpectationMessage = "to have valid ID")]
    public static bool HasValidId(this User user)
    {
        return user.Id > 0;
    }

    // With parameters
    [EditorBrowsable(EditorBrowsableState.Never)]
    [GenerateAssertion(ExpectationMessage = "to have role '{role}'")]
    public static bool HasRole(this User user, string role)
    {
        return user.Roles.Contains(role);
    }

    // Custom messages with AssertionResult
    [EditorBrowsable(EditorBrowsableState.Never)]
    [GenerateAssertion(ExpectationMessage = "to have valid email")]
    public static AssertionResult HasValidEmail(this User user)
    {
        if (string.IsNullOrEmpty(user.Email))
            return AssertionResult.Failed("Email is null or empty");

        if (!user.Email.Contains("@"))
            return AssertionResult.Failed($"Email '{user.Email}' is not valid");

        return AssertionResult.Passed;
    }

    // Async with database
    [EditorBrowsable(EditorBrowsableState.Never)]
    [GenerateAssertion(ExpectationMessage = "to exist in database")]
    public static async Task<bool> ExistsInDatabaseAsync(this User user, DbContext db)
    {
        return await db.Users.AnyAsync(u => u.Id == user.Id);
    }
}

// Usage in tests:
[Test]
public async Task ValidateUser()
{
    var user = new User { Id = 1, Email = "test@example.com", Roles = ["Admin"] };

    await Assert.That(user).HasValidId();
    await Assert.That(user).HasRole("Admin");
    await Assert.That(user).HasValidEmail();
    await Assert.That(user).ExistsInDatabaseAsync(dbContext);

    // Chaining:
    await Assert.That(user)
        .HasValidId()
        .And.HasValidEmail()
        .And.HasRole("Admin");
}
```

---

## See Also

- [Custom Assertions (Manual)](./custom-assertions.md) - For when you need full control

---

## FSharp


As awaiting doesn't work quite the same in F#, the syntax instead looks like this:

```fsharp
do! check Assert.That(...).IsSomething()
```

So a test could look like:

```fsharp
member this.CheckPositive() = async {
    let result = 1 + 1
    do! check (Assert.That(result).IsPositive())
}
```

F# is a lot more strict with type resolution when it comes to extension methods and method overloads. Because of that you may need to annotate the type for the assertions.

For example,

```fsharp
[<Test>]
[<Category("Pass")>]
member _.Test3() = async {
    let value = "1"
    do! check (Assert.That<string>(value).IsEqualTo("1"))
}

[<Test>]
[<Category("Fail")>]
member _.Throws1() = async {
    do! check (Assert.That<string>(fun () -> task { return new string([||]) }).ThrowsException())
}

[<Test>]
[<Category("Pass")>]
member _.Throws4() = async {
    do! check (Assert.That<bool>(fun () -> Task.FromResult(true)).ThrowsNothing())
}
```

## taskAssert expression

For Task-based tests you can also use the taskAssert computation expression to avoid wrapping every assertion in check.

To use it, open the namespace:

```fsharp
open TUnit.Assertions.FSharp.TaskAssert
```

Inside a taskAssert block you can directly do! the assertion:
```fsharp
[<Test>]
[<Category("Pass")>]
member _.Test3() = taskAssert {
    let value = "1"
    do! Assert.That(value).IsEqualTo("1")
}
```

---

## Getting Started with Assertions


TUnit provides a comprehensive, fluent assertion library that makes your tests readable and expressive. This guide introduces the core concepts and gets you started with writing assertions.

## Basic Syntax

All assertions in TUnit follow a consistent pattern using the `Assert.That()` method:

```csharp
await Assert.That(actualValue).IsEqualTo(expectedValue);
```

The basic flow is:
1. Start with `Assert.That(value)`
2. Chain assertion methods (e.g., `.IsEqualTo()`, `.Contains()`, `.IsGreaterThan()`)
3. Always `await` the assertion (TUnit's assertions are async)

## Why Await?

TUnit assertions must be awaited. This design enables:
- **Async support**: Seamlessly test async operations
- **Rich error messages**: Build detailed failure messages during execution
- **Extensibility**: Create custom assertions that can perform async operations

```csharp
// ✅ Correct - awaited
await Assert.That(result).IsEqualTo(42);

// ❌ Wrong - will cause compiler warning
Assert.That(result).IsEqualTo(42);
```

TUnit includes a built-in analyzer that warns you if you forget to `await` an assertion.

## Assertion Categories

TUnit provides assertions for all common scenarios:

### Equality & Comparison

```csharp
await Assert.That(actual).IsEqualTo(expected);
await Assert.That(value).IsNotEqualTo(other);
await Assert.That(score).IsGreaterThan(70);
await Assert.That(age).IsLessThanOrEqualTo(100);
await Assert.That(temperature).IsBetween(20, 30);
```

### Strings

```csharp
await Assert.That(message).Contains("Hello");
await Assert.That(filename).StartsWith("test_");
await Assert.That(email).Matches(@"^[\w\.-]+@[\w\.-]+\.\w+$");
await Assert.That(input).IsNotEmpty();
```

### Collections

```csharp
await Assert.That(numbers).Contains(42);
await Assert.That(items).Count().IsEqualTo(5);
await Assert.That(list).IsNotEmpty();
await Assert.That(values).All(x => x > 0);
```

### Booleans & Null

```csharp
await Assert.That(isValid).IsTrue();
await Assert.That(result).IsNotNull();
await Assert.That(optional).IsDefault();
```

### Exceptions

```csharp
await Assert.That(() => DivideByZero())
    .Throws<DivideByZeroException>()
    .WithMessage("Attempted to divide by zero.");
```

### Type Checking

```csharp
await Assert.That(obj).IsTypeOf<MyClass>();
await Assert.That(typeof(Dog)).IsAssignableTo<Animal>();
```

## Chaining Assertions

Combine multiple assertions on the same value using `.And`:

```csharp
await Assert.That(username)
    .IsNotNull()
    .And.IsNotEmpty()
    .And.Length().IsGreaterThan(3)
    .And.Length().IsLessThan(20);
```

Use `.Or` when any condition can be true:

```csharp
await Assert.That(statusCode)
    .IsEqualTo(200)
    .Or.IsEqualTo(201)
    .Or.IsEqualTo(204);
```

## Multiple Assertions with Assert.Multiple()

Group related assertions together so all failures are reported:

```csharp
using (Assert.Multiple())
{
    await Assert.That(user.FirstName).IsEqualTo("John");
    await Assert.That(user.LastName).IsEqualTo("Doe");
    await Assert.That(user.Age).IsGreaterThan(18);
    await Assert.That(user.Email).IsNotNull();
}
```

Instead of stopping at the first failure, `Assert.Multiple()` runs all assertions and reports every failure together.

## Member Assertions

Assert on object properties using `.Member()`:

```csharp
await Assert.That(person)
    .Member(p => p.Name, name => name.IsEqualTo("Alice"))
    .And.Member(p => p.Age, age => age.IsGreaterThan(18));
```

This works with nested properties too:

```csharp
await Assert.That(order)
    .Member(o => o.Customer.Address.City, city => city.IsEqualTo("Seattle");
```

## Working with Collections

Collections have rich assertion support:

```csharp
var numbers = new[] { 1, 2, 3, 4, 5 };

// Count and emptiness
await Assert.That(numbers).Count().IsEqualTo(5);
await Assert.That(numbers).IsNotEmpty();

// Membership
await Assert.That(numbers).Contains(3);
await Assert.That(numbers).DoesNotContain(10);

// Predicates
await Assert.That(numbers).All(n => n > 0);
await Assert.That(numbers).Any(n => n == 3);

// Ordering
await Assert.That(numbers).IsInOrder();

// Equivalence (same items, any order)
await Assert.That(numbers).IsEquivalentTo(new[] { 5, 4, 3, 2, 1 });
```

## Returning Values from Assertions

Some assertions return the value being tested, allowing you to continue working with it:

```csharp
// HasSingleItem returns the single item
var user = await Assert.That(users).HasSingleItem();
await Assert.That(user.Name).IsEqualTo("Alice");

// Contains with predicate returns the found item
var admin = await Assert.That(users).Contains(u => u.Role == "Admin");
await Assert.That(admin.Permissions).IsNotEmpty();
```

## Custom Expectations

Use `.Satisfies()` for custom conditions:

```csharp
await Assert.That(value).Satisfies(v => v % 2 == 0, "Value must be even");
```

Or map to a different value before asserting:

```csharp
await Assert.That(order)
    .Satisfies(o => o.Total, total => total > 100);
```

## Common Patterns

### Testing Numeric Ranges

```csharp
await Assert.That(score).IsBetween(0, 100);
await Assert.That(temperature).IsGreaterThanOrEqualTo(32);
```

### Testing with Tolerance

For floating-point comparisons:

```csharp
await Assert.That(3.14159).IsEqualTo(Math.PI).Within(0.001);
```

### Testing Async Operations

```csharp
await Assert.That(async () => await FetchDataAsync())
    .Throws<HttpRequestException>();

await Assert.That(longRunningTask).CompletesWithin(TimeSpan.FromSeconds(5));
```

### Testing Multiple Conditions

```csharp
await Assert.That(username)
    .IsNotNull()
    .And.Satisfies(name => name.Length >= 3 && name.Length <= 20,
                   "Username must be 3-20 characters");
```

## Type Safety

TUnit's assertions are strongly typed and catch type mismatches at compile time:

```csharp
int number = 42;
string text = "42";

// ✅ This works - both are ints
await Assert.That(number).IsEqualTo(42);

// ❌ This won't compile - can't compare int to string
// await Assert.That(number).IsEqualTo("42");
```

## Common Mistakes & Best Practices

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

### Forgetting to Await

<Tabs>
  <TabItem value="bad" label="❌ Bad - Missing Await" default>

```csharp
[Test]
public void TestValue()
{
    // Compiler warning: assertion not awaited
    Assert.That(result).IsEqualTo(42);
}
```

**Problem:** Assertion never executes, test always passes even if it should fail.

  </TabItem>
  <TabItem value="good" label="✅ Good - Awaited Properly">

```csharp
[Test]
public async Task TestValue()
{
    await Assert.That(result).IsEqualTo(42);
}
```

**Why:** Awaiting ensures the assertion executes and can fail the test.

  </TabItem>
</Tabs>

### Comparing Different Types

<Tabs>
  <TabItem value="bad" label="❌ Bad - Type Confusion">

```csharp
int number = 42;
// This won't compile - can't compare int to string
// await Assert.That(number).IsEqualTo("42");

// Or this pattern that converts implicitly
string value = GetValue();
await Assert.That(value).IsEqualTo(42); // Won't compile
```

**Problem:** Type mismatches are caught at compile time, preventing runtime surprises.

  </TabItem>
  <TabItem value="good" label="✅ Good - Explicit Conversion">

```csharp
string value = GetValue();
int parsed = int.Parse(value);
await Assert.That(parsed).IsEqualTo(42);

// Or test the string directly
await Assert.That(value).IsEqualTo("42");
```

**Why:** Be explicit about what you're testing - the string value or its parsed equivalent.

  </TabItem>
</Tabs>

### Collection Ordering

<Tabs>
  <TabItem value="bad" label="❌ Bad - Assuming Order">

```csharp
var items = GetItemsFromDatabase(); // Order not guaranteed
await Assert.That(items).IsEqualTo(new[] { 1, 2, 3 });
```

**Problem:** Fails unexpectedly if database returns `[3, 1, 2]` even though items are equivalent.

  </TabItem>
  <TabItem value="good" label="✅ Good - Order-Independent">

```csharp
var items = GetItemsFromDatabase();
await Assert.That(items).IsEquivalentTo(new[] { 1, 2, 3 });
```

**Why:** `IsEquivalentTo` checks for same items regardless of order, making tests more resilient.

  </TabItem>
</Tabs>

### Multiple Related Assertions

<Tabs>
  <TabItem value="bad" label="❌ Bad - Sequential Assertions">

```csharp
await Assert.That(user.FirstName).IsEqualTo("John");
await Assert.That(user.LastName).IsEqualTo("Doe");
await Assert.That(user.Age).IsGreaterThan(18);
// If first assertion fails, you won't see the other failures
```

**Problem:** Stops at first failure, hiding other issues.

  </TabItem>
  <TabItem value="good" label="✅ Good - Assert.Multiple">

```csharp
using (Assert.Multiple())
{
    await Assert.That(user.FirstName).IsEqualTo("John");
    await Assert.That(user.LastName).IsEqualTo("Doe");
    await Assert.That(user.Age).IsGreaterThan(18);
}
// Shows ALL failures at once
```

**Why:** See all failures in one test run, saving debugging time.

  </TabItem>
</Tabs>

## Next Steps

Now that you understand the basics, explore specific assertion types:

- **[Equality & Comparison](equality-and-comparison.md)** - Detailed equality and comparison assertions
- **[Strings](string.md)** - Comprehensive string testing
- **[Collections](collections.md)** - Advanced collection assertions
- **[Exceptions](exceptions.md)** - Testing thrown exceptions
- **[Custom Assertions](extensibility/custom-assertions.md)** - Create your own assertions

## Quick Reference

| Assertion Category | Example |
|-------------------|---------|
| Equality | `IsEqualTo()`, `IsNotEqualTo()` |
| Comparison | `IsGreaterThan()`, `IsLessThan()`, `IsBetween()` |
| Null/Default | `IsNull()`, `IsNotNull()`, `IsDefault()` |
| Boolean | `IsTrue()`, `IsFalse()` |
| Strings | `Contains()`, `StartsWith()`, `Matches()` |
| Collections | `Contains()`, `Count()`, `All()`, `Any()` |
| Exceptions | `Throws<T>()`, `ThrowsNothing()` |
| Types | `IsTypeOf<T>()`, `IsAssignableTo<T>()` |
| Async | `CompletesWithin()`, async exception testing |

For a complete list of all assertions, see the specific category pages in the sidebar.

---

## Assertions Library

import AssertionsLibrary from '@site/src/components/AssertionsLibrary';

<AssertionsLibrary />

---

## Member Assertions


The `.Member()` method allows you to assert on object properties while maintaining the parent object's context for chaining. This is useful when you need to validate multiple properties of the same object.

## Basic Usage

```csharp
[Test]
public async Task BasicMemberAssertions()
{
    var user = await GetUserAsync();

    // Assert on a single property
    await Assert.That(user)
        .Member(u => u.Email, email => email.IsEqualTo("user@example.com"));

    // Chain multiple property assertions
    await Assert.That(user)
        .Member(u => u.FirstName, name => name.IsEqualTo("John"))
        .And.Member(u => u.LastName, name => name.IsEqualTo("Doe"))
        .And.Member(u => u.Age, age => age.IsGreaterThan(18));
}
```

## Why Use Member Assertions?

The key advantage of `.Member()` is that it returns to the parent context after each assertion, allowing you to chain multiple property checks:

```csharp
[Test]
public async Task MemberAssertionsWithFullContext()
{
    var order = await GetOrderAsync();

    // Each .Member() call works on the order object
    await Assert.That(order)
        .IsNotNull()
        .And.Member(o => o.OrderId, id => id.IsGreaterThan(0))
        .And.Member(o => o.Status, status => status.IsEqualTo(OrderStatus.Pending))
        .And.Member(o => o.Total, total => total.IsGreaterThan(0));
}
```

## Nested Properties

Member assertions support nested properties:

```csharp
[Test]
public async Task NestedPropertyAssertions()
{
    var customer = await GetCustomerAsync();

    // Access nested properties directly
    await Assert.That(customer)
        .Member(c => c.Address.Street, street => street.IsNotNull())
        .And.Member(c => c.Address.City, city => city.IsEqualTo("Seattle"))
        .And.Member(c => c.Address.ZipCode, zip => zip.Matches(@"^\d{5}$"));
}
```

## Complex Assertions on Members

You can perform complex assertions on member values, including collections:

```csharp
[Test]
public async Task ComplexMemberAssertions()
{
    var team = await GetTeamAsync();

    await Assert.That(team)
        .Member(t => t.Name, name => name.StartsWith("Team"))
        .And.Member(t => t.Members, members => members
            .Count().IsGreaterThan(0)
            .And.All(m => m.IsActive)
            .And.Any(m => m.Role == "Lead"))
        .And.Member(t => t.CreatedDate, date => date
            .IsGreaterThan(DateTime.UtcNow.AddYears(-1)));
}
```

## Using Or Logic

Member assertions work with both `.And` and `.Or` combinators:

```csharp
[Test]
public async Task MemberAssertionsWithOrLogic()
{
    var product = await GetProductAsync();

    // Use Or to check alternative conditions
    await Assert.That(product)
        .Member(p => p.Status, status => status.IsEqualTo(ProductStatus.Active))
        .Or.Member(p => p.Status, status => status.IsEqualTo(ProductStatus.Preview));

    // Mix And and Or for complex logic
    await Assert.That(product)
        .Member(p => p.Price, price => price.IsGreaterThan(0))
        .And.Member(p => p.Stock, stock => stock.IsGreaterThan(0))
        .Or.Member(p => p.BackorderAllowed, allowed => allowed.IsTrue());
}
```

## Complete Example

```csharp
[Test]
public async Task ComplexObjectValidation()
{
    var user = await GetUserAsync("john.doe");

    // Chain multiple member assertions
    await Assert.That(user)
        .IsNotNull()
        .And.Member(u => u.Email, email => email.IsEqualTo("john.doe@example.com"))
        .And.Member(u => u.Age, age => age.IsGreaterThan(18))
        .And.Member(u => u.Roles, roles => roles.Contains("Admin"));
}
```

## Nested Object Assertions

```csharp
[Test]
public async Task NestedObjectAssertions()
{
    var company = await GetCompanyAsync();

    await Assert.That(company)
        .IsNotNull()
        .And.Member(c => c.Name, name => name.IsEqualTo("TechCorp"))
        .And.Member(c => c.Address.City, city => city.IsEqualTo("Seattle"))
        .And.Member(c => c.Address.ZipCode, zip => zip.Matches(@"^\d{5}$"))
        .And.Member(c => c.Employees, employees => employees
            .Count().IsBetween(100, 500)
            .And.All(e => e.Email.EndsWith("@techcorp.com")));
}
```

---

## Null and Default Value Assertions


TUnit provides assertions for testing null values and default values. These assertions integrate with C#'s nullability annotations to provide better compile-time safety.

## Null Assertions

### IsNull

Tests that a value is `null`:

```csharp
[Test]
public async Task Null_Value()
{
    string? result = GetOptionalValue();
    await Assert.That(result).IsNull();

    Person? person = FindPerson("unknown-id");
    await Assert.That(person).IsNull();
}
```

### IsNotNull

Tests that a value is not `null`:

```csharp
[Test]
public async Task Not_Null_Value()
{
    string? result = GetRequiredValue();
    await Assert.That(result).IsNotNull();

    var user = GetCurrentUser();
    await Assert.That(user).IsNotNull();
}
```

## Nullability Flow Analysis

When you use `IsNotNull()`, C#'s nullability analysis understands that the value is non-null afterward:

```csharp
[Test]
public async Task Nullability_Flow()
{
    string? maybeNull = GetValue();

    // After this assertion, compiler knows it's not null
    await Assert.That(maybeNull).IsNotNull();

    // No warning - compiler knows it's safe
    int length = maybeNull.Length;
}
```

This works with chaining too:

```csharp
[Test]
public async Task Chained_After_Null_Check()
{
    string? input = GetInput();

    await Assert.That(input)
        .IsNotNull()
        .And.IsNotEmpty()  // Compiler knows input is not null
        .And.Length().IsGreaterThan(5);
}
```

## Default Value Assertions

### IsDefault

Tests that a value equals the default value for its type:

```csharp
[Test]
public async Task Default_Values()
{
    // Reference types - default is null
    string? text = default;
    await Assert.That(text).IsDefault();

    // Value types - default is zero/false/empty struct
    int number = default;
    await Assert.That(number).IsDefault(); // 0

    bool flag = default;
    await Assert.That(flag).IsDefault(); // false

    DateTime date = default;
    await Assert.That(date).IsDefault(); // DateTime.MinValue

    Guid id = default;
    await Assert.That(id).IsDefault(); // Guid.Empty
}
```

### IsNotDefault

Tests that a value is not the default value for its type:

```csharp
[Test]
public async Task Not_Default_Values()
{
    var name = "Alice";
    await Assert.That(name).IsNotDefault();

    var count = 42;
    await Assert.That(count).IsNotDefault();

    var isValid = true;
    await Assert.That(isValid).IsNotDefault();

    var id = Guid.NewGuid();
    await Assert.That(id).IsNotDefault();
}
```

## Reference Types vs Value Types

### Reference Type Defaults

For reference types, default equals `null`:

```csharp
[Test]
public async Task Reference_Type_Defaults()
{
    string? text = default;
    object? obj = default;
    Person? person = default;

    await Assert.That(text).IsDefault();   // Same as IsNull()
    await Assert.That(obj).IsDefault();    // Same as IsNull()
    await Assert.That(person).IsDefault(); // Same as IsNull()
}
```

### Value Type Defaults

For value types, default is the zero-initialized value:

```csharp
[Test]
public async Task Value_Type_Defaults()
{
    // Numeric types default to 0
    int intVal = default;
    await Assert.That(intVal).IsDefault();
    await Assert.That(intVal).IsEqualTo(0);

    double doubleVal = default;
    await Assert.That(doubleVal).IsDefault();
    await Assert.That(doubleVal).IsEqualTo(0.0);

    // Boolean defaults to false
    bool boolVal = default;
    await Assert.That(boolVal).IsDefault();
    await Assert.That(boolVal).IsFalse();

    // Struct defaults to all fields/properties at their defaults
    Point point = default;
    await Assert.That(point).IsDefault();
    await Assert.That(point).IsEqualTo(new Point(0, 0));
}
```

### Nullable Value Types

Nullable value types (`T?`) are reference types, so their default is `null`:

```csharp
[Test]
public async Task Nullable_Value_Type_Defaults()
{
    int? nullableInt = default;
    await Assert.That(nullableInt).IsDefault(); // Same as IsNull()
    await Assert.That(nullableInt).IsNull();    // Also works

    DateTime? nullableDate = default;
    await Assert.That(nullableDate).IsDefault();
    await Assert.That(nullableDate).IsNull();
}
```

## Practical Examples

### Optional Parameters and Returns

```csharp
[Test]
public async Task Optional_Return_Value()
{
    // API might return null if item not found
    var item = await _repository.FindByIdAsync("unknown-id");
    await Assert.That(item).IsNull();

    // API should return value if item exists
    var existing = await _repository.FindByIdAsync("valid-id");
    await Assert.That(existing).IsNotNull();
}
```

### Initialization Checks

```csharp
[Test]
public async Task Uninitialized_Field()
{
    var service = new MyService();

    // Before initialization
    await Assert.That(service.Connection).IsNull();

    await service.InitializeAsync();

    // After initialization
    await Assert.That(service.Connection).IsNotNull();
}
```

### Dependency Injection Validation

```csharp
[Test]
public async Task Constructor_Injection()
{
    var logger = new Mock<ILogger>();
    var service = new UserService(logger.Object);

    // Verify dependency was injected
    await Assert.That(service.Logger).IsNotNull();
}
```

### Lazy Initialization

```csharp
[Test]
public async Task Lazy_Property()
{
    var calculator = new ExpensiveCalculator();

    // Before first access
    await Assert.That(calculator.CachedResult).IsNull();

    var result = calculator.GetResult();

    // After first access - cached
    await Assert.That(calculator.CachedResult).IsNotNull();
}
```

## Checking Multiple Properties

Use `Assert.Multiple()` to check multiple null conditions:

```csharp
[Test]
public async Task Validate_All_Required_Fields()
{
    var user = CreateUser();

    using (Assert.Multiple())
    {
        await Assert.That(user).IsNotNull();
        await Assert.That(user.FirstName).IsNotNull();
        await Assert.That(user.LastName).IsNotNull();
        await Assert.That(user.Email).IsNotNull();
        await Assert.That(user.CreatedDate).IsNotDefault();
    }
}
```

Or chain them:

```csharp
[Test]
public async Task Required_Fields_With_Chaining()
{
    var config = LoadConfiguration();

    await Assert.That(config.DatabaseConnection)
        .IsNotNull()
        .And.Member(c => c.Server).IsNotNull()
        .And.Member(c => c.Database).IsNotNull();
}
```

## Default Values for Custom Types

### Structs

```csharp
public struct Rectangle
{
    public int Width { get; init; }
    public int Height { get; init; }
}

[Test]
public async Task Struct_Default()
{
    Rectangle rect = default;

    await Assert.That(rect).IsDefault();
    await Assert.That(rect.Width).IsEqualTo(0);
    await Assert.That(rect.Height).IsEqualTo(0);
}
```

### Records

```csharp
public record Person(string Name, int Age);

[Test]
public async Task Record_Default()
{
    Person? person = default;
    await Assert.That(person).IsDefault(); // null for reference types
    await Assert.That(person).IsNull();
}

public record struct Point(int X, int Y);

[Test]
public async Task Record_Struct_Default()
{
    Point point = default;
    await Assert.That(point).IsDefault();
    await Assert.That(point.X).IsEqualTo(0);
    await Assert.That(point.Y).IsEqualTo(0);
}
```

## Special Cases

### Empty Collections vs Null

```csharp
[Test]
public async Task Empty_vs_Null()
{
    List<string>? nullList = null;
    List<string> emptyList = new();

    await Assert.That(nullList).IsNull();
    await Assert.That(emptyList).IsNotNull();
    await Assert.That(emptyList).IsEmpty(); // Not null, but empty
}
```

### Empty Strings vs Null

```csharp
[Test]
public async Task Empty_String_vs_Null()
{
    string? nullString = null;
    string emptyString = "";

    await Assert.That(nullString).IsNull();
    await Assert.That(emptyString).IsNotNull();
    await Assert.That(emptyString).IsEmpty(); // Not null, but empty
}
```

### Default GUID

```csharp
[Test]
public async Task GUID_Default()
{
    Guid id = default;

    await Assert.That(id).IsDefault();
    await Assert.That(id).IsEqualTo(Guid.Empty);
    await Assert.That(id).IsEmptyGuid(); // TUnit specific assertion
}
```

### Default DateTime

```csharp
[Test]
public async Task DateTime_Default()
{
    DateTime date = default;

    await Assert.That(date).IsDefault();
    await Assert.That(date).IsEqualTo(DateTime.MinValue);
}
```

## Combining with Other Assertions

### Null Coalescing Validation

```csharp
[Test]
public async Task Null_Coalescing_Default()
{
    string? input = GetOptionalInput();
    string result = input ?? "default";

    if (input == null)
    {
        await Assert.That(result).IsEqualTo("default");
    }
    else
    {
        await Assert.That(result).IsEqualTo(input);
    }
}
```

### Null Conditional Operator

```csharp
[Test]
public async Task Null_Conditional()
{
    Person? person = FindPerson("id");
    string? name = person?.Name;

    if (person == null)
    {
        await Assert.That(name).IsNull();
    }
    else
    {
        await Assert.That(name).IsNotNull();
    }
}
```

## Common Patterns

### Validate Required Dependencies

```csharp
[Test]
public async Task All_Dependencies_Provided()
{
    var service = CreateService();

    await Assert.That(service.Logger).IsNotNull();
    await Assert.That(service.Repository).IsNotNull();
    await Assert.That(service.Cache).IsNotNull();
}
```

### Validate Optional Features

```csharp
[Test]
public async Task Optional_Feature_Not_Enabled()
{
    var config = LoadConfiguration();

    if (!config.EnableAdvancedFeatures)
    {
        await Assert.That(config.AdvancedSettings).IsNull();
    }
}
```

### State Machine Validation

```csharp
[Test]
public async Task State_Transitions()
{
    var workflow = new Workflow();

    // Initial state
    await Assert.That(workflow.CurrentState).IsDefault();

    await workflow.StartAsync();

    // After start
    await Assert.That(workflow.CurrentState).IsNotDefault();
}
```

## See Also

- [Equality & Comparison](equality-and-comparison.md) - Comparing values including defaults
- [Boolean Assertions](boolean.md) - Testing true/false values
- [String Assertions](string.md) - String-specific null and empty checks
- [Collections](collections.md) - Collection null and empty checks

---

## Numeric Assertions


TUnit provides comprehensive assertions for testing numeric values, including specialized assertions for positive/negative values and comparison assertions with tolerance support.

## Sign Assertions

### IsPositive

Tests that a numeric value is greater than zero:

```csharp
[Test]
public async Task Positive_Values()
{
    var profit = 1500m;
    await Assert.That(profit).IsPositive();

    var count = 5;
    await Assert.That(count).IsPositive();

    var rating = 4.5;
    await Assert.That(rating).IsPositive();
}
```

Works with all numeric types:

```csharp
[Test]
public async Task All_Numeric_Types()
{
    // Integers
    await Assert.That(1).IsPositive();           // int
    await Assert.That(1L).IsPositive();          // long
    await Assert.That((short)1).IsPositive();    // short
    await Assert.That((byte)1).IsPositive();     // byte

    // Floating point
    await Assert.That(1.5).IsPositive();         // double
    await Assert.That(1.5f).IsPositive();        // float
    await Assert.That(1.5m).IsPositive();        // decimal
}
```

### IsNegative

Tests that a numeric value is less than zero:

```csharp
[Test]
public async Task Negative_Values()
{
    var loss = -250.50m;
    await Assert.That(loss).IsNegative();

    var temperature = -5;
    await Assert.That(temperature).IsNegative();

    var delta = -0.001;
    await Assert.That(delta).IsNegative();
}
```

### Zero is Neither Positive Nor Negative

```csharp
[Test]
public async Task Zero_Checks()
{
    var zero = 0;

    // These will both fail:
    // await Assert.That(zero).IsPositive();  // ❌ Fails
    // await Assert.That(zero).IsNegative();  // ❌ Fails

    // Instead, check for zero explicitly:
    await Assert.That(zero).IsEqualTo(0);
}
```

## Comparison Assertions

All comparison operators work with numeric types. See [Equality and Comparison](equality-and-comparison.md) for full details.

### Quick Reference

```csharp
[Test]
public async Task Numeric_Comparisons()
{
    var value = 42;

    await Assert.That(value).IsGreaterThan(40);
    await Assert.That(value).IsGreaterThanOrEqualTo(42);
    await Assert.That(value).IsLessThan(50);
    await Assert.That(value).IsLessThanOrEqualTo(42);
    await Assert.That(value).IsBetween(0, 100);
}
```

## Tolerance for Floating-Point Numbers

Floating-point arithmetic can introduce rounding errors. Use tolerance for safe comparisons:

### Double Tolerance

```csharp
[Test]
public async Task Double_Tolerance()
{
    double result = 1.0 / 3.0;  // 0.33333333...
    double expected = 0.333;

    // Without tolerance - might fail
    // await Assert.That(result).IsEqualTo(expected);

    // With tolerance - safe
    await Assert.That(result).IsEqualTo(expected).Within( 0.001);
}
```

### Float Tolerance

```csharp
[Test]
public async Task Float_Tolerance()
{
    float pi = 3.14159f;
    float approximation = 3.14f;

    await Assert.That(pi).IsEqualTo(approximation).Within(0.01f);
}
```

### Decimal Tolerance

Useful for monetary calculations:

```csharp
[Test]
public async Task Decimal_Tolerance()
{
    decimal price = 19.995m;
    decimal rounded = 20.00m;

    await Assert.That(price).IsEqualTo(rounded).Within(0.01m);
}
```

### Long Tolerance

For timestamp or large number comparisons:

```csharp
[Test]
public async Task Long_Tolerance()
{
    long timestamp1 = DateTimeOffset.UtcNow.ToUnixTimeMilliseconds();
    await Task.Delay(50);
    long timestamp2 = DateTimeOffset.UtcNow.ToUnixTimeMilliseconds();

    // Allow 100ms difference
    await Assert.That(timestamp1).IsEqualTo(timestamp2).Within(100L);
}
```

## Practical Examples

### Financial Calculations

```csharp
[Test]
public async Task Calculate_Total_Price()
{
    decimal unitPrice = 9.99m;
    int quantity = 3;
    decimal tax = 0.08m; // 8%

    decimal subtotal = unitPrice * quantity;
    decimal total = subtotal * (1 + tax);

    await Assert.That(total).IsPositive();
    await Assert.That(total).IsGreaterThan(subtotal);
    await Assert.That(total).IsEqualTo(32.37m).Within(0.01m);
}
```

### Temperature Conversions

```csharp
[Test]
public async Task Celsius_To_Fahrenheit()
{
    double celsius = 20.0;
    double fahrenheit = celsius * 9.0 / 5.0 + 32.0;

    await Assert.That(fahrenheit).IsEqualTo(68.0).Within(0.1);
    await Assert.That(fahrenheit).IsGreaterThan(celsius);
}
```

### Percentage Calculations

```csharp
[Test]
public async Task Calculate_Percentage()
{
    int total = 200;
    int passed = 175;
    double percentage = (double)passed / total * 100;

    await Assert.That(percentage).IsPositive();
    await Assert.That(percentage).IsBetween(0, 100);
    await Assert.That(percentage).IsEqualTo(87.5).Within(0.1);
}
```

### Statistical Calculations

```csharp
[Test]
public async Task Calculate_Average()
{
    var numbers = new[] { 10, 20, 30, 40, 50 };
    double average = numbers.Average();

    await Assert.That(average).IsEqualTo(30.0).Within(0.01);
    await Assert.That(average).IsGreaterThan(numbers.Min());
    await Assert.That(average).IsLessThan(numbers.Max());
}
```

## Range Validation

### Valid Range Checks

```csharp
[Test]
public async Task Validate_Age()
{
    int age = 25;

    await Assert.That(age).IsBetween(0, 120);
    await Assert.That(age).IsGreaterThanOrEqualTo(0);
}
```

### Percentage Range

```csharp
[Test]
public async Task Validate_Percentage()
{
    double successRate = 87.5;

    await Assert.That(successRate).IsBetween(0, 100);
    await Assert.That(successRate).IsPositive();
}
```

### Score Validation

```csharp
[Test]
public async Task Validate_Score()
{
    int score = 85;
    int minPassing = 60;
    int maxScore = 100;

    await Assert.That(score).IsBetween(minPassing, maxScore);
    await Assert.That(score).IsGreaterThanOrEqualTo(minPassing);
}
```

## Mathematical Operations

### Addition

```csharp
[Test]
public async Task Addition()
{
    var result = 5 + 3;

    await Assert.That(result).IsEqualTo(8);
    await Assert.That(result).IsPositive();
    await Assert.That(result).IsGreaterThan(5);
}
```

### Subtraction

```csharp
[Test]
public async Task Subtraction()
{
    var result = 10 - 3;

    await Assert.That(result).IsEqualTo(7);
    await Assert.That(result).IsPositive();
}
```

### Multiplication

```csharp
[Test]
public async Task Multiplication()
{
    var result = 4 * 5;

    await Assert.That(result).IsEqualTo(20);
    await Assert.That(result).IsPositive();
}
```

### Division

```csharp
[Test]
public async Task Division()
{
    double result = 10.0 / 4.0;

    await Assert.That(result).IsEqualTo(2.5).Within(0.001);
    await Assert.That(result).IsPositive();
}
```

### Modulo

```csharp
[Test]
public async Task Modulo()
{
    var result = 17 % 5;

    await Assert.That(result).IsEqualTo(2);
    await Assert.That(result).IsGreaterThanOrEqualTo(0);
    await Assert.That(result).IsLessThan(5);
}
```

## Working with Math Library

### Rounding

```csharp
[Test]
public async Task Math_Round()
{
    double value = 3.7;
    double rounded = Math.Round(value);

    await Assert.That(rounded).IsEqualTo(4.0).Within(0.001);
}
```

### Ceiling and Floor

```csharp
[Test]
public async Task Math_Ceiling_Floor()
{
    double value = 3.2;

    double ceiling = Math.Ceiling(value);
    await Assert.That(ceiling).IsEqualTo(4.0);

    double floor = Math.Floor(value);
    await Assert.That(floor).IsEqualTo(3.0);
}
```

### Absolute Value

```csharp
[Test]
public async Task Math_Abs()
{
    int negative = -42;
    int positive = Math.Abs(negative);

    await Assert.That(positive).IsPositive();
    await Assert.That(positive).IsEqualTo(42);
}
```

### Power and Square Root

```csharp
[Test]
public async Task Math_Power_Sqrt()
{
    double squared = Math.Pow(5, 2);
    await Assert.That(squared).IsEqualTo(25.0).Within(0.001);

    double root = Math.Sqrt(25);
    await Assert.That(root).IsEqualTo(5.0).Within(0.001);
}
```

### Trigonometry

```csharp
[Test]
public async Task Math_Trigonometry()
{
    double angle = Math.PI / 4; // 45 degrees
    double sine = Math.Sin(angle);

    await Assert.That(sine).IsEqualTo(Math.Sqrt(2) / 2).Within(0.0001);
    await Assert.That(sine).IsPositive();
    await Assert.That(sine).IsBetween(0, 1);
}
```

## Increment and Decrement

```csharp
[Test]
public async Task Increment_Decrement()
{
    int counter = 0;

    counter++;
    await Assert.That(counter).IsEqualTo(1);
    await Assert.That(counter).IsPositive();

    counter--;
    await Assert.That(counter).IsEqualTo(0);

    counter--;
    await Assert.That(counter).IsEqualTo(-1);
    await Assert.That(counter).IsNegative();
}
```

## Chaining Numeric Assertions

```csharp
[Test]
public async Task Chained_Numeric_Assertions()
{
    int score = 85;

    await Assert.That(score)
        .IsPositive()
        .And.IsGreaterThan(70)
        .And.IsLessThan(100)
        .And.IsBetween(80, 90);
}
```

## Nullable Numeric Types

```csharp
[Test]
public async Task Nullable_Numerics()
{
    int? value = 42;

    await Assert.That(value).IsNotNull();
    await Assert.That(value).IsEqualTo(42);
    await Assert.That(value).IsPositive();
}

[Test]
public async Task Nullable_Null()
{
    int? value = null;

    await Assert.That(value).IsNull();
}
```

## Special Floating-Point Values

### Infinity

```csharp
[Test]
public async Task Infinity_Checks()
{
    double positiveInfinity = double.PositiveInfinity;
    double negativeInfinity = double.NegativeInfinity;

    await Assert.That(positiveInfinity).IsEqualTo(double.PositiveInfinity);
    await Assert.That(negativeInfinity).IsEqualTo(double.NegativeInfinity);
}
```

### NaN (Not a Number)

```csharp
[Test]
public async Task NaN_Checks()
{
    double nan = double.NaN;

    // NaN is never equal to itself
    await Assert.That(double.IsNaN(nan)).IsTrue();

    // Can't use IsEqualTo with NaN
    // await Assert.That(nan).IsEqualTo(double.NaN); // ❌ Won't work
}
```

## Performance Metrics

```csharp
[Test]
public async Task Response_Time_Check()
{
    var stopwatch = Stopwatch.StartNew();
    await PerformOperationAsync();
    stopwatch.Stop();

    long milliseconds = stopwatch.ElapsedMilliseconds;

    await Assert.That(milliseconds).IsPositive();
    await Assert.That(milliseconds).IsLessThan(1000); // Under 1 second
}
```

## Common Patterns

### Boundary Testing

```csharp
[Test]
public async Task Boundary_Values()
{
    int min = int.MinValue;
    int max = int.MaxValue;

    await Assert.That(min).IsNegative();
    await Assert.That(max).IsPositive();
    await Assert.That(min).IsLessThan(max);
}
```

### Growth Rate Validation

```csharp
[Test]
public async Task Growth_Rate()
{
    decimal previousValue = 100m;
    decimal currentValue = 125m;
    decimal growthRate = (currentValue - previousValue) / previousValue * 100;

    await Assert.That(growthRate).IsPositive();
    await Assert.That(growthRate).IsEqualTo(25m).Within(0.1m);
}
```

### Ratio Calculations

```csharp
[Test]
public async Task Success_Ratio()
{
    int successful = 85;
    int total = 100;
    double ratio = (double)successful / total;

    await Assert.That(ratio).IsPositive();
    await Assert.That(ratio).IsBetween(0, 1);
    await Assert.That(ratio).IsGreaterThan(0.8); // 80% threshold
}
```

## See Also

- [Equality & Comparison](equality-and-comparison.md) - General comparison assertions
- [DateTime Assertions](datetime.md) - Time-based numeric values with tolerance
- [Collections](collections.md) - Numeric operations on collections (Count, Sum, Average)

---

## Or Conditions


Similar to the `And` property, there is also the `Or` property.

When using this, only one condition needs to pass:

```csharp
    [Test]
    [Repeat(100)]
    public async Task MyTest()
    {
        int[] array = [1, 2];
        var randomValue1 = Random.Shared.GetItems(array, 1).First();
        var randomValue2 = Random.Shared.GetItems(array, 1).First();
        
        var result = Add(randomValue1, randomValue2);

        await Assert.That(result)
            .IsEqualTo(2)
            .Or.IsEqualTo(3)
            .Or.IsEqualTo(4);
    }
```

---

## Regex Assertions


The `.Matches()` method allows you to validate strings against regular expressions and assert on capture groups, match positions, and match lengths. This is useful when you need to validate structured text like emails, phone numbers, dates, or extract specific parts of a string.

## Basic Usage

```csharp
[Test]
public async Task BasicRegexAssertions()
{
    var email = "john.doe@example.com";

    // Assert that string matches a pattern
    await Assert.That(email).Matches(@"^[\w.]+@[\w.]+$");

    // Use a compiled Regex object
    var emailRegex = new Regex(@"^[\w.]+@[\w.]+$");
    await Assert.That(email).Matches(emailRegex);

    // Use source-generated regex (C# 11+)
    [GeneratedRegex(@"^[\w.]+@[\w.]+$")]
    static partial Regex EmailRegex();

    await Assert.That(email).Matches(EmailRegex());
}
```

## Group Assertions

The key advantage of regex assertions is the ability to assert on capture groups using `.Group()`:

### Named Groups

```csharp
[Test]
public async Task NamedGroupAssertions()
{
    var email = "john.doe@example.com";
    var pattern = @"(?<username>[\w.]+)@(?<domain>[\w.]+)";

    // Assert on named capture groups (requires .And before .Group())
    await Assert.That(email)
        .Matches(pattern)
        .And.Group("username", user => user.IsEqualTo("john.doe"))
        .And.Group("domain", domain => domain.IsEqualTo("example.com"));
}
```

### Indexed Groups

```csharp
[Test]
public async Task IndexedGroupAssertions()
{
    var date = "2025-10-28";
    var pattern = @"(\d{4})-(\d{2})-(\d{2})";

    // Assert on indexed capture groups (1-based, 0 is full match)
    await Assert.That(date)
        .Matches(pattern)
        .And.Group(0, full => full.IsEqualTo("2025-10-28"))
        .And.Group(1, year => year.IsEqualTo("2025"))
        .And.Group(2, month => month.IsEqualTo("10"))
        .And.Group(3, day => day.IsEqualTo("28"));
}
```

## Multiple Matches

When a regex matches multiple times in a string, you can access specific matches using `.Match(index)`:

```csharp
[Test]
public async Task MultipleMatchAssertions()
{
    var text = "test123 hello456 world789";
    var pattern = @"\w+\d+";

    // Assert on first match
    await Assert.That(text)
        .Matches(pattern)
        .And.Match(0)
        .And.Group(0, match => match.IsEqualTo("test123"));

    // Use lambda pattern to assert on a specific match
    await Assert.That(text)
        .Matches(pattern)
        .And.Match(1, match => match.Group(0, g => g.IsEqualTo("hello456")));
}
```

## Match Position and Length

You can assert on where a match occurs and its length:

```csharp
[Test]
public async Task PositionAndLengthAssertions()
{
    var text = "Hello World 123";
    var pattern = @"\d+";

    // Assert that match is at specific index
    await Assert.That(text)
        .Matches(pattern)
        .AtIndex(12);

    // Assert that match has specific length
    await Assert.That(text)
        .Matches(pattern)
        .Length().IsEqualTo(3);

    // Combine with group assertions
    await Assert.That(text)
        .Matches(pattern)
        .AtIndex(12)
        .And.Length().IsEqualTo(3);
}
```

## Complex Patterns with Multiple Groups

```csharp
[Test]
public async Task ComplexPatternAssertions()
{
    var logEntry = "[2025-10-28 14:30:45] ERROR: Connection timeout";
    var pattern = @"\[(?<date>\d{4}-\d{2}-\d{2}) (?<time>\d{2}:\d{2}:\d{2})\] (?<level>\w+): (?<message>.+)";

    await Assert.That(logEntry)
        .Matches(pattern)
        .And.Group("date", date => date.IsEqualTo("2025-10-28"))
        .And.Group("time", time => time.StartsWith("14"))
        .And.Group("level", level => level.IsEqualTo("ERROR"))
        .And.Group("message", msg => msg.Contains("timeout"));
}
```

## Product Information Validation

```csharp
[Test]
public async Task ProductCodeValidation()
{
    var product = "Product: ABC-123 Price: $99.99 Stock: 42";
    var pattern = @"Product:\s+(?<code>[A-Z]+-\d+)\s+Price:\s+\$(?<price>[\d.]+)\s+Stock:\s+(?<stock>\d+)";

    await Assert.That(product)
        .Matches(pattern)
        .And.Group("code", code => code.StartsWith("ABC"))
        .And.Group("price", price => price.Contains(".99"))
        .And.Group("stock", stock => stock.Length().IsEqualTo(2));
}
```

## URL Parsing

```csharp
[Test]
public async Task UrlParsingAssertions()
{
    var url = "https://api.example.com:8080/users/123?format=json";
    var pattern = @"(?<protocol>https?)://(?<host>[\w.]+):(?<port>\d+)/(?<path>[^?]+)\?(?<query>.+)";

    await Assert.That(url)
        .Matches(pattern)
        .And.Group("protocol", p => p.IsEqualTo("https"))
        .And.Group("host", h => h.Contains("api"))
        .And.Group("port", p => p.IsEqualTo("8080"))
        .And.Group("path", p => p.StartsWith("users/"))
        .And.Group("query", q => q.Contains("format=json"));
}
```

## Regex Options

Use `.IgnoringCase()` or `.WithOptions()` for case-insensitive or other regex options:

```csharp
[Test]
public async Task RegexOptionsAssertions()
{
    var text = "HELLO world";

    // Case-insensitive matching
    await Assert.That(text)
        .Matches(@"hello")
        .IgnoringCase();

    // Custom options
    await Assert.That(text)
        .Matches(@"^hello.*world$")
        .WithOptions(RegexOptions.IgnoreCase | RegexOptions.Singleline);
}
```

## Source-Generated Regex (Recommended)

For performance-critical code, use C# 11+ source-generated regex:

```csharp
public partial class MyTests
{
    [GeneratedRegex(@"(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{2})")]
    private static partial Regex DatePattern();

    [Test]
    public async Task SourceGeneratedRegexAssertions()
    {
        var date = "2025-10-28";

        // Source-generated regex provides better performance
        await Assert.That(date)
            .Matches(DatePattern())
            .And.Group("year", y => y.IsEqualTo("2025"))
            .And.Group("month", m => m.IsEqualTo("10"))
            .And.Group("day", d => d.IsEqualTo("28"));
    }
}
```

## Optional and Empty Groups

Handle optional capture groups that may be empty:

```csharp
[Test]
public async Task OptionalGroupAssertions()
{
    var phone1 = "(555) 123-4567";
    var phone2 = "123-4567";
    var pattern = @"(\((?<area>\d{3})\)\s+)?(?<prefix>\d{3})-(?<line>\d{4})";

    // Phone with area code
    await Assert.That(phone1)
        .Matches(pattern)
        .And.Group("area", area => area.IsEqualTo("555"))
        .And.Group("prefix", p => p.IsEqualTo("123"));

    // Phone without area code (optional group is empty)
    await Assert.That(phone2)
        .Matches(pattern)
        .And.Group("area", area => area.IsEqualTo(""))
        .And.Group("prefix", p => p.IsEqualTo("123"));
}
```

## Complete Example

```csharp
[Test]
public async Task CompleteEmailValidation()
{
    var email = "john.doe+test@mail.example.com";
    var pattern = @"(?<local>[\w.+-]+)@(?<subdomain>[\w]+)\.(?<domain>[\w]+)\.(?<tld>\w+)";

    await Assert.That(email)
        .Matches(pattern)
        .And.Group("local", local => local.StartsWith("john"))
        .And.Group("subdomain", sub => sub.IsEqualTo("mail"))
        .And.Group("domain", domain => domain.IsEqualTo("example"))
        .And.Group("tld", tld => tld.Length().IsEqualTo(3))
        .And.AtIndex(0)
        .And.Length().IsEqualTo(email.Length);
}
```

## Error Handling

The regex assertions throw specific exceptions for common error cases:

```csharp
[Test]
public async Task RegexAssertionErrors()
{
    var text = "Hello123World";

    // Throws ArgumentNullException if text is null
    await Assert.That((string?)null)
        .ThrowsAsync<ArgumentNullException>()
        .When(() => Matches(@"\d+"));

    // Throws RegexParseException for invalid patterns
    await Assert.That(text)
        .ThrowsAsync<RegexParseException>()
        .When(() => Matches(@"[invalid"));

    // Throws ArgumentOutOfRangeException for invalid group index
    await Assert.That(text)
        .Matches(@"Hello(\d+)World")
        .ThrowsAsync<ArgumentOutOfRangeException>()
        .When(m => m.Group(99, g => g.IsEqualTo("123")));

    // Throws ArgumentException for empty group name
    await Assert.That(text)
        .Matches(@"Hello(?<num>\d+)World")
        .ThrowsAsync<ArgumentException>()
        .When(m => m.Group("", g => g.IsEqualTo("123")));
}
```

## Best Practices

1. **Use source-generated regex** for better performance and compile-time validation
2. **Name your capture groups** descriptively (e.g., `username`, `domain`, not `g1`, `g2`)
3. **Chain assertions** using `.And` to validate multiple aspects in one test
4. **Handle optional groups** explicitly by checking for empty strings
5. **Test edge cases** like empty matches, multiple occurrences, and boundary conditions
6. **Use raw string literals** (`@""` or `"""`) to avoid escaping backslashes

## Related Assertions

- [String Assertions](string.md) - Basic string validation
- [Member Assertions](member-assertions.md) - Object property validation
- [Collection Assertions](collections.md) - Collection validation

---

## Assertion Scopes


In TUnit you can create an assertion scope by calling `Assert.Multiple()`. This returns an `IDisposable` and so you should use that by encapsulating the returned value in a `using` block. This will make sure that any assertion exceptions are aggregated together and thrown only after the scope is exited.

This is useful for asserting multiple properties and showing all errors at once, instead of having to fix > rerun > fix > rerun.

## Behavior Differences

**Outside `Assert.Multiple()`**: Assertions throw immediately when they fail, stopping test execution.

**Inside `Assert.Multiple()`**: Assertions accumulate failures and only throw when the scope exits, allowing all assertions within the scope to execute.

Implicit Scope:

```csharp
[Test]
    public async Task MyTest()
    {
        var result = Add(1, 2);

        using var _ = Assert.Multiple();

        await Assert.That(result).IsPositive();
        await Assert.That(result).IsEqualTo(3);
    }
```

Explicit Scope:

```csharp
[Test]
    public async Task MyTest()
    {
        var result = Add(1, 2);

        using (Assert.Multiple())
        {
            await Assert.That(result).IsPositive();
            await Assert.That(result).IsEqualTo(3);
        }
    }
```

---

## Specialized Type Assertions


TUnit provides assertions for many specialized .NET types beyond the common primitives. This page covers GUID, HTTP, file system, networking, and other specialized assertions.

## GUID Assertions

### IsEmptyGuid / IsNotEmptyGuid

Tests whether a GUID is empty (`Guid.Empty`):

```csharp
[Test]
public async Task GUID_Is_Empty()
{
    var emptyGuid = Guid.Empty;
    await Assert.That(emptyGuid).IsEmptyGuid();

    var newGuid = Guid.NewGuid();
    await Assert.That(newGuid).IsNotEmptyGuid();
}
```

Practical usage:

```csharp
[Test]
public async Task Entity_Has_Valid_ID()
{
    var entity = new Entity { Id = Guid.NewGuid() };

    await Assert.That(entity.Id).IsNotEmptyGuid();
    await Assert.That(entity.Id).IsNotEqualTo(Guid.Empty);
}
```

## HTTP Status Code Assertions

### IsSuccess

Tests for 2xx success status codes:

```csharp
[Test]
public async Task HTTP_Success_Status()
{
    var response = await _client.GetAsync("/api/users");

    await Assert.That(response.StatusCode).IsSuccess();
}
```

Works with all 2xx codes:

```csharp
[Test]
public async Task Various_Success_Codes()
{
    await Assert.That(HttpStatusCode.OK).IsSuccess();                  // 200
    await Assert.That(HttpStatusCode.Created).IsSuccess();             // 201
    await Assert.That(HttpStatusCode.Accepted).IsSuccess();            // 202
    await Assert.That(HttpStatusCode.NoContent).IsSuccess();           // 204
}
```

### IsNotSuccess

```csharp
[Test]
public async Task HTTP_Not_Success()
{
    await Assert.That(HttpStatusCode.NotFound).IsNotSuccess();         // 404
    await Assert.That(HttpStatusCode.InternalServerError).IsNotSuccess(); // 500
}
```

### IsClientError

Tests for 4xx client error status codes:

```csharp
[Test]
public async Task HTTP_Client_Error()
{
    await Assert.That(HttpStatusCode.BadRequest).IsClientError();      // 400
    await Assert.That(HttpStatusCode.Unauthorized).IsClientError();    // 401
    await Assert.That(HttpStatusCode.Forbidden).IsClientError();       // 403
    await Assert.That(HttpStatusCode.NotFound).IsClientError();        // 404
}
```

### IsServerError

Tests for 5xx server error status codes:

```csharp
[Test]
public async Task HTTP_Server_Error()
{
    await Assert.That(HttpStatusCode.InternalServerError).IsServerError(); // 500
    await Assert.That(HttpStatusCode.BadGateway).IsServerError();          // 502
    await Assert.That(HttpStatusCode.ServiceUnavailable).IsServerError();  // 503
}
```

### IsRedirection

Tests for 3xx redirection status codes:

```csharp
[Test]
public async Task HTTP_Redirection()
{
    await Assert.That(HttpStatusCode.MovedPermanently).IsRedirection();    // 301
    await Assert.That(HttpStatusCode.Found).IsRedirection();               // 302
    await Assert.That(HttpStatusCode.TemporaryRedirect).IsRedirection();   // 307
}
```

## CancellationToken Assertions

### IsCancellationRequested / IsNotCancellationRequested

```csharp
[Test]
public async Task CancellationToken_Is_Requested()
{
    var cts = new CancellationTokenSource();
    cts.Cancel();

    await Assert.That(cts.Token).IsCancellationRequested();
}

[Test]
public async Task CancellationToken_Not_Requested()
{
    var cts = new CancellationTokenSource();

    await Assert.That(cts.Token).IsNotCancellationRequested();
}
```

### CanBeCanceled / CannotBeCanceled

```csharp
[Test]
public async Task Token_Can_Be_Canceled()
{
    var cts = new CancellationTokenSource();

    await Assert.That(cts.Token).CanBeCanceled();
}

[Test]
public async Task Default_Token_Cannot_Be_Canceled()
{
    var token = CancellationToken.None;

    await Assert.That(token).CannotBeCanceled();
}
```

## Character Assertions

### IsLetter / IsNotLetter

```csharp
[Test]
public async Task Char_Is_Letter()
{
    await Assert.That('A').IsLetter();
    await Assert.That('z').IsLetter();

    await Assert.That('5').IsNotLetter();
    await Assert.That('!').IsNotLetter();
}
```

### IsDigit / IsNotDigit

```csharp
[Test]
public async Task Char_Is_Digit()
{
    await Assert.That('0').IsDigit();
    await Assert.That('9').IsDigit();

    await Assert.That('A').IsNotDigit();
}
```

### IsWhiteSpace / IsNotWhiteSpace

```csharp
[Test]
public async Task Char_Is_WhiteSpace()
{
    await Assert.That(' ').IsWhiteSpace();
    await Assert.That('\t').IsWhiteSpace();
    await Assert.That('\n').IsWhiteSpace();

    await Assert.That('A').IsNotWhiteSpace();
}
```

### IsUpper / IsNotUpper

```csharp
[Test]
public async Task Char_Is_Upper()
{
    await Assert.That('A').IsUpper();
    await Assert.That('Z').IsUpper();

    await Assert.That('a').IsNotUpper();
}
```

### IsLower / IsNotLower

```csharp
[Test]
public async Task Char_Is_Lower()
{
    await Assert.That('a').IsLower();
    await Assert.That('z').IsLower();

    await Assert.That('A').IsNotLower();
}
```

### IsPunctuation / IsNotPunctuation

```csharp
[Test]
public async Task Char_Is_Punctuation()
{
    await Assert.That('.').IsPunctuation();
    await Assert.That(',').IsPunctuation();
    await Assert.That('!').IsPunctuation();

    await Assert.That('A').IsNotPunctuation();
}
```

## File System Assertions

### DirectoryInfo

#### Exists / DoesNotExist

```csharp
[Test]
public async Task Directory_Exists()
{
    var tempDir = new DirectoryInfo(Path.GetTempPath());

    await Assert.That(tempDir).Exists();
}

[Test]
public async Task Directory_Does_Not_Exist()
{
    var nonExistent = new DirectoryInfo(@"C:\NonExistentFolder");

    await Assert.That(nonExistent).DoesNotExist();
}
```

#### HasFiles / IsEmpty

```csharp
[Test]
public async Task Directory_Has_Files()
{
    var tempDir = new DirectoryInfo(Path.GetTempPath());

    // Likely has files
    await Assert.That(tempDir).HasFiles();
}

[Test]
public async Task Directory_Is_Empty()
{
    var emptyDir = Directory.CreateDirectory(Path.Combine(Path.GetTempPath(), Guid.NewGuid().ToString()));

    await Assert.That(emptyDir).IsEmpty();

    // Cleanup
    emptyDir.Delete();
}
```

#### HasSubdirectories / HasNoSubdirectories

```csharp
[Test]
public async Task Directory_Has_Subdirectories()
{
    var windowsDir = new DirectoryInfo(@"C:\Windows");

    await Assert.That(windowsDir).HasSubdirectories();
}
```

### FileInfo

#### Exists / DoesNotExist

```csharp
[Test]
public async Task File_Exists()
{
    var tempFile = Path.GetTempFileName();
    var fileInfo = new FileInfo(tempFile);

    await Assert.That(fileInfo).Exists();

    // Cleanup
    File.Delete(tempFile);
}

[Test]
public async Task File_Does_Not_Exist()
{
    var nonExistent = new FileInfo(@"C:\nonexistent.txt");

    await Assert.That(nonExistent).DoesNotExist();
}
```

#### IsReadOnly / IsNotReadOnly

```csharp
[Test]
public async Task File_Is_ReadOnly()
{
    var tempFile = Path.GetTempFileName();
    var fileInfo = new FileInfo(tempFile);

    fileInfo.IsReadOnly = true;
    await Assert.That(fileInfo).IsReadOnly();

    fileInfo.IsReadOnly = false;
    await Assert.That(fileInfo).IsNotReadOnly();

    // Cleanup
    File.Delete(tempFile);
}
```

#### IsHidden / IsNotHidden

```csharp
[Test]
public async Task File_Is_Hidden()
{
    var tempFile = Path.GetTempFileName();
    var fileInfo = new FileInfo(tempFile);

    fileInfo.Attributes |= FileAttributes.Hidden;
    await Assert.That(fileInfo).IsHidden();

    // Cleanup
    fileInfo.Attributes &= ~FileAttributes.Hidden;
    File.Delete(tempFile);
}
```

#### IsSystem / IsNotSystem

```csharp
[Test]
public async Task File_Is_System()
{
    // System files are typically in System32
    var systemFile = new FileInfo(@"C:\Windows\System32\kernel32.dll");

    if (systemFile.Exists)
    {
        await Assert.That(systemFile).IsSystem();
    }
}
```

#### IsExecutable / IsNotExecutable

```csharp
[Test]
public async Task File_Is_Executable()
{
    var exeFile = new FileInfo(@"C:\Windows\notepad.exe");

    if (exeFile.Exists)
    {
        await Assert.That(exeFile).IsExecutable();
    }
}
```

## IP Address Assertions

### IsIPv4 / IsNotIPv4

```csharp
[Test]
public async Task IP_Is_IPv4()
{
    var ipv4 = IPAddress.Parse("192.168.1.1");

    await Assert.That(ipv4).IsIPv4();
}

[Test]
public async Task IP_Not_IPv4()
{
    var ipv6 = IPAddress.Parse("::1");

    await Assert.That(ipv6).IsNotIPv4();
}
```

### IsIPv6 / IsNotIPv6

```csharp
[Test]
public async Task IP_Is_IPv6()
{
    var ipv6 = IPAddress.Parse("2001:0db8:85a3:0000:0000:8a2e:0370:7334");

    await Assert.That(ipv6).IsIPv6();
}

[Test]
public async Task IP_Not_IPv6()
{
    var ipv4 = IPAddress.Parse("127.0.0.1");

    await Assert.That(ipv4).IsNotIPv6();
}
```

## Lazy\<T\> Assertions

### IsValueCreated / IsNotValueCreated

```csharp
[Test]
public async Task Lazy_Value_Not_Created()
{
    var lazy = new Lazy<int>(() => 42);

    await Assert.That(lazy).IsNotValueCreated();

    var value = lazy.Value;

    await Assert.That(lazy).IsValueCreated();
    await Assert.That(value).IsEqualTo(42);
}
```

## Stream Assertions

### CanRead / CannotRead

```csharp
[Test]
public async Task Stream_Can_Read()
{
    using var stream = new MemoryStream();

    await Assert.That(stream).CanRead();
}
```

### CanWrite / CannotWrite

```csharp
[Test]
public async Task Stream_Can_Write()
{
    using var stream = new MemoryStream();

    await Assert.That(stream).CanWrite();
}

[Test]
public async Task Stream_Cannot_Write()
{
    var readOnlyStream = new MemoryStream(new byte[10], writable: false);

    await Assert.That(readOnlyStream).CannotWrite();
}
```

### CanSeek / CannotSeek

```csharp
[Test]
public async Task Stream_Can_Seek()
{
    using var stream = new MemoryStream();

    await Assert.That(stream).CanSeek();
}
```

### CanTimeout / CannotTimeout

```csharp
[Test]
public async Task Network_Stream_Can_Timeout()
{
    using var client = new TcpClient();
    // Note: stream only available after connection
    // await Assert.That(stream).CanTimeout();
}
```

## Process Assertions

### HasExited / HasNotExited

```csharp
[Test]
public async Task Process_Has_Not_Exited()
{
    var process = Process.Start("notepad.exe");

    await Assert.That(process).HasNotExited();

    process.Kill();
    process.WaitForExit();

    await Assert.That(process).HasExited();
}
```

### IsResponding / IsNotResponding

```csharp
[Test]
public async Task Process_Is_Responding()
{
    var process = Process.GetCurrentProcess();

    await Assert.That(process).IsResponding();
}
```

## Thread Assertions

### IsAlive / IsNotAlive

```csharp
[Test]
public async Task Thread_Is_Alive()
{
    var thread = new Thread(() => Thread.Sleep(1000));
    thread.Start();

    await Assert.That(thread).IsAlive();

    thread.Join();
    await Assert.That(thread).IsNotAlive();
}
```

### IsBackground / IsNotBackground

```csharp
[Test]
public async Task Thread_Is_Background()
{
    var thread = new Thread(() => { });
    thread.IsBackground = true;

    await Assert.That(thread).IsBackground();
}
```

### IsThreadPoolThread / IsNotThreadPoolThread

```csharp
[Test]
public async Task Check_ThreadPool_Thread()
{
    var currentThread = Thread.CurrentThread;

    // Test thread is typically not a thread pool thread
    await Assert.That(currentThread).IsNotThreadPoolThread();
}
```

## WeakReference Assertions

### IsAlive / IsNotAlive

```csharp
[Test]
public async Task WeakReference_Is_Alive()
{
    var obj = new object();
    var weakRef = new WeakReference(obj);

    await Assert.That(weakRef).IsAlive();

    obj = null!;
    GC.Collect();
    GC.WaitForPendingFinalizers();

    await Assert.That(weakRef).IsNotAlive();
}
```

## URI Assertions

### IsAbsoluteUri / IsNotAbsoluteUri

```csharp
[Test]
public async Task URI_Is_Absolute()
{
    var absolute = new Uri("https://example.com/path");

    await Assert.That(absolute).IsAbsoluteUri();
}

[Test]
public async Task URI_Is_Relative()
{
    var relative = new Uri("/path/to/resource", UriKind.Relative);

    await Assert.That(relative).IsNotAbsoluteUri();
}
```

## Encoding Assertions

### IsUtf8 / IsNotUtf8

```csharp
[Test]
public async Task Encoding_Is_UTF8()
{
    var encoding = Encoding.UTF8;

    await Assert.That(encoding).IsUtf8();
}

[Test]
public async Task Encoding_Not_UTF8()
{
    var encoding = Encoding.ASCII;

    await Assert.That(encoding).IsNotUtf8();
}
```

## Version Assertions

Version comparisons using standard comparison operators:

```csharp
[Test]
public async Task Version_Comparison()
{
    var v1 = new Version(1, 0, 0);
    var v2 = new Version(2, 0, 0);

    await Assert.That(v2).IsGreaterThan(v1);
    await Assert.That(v1).IsLessThan(v2);
}
```

## DayOfWeek Assertions

### IsWeekend / IsNotWeekend

```csharp
[Test]
public async Task Day_Is_Weekend()
{
    await Assert.That(DayOfWeek.Saturday).IsWeekend();
    await Assert.That(DayOfWeek.Sunday).IsWeekend();
}
```

### IsWeekday / IsNotWeekday

```csharp
[Test]
public async Task Day_Is_Weekday()
{
    await Assert.That(DayOfWeek.Monday).IsWeekday();
    await Assert.That(DayOfWeek.Tuesday).IsWeekday();
    await Assert.That(DayOfWeek.Wednesday).IsWeekday();
    await Assert.That(DayOfWeek.Thursday).IsWeekday();
    await Assert.That(DayOfWeek.Friday).IsWeekday();
}
```

## Practical Examples

### API Testing

```csharp
[Test]
public async Task API_Returns_Success()
{
    var response = await _client.GetAsync("/api/health");

    await Assert.That(response.StatusCode).IsSuccess();
    await Assert.That(response.StatusCode).IsNotEqualTo(HttpStatusCode.InternalServerError);
}
```

### File Upload Validation

```csharp
[Test]
public async Task Uploaded_File_Validation()
{
    var uploadedFile = new FileInfo("upload.txt");

    await Assert.That(uploadedFile).Exists();
    await Assert.That(uploadedFile).IsNotReadOnly();
    await Assert.That(uploadedFile.Length).IsGreaterThan(0);
}
```

### Configuration Directory Check

```csharp
[Test]
public async Task Config_Directory_Setup()
{
    var configDir = new DirectoryInfo(@"C:\ProgramData\MyApp");

    await Assert.That(configDir).Exists();
    await Assert.That(configDir).HasFiles();
}
```

### Network Validation

```csharp
[Test]
public async Task Server_IP_Is_Valid()
{
    var serverIp = IPAddress.Parse(Configuration["ServerIP"]);

    await Assert.That(serverIp).IsIPv4();
}
```

## See Also

- [Boolean](boolean.md) - For boolean properties of specialized types
- [String](string.md) - For string conversions and properties
- [Collections](collections.md) - For collections of specialized types
- [Types](types.md) - For type checking specialized types

---

## String Assertions


TUnit provides rich assertions for testing strings, including substring matching, pattern matching, length checks, and various string comparison options.

## Content Assertions

### Contains

Tests that a string contains a substring:

```csharp
[Test]
public async Task String_Contains()
{
    var message = "Hello, World!";

    await Assert.That(message).Contains("World");
    await Assert.That(message).Contains("Hello");
    await Assert.That(message).Contains(", ");
}
```

#### Case-Insensitive Contains

```csharp
[Test]
public async Task Contains_Ignoring_Case()
{
    var message = "Hello, World!";

    await Assert.That(message)
        .Contains("world")
        .IgnoringCase();

    await Assert.That(message)
        .Contains("HELLO")
        .IgnoringCase();
}
```

#### With String Comparison

```csharp
[Test]
public async Task Contains_With_Comparison()
{
    var message = "Hello, World!";

    await Assert.That(message)
        .Contains("world")
        .WithComparison(StringComparison.OrdinalIgnoreCase);
}
```

#### With Trimming

```csharp
[Test]
public async Task Contains_With_Trimming()
{
    var message = "  Hello, World!  ";

    await Assert.That(message)
        .Contains("Hello, World!")
        .WithTrimming();
}
```

#### Ignoring Whitespace

```csharp
[Test]
public async Task Contains_Ignoring_Whitespace()
{
    var message = "Hello,    World!";

    await Assert.That(message)
        .Contains("Hello, World!")
        .IgnoringWhitespace();
}
```

### DoesNotContain

Tests that a string does not contain a substring:

```csharp
[Test]
public async Task String_Does_Not_Contain()
{
    var message = "Hello, World!";

    await Assert.That(message).DoesNotContain("Goodbye");
    await Assert.That(message).DoesNotContain("xyz");
}
```

All modifiers work with `DoesNotContain`:

```csharp
[Test]
public async Task Does_Not_Contain_Ignoring_Case()
{
    var message = "Hello, World!";

    await Assert.That(message)
        .DoesNotContain("goodbye")
        .IgnoringCase();
}
```

### StartsWith

Tests that a string starts with a specific prefix:

```csharp
[Test]
public async Task String_Starts_With()
{
    var filename = "report_2024.pdf";

    await Assert.That(filename).StartsWith("report");

    var url = "https://example.com";
    await Assert.That(url).StartsWith("https://");
}
```

With case-insensitive comparison:

```csharp
[Test]
public async Task Starts_With_Ignoring_Case()
{
    var filename = "Report_2024.pdf";

    await Assert.That(filename)
        .StartsWith("report")
        .IgnoringCase();
}
```

### EndsWith

Tests that a string ends with a specific suffix:

```csharp
[Test]
public async Task String_Ends_With()
{
    var filename = "document.pdf";

    await Assert.That(filename).EndsWith(".pdf");

    var email = "user@example.com";
    await Assert.That(email).EndsWith("example.com");
}
```

With case-insensitive comparison:

```csharp
[Test]
public async Task Ends_With_Ignoring_Case()
{
    var filename = "document.PDF";

    await Assert.That(filename)
        .EndsWith(".pdf")
        .IgnoringCase();
}
```

## Pattern Matching

### Matches (Regex)

Tests that a string matches a regular expression pattern:

```csharp
[Test]
public async Task String_Matches_Pattern()
{
    var email = "test@example.com";

    await Assert.That(email).Matches(@"^[\w\.-]+@[\w\.-]+\.\w+$");
}
```

With a compiled `Regex`:

```csharp
[Test]
public async Task Matches_With_Regex()
{
    var phoneNumber = "(123) 456-7890";
    var pattern = new Regex(@"^\(\d{3}\) \d{3}-\d{4}$");

    await Assert.That(phoneNumber).Matches(pattern);
}
```

#### Case-Insensitive Matching

```csharp
[Test]
public async Task Matches_Ignoring_Case()
{
    var text = "Hello World";

    await Assert.That(text)
        .Matches("hello.*world")
        .IgnoringCase();
}
```

#### With Regex Options

```csharp
[Test]
public async Task Matches_With_Options()
{
    var multiline = "Line 1\nLine 2\nLine 3";

    await Assert.That(multiline)
        .Matches("^Line 2$")
        .WithOptions(RegexOptions.Multiline);
}
```

### DoesNotMatch

Tests that a string does not match a pattern:

```csharp
[Test]
public async Task String_Does_Not_Match()
{
    var text = "abc123";

    await Assert.That(text).DoesNotMatch(@"^\d+$"); // Not all digits
}
```

## Length Assertions

### IsEmpty

Tests that a string is empty (`""`):

```csharp
[Test]
public async Task String_Is_Empty()
{
    var emptyString = "";

    await Assert.That(emptyString).IsEmpty();
}
```

Note: This checks for an empty string, not `null`:

```csharp
[Test]
public async Task Empty_vs_Null()
{
    string? nullString = null;
    string emptyString = "";

    await Assert.That(nullString).IsNull();      // null
    await Assert.That(emptyString).IsEmpty();    // not null, but empty
    await Assert.That(emptyString).IsNotNull();  // also passes
}
```

### IsNotEmpty

Tests that a string is not empty:

```csharp
[Test]
public async Task String_Is_Not_Empty()
{
    var text = "Hello";

    await Assert.That(text).IsNotEmpty();
}
```

### Length

Tests that a string has a specific length:

```csharp
[Test]
public async Task String_Has_Length()
{
    var code = "ABC123";

    await Assert.That(code).Length().IsEqualTo(6);
}
```

With chained comparison:

```csharp
[Test]
public async Task Length_With_Comparison()
{
    var username = "alice";

    await Assert.That(username)
        .Length().IsGreaterThan(3)
        .And.Length().IsLessThan(20);
}
```

Using `IsBetween`:

```csharp
[Test]
public async Task Length_Range()
{
    var username = "alice";

    await Assert.That(username).Length().IsBetween(3, 20);
}
```

## Equality with Options

### IsEqualTo

String equality with various comparison options:

```csharp
[Test]
public async Task String_Equality()
{
    var actual = "Hello";
    var expected = "Hello";

    await Assert.That(actual).IsEqualTo(expected);
}
```

#### Ignoring Case

```csharp
[Test]
public async Task Equality_Ignoring_Case()
{
    var actual = "Hello";
    var expected = "HELLO";

    await Assert.That(actual)
        .IsEqualTo(expected)
        .IgnoringCase();
}
```

#### With String Comparison

```csharp
[Test]
public async Task Equality_With_Comparison()
{
    var actual = "café";
    var expected = "CAFÉ";

    await Assert.That(actual)
        .IsEqualTo(expected)
        .WithComparison(StringComparison.CurrentCultureIgnoreCase);
}
```

## String Parsing

You can parse strings to other types and assert on the result:

```csharp
[Test]
public async Task Parse_String_To_Int()
{
    var text = "42";

    var number = await Assert.That(text).WhenParsedInto<int>();
    await Assert.That(number).IsEqualTo(42);
}
```

```csharp
[Test]
public async Task Parse_String_To_DateTime()
{
    var text = "2024-01-15";

    var date = await Assert.That(text).WhenParsedInto<DateTime>();
    await Assert.That(date.Year).IsEqualTo(2024);
}
```

## Practical Examples

### Email Validation

```csharp
[Test]
public async Task Validate_Email()
{
    var email = "user@example.com";

    await Assert.That(email)
        .Contains("@")
        .And.Matches(@"^[\w\.-]+@[\w\.-]+\.\w+$")
        .And.DoesNotContain(" ");
}
```

### URL Validation

```csharp
[Test]
public async Task Validate_URL()
{
    var url = "https://www.example.com/path";

    await Assert.That(url)
        .StartsWith("https://")
        .And.Contains("example.com")
        .And.Matches(@"^https?://[\w\.-]+");
}
```

### File Extension Check

```csharp
[Test]
public async Task Check_File_Extension()
{
    var filename = "document.pdf";

    await Assert.That(filename)
        .EndsWith(".pdf")
        .IgnoringCase();
}
```

### Username Validation

```csharp
[Test]
public async Task Validate_Username()
{
    var username = "alice_123";

    await Assert.That(username)
        .Length().IsGreaterThanOrEqualTo(3)
        .And.Length().IsLessThanOrEqualTo(20)
        .And.Matches(@"^[a-zA-Z0-9_]+$")
        .And.DoesNotContain(" ");
}
```

### Password Requirements

```csharp
[Test]
public async Task Validate_Password()
{
    var password = "SecureP@ss123";

    await Assert.That(password)
        .Length().IsGreaterThanOrEqualTo(8)
        .And.Matches(@"[A-Z]")  // Has uppercase
        .And.Matches(@"[a-z]")  // Has lowercase
        .And.Matches(@"\d")     // Has digit
        .And.Matches(@"[@$!%*?&]"); // Has special char
}
```

### JSON String Content

```csharp
[Test]
public async Task Check_JSON_Content()
{
    var json = """{"name":"Alice","age":30}""";

    await Assert.That(json)
        .Contains("\"name\"")
        .And.Contains("\"Alice\"")
        .And.StartsWith("{")
        .And.EndsWith("}");
}
```

### SQL Query Validation

```csharp
[Test]
public async Task Validate_SQL_Query()
{
    var query = "SELECT * FROM Users WHERE Age > 18";

    await Assert.That(query)
        .StartsWith("SELECT")
        .And.Contains("FROM Users")
        .And.Matches(@"WHERE\s+\w+\s*[><=]");
}
```

## Null and Empty Checks Combined

### IsNullOrEmpty Equivalent

```csharp
[Test]
public async Task Check_Null_Or_Empty()
{
    string? text = GetOptionalString();

    // Option 1: Check both conditions
    if (string.IsNullOrEmpty(text))
    {
        // Handle null or empty
    }
    else
    {
        await Assert.That(text).IsNotNull();
        await Assert.That(text).IsNotEmpty();
    }
}
```

### IsNullOrWhiteSpace Equivalent

```csharp
[Test]
public async Task Check_Null_Or_Whitespace()
{
    string? text = "   ";

    await Assert.That(string.IsNullOrWhiteSpace(text)).IsTrue();
}
```

Better with trimming:

```csharp
[Test]
public async Task Require_Non_Whitespace()
{
    string? text = GetInput();

    await Assert.That(text)
        .IsNotNull()
        .And.IsNotEmpty();

    var trimmed = text.Trim();
    await Assert.That(trimmed).IsNotEmpty();
}
```

## StringBuilder Assertions

TUnit also supports assertions on `StringBuilder`:

```csharp
[Test]
public async Task StringBuilder_Tests()
{
    var builder = new StringBuilder();
    builder.Append("Hello");
    builder.Append(" ");
    builder.Append("World");

    var result = builder.ToString();

    await Assert.That(result).IsEqualTo("Hello World");
    await Assert.That(result).Contains("Hello");
}
```

## Chaining String Assertions

```csharp
[Test]
public async Task Chained_String_Assertions()
{
    var input = "Hello, World!";

    await Assert.That(input)
        .IsNotNull()
        .And.IsNotEmpty()
        .And.Contains("World")
        .And.StartsWith("Hello")
        .And.EndsWith("!")
        .And.Length().IsEqualTo(13);
}
```

## Case Sensitivity Patterns

```csharp
[Test]
public async Task Case_Sensitivity()
{
    var text = "TUnit Framework";

    // Case-sensitive (default)
    await Assert.That(text).Contains("TUnit");

    // Case-insensitive
    await Assert.That(text)
        .Contains("tunit")
        .IgnoringCase();

    // Using StringComparison
    await Assert.That(text)
        .Contains("framework")
        .WithComparison(StringComparison.OrdinalIgnoreCase);
}
```

## String Formatting Validation

```csharp
[Test]
public async Task Formatted_String()
{
    var name = "Alice";
    var age = 30;
    var message = $"User {name} is {age} years old";

    await Assert.That(message)
        .IsEqualTo("User Alice is 30 years old")
        .And.Contains(name)
        .And.Contains(age.ToString());
}
```

## Multi-line Strings

```csharp
[Test]
public async Task Multiline_String()
{
    var multiline = """
        Line 1
        Line 2
        Line 3
        """;

    await Assert.That(multiline)
        .Contains("Line 1")
        .And.Contains("Line 2")
        .And.Matches("Line.*Line.*Line");
}
```

## Common String Comparison Options

```csharp
[Test]
public async Task String_Comparison_Options()
{
    var text = "Hello";

    // Ordinal (binary comparison)
    await Assert.That(text)
        .IsEqualTo("hello")
        .WithComparison(StringComparison.OrdinalIgnoreCase);

    // Current culture
    await Assert.That(text)
        .IsEqualTo("hello")
        .WithComparison(StringComparison.CurrentCultureIgnoreCase);

    // Invariant culture
    await Assert.That(text)
        .IsEqualTo("hello")
        .WithComparison(StringComparison.InvariantCultureIgnoreCase);
}
```

## Path Validation

```csharp
[Test]
public async Task File_Path_Validation()
{
    var path = @"C:\Users\Alice\Documents\file.txt";

    await Assert.That(path)
        .Contains(@"\")
        .And.EndsWith(".txt")
        .And.Matches(@"[A-Z]:\\");
}
```

Unix path:

```csharp
[Test]
public async Task Unix_Path_Validation()
{
    var path = "/home/alice/documents/file.txt";

    await Assert.That(path)
        .StartsWith("/")
        .And.Contains("/")
        .And.EndsWith(".txt");
}
```

## Common Patterns

### Trim and Assert

```csharp
[Test]
public async Task Trim_Before_Assert()
{
    var input = "  Hello  ";
    var trimmed = input.Trim();

    await Assert.That(trimmed).IsEqualTo("Hello");
}
```

### Case Normalization

```csharp
[Test]
public async Task Normalize_Case()
{
    var input = "Hello World";
    var lower = input.ToLowerInvariant();

    await Assert.That(lower).IsEqualTo("hello world");
}
```

### Substring Extraction

```csharp
[Test]
public async Task Extract_Substring()
{
    var text = "Hello, World!";
    var greeting = text.Substring(0, 5);

    await Assert.That(greeting).IsEqualTo("Hello");
}
```

## See Also

- [Equality & Comparison](equality-and-comparison.md) - String equality assertions
- [Collections](collections.md) - Working with collections of strings
- [Null & Default](null-and-default.md) - Null string checks

---

## Task and Async Assertions


TUnit provides specialized assertions for testing `Task` and `Task<T>` objects, including state checking, completion timeouts, and async exception handling.

## Task State Assertions

### IsCompleted / IsNotCompleted

Tests whether a task has completed (successfully, faulted, or canceled):

```csharp
[Test]
public async Task Task_Is_Completed()
{
    var completedTask = Task.CompletedTask;
    await Assert.That(completedTask).IsCompleted();

    var runningTask = Task.Delay(10000);
    await Assert.That(runningTask).IsNotCompleted();
}
```

### IsCanceled / IsNotCanceled

Tests whether a task was canceled:

```csharp
[Test]
public async Task Task_Is_Canceled()
{
    var cts = new CancellationTokenSource();
    cts.Cancel();

    var task = Task.Run(() => { }, cts.Token);

    try
    {
        await task;
    }
    catch (TaskCanceledException)
    {
        // Expected
    }

    await Assert.That(task).IsCanceled();
}
```

```csharp
[Test]
public async Task Task_Not_Canceled()
{
    var task = Task.CompletedTask;

    await Assert.That(task).IsNotCanceled();
}
```

### IsFaulted / IsNotFaulted

Tests whether a task ended in a faulted state (threw an exception):

```csharp
[Test]
public async Task Task_Is_Faulted()
{
    var faultedTask = Task.Run(() => throw new InvalidOperationException());

    try
    {
        await faultedTask;
    }
    catch
    {
        // Expected
    }

    await Assert.That(faultedTask).IsFaulted();
}
```

```csharp
[Test]
public async Task Task_Not_Faulted()
{
    var successfulTask = Task.CompletedTask;

    await Assert.That(successfulTask).IsNotFaulted();
}
```

### IsCompletedSuccessfully / IsNotCompletedSuccessfully (.NET 6+)

Tests whether a task completed successfully (not faulted or canceled):

```csharp
[Test]
public async Task Task_Completed_Successfully()
{
    var task = Task.CompletedTask;

    await Assert.That(task).IsCompletedSuccessfully();
}
```

```csharp
[Test]
public async Task Task_Not_Completed_Successfully()
{
    var cts = new CancellationTokenSource();
    cts.Cancel();
    var canceledTask = Task.FromCanceled(cts.Token);

    await Assert.That(canceledTask).IsNotCompletedSuccessfully();
}
```

## Timeout Assertions

### CompletesWithin

Tests that a task completes within a specified time:

```csharp
[Test]
public async Task Task_Completes_Within_Timeout()
{
    var fastTask = Task.Delay(100);

    await Assert.That(fastTask).CompletesWithin(TimeSpan.FromSeconds(1));
}
```

Fails if timeout exceeded:

```csharp
[Test]
public async Task Task_Exceeds_Timeout()
{
    var slowTask = Task.Delay(5000);

    // This will fail - task takes longer than timeout
    // await Assert.That(slowTask).CompletesWithin(TimeSpan.FromMilliseconds(100));
}
```

### WaitsFor

Waits for a condition to become true within a timeout:

```csharp
[Test]
public async Task Wait_For_Condition()
{
    bool condition = false;

    _ = Task.Run(async () =>
    {
        await Task.Delay(500);
        condition = true;
    });

    await Assert.That(() => condition)
        .WaitsFor(c => c == true, timeout: TimeSpan.FromSeconds(2));
}
```

## Practical Examples

### API Call Timeout

```csharp
[Test]
public async Task API_Call_Completes_In_Time()
{
    var apiTask = _httpClient.GetAsync("https://api.example.com/data");

    await Assert.That(apiTask).CompletesWithin(TimeSpan.FromSeconds(5));

    var response = await apiTask;
    await Assert.That(response.IsSuccessStatusCode).IsTrue();
}
```

### Background Task Completion

```csharp
[Test]
public async Task Background_Processing_Completes()
{
    var processingTask = ProcessDataInBackgroundAsync();

    await Assert.That(processingTask).CompletesWithin(TimeSpan.FromMinutes(1));
    await Assert.That(processingTask).IsCompletedSuccessfully();
}
```

### Cancellation Token Handling

```csharp
[Test]
public async Task Operation_Respects_Cancellation()
{
    using var cts = new CancellationTokenSource();
    cts.CancelAfter(TimeSpan.FromMilliseconds(100));

    var task = LongRunningOperationAsync(cts.Token);

    try
    {
        await task;
    }
    catch (OperationCanceledException)
    {
        // Expected
    }

    await Assert.That(task).IsCanceled();
}
```

### Async Exception Handling

For testing exceptions in async code, use exception assertions:

```csharp
[Test]
public async Task Async_Method_Throws_Exception()
{
    await Assert.That(async () => await FailingOperationAsync())
        .Throws<InvalidOperationException>();
}
```

### Task Result Assertions

For `Task<T>`, await the task first, then assert on the result:

```csharp
[Test]
public async Task Task_Returns_Expected_Result()
{
    var task = GetValueAsync();

    // Ensure it completes in time
    await Assert.That(task).CompletesWithin(TimeSpan.FromSeconds(1));

    // Get the result
    var result = await task;

    // Assert on the result
    await Assert.That(result).IsEqualTo(42);
}
```

### Parallel Task Execution

```csharp
[Test]
public async Task Parallel_Tasks_Complete()
{
    var task1 = Task.Delay(100);
    var task2 = Task.Delay(100);
    var task3 = Task.Delay(100);

    var allTasks = Task.WhenAll(task1, task2, task3);

    await Assert.That(allTasks).CompletesWithin(TimeSpan.FromSeconds(1));
    await Assert.That(allTasks).IsCompletedSuccessfully();
}
```

### Task State Transitions

```csharp
[Test]
public async Task Task_State_Progression()
{
    var tcs = new TaskCompletionSource<int>();
    var task = tcs.Task;

    // Initially not completed
    await Assert.That(task).IsNotCompleted();

    // Complete the task
    tcs.SetResult(42);

    // Now completed
    await Assert.That(task).IsCompleted();
    await Assert.That(task).IsCompletedSuccessfully();

    var result = await task;
    await Assert.That(result).IsEqualTo(42);
}
```

### Failed Task

```csharp
[Test]
public async Task Task_Fails_With_Exception()
{
    var tcs = new TaskCompletionSource<int>();
    var task = tcs.Task;

    tcs.SetException(new InvalidOperationException("Operation failed"));

    await Assert.That(task).IsFaulted();
    await Assert.That(task).IsNotCompletedSuccessfully();
}
```

### Canceled Task

```csharp
[Test]
public async Task Task_Can_Be_Canceled()
{
    var tcs = new TaskCompletionSource<int>();
    var task = tcs.Task;

    tcs.SetCanceled();

    await Assert.That(task).IsCanceled();
    await Assert.That(task).IsNotCompletedSuccessfully();
}
```

## WhenAll and WhenAny

### WhenAll Completion

```csharp
[Test]
public async Task All_Tasks_Complete()
{
    var tasks = Enumerable.Range(1, 5)
        .Select(i => Task.Delay(i * 100))
        .ToArray();

    var allCompleted = Task.WhenAll(tasks);

    await Assert.That(allCompleted).CompletesWithin(TimeSpan.FromSeconds(1));
}
```

### WhenAny Completion

```csharp
[Test]
public async Task Any_Task_Completes()
{
    var fastTask = Task.Delay(100);
    var slowTask = Task.Delay(5000);

    var firstCompleted = Task.WhenAny(fastTask, slowTask);

    await Assert.That(firstCompleted).CompletesWithin(TimeSpan.FromMilliseconds(500));

    var completed = await firstCompleted;
    await Assert.That(completed).IsSameReferenceAs(fastTask);
}
```

## ValueTask Assertions

`ValueTask` and `ValueTask<T>` work similarly:

```csharp
[Test]
public async Task ValueTask_Completion()
{
    var valueTask = GetValueTaskAsync();

    var result = await valueTask;
    await Assert.That(result).IsGreaterThan(0);
}

async ValueTask<int> GetValueTaskAsync()
{
    await Task.Delay(10);
    return 42;
}
```

## Chaining Task Assertions

```csharp
[Test]
public async Task Chained_Task_Assertions()
{
    var task = GetDataAsync();

    await Assert.That(task)
        .CompletesWithin(TimeSpan.FromSeconds(5));

    await Assert.That(task)
        .IsCompleted()
        .And.IsCompletedSuccessfully()
        .And.IsNotCanceled()
        .And.IsNotFaulted();
}
```

## Common Patterns

### Retry Logic Testing

```csharp
[Test]
public async Task Retry_Eventually_Succeeds()
{
    int attempts = 0;

    var task = RetryAsync(async () =>
    {
        attempts++;
        if (attempts < 3)
            throw new Exception("Temporary failure");
        return "Success";
    }, maxRetries: 5);

    await Assert.That(task).CompletesWithin(TimeSpan.FromSeconds(10));
    var result = await task;
    await Assert.That(result).IsEqualTo("Success");
}
```

### Debounce Testing

```csharp
[Test]
public async Task Debounced_Operation()
{
    var trigger = new Subject<string>();
    var debouncedTask = trigger
        .Throttle(TimeSpan.FromMilliseconds(500))
        .FirstAsync()
        .ToTask();

    trigger.OnNext("value");

    await Assert.That(debouncedTask)
        .CompletesWithin(TimeSpan.FromSeconds(1));
}
```

### Circuit Breaker Testing

```csharp
[Test]
public async Task Circuit_Breaker_Opens()
{
    var circuitBreaker = new CircuitBreaker();

    // Fail enough times to open circuit
    for (int i = 0; i < 5; i++)
    {
        try
        {
            await circuitBreaker.ExecuteAsync(() => throw new Exception());
        }
        catch { }
    }

    // Circuit should be open
    var task = circuitBreaker.ExecuteAsync(() => Task.CompletedTask);

    await Assert.That(async () => await task)
        .Throws<CircuitBreakerOpenException>();
}
```

### Producer-Consumer Testing

```csharp
[Test]
public async Task Producer_Consumer_Processes_Items()
{
    var channel = Channel.CreateUnbounded<int>();

    var producer = ProduceItemsAsync(channel.Writer);
    var consumer = ConsumeItemsAsync(channel.Reader);

    await Assert.That(producer).CompletesWithin(TimeSpan.FromSeconds(1));
    await Assert.That(consumer).CompletesWithin(TimeSpan.FromSeconds(2));
}
```

### Rate Limiting

```csharp
[Test]
public async Task Rate_Limiter_Delays_Requests()
{
    var rateLimiter = new RateLimiter(maxRequests: 5, perTimeSpan: TimeSpan.FromSeconds(1));

    var stopwatch = Stopwatch.StartNew();

    // Make 10 requests (should take ~2 seconds due to rate limiting)
    var tasks = Enumerable.Range(0, 10)
        .Select(_ => rateLimiter.ExecuteAsync(() => Task.CompletedTask));

    await Task.WhenAll(tasks);
    stopwatch.Stop();

    await Assert.That(stopwatch.Elapsed).IsGreaterThan(TimeSpan.FromSeconds(1.5));
}
```

## Testing Async Disposal

```csharp
[Test]
public async Task Async_Disposable_Cleanup()
{
    var resource = new AsyncResource();

    await using (resource)
    {
        // Use resource
    }

    // After disposal
    await Assert.That(resource.IsDisposed).IsTrue();
}
```

## See Also

- [Exceptions](exceptions.md) - Testing async exceptions
- [DateTime](datetime.md) - Timeout and duration testing
- [Boolean](boolean.md) - Testing task state booleans

---

## Type Checking


TUnit assertions try to check the types at compile time. 
This gives faster developer feedback and helps speed up development time.
(Ever made a silly mistake on a test, but haven't realised till 15 minutes later after your build pipeline has finally told you? I know I have!)

So this wouldn't compile, because we're comparing an `int` and a `string`:

```csharp
    [Test]
    public async Task MyTest()
    {
        await Assert.That(1).IsEqualTo("1");
    }
```

---

## Type Assertions


TUnit provides comprehensive assertions for testing types and type properties. These assertions work with both runtime values and `Type` objects themselves.

## Value Type Assertions

### IsTypeOf&lt;T&gt;

Tests that a value is exactly of a specific type:

```csharp
[Test]
public async Task Value_Is_Type()
{
    object value = "Hello";

    await Assert.That(value).IsTypeOf<string>();
}
```

Works with all types:

```csharp
[Test]
public async Task Various_Types()
{
    await Assert.That(42).IsTypeOf<int>();
    await Assert.That(3.14).IsTypeOf<double>();
    await Assert.That(true).IsTypeOf<bool>();
    await Assert.That(new List<int>()).IsTypeOf<List<int>>();
}
```

### IsAssignableTo&lt;T&gt;

Tests that a type can be assigned to a target type (inheritance/interface):

```csharp
[Test]
public async Task Type_Is_Assignable()
{
    var list = new List<int>();

    await Assert.That(list).IsAssignableTo<IList<int>>();
    await Assert.That(list).IsAssignableTo<IEnumerable<int>>();
    await Assert.That(list).IsAssignableTo<object>();
}
```

With inheritance:

```csharp
public class Animal { }
public class Dog : Animal { }

[Test]
public async Task Inheritance_Assignability()
{
    var dog = new Dog();

    await Assert.That(dog).IsAssignableTo<Animal>();
    await Assert.That(dog).IsAssignableTo<Dog>();
    await Assert.That(dog).IsAssignableTo<object>();
}
```

### IsNotAssignableTo&lt;T&gt;

Tests that a type cannot be assigned to a target type:

```csharp
[Test]
public async Task Type_Not_Assignable()
{
    var value = 42;

    await Assert.That(value).IsNotAssignableTo<string>();
    await Assert.That(value).IsNotAssignableTo<double>();
}
```

## Type Object Assertions

All the following assertions work on `Type` objects directly:

```csharp
[Test]
public async Task Type_Object_Assertions()
{
    var type = typeof(string);

    await Assert.That(type).IsClass();
    await Assert.That(type).IsNotInterface();
}
```

### Class and Interface

#### IsClass / IsNotClass

```csharp
[Test]
public async Task Is_Class()
{
    await Assert.That(typeof(string)).IsClass();
    await Assert.That(typeof(List<int>)).IsClass();
    await Assert.That(typeof(object)).IsClass();

    await Assert.That(typeof(IEnumerable)).IsNotClass();
    await Assert.That(typeof(int)).IsNotClass(); // Value type
}
```

#### IsInterface / IsNotInterface

```csharp
[Test]
public async Task Is_Interface()
{
    await Assert.That(typeof(IEnumerable)).IsInterface();
    await Assert.That(typeof(IDisposable)).IsInterface();

    await Assert.That(typeof(string)).IsNotInterface();
}
```

### Modifiers

#### IsAbstract / IsNotAbstract

```csharp
public abstract class AbstractBase { }
public class Concrete : AbstractBase { }

[Test]
public async Task Is_Abstract()
{
    await Assert.That(typeof(AbstractBase)).IsAbstract();
    await Assert.That(typeof(Concrete)).IsNotAbstract();
}
```

#### IsSealed / IsNotSealed

```csharp
public sealed class SealedClass { }
public class OpenClass { }

[Test]
public async Task Is_Sealed()
{
    await Assert.That(typeof(SealedClass)).IsSealed();
    await Assert.That(typeof(string)).IsSealed(); // string is sealed
    await Assert.That(typeof(OpenClass)).IsNotSealed();
}
```

### Value Types and Enums

#### IsValueType / IsNotValueType

```csharp
[Test]
public async Task Is_Value_Type()
{
    await Assert.That(typeof(int)).IsValueType();
    await Assert.That(typeof(DateTime)).IsValueType();
    await Assert.That(typeof(Guid)).IsValueType();

    await Assert.That(typeof(string)).IsNotValueType();
    await Assert.That(typeof(object)).IsNotValueType();
}
```

#### IsEnum / IsNotEnum

```csharp
public enum Color { Red, Green, Blue }

[Test]
public async Task Is_Enum()
{
    await Assert.That(typeof(Color)).IsEnum();
    await Assert.That(typeof(DayOfWeek)).IsEnum();

    await Assert.That(typeof(int)).IsNotEnum();
}
```

#### IsPrimitive / IsNotPrimitive

```csharp
[Test]
public async Task Is_Primitive()
{
    // Primitives: bool, byte, sbyte, short, ushort, int, uint,
    //             long, ulong, char, double, float, IntPtr, UIntPtr
    await Assert.That(typeof(int)).IsPrimitive();
    await Assert.That(typeof(bool)).IsPrimitive();
    await Assert.That(typeof(char)).IsPrimitive();

    await Assert.That(typeof(string)).IsNotPrimitive();
    await Assert.That(typeof(decimal)).IsNotPrimitive();
}
```

### Visibility

#### IsPublic / IsNotPublic

```csharp
public class PublicClass { }
internal class InternalClass { }

[Test]
public async Task Is_Public()
{
    await Assert.That(typeof(PublicClass)).IsPublic();
    await Assert.That(typeof(string)).IsPublic();

    await Assert.That(typeof(InternalClass)).IsNotPublic();
}
```

### Generics

#### IsGenericType / IsNotGenericType

```csharp
[Test]
public async Task Is_Generic_Type()
{
    await Assert.That(typeof(List<int>)).IsGenericType();
    await Assert.That(typeof(Dictionary<string, int>)).IsGenericType();

    await Assert.That(typeof(string)).IsNotGenericType();
}
```

#### IsGenericTypeDefinition / IsNotGenericTypeDefinition

```csharp
[Test]
public async Task Is_Generic_Type_Definition()
{
    // Generic type definition (unbound)
    await Assert.That(typeof(List<>)).IsGenericTypeDefinition();
    await Assert.That(typeof(Dictionary<,>)).IsGenericTypeDefinition();

    // Constructed generic type (bound)
    await Assert.That(typeof(List<int>)).IsNotGenericTypeDefinition();
}
```

#### IsConstructedGenericType / IsNotConstructedGenericType

```csharp
[Test]
public async Task Is_Constructed_Generic_Type()
{
    await Assert.That(typeof(List<int>)).IsConstructedGenericType();
    await Assert.That(typeof(Dictionary<string, int>)).IsConstructedGenericType();

    await Assert.That(typeof(List<>)).IsNotConstructedGenericType();
    await Assert.That(typeof(string)).IsNotConstructedGenericType();
}
```

#### ContainsGenericParameters / DoesNotContainGenericParameters

```csharp
[Test]
public async Task Contains_Generic_Parameters()
{
    await Assert.That(typeof(List<>)).ContainsGenericParameters();

    await Assert.That(typeof(List<int>)).DoesNotContainGenericParameters();
    await Assert.That(typeof(string)).DoesNotContainGenericParameters();
}
```

### Arrays and Pointers

#### IsArray / IsNotArray

```csharp
[Test]
public async Task Is_Array()
{
    await Assert.That(typeof(int[])).IsArray();
    await Assert.That(typeof(string[])).IsArray();
    await Assert.That(typeof(int[,])).IsArray(); // Multi-dimensional

    await Assert.That(typeof(List<int>)).IsNotArray();
}
```

#### IsByRef / IsNotByRef

```csharp
[Test]
public async Task Is_By_Ref()
{
    var method = typeof(string).GetMethod(nameof(int.TryParse));
    var parameters = method!.GetParameters();
    var outParam = parameters.First(p => p.IsOut);

    await Assert.That(outParam.ParameterType).IsByRef();
}
```

#### IsByRefLike / IsNotByRefLike (.NET 5+)

```csharp
[Test]
public async Task Is_By_Ref_Like()
{
    await Assert.That(typeof(Span<int>)).IsByRefLike();
    await Assert.That(typeof(ReadOnlySpan<int>)).IsByRefLike();

    await Assert.That(typeof(string)).IsNotByRefLike();
}
```

#### IsPointer / IsNotPointer

```csharp
[Test]
public async Task Is_Pointer()
{
    unsafe
    {
        var intPtr = typeof(int*);
        await Assert.That(intPtr).IsPointer();
    }

    await Assert.That(typeof(int)).IsNotPointer();
}
```

### Nested Types

#### IsNested / IsNotNested

```csharp
public class Outer
{
    public class Inner { }
}

[Test]
public async Task Is_Nested()
{
    await Assert.That(typeof(Outer.Inner)).IsNested();
    await Assert.That(typeof(Outer)).IsNotNested();
}
```

#### IsNestedPublic / IsNotNestedPublic

```csharp
public class Container
{
    public class PublicNested { }
    private class PrivateNested { }
}

[Test]
public async Task Is_Nested_Public()
{
    await Assert.That(typeof(Container.PublicNested)).IsNestedPublic();
}
```

#### IsNestedPrivate / IsNotNestedPrivate

```csharp
[Test]
public async Task Is_Nested_Private()
{
    var privateType = typeof(Container)
        .GetNestedType("PrivateNested", BindingFlags.NonPublic);

    await Assert.That(privateType).IsNestedPrivate();
}
```

#### IsNestedAssembly / IsNotNestedAssembly

For internal nested types.

#### IsNestedFamily / IsNotNestedFamily

For protected nested types.

### Visibility Checks

#### IsVisible / IsNotVisible

```csharp
[Test]
public async Task Is_Visible()
{
    await Assert.That(typeof(string)).IsVisible();
    await Assert.That(typeof(List<int>)).IsVisible();

    // Internal types are not visible
    var internalType = Assembly.GetExecutingAssembly()
        .GetTypes()
        .FirstOrDefault(t => !t.IsPublic && !t.IsNested);

    if (internalType != null)
    {
        await Assert.That(internalType).IsNotVisible();
    }
}
```

### COM Interop

#### IsCOMObject / IsNotCOMObject

```csharp
[Test]
public async Task Is_COM_Object()
{
    await Assert.That(typeof(string)).IsNotCOMObject();
    // COM types would return true
}
```

## Practical Examples

### Dependency Injection Validation

```csharp
[Test]
public async Task Service_Implements_Interface()
{
    var service = GetService<IUserService>();

    await Assert.That(service).IsAssignableTo<IUserService>();
    await Assert.That(service).IsNotNull();
}
```

### Plugin System

```csharp
public interface IPlugin { }

[Test]
public async Task Plugin_Implements_Interface()
{
    var pluginType = LoadPluginType();

    await Assert.That(pluginType).IsAssignableTo<IPlugin>();
    await Assert.That(pluginType).IsClass();
    await Assert.That(pluginType).IsNotAbstract();
}
```

### Reflection Testing

```csharp
[Test]
public async Task Type_Has_Expected_Properties()
{
    var type = typeof(User);

    await Assert.That(type).IsClass();
    await Assert.That(type).IsPublic();
    await Assert.That(type).IsNotAbstract();
    await Assert.That(type).IsNotSealed();
}
```

### Generic Constraints

```csharp
[Test]
public async Task Validate_Generic_Constraints()
{
    var listType = typeof(List<int>);

    await Assert.That(listType).IsGenericType();
    await Assert.That(listType).IsAssignableTo<IEnumerable<int>>();
}
```

### Enum Validation

```csharp
[Test]
public async Task Type_Is_Enum()
{
    var statusType = typeof(OrderStatus);

    await Assert.That(statusType).IsEnum();
    await Assert.That(statusType).IsValueType();
}
```

### Abstract Class Validation

```csharp
[Test]
public async Task Base_Class_Is_Abstract()
{
    var baseType = typeof(BaseRepository);

    await Assert.That(baseType).IsClass();
    await Assert.That(baseType).IsAbstract();
}
```

## Chaining Type Assertions

```csharp
[Test]
public async Task Chained_Type_Assertions()
{
    var type = typeof(MyService);

    await Assert.That(type)
        .IsClass()
        .And.IsPublic()
        .And.IsNotAbstract()
        .And.IsNotSealed();
}
```

## Type Comparison

```csharp
[Test]
public async Task Compare_Types()
{
    var type1 = typeof(List<int>);
    var type2 = typeof(List<int>);
    var type3 = typeof(List<string>);

    await Assert.That(type1).IsEqualTo(type2);
    await Assert.That(type1).IsNotEqualTo(type3);
}
```

## Working with Base Types

```csharp
[Test]
public async Task Check_Base_Type()
{
    var type = typeof(ArgumentNullException);
    var baseType = type.BaseType;

    await Assert.That(baseType).IsEqualTo(typeof(ArgumentException));
}
```

## Interface Implementation

```csharp
[Test]
public async Task Implements_Multiple_Interfaces()
{
    var type = typeof(List<int>);

    await Assert.That(type).IsAssignableTo<IList<int>>();
    await Assert.That(type).IsAssignableTo<ICollection<int>>();
    await Assert.That(type).IsAssignableTo<IEnumerable<int>>();
}
```

## Common Patterns

### Factory Pattern Validation

```csharp
[Test]
public async Task Factory_Returns_Correct_Type()
{
    var instance = Factory.Create("user-service");

    await Assert.That(instance).IsTypeOf<UserService>();
    await Assert.That(instance).IsAssignableTo<IService>();
}
```

### ORM Entity Validation

```csharp
[Test]
public async Task Entity_Is_Properly_Configured()
{
    var entityType = typeof(Order);

    await Assert.That(entityType).IsClass();
    await Assert.That(entityType).IsPublic();
    await Assert.That(entityType).IsNotAbstract();

    // Check for required interfaces
    await Assert.That(entityType).IsAssignableTo<IEntity>();
}
```

### Serialization Requirements

```csharp
[Test]
public async Task Type_Is_Serializable()
{
    var type = typeof(DataTransferObject);

    await Assert.That(type).IsClass();
    await Assert.That(type).IsPublic();

    // All properties should be public
    var properties = type.GetProperties();
    await Assert.That(properties).All(p => p.GetMethod?.IsPublic ?? false);
}
```

### Test Double Validation

```csharp
[Test]
public async Task Mock_Implements_Interface()
{
    var mock = new Mock<IUserRepository>();
    var instance = mock.Object;

    await Assert.That(instance).IsAssignableTo<IUserRepository>();
}
```

## Struct Validation

```csharp
public struct Point
{
    public int X { get; set; }
    public int Y { get; set; }
}

[Test]
public async Task Struct_Properties()
{
    var type = typeof(Point);

    await Assert.That(type).IsValueType();
    await Assert.That(type).IsNotClass();
    await Assert.That(type).IsNotEnum();
}
```

## Record Validation

```csharp
public record Person(string Name, int Age);

[Test]
public async Task Record_Properties()
{
    var type = typeof(Person);

    await Assert.That(type).IsClass();
    // Records are classes with special properties
}
```

## See Also

- [Exceptions](exceptions.md) - Type checking for exceptions
- [Equality & Comparison](equality-and-comparison.md) - Comparing type objects
- [Collections](collections.md) - Type checking collection elements

---

## AsyncTests

# AsyncTests Benchmark

:::info Last Updated
This benchmark was automatically generated on **2026-02-14** from the latest CI run.

**Environment:** Ubuntu Latest • .NET SDK 10.0.103
:::

## 📊 Results

| Framework | Version | Mean | Median | StdDev |
|-----------|---------|------|--------|--------|
| **TUnit** | 1.13.56 | 531.7 ms | 531.8 ms | 2.16 ms |
| NUnit | 4.4.0 | 670.1 ms | 668.0 ms | 4.74 ms |
| MSTest | 4.1.0 | 614.3 ms | 613.6 ms | 4.60 ms |
| xUnit3 | 3.2.2 | 733.3 ms | 733.0 ms | 6.50 ms |
| **TUnit (AOT)** | 1.13.56 | 125.2 ms | 125.2 ms | 0.27 ms |

## 📈 Visual Comparison

```mermaid
%%{init: {
  'theme':'base',
  'themeVariables': {
    'primaryColor': '#2563eb',
    'primaryTextColor': '#ffffff',
    'primaryBorderColor': '#1e40af',
    'lineColor': '#6b7280',
    'secondaryColor': '#7c3aed',
    'tertiaryColor': '#dc2626',
    'background': '#ffffff',
    'mainBkg': '#2563eb',
    'secondBkg': '#7c3aed',
    'tertiaryBkg': '#dc2626',
    'clusterBkg': '#f3f4f6',
    'edgeLabelBackground': '#ffffff',
    'tertiaryTextColor': '#1f2937',
    'pie1': '#2563eb',
    'pie2': '#7c3aed',
    'pie3': '#dc2626',
    'pie4': '#f59e0b',
    'pie5': '#10b981',
    'pie6': '#06b6d4',
    'pie7': '#ec4899',
    'pie8': '#6366f1',
    'pie9': '#84cc16',
    'pie10': '#f97316',
    'pie11': '#14b8a6',
    'pie12': '#a855f7'
  }
}}%%
xychart-beta
  title "AsyncTests Performance Comparison"
  x-axis ["TUnit", "NUnit", "MSTest", "xUnit3", "TUnit_AOT"]
  y-axis "Time (ms)" 0 --> 880
  bar [531.7, 670.1, 614.3, 733.3, 125.2]
```

## 🎯 Key Insights

This benchmark compares TUnit's performance against NUnit, MSTest, xUnit3 using identical test scenarios.

---

:::note Methodology
View the [benchmarks overview](/docs/benchmarks) for methodology details and environment information.
:::

*Last generated: 2026-02-14T00:35:42.810Z*

---

## Build Performance

# Build Performance Benchmark

:::info Last Updated
This benchmark was automatically generated on **2026-02-14** from the latest CI run.

**Environment:** Ubuntu Latest • .NET SDK 10.0.103
:::

## 📊 Results

Compilation time comparison across frameworks:

| Framework | Version | Mean | Median | StdDev |
|-----------|---------|------|--------|--------|
| **TUnit** | 1.13.56 | 2.320 s | 2.311 s | 0.0346 s |
| Build_NUnit | 4.4.0 | 1.903 s | 1.900 s | 0.0220 s |
| Build_MSTest | 4.1.0 | 1.947 s | 1.957 s | 0.0276 s |
| Build_xUnit3 | 3.2.2 | 1.872 s | 1.867 s | 0.0268 s |

## 📈 Visual Comparison

```mermaid
%%{init: {
  'theme':'base',
  'themeVariables': {
    'primaryColor': '#2563eb',
    'primaryTextColor': '#ffffff',
    'primaryBorderColor': '#1e40af',
    'lineColor': '#6b7280',
    'secondaryColor': '#7c3aed',
    'tertiaryColor': '#dc2626',
    'background': '#ffffff',
    'mainBkg': '#2563eb',
    'secondBkg': '#7c3aed',
    'tertiaryBkg': '#dc2626',
    'clusterBkg': '#f3f4f6',
    'edgeLabelBackground': '#ffffff',
    'tertiaryTextColor': '#1f2937',
    'pie1': '#2563eb',
    'pie2': '#7c3aed',
    'pie3': '#dc2626',
    'pie4': '#f59e0b',
    'pie5': '#10b981',
    'pie6': '#06b6d4',
    'pie7': '#ec4899',
    'pie8': '#6366f1',
    'pie9': '#84cc16',
    'pie10': '#f97316',
    'pie11': '#14b8a6',
    'pie12': '#a855f7'
  }
}}%%
xychart-beta
  title "Build Time Comparison"
  x-axis ["Build_TUnit", "Build_NUnit", "Build_MSTest", "Build_xUnit3"]
  y-axis "Time (s)" 0 --> 3
  bar [2.32, 1.903, 1.947, 1.872]
```

---

:::note Methodology
View the [benchmarks overview](/docs/benchmarks) for methodology details and environment information.
:::

*Last generated: 2026-02-14T00:35:42.812Z*

---

## DataDrivenTests

# DataDrivenTests Benchmark

:::info Last Updated
This benchmark was automatically generated on **2026-02-14** from the latest CI run.

**Environment:** Ubuntu Latest • .NET SDK 10.0.103
:::

## 📊 Results

| Framework | Version | Mean | Median | StdDev |
|-----------|---------|------|--------|--------|
| **TUnit** | 1.13.56 | 467.81 ms | 467.69 ms | 4.236 ms |
| NUnit | 4.4.0 | 534.94 ms | 531.70 ms | 7.743 ms |
| MSTest | 4.1.0 | 458.02 ms | 456.64 ms | 6.994 ms |
| xUnit3 | 3.2.2 | 581.22 ms | 579.48 ms | 5.775 ms |
| **TUnit (AOT)** | 1.13.56 | 24.42 ms | 24.41 ms | 0.821 ms |

## 📈 Visual Comparison

```mermaid
%%{init: {
  'theme':'base',
  'themeVariables': {
    'primaryColor': '#2563eb',
    'primaryTextColor': '#ffffff',
    'primaryBorderColor': '#1e40af',
    'lineColor': '#6b7280',
    'secondaryColor': '#7c3aed',
    'tertiaryColor': '#dc2626',
    'background': '#ffffff',
    'mainBkg': '#2563eb',
    'secondBkg': '#7c3aed',
    'tertiaryBkg': '#dc2626',
    'clusterBkg': '#f3f4f6',
    'edgeLabelBackground': '#ffffff',
    'tertiaryTextColor': '#1f2937',
    'pie1': '#2563eb',
    'pie2': '#7c3aed',
    'pie3': '#dc2626',
    'pie4': '#f59e0b',
    'pie5': '#10b981',
    'pie6': '#06b6d4',
    'pie7': '#ec4899',
    'pie8': '#6366f1',
    'pie9': '#84cc16',
    'pie10': '#f97316',
    'pie11': '#14b8a6',
    'pie12': '#a855f7'
  }
}}%%
xychart-beta
  title "DataDrivenTests Performance Comparison"
  x-axis ["TUnit", "NUnit", "MSTest", "xUnit3", "TUnit_AOT"]
  y-axis "Time (ms)" 0 --> 698
  bar [467.81, 534.94, 458.02, 581.22, 24.42]
```

## 🎯 Key Insights

This benchmark compares TUnit's performance against NUnit, MSTest, xUnit3 using identical test scenarios.

---

:::note Methodology
View the [benchmarks overview](/docs/benchmarks) for methodology details and environment information.
:::

*Last generated: 2026-02-14T00:35:42.810Z*

---

## MassiveParallelTests

# MassiveParallelTests Benchmark

:::info Last Updated
This benchmark was automatically generated on **2026-02-14** from the latest CI run.

**Environment:** Ubuntu Latest • .NET SDK 10.0.103
:::

## 📊 Results

| Framework | Version | Mean | Median | StdDev |
|-----------|---------|------|--------|--------|
| **TUnit** | 1.13.56 | 564.9 ms | 563.4 ms | 6.83 ms |
| NUnit | 4.4.0 | 1,223.2 ms | 1,222.4 ms | 10.49 ms |
| MSTest | 4.1.0 | 2,974.9 ms | 2,975.9 ms | 7.25 ms |
| xUnit3 | 3.2.2 | 3,103.3 ms | 3,102.0 ms | 8.92 ms |
| **TUnit (AOT)** | 1.13.56 | 128.4 ms | 128.4 ms | 0.28 ms |

## 📈 Visual Comparison

```mermaid
%%{init: {
  'theme':'base',
  'themeVariables': {
    'primaryColor': '#2563eb',
    'primaryTextColor': '#ffffff',
    'primaryBorderColor': '#1e40af',
    'lineColor': '#6b7280',
    'secondaryColor': '#7c3aed',
    'tertiaryColor': '#dc2626',
    'background': '#ffffff',
    'mainBkg': '#2563eb',
    'secondBkg': '#7c3aed',
    'tertiaryBkg': '#dc2626',
    'clusterBkg': '#f3f4f6',
    'edgeLabelBackground': '#ffffff',
    'tertiaryTextColor': '#1f2937',
    'pie1': '#2563eb',
    'pie2': '#7c3aed',
    'pie3': '#dc2626',
    'pie4': '#f59e0b',
    'pie5': '#10b981',
    'pie6': '#06b6d4',
    'pie7': '#ec4899',
    'pie8': '#6366f1',
    'pie9': '#84cc16',
    'pie10': '#f97316',
    'pie11': '#14b8a6',
    'pie12': '#a855f7'
  }
}}%%
xychart-beta
  title "MassiveParallelTests Performance Comparison"
  x-axis ["TUnit", "NUnit", "MSTest", "xUnit3", "TUnit_AOT"]
  y-axis "Time (ms)" 0 --> 3724
  bar [564.9, 1223.2, 2974.9, 3103.3, 128.4]
```

## 🎯 Key Insights

This benchmark compares TUnit's performance against NUnit, MSTest, xUnit3 using identical test scenarios.

---

:::note Methodology
View the [benchmarks overview](/docs/benchmarks) for methodology details and environment information.
:::

*Last generated: 2026-02-14T00:35:42.811Z*

---

## MatrixTests

# MatrixTests Benchmark

:::info Last Updated
This benchmark was automatically generated on **2026-02-14** from the latest CI run.

**Environment:** Ubuntu Latest • .NET SDK 10.0.103
:::

## 📊 Results

| Framework | Version | Mean | Median | StdDev |
|-----------|---------|------|--------|--------|
| **TUnit** | 1.13.56 | 525.91 ms | 525.56 ms | 3.748 ms |
| NUnit | 4.4.0 | 1,554.94 ms | 1,553.00 ms | 9.211 ms |
| MSTest | 4.1.0 | 1,481.77 ms | 1,481.30 ms | 7.811 ms |
| xUnit3 | 3.2.2 | 1,601.40 ms | 1,602.07 ms | 4.504 ms |
| **TUnit (AOT)** | 1.13.56 | 77.58 ms | 77.51 ms | 0.450 ms |

## 📈 Visual Comparison

```mermaid
%%{init: {
  'theme':'base',
  'themeVariables': {
    'primaryColor': '#2563eb',
    'primaryTextColor': '#ffffff',
    'primaryBorderColor': '#1e40af',
    'lineColor': '#6b7280',
    'secondaryColor': '#7c3aed',
    'tertiaryColor': '#dc2626',
    'background': '#ffffff',
    'mainBkg': '#2563eb',
    'secondBkg': '#7c3aed',
    'tertiaryBkg': '#dc2626',
    'clusterBkg': '#f3f4f6',
    'edgeLabelBackground': '#ffffff',
    'tertiaryTextColor': '#1f2937',
    'pie1': '#2563eb',
    'pie2': '#7c3aed',
    'pie3': '#dc2626',
    'pie4': '#f59e0b',
    'pie5': '#10b981',
    'pie6': '#06b6d4',
    'pie7': '#ec4899',
    'pie8': '#6366f1',
    'pie9': '#84cc16',
    'pie10': '#f97316',
    'pie11': '#14b8a6',
    'pie12': '#a855f7'
  }
}}%%
xychart-beta
  title "MatrixTests Performance Comparison"
  x-axis ["TUnit", "NUnit", "MSTest", "xUnit3", "TUnit_AOT"]
  y-axis "Time (ms)" 0 --> 1922
  bar [525.91, 1554.94, 1481.77, 1601.4, 77.58]
```

## 🎯 Key Insights

This benchmark compares TUnit's performance against NUnit, MSTest, xUnit3 using identical test scenarios.

---

:::note Methodology
View the [benchmarks overview](/docs/benchmarks) for methodology details and environment information.
:::

*Last generated: 2026-02-14T00:35:42.811Z*

---

## ScaleTests

# ScaleTests Benchmark

:::info Last Updated
This benchmark was automatically generated on **2026-02-14** from the latest CI run.

**Environment:** Ubuntu Latest • .NET SDK 10.0.103
:::

## 📊 Results

| Framework | Version | Mean | Median | StdDev |
|-----------|---------|------|--------|--------|
| **TUnit** | 1.13.56 | 485.83 ms | 486.11 ms | 4.537 ms |
| NUnit | 4.4.0 | 606.07 ms | 604.03 ms | 7.670 ms |
| MSTest | 4.1.0 | 561.57 ms | 560.34 ms | 21.228 ms |
| xUnit3 | 3.2.2 | 634.29 ms | 636.78 ms | 14.806 ms |
| **TUnit (AOT)** | 1.13.56 | 35.77 ms | 35.30 ms | 2.992 ms |

## 📈 Visual Comparison

```mermaid
%%{init: {
  'theme':'base',
  'themeVariables': {
    'primaryColor': '#2563eb',
    'primaryTextColor': '#ffffff',
    'primaryBorderColor': '#1e40af',
    'lineColor': '#6b7280',
    'secondaryColor': '#7c3aed',
    'tertiaryColor': '#dc2626',
    'background': '#ffffff',
    'mainBkg': '#2563eb',
    'secondBkg': '#7c3aed',
    'tertiaryBkg': '#dc2626',
    'clusterBkg': '#f3f4f6',
    'edgeLabelBackground': '#ffffff',
    'tertiaryTextColor': '#1f2937',
    'pie1': '#2563eb',
    'pie2': '#7c3aed',
    'pie3': '#dc2626',
    'pie4': '#f59e0b',
    'pie5': '#10b981',
    'pie6': '#06b6d4',
    'pie7': '#ec4899',
    'pie8': '#6366f1',
    'pie9': '#84cc16',
    'pie10': '#f97316',
    'pie11': '#14b8a6',
    'pie12': '#a855f7'
  }
}}%%
xychart-beta
  title "ScaleTests Performance Comparison"
  x-axis ["TUnit", "NUnit", "MSTest", "xUnit3", "TUnit_AOT"]
  y-axis "Time (ms)" 0 --> 762
  bar [485.83, 606.07, 561.57, 634.29, 35.77]
```

## 🎯 Key Insights

This benchmark compares TUnit's performance against NUnit, MSTest, xUnit3 using identical test scenarios.

---

:::note Methodology
View the [benchmarks overview](/docs/benchmarks) for methodology details and environment information.
:::

*Last generated: 2026-02-14T00:35:42.811Z*

---

## SetupTeardownTests

# SetupTeardownTests Benchmark

:::info Last Updated
This benchmark was automatically generated on **2026-02-14** from the latest CI run.

**Environment:** Ubuntu Latest • .NET SDK 10.0.103
:::

## 📊 Results

| Framework | Version | Mean | Median | StdDev |
|-----------|---------|------|--------|--------|
| **TUnit** | 1.13.56 | 562.4 ms | 562.8 ms | 4.21 ms |
| NUnit | 4.4.0 | 1,167.2 ms | 1,168.0 ms | 8.40 ms |
| MSTest | 4.1.0 | 1,114.9 ms | 1,112.1 ms | 11.24 ms |
| xUnit3 | 3.2.2 | 1,224.9 ms | 1,224.3 ms | 8.70 ms |
| **TUnit (AOT)** | 1.13.56 | NA | NA | NA |

## 📈 Visual Comparison

```mermaid
%%{init: {
  'theme':'base',
  'themeVariables': {
    'primaryColor': '#2563eb',
    'primaryTextColor': '#ffffff',
    'primaryBorderColor': '#1e40af',
    'lineColor': '#6b7280',
    'secondaryColor': '#7c3aed',
    'tertiaryColor': '#dc2626',
    'background': '#ffffff',
    'mainBkg': '#2563eb',
    'secondBkg': '#7c3aed',
    'tertiaryBkg': '#dc2626',
    'clusterBkg': '#f3f4f6',
    'edgeLabelBackground': '#ffffff',
    'tertiaryTextColor': '#1f2937',
    'pie1': '#2563eb',
    'pie2': '#7c3aed',
    'pie3': '#dc2626',
    'pie4': '#f59e0b',
    'pie5': '#10b981',
    'pie6': '#06b6d4',
    'pie7': '#ec4899',
    'pie8': '#6366f1',
    'pie9': '#84cc16',
    'pie10': '#f97316',
    'pie11': '#14b8a6',
    'pie12': '#a855f7'
  }
}}%%
xychart-beta
  title "SetupTeardownTests Performance Comparison"
  x-axis ["TUnit", "NUnit", "MSTest", "xUnit3", "TUnit_AOT"]
  y-axis "Time (ms)" 0 --> 1470
  bar [562.4, 1167.2, 1114.9, 1224.9, 0]
```

## 🎯 Key Insights

This benchmark compares TUnit's performance against NUnit, MSTest, xUnit3 using identical test scenarios.

---

:::note Methodology
View the [benchmarks overview](/docs/benchmarks) for methodology details and environment information.
:::

*Last generated: 2026-02-14T00:35:42.811Z*

---

## Performance Benchmarks


:::info Last Updated
These benchmarks were automatically generated on **2026-02-14** from the latest CI run.

**Environment:** Ubuntu Latest • .NET SDK 10.0.103
:::

## 🚀 Runtime Benchmarks

Click on any benchmark to view detailed results:

- [AsyncTests](AsyncTests) - Detailed performance analysis
- [DataDrivenTests](DataDrivenTests) - Detailed performance analysis
- [MassiveParallelTests](MassiveParallelTests) - Detailed performance analysis
- [MatrixTests](MatrixTests) - Detailed performance analysis
- [ScaleTests](ScaleTests) - Detailed performance analysis
- [SetupTeardownTests](SetupTeardownTests) - Detailed performance analysis

## 🔨 Build Benchmarks

- [Build Performance](BuildTime) - Compilation time comparison

---

## 📊 Methodology

These benchmarks compare TUnit against the most popular .NET testing frameworks:

| Framework | Version Tested |
|-----------|----------------|
| **TUnit** | 1.13.56 |
| **xUnit v3** | 3.2.2 |
| **NUnit** | 4.4.0 |
| **MSTest** | 4.1.0 |

### Test Scenarios

The benchmarks measure real-world testing patterns:

- **DataDrivenTests**: Parameterized tests with multiple data sources
- **AsyncTests**: Realistic async/await patterns with I/O simulation
- **ScaleTests**: Large test suites (150+ tests) measuring scalability
- **MatrixTests**: Combinatorial test generation and execution
- **MassiveParallelTests**: Parallel execution stress tests
- **SetupTeardownTests**: Expensive test fixtures with setup/teardown overhead

### Environment

- **OS**: Ubuntu Latest (GitHub Actions)
- **Runtime**: .NET 10.0.3 (10.0.3, 10.0.326.7603), X64 RyuJIT x86-64-v3
- **SDK**: .NET SDK 10.0.103
- **Hardware**: GitHub Actions Standard Runner (Ubuntu)
- **Tool**: BenchmarkDotNet v0.15.8, Linux Ubuntu 24.04.3 LTS (Noble Numbat)

### Why These Numbers Matter

- **No Mocking**: All tests use realistic patterns, not artificial micro-benchmarks
- **Equivalent Logic**: Each framework implements identical test scenarios
- **Warm-Up Excluded**: Measurements exclude JIT warm-up overhead
- **Statistical Rigor**: Multiple iterations with outlier detection

### Source Code

All benchmark source code is available in the [`tools/speed-comparison`](https://github.com/thomhurst/TUnit/tree/main/tools/speed-comparison) directory.

---

:::note Continuous Benchmarking
These benchmarks run automatically daily via [GitHub Actions](https://github.com/thomhurst/TUnit/actions/workflows/speed-comparison.yml).

Each benchmark runs multiple iterations with statistical analysis to ensure accuracy. Results may vary based on hardware and test characteristics.
:::

*Last generated: 2026-02-14T00:35:42.812Z*

---

## Benchmark Methodology


This page explains how TUnit's performance benchmarks are conducted to ensure fair, accurate, and reproducible results.

## Core Principles

### 1. Real-World Scenarios
Benchmarks test realistic patterns, not artificial micro-benchmarks:
- Actual assertion logic
- Real data source patterns
- Typical setup/teardown workflows
- Common parallelization strategies

### 2. Fair Comparison
Every framework implements identical test logic:
- Same test methods
- Same data inputs
- Same assertion complexity
- Equivalent configuration

### 3. Statistical Rigor
All benchmarks use [BenchmarkDotNet](https://benchmarkdotnet.org/), the industry-standard .NET benchmarking library:
- Multiple iterations per benchmark
- Statistical outlier detection
- Warm-up phase excluded from measurements
- Standard deviation and median reported

## Test Categories

### Runtime Benchmarks

#### DataDrivenTests
**Purpose**: Measure parameterized test performance

**What's tested**:
```csharp
[Test]
[Arguments(1, 2, 3)]
[Arguments(4, 5, 9)]
// ... 50 argument sets
public void TestAddition(int a, int b, int expected)
{
    Assert.That(a + b).IsEqualTo(expected);
}
```

**Why it matters**: Most test suites use parameterized tests extensively.

---

#### AsyncTests
**Purpose**: Measure async/await pattern performance

**What's tested**:
```csharp
[Test]
public async Task TestAsyncOperation()
{
    var result = await SimulateAsyncWork();
    await Assert.That(result).IsNotNull();
}
```

**Why it matters**: Modern .NET is async-first.

---

#### ScaleTests
**Purpose**: Measure scalability with large test counts

**What's tested**:
- 1000+ test methods
- Parallel execution
- Memory efficiency

**Why it matters**: Enterprise codebases have thousands of tests.

---

#### MatrixTests
**Purpose**: Measure combinatorial test generation

**What's tested**:
```csharp
[Test]
[Matrix("Create", "Update", "Delete")] // Operation
[Matrix("User", "Admin", "Guest")]     // Role
public void TestPermissions(string op, string role)
{
    // 9 test combinations
}
```

**Why it matters**: Matrix testing is common for comprehensive coverage.

---

#### MassiveParallelTests
**Purpose**: Stress test parallel execution

**What's tested**:
- 100+ tests running concurrently
- Resource contention
- Thread safety

**Why it matters**: Parallel execution is TUnit's default behavior.

---

### Build Benchmarks

**Purpose**: Measure compilation time impact

**What's tested**:
- Clean build time
- Incremental build time
- Source generator overhead

**Why it matters**: Fast builds improve developer productivity.

## Environment

### Hardware
- **Platform**: GitHub Actions Ubuntu runners
- **Consistency**: Same hardware for all frameworks
- **Reproducibility**: Daily automated runs

### Software
- **Framework Versions**: Latest stable releases
- **.NET Version**: .NET 10 (latest)
- **OS**: Ubuntu Latest

### Configuration
- **Release Mode**: All tests compiled with optimizations
- **Native AOT**: Separate TUnit_AOT benchmark
- **Default Settings**: No special framework configuration

## Measurement Process

### 1. Build Phase
```bash
# Build all frameworks identically
dotnet build -c Release -p:TestFramework=TUNIT
dotnet build -c Release -p:TestFramework=XUNIT3
dotnet build -c Release -p:TestFramework=NUNIT
dotnet build -c Release -p:TestFramework=MSTEST
```

### 2. Execution Phase
```csharp
[Benchmark]
public async Task TUnit()
{
    await Cli.Wrap("UnifiedTests.exe")
        .WithArguments(["--filter", "TestCategory"])
        .ExecuteBufferedAsync();
}
```

### 3. Analysis Phase
- BenchmarkDotNet collects metrics
- Statistical analysis performed
- Results exported to markdown
- Historical trends tracked

## What Gets Measured

### Primary Metrics

#### Mean Execution Time
- **Definition**: Average time across all iterations
- **Unit**: Milliseconds (ms) or Seconds (s)
- **Lower is better**

#### Median Execution Time
- **Definition**: Middle value, less affected by outliers
- **Unit**: Milliseconds (ms) or Seconds (s)
- **More stable than mean**

#### Standard Deviation
- **Definition**: Measure of result consistency
- **Unit**: Same as mean
- **Lower is better** (more consistent)

### Derived Metrics

#### Speedup Factor
```
Speedup = (Other Framework Time) / (TUnit Time)
```

Example: "2.5x faster" means TUnit is 2.5 times faster.

#### AOT Improvement
```
AOT Speedup = (TUnit JIT Time) / (TUnit AOT Time)
```

Example: "4x faster with AOT" means Native AOT is 4 times faster than JIT.

## Benchmark Automation

### Daily Execution
Benchmarks run automatically every 24 hours via [GitHub Actions](https://github.com/thomhurst/TUnit/blob/main/.github/workflows/speed-comparison.yml).

### Process
1. **Build**: Compile all framework versions
2. **Execute**: Run benchmarks in isolated processes
3. **Analyze**: Parse BenchmarkDotNet output
4. **Publish**: Update documentation automatically
5. **Track**: Store historical trends

### Artifacts
All raw benchmark results are available as GitHub Actions artifacts for 90 days.

## Reproducibility

### Running Locally

```bash
# 1. Navigate to benchmark project
cd tools/speed-comparison

# 2. Build all frameworks
dotnet build -c Release

# 3. Run specific benchmark
cd Tests.Benchmark
dotnet run -c Release -- --filter "*RuntimeBenchmarks*"
```

### Viewing Results
Results are generated in `BenchmarkDotNet.Artifacts/results/`:
- Markdown reports (*.md)
- CSV data (*.csv)
- HTML reports (*.html)

## Limitations & Caveats

### What Benchmarks Don't Measure

❌ **IDE Integration**: Benchmarks don't measure test discovery in IDEs

❌ **Debugger Performance**: Debug mode performance is not measured

❌ **Real I/O**: Most tests use in-memory operations to avoid I/O variance

❌ **External Dependencies**: No database, network, or file system calls

### Variance Factors

Results can vary based on:
- Hardware configuration
- Background processes
- OS scheduling
- .NET runtime version
- Test complexity

### Interpreting Results

- **Relative Performance**: Compare frameworks, not absolute times
- **Your Mileage May Vary**: Real-world results depend on test characteristics
- **Trends Matter More**: Watch for performance regressions over time

## Transparency

### Open Source
All benchmark code is open source:
- [Unified Test Suite](https://github.com/thomhurst/TUnit/tree/main/tools/speed-comparison/UnifiedTests)
- [Benchmark Harness](https://github.com/thomhurst/TUnit/tree/main/tools/speed-comparison/Tests.Benchmark)
- [CI Workflow](https://github.com/thomhurst/TUnit/blob/main/.github/workflows/speed-comparison.yml)

### Community Verification
Found an issue with the benchmarks? [Open an issue](https://github.com/thomhurst/TUnit/issues) or submit a PR!

---

## Further Reading

- [BenchmarkDotNet Documentation](https://benchmarkdotnet.org/articles/overview.html)
- [.NET Performance Best Practices](https://learn.microsoft.com/en-us/dotnet/framework/performance/)
- [TUnit Performance Best Practices](/docs/advanced/performance-best-practices)

*Last updated: {new Date().toISOString().split('T')[0]}*

---

## Attributes


Here are TUnit's equivalent attributes to other test frameworks.

## Test Attributes

| TUnit  | xUnit    | NUnit            | MSTest           |
| ------ | -------- | ---------------- | ---------------- |
| [Test] | [Fact]   | [Test]           | [TestMethod]     |
| [Test] | [Theory] | [TestCase]       | [DataTestMethod] |
| [Test] | [Theory] | [TestCaseSource] | [DataTestMethod] |
| [Test] | -        | [Combinatorial]  | -                |

## Data Injection Attributes

| TUnit                        | xUnit                             | NUnit            | MSTest        |
| ---------------------------- | --------------------------------- | ---------------- | ------------- |
| [Arguments]                  | [InlineData]                      | [TestCase]       | [DataRow]     |
| [ClassDataSource]            | [ClassData] or `IClassFixture<T>` | [TestCaseSource] | -             |
| [MethodDataSource]           | [MemberData]                      | [TestCaseSource] | [DynamicData] |
| [Matrix]                     | -                                 | [Values]         | -             |

## Test Control Attributes

| TUnit           | xUnit                                                 | NUnit                | MSTest   |
| --------------- | ----------------------------------------------------- | -------------------- | -------- |
| [Repeat]        | -                                                     | [Repeat]             | -        |
| [Retry]         | -                                                     | [Retry]              | -        |
| [Skip]          | [Fact(Skip="")]                                       | [Ignore]             | [Ignore] |
| [Timeout]       | -                                                     | [TimeOut]            | -        |
| [Explicit]      | -                                                     | [Explicit]           | -        |
| [NotInParallel] | [CollectionDefinition(DisableParallelization = true)] | [LevelOfParallelism] | -        |

## Lifecycle Hook Attributes

| TUnit                   | xUnit                                      | NUnit                              | MSTest               |
| ----------------------- | ------------------------------------------ | ---------------------------------- | -------------------- |
| [Before(Test)]          | `< Constructor >`                          | [SetUp]                            | [TestInitialize]     |
| [After(Test)]           | `IDisposable.Dispose`                      | [TearDown]                         | [TestCleanup]        |
| [Before(Class)]         | `IClassFixture<T>`                         | [OneTimeSetUp]                     | [ClassInitialize]    |
| [After(Class)]          | `IClassFixture<T>` + `IDisposable.Dispose` | [OneTimeTearDown]                  | [ClassCleanup]       |
| [Before(Assembly)]      | -                                          | [SetUpFixture] + [OneTimeSetUp]    | [AssemblyInitialize] |
| [After(Assembly)]       | -                                          | [SetUpFixture] + [OneTimeTearDown] | [AssemblyCleanup]    |
| [Before(TestSession)]   | -                                          | -                                  | -                    |
| [After(TestSession)]    | -                                          | -                                  | -                    |
| [Before(TestDiscovery)] | -                                          | -                                  | -                    |
| [After(TestDiscovery)]  | -                                          | -                                  | -                    |
| [BeforeEvery(Test)]     | -                                          | -                                  | -                    |
| [AfterEvery(Test)]      | -                                          | -                                  | -                    |
| [BeforeEvery(Class)]    | -                                          | -                                  | -                    |
| [AfterEvery(Class)]     | -                                          | -                                  | -                    |
| [BeforeEvery(Assembly)] | -                                          | -                                  | -                    |
| [AfterEvery(Assembly)]  | -                                          | -                                  | -                    |

## Metadata Attributes

| TUnit      | xUnit                  | NUnit      | MSTest         |
| ---------- | ---------------------- | ---------- | -------------- |
| [Category] | [Trait("Category","")] | [Category] | [TestCategory] |
| [Property] | [Trait]                | [Property] | [TestProperty] |

## Culture-sensitive Attributes

| TUnit              | xUnit | NUnit                  | MSTest |
|--------------------|-------|------------------------|--------|
| [Culture("en-US")] | -     | [SetCulture("en-US")]  | -      |
| -                  | -     | [Culture("en-US")]     | -      |
| -                  | -     | [SetUICulture("en-US") | -      |

---

## Framework Differences


TUnit is inspired by NUnit and xUnit, and first and foremost I want to say that these are amazing frameworks and no hate to them.

**Why use TUnit?**
TUnit aims to address some pain points and limitations found in other frameworks, especially around parallelism, lifecycle hooks, test isolation, and extensibility.
Below are some scenarios where TUnit offers a different or improved approach.

## Quick Comparison: Basic Test Structure

| Framework | Class Attribute | Method Attribute | Example |
|-----------|----------------|------------------|---------|
| **TUnit** | ❌ None needed | `[Test]` | `public class MyTests { [Test] public async Task MyTest() { } }` |
| **MSTest** | `[TestClass]` | `[TestMethod]` | `[TestClass] public class MyTests { [TestMethod] public void MyTest() { } }` |
| **NUnit** | `[TestFixture]` (optional) | `[Test]` | `[TestFixture] public class MyTests { [Test] public void MyTest() { } }` |
| **xUnit** | ❌ None needed | `[Fact]` or `[Theory]` | `public class MyTests { [Fact] public void MyTest() { } }` |

**Key Point**: TUnit does **NOT** require `[TestClass]` or `[TestFixture]` attributes. You only need `[Test]` on your test methods.

### Complete TUnit Test Example

**With explicit using statements:**

```csharp
using TUnit.Assertions;
using TUnit.Assertions.Extensions;
using TUnit.Core;

namespace MyTests;

public class ValidatorTests  // No [TestClass] needed!
{
    [Test]  // Only this attribute is required
    public async Task IsPositive_WithNegativeNumber_ReturnsFalse()
    {
        var result = Validator.IsPositive(-1);
        await Assert.That(result).IsFalse();
    }
}
```

**Without explicit using statements (TUnit automatically provides global usings):**

```csharp
namespace MyTests;

public class ValidatorTests
{
    [Test]
    public async Task IsPositive_WithNegativeNumber_ReturnsFalse()
    {
        var result = Validator.IsPositive(-1);
        await Assert.That(result).IsFalse();
    }
}
```

The TUnit package automatically configures global usings for common TUnit namespaces, so you don't need to include using statements in your test files.

So you'll be asking why use TUnit instead of them, right?
Here are some things I've stumbled across in the past that I've found limiting when writing a test suite.

## xUnit

### Async tests parallel limit
xUnit gives you a way to limit the 'thread count' - but this doesn't map 1-to-1 to async tests. 1 thread can run multiple async tests when they yield, and that means limiting the thread count doesn't limit the test count. This can be problematic in certain scenarios. For example, running UI tests, you might want to limit the number of concurrent tests because spawning up too many browser instances overwhelms your system. With TUnit, you can pass in a CLI flag to limit the number of concurrent tests: `--maximum-parallel-tests 8`

### Set up and tear downs
Set ups and tear-downs work largely off of constructors and the `IDisposable` interface (TUnit can do this too if you like this pattern). If you have async requirements, you can implement an `IAsyncLifetime` interface. While some people like this approach as its familiar, things get messier when your classes rely on inheritance. If your base class uses these interfaces, you have to then hide the base members, implement your version, and then call the base method manually. Also with tear downs, if you want to guarantee execution of multiple pieces of code, you can't implement the interface multiple times. So you end up having to do lots of try/catches. In TUnit, you can declare multiple methods with `[After(Test)]` attributes, and they are all guaranteed to run, even if a previous one failed. And it'll lazily aggregate and throw any exceptions after they've all run. On top of this, any set ups and tear downs are collected all the way down to the base class, and run in an order than means members are initialised and cleaned up that makes sense:
    - For set ups, that means base set up methods are run first, and then the subsequent inherited class's methods
    - For clean ups, the top most clean ups are run first, and then the subsequent base methods

### Assembly level hooks
There isn't a simplistic way to do something on starting an assembly's tests. For example, we might want to spin up 1 in-memory server to run some tests against. TUnit supports this with a simple static class, with a method containing the attribute `[Before(Assembly)]`. Tear down is as simple as another method with `[After(Assembly)]`. 

### TestContext
Sometimes we want to access information about the state of a test. For example, when running UI tests, I like to take a screenshot on a test failure, so I can more easily see what went wrong. xUnit does not have a native way of determining if a test failed when you're in a tear down method. With TUnit, you can inject in a `TestContext` object into your tear down method, or you can call the static `TestContext.Current` static method.

### Assertions
xUnit assertions are fairly basic and have the problem of it being unclear which argument goes in which position, without sifting through intellisense/documentation.

```csharp
var one = 2;
Assert.Equal(1, one)
Assert.Equal(one, 1)
```

## NUnit

### Shared test class instances
This one has bitten me so many times, and I've seen it bite many others too. And a lot of people don't even know it. But the default behaviour of NUnit is to run all your tests within a class, against a single instance of that class. That means if you're storing state in fields/properties, they're going to be left over from previous tests.
This is what I call leaky test states, and I am firmly against it. Tests should be isolated from one another and really unable to affect one another. So TUnit by design runs every test against a new instance, and there is no way to change that because I consider it bad practice. If you want to share state in a field, then that's entirely possible by making it `static`. By utilising the language instead, it makes it clear to anyone reading it whether multiple tests can access that.

### Setting properties based off of dynamically injected data
I had a scenario in a multi-tenanted test suite where tests tests were repeated with different tenants injected in.
Like this:
```csharp
[TestFixtureSource(typeof(Tenant), nameof(Tenant.AllTenants))]
public class MyTests(Tenant tenant)
{
    [Test]
    public async Task Test1()
    {
        ...
    }
}
```

With this, I wanted to be able to filter by the tenant. So I tried using a custom attribute with `IApplyToTest` and setting a property based on the constructor argument. This didn't work. I think they're enumerated upon starting, and so you can't set this up beforehand. With TUnit, tests are enumerated and initialised via source-generation so this is all done up-front. So I could set a property in TUnit with an attribute with `ITestDiscoveryEvent`, set a property based constructor arguments, and then run `dotnet run --treenode-filter /*/*/*/*[Tenant=MyTenant]` 

### Assembly & class level attributes
Want to use the `[Repeat]` or `[Retry]` attributes on a class? Or even an assembly? You can't. They're only supported for test methods. With TUnit, most attributes are supported at Test, Class & Assembly levels. Test takes the highest priority, then class, then assembly. So you could set defaults with an assembly/class attribute, and then override it for certain tests by setting that same attribute on the test.

### Assertions
NUnit assertions largely influenced the way that TUnit assertions work. However, NUnit assertions do not have compile time checks. I could check if a string is negative (`NUnitAssert.That("String", Is.Negative);`) or if a boolean throws an exception (`NUnitAssert.That(true, Throws.ArgumentException);`). These assertions don't make sense. There are analyzers to help catch these - But they will compile if these analyzers aren't run. TUnit assertions are built with the type system in mind (where possible!). Specific assertions are built via extensions to the relevant types, and not in a generic sense that could apply to anything. That means when you're using intellisense to see what methods you have available, you should only see assertions that are relevant for your type. This makes it harder to make mistakes, and decreases your feedback loop time.

## Other

### Source generated + Native AOT Support + Single File Support
As mentioned, TUnit is source generated. This should mean things are fast. And you can check out the generated code yourself! Because tests are source generated and not scanned via reflection, this means you can build your test projects using Native AOT or as a Single File application - Something that you can't current do with NUnit or xUnit.

### More lifecycle hooks
TUnit has tried to make it easy to hook into a range of lifecycles.
The attributes you can use on your hook methods are:
- `[Before(Test)]` - Run before every test in the class it's defined in
- `[After(Test)]` - Run after every test in the class it's defined in
- `[Before(Class)]` - Run once before all tests in the class it's defined in
- `[After(Class)]` - Run once after all tests in the class it's defined in
- `[Before(Assembly)]` - Run once before all tests in the assembly it's defined in
- `[After(Assembly)]` - Run once after all tests in the assembly it's defined in
- `[Before(TestSession)]` - Run once before all tests in the test run
- `[After(TestSession)]` - Run once after all tests in the test run
- `[Before(TestDiscovery)]` - Run once before any tests are discovered
- `[After(TestDiscovery)]` - Run once after all tests are discovered

- `[BeforeEvery(Test)]` - Run before every test in the test run
- `[AfterEvery(Test)]` - Run after every test in the test run
- `[BeforeEvery(Class)]` - Run before the first test in every class in the test run
- `[AfterEvery(Class)]` - Run after the last test in every class in the test run
- `[BeforeEvery(Assembly)]` - Run before the first test in every assembly in the test run
- `[AfterEvery(Assembly)]` - Run after the last test in every assembly in the test run

And all those hooks allow injecting in a relevant `[HookType]Context` object - So you can interrogate it for information about the test run so far. Hopefully meeting the needs of most users!

### Test dependencies
Got tests that require another test to execute first?
In other frameworks it usually involves turning off parallelisation, then setting an `[Order]` attribute with 1, 2, 3, etc.
In TUnit, you can use a `[DependsOn(...)]` attribute. That test will wait to start, only once its dependencies have finished. And you don't have to turn off parallelisation of other tests!

```csharp
    [Test]
    public async Task Test1()
    {
        ...
    }
    
    [Test]
    public async Task Test2()
    {
        ...
    }
    
    [Test]
    [DependsOn(nameof(Test1))]
    [DependsOn(nameof(Test2))]
    public async Task Test3()
    {
        ...
    }
```

### Class Arguments
A lot of the data injection mechanisms in xUnit/NUnit work for the method, or the class, and not vice-versa. With TUnit, you can use `[Arguments(...)]` or `[Matrix(...)]` or `[MethodDataSource(...)]` etc. for both classes and test methods, making it super flexible!

---

## Argument Formatters


When writing data-driven tests, especially with custom classes as arguments, the test explorer may only show the class name, making it hard to distinguish test cases.  
Argument formatters let you control how arguments are displayed in test names and test explorers.

If you want control over how injected arguments appear in the test explorer, you can create a class that inherits from `ArgumentDisplayFormatter` and then decorate your test with the `[ArgumentDisplayFormatter<T>]` attribute.

For example:

```csharp
    [Test]
    [MethodDataSource(nameof(SomeMethod))]
    [ArgumentDisplayFormatter<MyFormatter>]
    public async Task Test(SomeClass someClass)
    {
        await Assert.That(TestContext.Current!.GetDisplayName()).IsEqualTo("A super important test!");
    }
```

```csharp
public class MyFormatter : ArgumentDisplayFormatter
{
    public override bool CanHandle(object? value)
    {
        return value is SomeClass;
    }

    public override string FormatValue(object? value)
    {
        var someClass = (SomeClass)value;
        return $"One: {someClass.One} | Two: {someClass.Two}";
    }
}
```

:::info
You can apply multiple `[ArgumentDisplayFormatter<T>]` attributes if you have different types to format.  
The first formatter whose `CanHandle` returns true will be used.
:::

---

## Data Source Generators


TUnit provides several base classes for creating custom data source generators:

## DataSourceGeneratorAttribute

The standard `DataSourceGeneratorAttribute` class uses generic `Type` arguments to keep your data strongly typed. This attribute can be useful to easily populate data in a generic way, and without having to define lots of specific `MethodDataSources`.

If you just need to generate data for a single parameter, you simply return `T`.

If you need to generate data for multiple parameters, you must use a `Tuple<>` return type. E.g. `return (T1, T2, T3)`

Here's an example that uses AutoFixture to generate arguments:

```csharp
using TUnit.Core;

namespace MyTestProject;

public class AutoFixtureGeneratorAttribute<T1, T2, T3> : DataSourceGeneratorAttribute<T1, T2, T3>
{
    public override IEnumerable<Func<(T1, T2, T3)>> GenerateDataSources(DataGeneratorMetadata dataGeneratorMetadata)
    {
        var fixture = new Fixture();
        
        yield return () => (fixture.Create<T1>(), fixture.Create<T2>(), fixture.Create<T3>());
    }
}

[AutoFixtureGenerator<SomeClass1, SomeClass2, SomeClass3>]
public class MyTestClass(SomeClass1 someClass1, SomeClass2 someClass2, SomeClass3 someClass3)
{
    [Test]
    [AutoFixtureGenerator<int, string, bool>]
    public async Task Test((int value, string value2, bool value3))
    {
        // ...
    }
}

```

## AsyncDataSourceGeneratorAttribute

For data sources that need to perform asynchronous operations (like reading from a database, calling an API, or loading files), TUnit provides `AsyncDataSourceGeneratorAttribute`.

This works similarly to `DataSourceGeneratorAttribute` but allows you to use async/await:

:::warning Performance Consideration
**Important**: AsyncDataSourceGenerator code runs at test discovery time, not test execution time. This means:
- Keep async operations fast and lightweight
- Avoid long-running operations or external dependencies that might be slow/unavailable
- If an async operation hangs, your tests may never be discovered
- Consider caching results if the operation is expensive
- For heavy operations, consider using a regular test method that loads data once and shares it across tests
:::

```csharp
using TUnit.Core;

namespace MyTestProject;

public class DatabaseDataGeneratorAttribute<T> : AsyncDataSourceGeneratorAttribute<T> where T : class
{
    private readonly string _connectionString;
    
    public DatabaseDataGeneratorAttribute(string connectionString)
    {
        _connectionString = connectionString;
    }
    
    public override async IAsyncEnumerable<Func<T>> GenerateDataSources(DataGeneratorMetadata dataGeneratorMetadata)
    {
        await using var connection = new SqlConnection(_connectionString);
        await connection.OpenAsync();
        
        var entities = await connection.QueryAsync<T>("SELECT * FROM " + typeof(T).Name);
        
        foreach (var entity in entities)
        {
            yield return () => entity;
        }
    }
}

[Test]
[DatabaseDataGenerator<Customer>("Server=localhost;Database=TestDb;")]
public async Task TestCustomerBehavior(Customer customer)
{
    // Test with real customer data from database
}
```

## UntypedDataSourceGeneratorAttribute

For scenarios where you need to generate dynamic types or work with libraries that don't have compile-time type information (like AutoFixture), TUnit provides `UntypedDataSourceGeneratorAttribute`.

This is particularly useful when:
- Working with anonymous types
- Using dynamic type generation libraries
- Creating data where the type isn't known at compile time

```csharp
using TUnit.Core;
using AutoFixture;

namespace MyTestProject;

public class AutoFixtureGeneratorAttribute : UntypedDataSourceGeneratorAttribute
{
    private readonly Type[] _types;
    
    public AutoFixtureGeneratorAttribute(params Type[] types)
    {
        _types = types;
    }
    
    public override IEnumerable<Func<object?[]>> GenerateDataSources(DataGeneratorMetadata dataGeneratorMetadata)
    {
        var fixture = new Fixture();
        
        yield return () => _types.Select(type => fixture.Create(type, new SpecimenContext(fixture))).ToArray();
    }
}

[Test]
[AutoFixtureGenerator(typeof(Customer), typeof(Order), typeof(Product))]
public async Task TestWithDynamicTypes(Customer customer, Order order, Product product)
{
    // AutoFixture will generate test data for all three parameters
}

// You can also use it at the class level
[AutoFixtureGenerator(typeof(DatabaseContext))]
public class RepositoryTests(DatabaseContext context)
{
    [Test]
    public async Task TestRepository()
    {
        // context is populated by AutoFixture
    }
}
```

## Important Notes

### Func Return Pattern
`GenerateDataSources()` could be called multiple times if you have nested loops to generate data within your tests. Because of this, you are required to return a `Func` - This means that tests can create a new object each time for a test case. Otherwise, we'd be pointing to the same object if we were in a nested loop and that could lead to unintended side-effects.

An example could be using a DataSourceGenerator on both the class and the test method, resulting with a loop within a loop.

### TestBuilderContext
Because this could be called multiple times, if you're subscribing to test events and storing state within the attribute, be aware of this and how this could affect disposal etc.

Instead, you can use the `yield return` pattern, and use the `TestBuilderContext` from the `DataGeneratorMetadata` object passed to you.
After each `yield`, the execution is passed back to TUnit, and TUnit will set a new `TestBuilderContext` for you - So as long as you yield each result, you'll get a unique context object for each test case.
The `TestBuilderContext` object exposes `Events` - And you can register a delegate to be invoked on them at the point in the test lifecycle that you wish.

```csharp
public override IEnumerable<Func<int>> GenerateDataSources(DataGeneratorMetadata dataGeneratorMetadata)
{
    dataGeneratorMetadata.TestBuilderContext.Current; // <-- Initial Context for first test
    
    yield return () => 1;
    
    dataGeneratorMetadata.TestBuilderContext.Current; // <-- This is now a different context object, as we yielded
    dataGeneratorMetadata.TestBuilderContext.Current; // <-- This is still the same as above because it'll only change on a yield
    
    yield return () => 2;
    
    dataGeneratorMetadata.TestBuilderContext.Current; // <-- A new object again
}
```

## Choosing the Right Base Class

- **DataSourceGeneratorAttribute**: Use when you know the types at compile time and want strong typing
- **AsyncDataSourceGeneratorAttribute**: Use when you need to perform async operations (database, API, file I/O)
- **UntypedDataSourceGeneratorAttribute**: Use when working with dynamic types or type generation libraries

---

## Display Names


If you want simple control over the name of a test, you can use the `[DisplayName(...)]` attribute.

```csharp
    [Test]
    [DisplayName("My first test!")]
    public async Task Test()
    {
        ...
    }
```

You can reference test parameters in the display name by using `$parameterName` within the attribute string. At runtime, these will be replaced with the actual argument values for each test case.

```csharp
    [Test]
    [Arguments("foo", 1, true)]
    [Arguments("bar", 2, false)]
    [DisplayName("Test with: $value1 $value2 $value3!")]
    public async Task Test3(string value1, int value2, bool value3)
    {
        ...
    }
```

The above would generate two test cases with their respective display name as:
- "Test with: foo 1 True"
- "Test with: bar 2 False"

If you have custom classes, you can combine this with [Argument Formatters](customization-extensibility/argument-formatters.md) to specify how to show them.

:::info
If you want to include a literal `$` in your display name, escape it as `$$`.  
For example: `[DisplayName("Total cost: $$100")]` will display as "Total cost: $100".
:::

## Custom Logic

If you want to have more control over how your test names are, you can create an attribute that inherits from `DisplayNameFormatterAttribute`.

There you will find a method that you must override: `FormatDisplayName`.
Here you have access to all the arguments and test details via the `TestContext` parameter.

Then simply add that custom attribute to your test.

---

## Libraries


If you want a library package to define things like re-useable base classes with hooks etc, then you shouldn't use the main `TUnit` package - As this assumes your project is a test project and tries to build it as an executable etc.

Instead, reference `TUnit.Core` instead - It has all of the models required for wiring up your tests, but without all the extra setting up of the test suite execution.

---

## Logging


TUnit provides a flexible logging system that captures all test output and routes it to configurable destinations called "log sinks".

## Basic Usage

By default, TUnit intercepts any logs to `Console.WriteLine()` and correlates them to the test that triggered the log using the current async context.

```csharp
[Test]
public async Task MyTest()
{
    Console.WriteLine("This output is captured and associated with this test");
}
```

### Logger Objects

For more control, use `TestContext.Current.GetDefaultLogger()` to get a logger instance:

```csharp
[Test]
public async Task MyTest()
{
    var logger = TestContext.Current!.GetDefaultLogger();
    logger.LogInformation("Information message");
    logger.LogWarning("Warning message");
    logger.LogError("Error message");
}
```

This logger can integrate with other logging frameworks like Microsoft.Extensions.Logging for ASP.NET applications.

## Log Sinks

TUnit uses a sink-based architecture where all output is routed through registered log sinks. Each sink decides how to handle the messages - write to files, stream to IDEs, send to external services, etc.

### Built-in Sinks

TUnit automatically registers these sinks based on your execution context:

| Sink | When Registered | Purpose |
|------|-----------------|---------|
| **TestOutputSink** | Always | Captures output for test results shown after execution |
| **ConsoleOutputSink** | `--output Detailed` | Writes real-time output to the console |
| **RealTimeOutputSink** | IDE clients + `TUNIT_ENABLE_IDE_STREAMING=1` | Streams output to IDE test explorers |

:::note
The RealTimeOutputSink (IDE streaming) is disabled by default due to compatibility issues with the Microsoft Testing Platform that can cause crashes in some IDEs. Set the `TUNIT_ENABLE_IDE_STREAMING=1` environment variable to opt in. See [Environment Variables](/docs/reference/environment-variables) for details.
:::

### Creating Custom Log Sinks

Implement the `ILogSink` interface to create a custom sink:

```csharp
using TUnit.Core;
using TUnit.Core.Logging;

public class FileLogSink : ILogSink, IAsyncDisposable
{
    private readonly StreamWriter _writer;

    public FileLogSink(string filePath)
    {
        _writer = new StreamWriter(filePath, append: true);
    }

    public bool IsEnabled(LogLevel level)
    {
        // Return false to skip processing for performance
        return level >= LogLevel.Information;
    }

    public void Log(LogLevel level, string message, Exception? exception, Context? context)
    {
        // Get test name from context if available
        var testName = context is TestContext tc
            ? tc.TestDetails.TestName
            : "Unknown";

        _writer.WriteLine($"[{DateTime.Now:HH:mm:ss}] [{level}] [{testName}] {message}");

        if (exception != null)
        {
            _writer.WriteLine(exception.ToString());
        }
    }

    public ValueTask LogAsync(LogLevel level, string message, Exception? exception, Context? context)
    {
        Log(level, message, exception, context);
        return ValueTask.CompletedTask;
    }

    public async ValueTask DisposeAsync()
    {
        await _writer.FlushAsync();
        await _writer.DisposeAsync();
    }
}
```

### Registering Custom Sinks

Register your sink in a `[Before(Assembly)]` hook so it's active before any tests run:

```csharp
public class TestSetup
{
    [Before(Assembly)]
    public static void SetupLogging()
    {
        // Register by instance (for sinks needing configuration)
        TUnitLoggerFactory.AddSink(new FileLogSink("test-output.log"));

        // Or register by type (for simple sinks)
        TUnitLoggerFactory.AddSink<DebugLogSink>();
    }
}
```

Sinks that implement `IDisposable` or `IAsyncDisposable` are automatically disposed when the test session ends.

### Context Information

The `context` parameter provides information about where the log originated:

```csharp
public void Log(LogLevel level, string message, Exception? exception, Context? context)
{
    switch (context)
    {
        case TestContext tc:
            // During test execution
            var testName = tc.TestDetails.TestName;
            var className = tc.TestDetails.ClassType.Name;
            break;

        case ClassHookContext chc:
            // During [Before(Class)] or [After(Class)] hooks
            var classType = chc.ClassType;
            break;

        case AssemblyHookContext ahc:
            // During [Before(Assembly)] or [After(Assembly)] hooks
            var assembly = ahc.Assembly;
            break;

        case null:
            // Outside test execution
            break;
    }
}
```

### Example: Seq/Serilog Integration

Here's an example sink that sends logs to Seq:

```csharp
public class SeqLogSink : ILogSink, IDisposable
{
    private readonly Serilog.ILogger _logger;

    public SeqLogSink(string seqUrl)
    {
        _logger = new LoggerConfiguration()
            .WriteTo.Seq(seqUrl)
            .CreateLogger();
    }

    public bool IsEnabled(LogLevel level) => true;

    public void Log(LogLevel level, string message, Exception? exception, Context? context)
    {
        var serilogLevel = level switch
        {
            LogLevel.Trace => Serilog.Events.LogEventLevel.Verbose,
            LogLevel.Debug => Serilog.Events.LogEventLevel.Debug,
            LogLevel.Information => Serilog.Events.LogEventLevel.Information,
            LogLevel.Warning => Serilog.Events.LogEventLevel.Warning,
            LogLevel.Error => Serilog.Events.LogEventLevel.Error,
            LogLevel.Critical => Serilog.Events.LogEventLevel.Fatal,
            _ => Serilog.Events.LogEventLevel.Information
        };

        var testName = context is TestContext tc ? tc.TestDetails.TestName : "Unknown";

        _logger
            .ForContext("TestName", testName)
            .Write(serilogLevel, exception, message);
    }

    public ValueTask LogAsync(LogLevel level, string message, Exception? exception, Context? context)
    {
        Log(level, message, exception, context);
        return ValueTask.CompletedTask;
    }

    public void Dispose()
    {
        (_logger as IDisposable)?.Dispose();
    }
}
```

## Log Levels

TUnit uses the same log level as provided to the Microsoft.Testing.Platform via command line:

```bash
dotnet run --log-level Warning
```

Available levels (from least to most severe):
- `Trace`
- `Debug`
- `Information` (default)
- `Warning`
- `Error`
- `Critical`

## Custom Loggers

You can also create custom loggers by inheriting from `DefaultLogger`:

```csharp
public class TestHeaderLogger : DefaultLogger
{
    private bool _hasOutputHeader;

    public TestHeaderLogger(Context context) : base(context) { }

    protected override string GenerateMessage(string message, Exception? exception, LogLevel logLevel)
    {
        var baseMessage = base.GenerateMessage(message, exception, logLevel);

        if (!_hasOutputHeader && Context is TestContext testContext)
        {
            _hasOutputHeader = true;
            var testId = $"{testContext.TestDetails.ClassType.Name}.{testContext.TestDetails.TestName}";
            return $"--- {testId} ---\n{baseMessage}";
        }

        return baseMessage;
    }
}
```

### Available Extension Points

- `Context` - Protected property to access the associated context
- `GenerateMessage(message, exception, logLevel)` - Override to customize message formatting
- `WriteToOutput(message, isError)` - Override to customize synchronous output
- `WriteToOutputAsync(message, isError)` - Override for asynchronous output

---

## ASP.NET Core Integration Testing


TUnit provides first-class support for ASP.NET Core integration testing through the `TUnit.AspNetCore` package. This package enables per-test isolation with shared infrastructure, making it easy to write fast, parallel integration tests.

## Installation

```bash
dotnet add package TUnit.AspNetCore
```

## Quick Start

### 1. Create a Test Factory

Create a factory that extends `TestWebApplicationFactory<TEntryPoint>`:

```csharp
using TUnit.AspNetCore;
using TUnit.Core.Interfaces;

public class WebApplicationFactory : TestWebApplicationFactory<Program>
{
    protected override void ConfigureWebHost(IWebHostBuilder builder)
    {
        // Configure shared services and settings
        builder.ConfigureAppConfiguration((context, config) =>
        {
            config.AddInMemoryCollection(new Dictionary<string, string?>
            {
                { "ConnectionStrings:Default", "..." }
            });
        });
    }
}
```

### 2. Create a Test Base Class

Create a base class that extends `WebApplicationTest<TFactory, TEntryPoint>`:

```csharp
using TUnit.AspNetCore;

public abstract class TestsBase : WebApplicationTest<WebApplicationFactory, Program>
{
}
```

### 3. Write Tests

```csharp
public class TodoApiTests : TestsBase
{
    [Test]
    public async Task GetTodos_ReturnsOk()
    {
        var client = Factory.CreateClient();

        var response = await client.GetAsync("/todos");

        await Assert.That(response.StatusCode).IsEqualTo(HttpStatusCode.OK);
    }
}
```

## Core Concepts

### Why Test Isolation Matters

:::warning Critical for Parallel Execution
TUnit runs tests in parallel by default. Without proper isolation, tests will interfere with each other, causing flaky failures that are difficult to debug.
:::

When tests share resources like database tables, message queues, or cache keys, you'll encounter problems:

| Shared Resource | What Goes Wrong |
|-----------------|-----------------|
| Database table | Test A inserts a record, Test B's `COUNT(*)` assertion fails |
| Message queue | Test A consumes Test B's messages |
| Cache key | Test A overwrites Test B's cached data |
| Redis key | Test A deletes keys that Test B is using |
| S3 bucket path | Test A's cleanup deletes Test B's files |

**The solution**: Give each test its own isolated resources using `GetIsolatedName()` and `GetIsolatedPrefix()`:

```csharp
protected override async Task SetupAsync()
{
    // Each test gets unique resources that no other test will touch
    var tableName = GetIsolatedName("todos");      // "Test_42_todos"
    var queueName = GetIsolatedName("events");     // "Test_42_events"
    var cachePrefix = GetIsolatedPrefix();         // "test_42_"

    await CreateTableAsync(tableName);
    await CreateQueueAsync(queueName);
}
```

This ensures:
- Tests can run in parallel without interference
- Test failures are deterministic and reproducible
- You can run the same test multiple times (with `[Repeat]`) safely

### WebApplicationTest Pattern

The `WebApplicationTest<TFactory, TEntryPoint>` base class provides:

- **Per-test isolation**: Each test gets its own delegating factory via `WithWebHostBuilder`
- **Shared infrastructure**: The global factory (containers, connections) is shared across tests
- **Parallel execution**: Tests run in parallel with complete isolation
- **Lifecycle hooks**: Async setup runs before sync configuration

### Lifecycle Order

Understanding the execution order is critical for writing correct tests. Here's the complete verified order:

```
┌─────────────────────────────────────────────────────────────────┐
│                    TEST LIFECYCLE                               │
├─────────────────────────────────────────────────────────────────┤
│  1. ConfigureTestOptions        Set test options (HTTP capture) │
│  2. SetupAsync                  Async setup (create tables)     │
│  ───────────────────────────────────────────────────────────    │
│  3. Factory.ConfigureWebHost    Base factory configuration      │
│  4. Factory.ConfigureStartup... Base factory startup config     │
│  ───────────────────────────────────────────────────────────    │
│  5. ConfigureTestConfiguration  Test config (overrides factory) │
│  6. ConfigureWebHostBuilder     Escape hatch (low-level access) │
│  7. ConfigureTestServices       Test services (overrides)       │
│  ───────────────────────────────────────────────────────────    │
│  8. Application Startup         Server starts                   │
│  ───────────────────────────────────────────────────────────    │
│  9. Test Method Executes        Your test code runs             │
│ 10. Factory Disposed            Cleanup                         │
└─────────────────────────────────────────────────────────────────┘
```

**Key Points:**

| Hook | Scope | Purpose |
|------|-------|---------|
| `ConfigureTestOptions` | Per-test | Enable features like HTTP capture |
| `SetupAsync` | Per-test | Async operations before config (create DB tables) |
| `Factory.ConfigureWebHost` | Shared | Base configuration for all tests |
| `Factory.ConfigureStartupConfiguration` | Shared | Base startup configuration |
| `ConfigureTestConfiguration` | Per-test | Override factory configuration |
| `ConfigureWebHostBuilder` | Per-test | Low-level escape hatch |
| `ConfigureTestServices` | Per-test | Override factory services |

:::tip Tests Can Override Factory
The order is designed so that **tests can override factory defaults**. Factory configuration runs first (steps 3-4), then test-specific configuration (steps 5-7) can override those values.
:::

:::warning Factory Methods Run Once
`Factory.ConfigureWebHost` and `Factory.ConfigureStartupConfiguration` run **once per test session** (when the factory is first used), not per-test. If different test classes need fundamentally different factory configurations, use different factory classes.
:::

## Override Methods

### ConfigureTestOptions

Use to configure test-level options before anything else runs:

```csharp
protected override void ConfigureTestOptions(WebApplicationTestOptions options)
{
    options.EnableHttpExchangeCapture = true;  // Capture HTTP requests/responses
}
```

This runs **first** in the lifecycle, before `SetupAsync`. Use it to enable features that affect how the test infrastructure is set up.

### SetupAsync

Use for async operations that must complete before the factory is created:

```csharp
public class TodoTests : TestsBase
{
    protected string TableName { get; private set; } = null!;

    protected override async Task SetupAsync()
    {
        TableName = GetIsolatedName("todos");
        await CreateTableAsync(TableName);
    }

    protected override void ConfigureTestConfiguration(IConfigurationBuilder config)
    {
        // TableName is already set from SetupAsync
        config.AddInMemoryCollection(new Dictionary<string, string?>
        {
            { "Database:TableName", TableName }
        });
    }
}
```

### ConfigureTestServices

Use for DI configuration:

```csharp
protected override void ConfigureTestServices(IServiceCollection services)
{
    // Replace a service with a mock
    services.ReplaceService<IEmailService>(new FakeEmailService());

    // Add test-specific services
    services.AddSingleton<ITestHelper, TestHelper>();
}
```

### ConfigureTestConfiguration

Use for app configuration:

```csharp
protected override void ConfigureTestConfiguration(IConfigurationBuilder config)
{
    config.AddInMemoryCollection(new Dictionary<string, string?>
    {
        { "Feature:Enabled", "true" },
        { "Api:BaseUrl", "https://test.example.com" }
    });
}
```

### ConfigureWebHostBuilder

Escape hatch for advanced scenarios:

```csharp
protected override void ConfigureWebHostBuilder(IWebHostBuilder builder)
{
    builder.UseEnvironment("Staging");
    builder.UseSetting("MyFeature:Enabled", "true");
    builder.ConfigureKestrel(options => options.AddServerHeader = false);
}
```

## Test Isolation Helpers

:::tip Available on All Tests
The isolation helpers (`UniqueId`, `GetIsolatedName`, `GetIsolatedPrefix`) are also available on `TestContext.Current!.Isolation` for any test — not just ASP.NET Core tests. Use `TestContext.Current!.Isolation.GetIsolatedName("resource")` when you don't inherit from `WebApplicationTest`. Both share the same counter, so IDs are unique across all test types.
:::

### GetIsolatedName

Creates a unique name for resources like database tables:

```csharp
// In a test with UniqueId = 42:
var tableName = GetIsolatedName("todos");  // Returns "Test_42_todos"
var topicName = GetIsolatedName("orders"); // Returns "Test_42_orders"
```

### GetIsolatedPrefix

Creates a unique prefix for key-based resources:

```csharp
// In a test with UniqueId = 42:
var prefix = GetIsolatedPrefix();       // Returns "test_42_"
var dotPrefix = GetIsolatedPrefix("."); // Returns "test.42."
```

## Container Integration

### With Testcontainers

```csharp
public class InMemoryDatabase : IAsyncInitializer, IAsyncDisposable
{
    public PostgreSqlContainer Container { get; } = new PostgreSqlBuilder()
        .WithImage("postgres:16-alpine")
        .Build();

    public async Task InitializeAsync() => await Container.StartAsync();
    public async ValueTask DisposeAsync() => await Container.DisposeAsync();
}

public class WebApplicationFactory : TestWebApplicationFactory<Program>
{
    [ClassDataSource<InMemoryDatabase>(Shared = SharedType.PerTestSession)]
    public InMemoryDatabase Database { get; init; } = null!;

    protected override void ConfigureWebHost(IWebHostBuilder builder)
    {
        builder.ConfigureAppConfiguration((_, config) =>
        {
            config.AddInMemoryCollection(new Dictionary<string, string?>
            {
                { "Database:ConnectionString", Database.Container.GetConnectionString() }
            });
        });
    }
}
```

### Per-Test Table Isolation

```csharp
public abstract class TodoTestBase : TestsBase
{
    [ClassDataSource<InMemoryDatabase>(Shared = SharedType.PerTestSession)]
    public InMemoryDatabase Database { get; init; } = null!;

    protected string TableName { get; private set; } = null!;

    protected override async Task SetupAsync()
    {
        TableName = GetIsolatedName("todos");
        await CreateTableAsync(TableName);
    }

    protected override void ConfigureTestConfiguration(IConfigurationBuilder config)
    {
        config.AddInMemoryCollection(new Dictionary<string, string?>
        {
            { "Database:TableName", TableName }
        });
    }

    [After(HookType.Test)]
    public async Task CleanupTable()
    {
        await DropTableAsync(TableName);
    }

    private async Task CreateTableAsync(string name) { /* ... */ }
    private async Task DropTableAsync(string name) { /* ... */ }
}
```

## HTTP Exchange Capture

Capture and inspect HTTP requests/responses for assertions:

```csharp
public class CaptureTests : TestsBase
{
    protected override WebApplicationTestOptions Options => new()
    {
        EnableHttpExchangeCapture = true
    };

    [Test]
    public async Task RequestIsCaptured()
    {
        var client = Factory.CreateClient();

        await client.GetAsync("/api/todos");

        await Assert.That(HttpCapture).IsNotNull();
        await Assert.That(HttpCapture!.Last!.Response.StatusCode)
            .IsEqualTo(HttpStatusCode.OK);
    }
}
```

### Capture Options

```csharp
protected override WebApplicationTestOptions Options => new()
{
    EnableHttpExchangeCapture = true,
    CaptureRequestBody = true,
    CaptureResponseBody = true,
    MaxBodySize = 1024 * 1024  // 1MB limit
};
```

### Inspecting Captured Exchanges

```csharp
// Get the last exchange
var last = HttpCapture!.Last;

// Get all exchanges
var all = HttpCapture.All;

// Inspect request
await Assert.That(last!.Request.Method).IsEqualTo("POST");
await Assert.That(last.Request.Path).IsEqualTo("/api/todos");
await Assert.That(last.Request.Body).Contains("\"title\"");

// Inspect response
await Assert.That(last.Response.StatusCode).IsEqualTo(HttpStatusCode.Created);
await Assert.That(last.Response.Body).Contains("\"id\"");
```

## TUnit Logging Integration

Server logs are automatically correlated with TUnit test output:

```csharp
protected override WebApplicationTestOptions Options => new()
{
    AddTUnitLogging = true  // Default is true
};
```

Logs from your ASP.NET Core app will appear in the test output, making debugging easier.

## Best Practices

### 1. Always Isolate Shared Resources

:::tip Golden Rule
If a resource is shared (database, queue, cache), each test must use its own isolated instance of that resource.
:::

```csharp
// ❌ BAD: All tests share the same table - will cause flaky failures
protected override void ConfigureTestConfiguration(IConfigurationBuilder config)
{
    config.AddInMemoryCollection(new Dictionary<string, string?>
    {
        { "Database:TableName", "todos" }  // Shared = flaky!
    });
}

// ✅ GOOD: Each test gets its own table
protected override async Task SetupAsync()
{
    TableName = GetIsolatedName("todos");  // "Test_42_todos"
    await CreateTableAsync(TableName);
}

protected override void ConfigureTestConfiguration(IConfigurationBuilder config)
{
    config.AddInMemoryCollection(new Dictionary<string, string?>
    {
        { "Database:TableName", TableName }  // Isolated = reliable!
    });
}
```

Common resources that need isolation:
- **Database tables**: Use `GetIsolatedName("tablename")`
- **Message queues/topics**: Use `GetIsolatedName("queue")`
- **Cache keys**: Use `GetIsolatedPrefix()` as a key prefix
- **Blob storage paths**: Use `GetIsolatedPrefix()` as a path prefix
- **Redis keys**: Use `GetIsolatedPrefix()` as a key prefix

### 2. Use Base Classes for Common Setup

```csharp
// Shared base for all tests
public abstract class TestsBase : WebApplicationTest<WebApplicationFactory, Program>
{
}

// Specialized base for database tests
public abstract class DatabaseTestBase : TestsBase
{
    protected override async Task SetupAsync()
    {
        await CreateSchemaAsync();
    }
}

// Actual tests
public class UserTests : DatabaseTestBase
{
    [Test]
    public async Task CreateUser_Works() { /* ... */ }
}
```

### 3. Clean Up Resources

```csharp
[After(HookType.Test)]
public async Task Cleanup()
{
    await CleanupTestDataAsync();
}
```

### 4. Inject Containers at Factory Level

```csharp
public class WebApplicationFactory : TestWebApplicationFactory<Program>
{
    // Shared across all tests
    [ClassDataSource<PostgresContainer>(Shared = SharedType.PerTestSession)]
    public PostgresContainer Postgres { get; init; } = null!;

    [ClassDataSource<RedisContainer>(Shared = SharedType.PerTestSession)]
    public RedisContainer Redis { get; init; } = null!;
}
```

## Complete Example

```csharp
// Container wrapper
public class InMemoryPostgres : IAsyncInitializer, IAsyncDisposable
{
    public PostgreSqlContainer Container { get; } = new PostgreSqlBuilder().Build();
    public async Task InitializeAsync() => await Container.StartAsync();
    public async ValueTask DisposeAsync() => await Container.DisposeAsync();
}

// Factory with shared container
public class WebApplicationFactory : TestWebApplicationFactory<Program>
{
    [ClassDataSource<InMemoryPostgres>(Shared = SharedType.PerTestSession)]
    public InMemoryPostgres Postgres { get; init; } = null!;

    protected override void ConfigureWebHost(IWebHostBuilder builder)
    {
        builder.ConfigureAppConfiguration((_, config) =>
        {
            config.AddInMemoryCollection(new Dictionary<string, string?>
            {
                { "Database:ConnectionString", Postgres.Container.GetConnectionString() }
            });
        });
    }
}

// Base class
public abstract class TestsBase : WebApplicationTest<WebApplicationFactory, Program>
{
}

// Test base with table isolation
public abstract class TodoTestBase : TestsBase
{
    [ClassDataSource<InMemoryPostgres>(Shared = SharedType.PerTestSession)]
    public InMemoryPostgres Postgres { get; init; } = null!;

    protected string TableName { get; private set; } = null!;

    protected override async Task SetupAsync()
    {
        TableName = GetIsolatedName("todos");
        await CreateTableAsync();
    }

    protected override void ConfigureTestConfiguration(IConfigurationBuilder config)
    {
        config.AddInMemoryCollection(new Dictionary<string, string?>
        {
            { "Database:TableName", TableName }
        });
    }

    [After(HookType.Test)]
    public async Task Cleanup() => await DropTableAsync();

    private async Task CreateTableAsync() { /* ... */ }
    private async Task DropTableAsync() { /* ... */ }
}

// Actual tests
public class TodoApiTests : TodoTestBase
{
    [Test]
    public async Task CreateTodo_ReturnsCreated()
    {
        var client = Factory.CreateClient();

        var response = await client.PostAsJsonAsync("/todos", new { Title = "Test" });

        await Assert.That(response.StatusCode).IsEqualTo(HttpStatusCode.Created);
    }

    [Test, Repeat(5)]
    public async Task ParallelTests_AreIsolated()
    {
        var client = Factory.CreateClient();

        // Each repetition has its own table
        await client.PostAsJsonAsync("/todos", new { Title = "Isolated" });

        var todos = await client.GetFromJsonAsync<List<Todo>>("/todos");
        await Assert.That(todos!.Count).IsEqualTo(1);  // Always 1, not 5
    }
}
```

## Migrating from Basic WebApplicationFactory

If you're currently using `WebApplicationFactory<TEntryPoint>` directly:

**Before:**
```csharp
public class MyTests
{
    [ClassDataSource<WebAppFactory>(Shared = SharedType.PerTestSession)]
    public required WebAppFactory Factory { get; init; }

    [Test]
    public async Task Test1()
    {
        var client = Factory.CreateClient();
        // Tests share state - not isolated!
    }
}
```

**After:**
```csharp
public class MyTests : WebApplicationTest<WebAppFactory, Program>
{
    [Test]
    public async Task Test1()
    {
        var client = Factory.CreateClient();  // Isolated per test!
    }
}
```

The key benefits:
- Each test gets its own isolated factory via `WithWebHostBuilder`
- `SetupAsync` enables async initialization before factory creation
- `ConfigureTestServices` and `ConfigureTestConfiguration` are per-test
- Built-in isolation helpers (`GetIsolatedName`, `GetIsolatedPrefix`)

## FAQ & Troubleshooting

### Why does my test configuration not override the factory?

**Problem:** You set a value in `ConfigureTestConfiguration` but the factory's value is still used.

**Solution:** Make sure you're using the same configuration key. The test configuration runs **after** the factory configuration (step 5 vs steps 3-4), so it should override. Check that:

1. You're using `AddInMemoryCollection` which adds to the config sources
2. The configuration key path is exactly the same
3. You're not accidentally reading from a different source (e.g., `appsettings.json`)

```csharp
// Factory sets default
protected override void ConfigureWebHost(IWebHostBuilder builder)
{
    builder.ConfigureAppConfiguration((_, config) =>
    {
        config.AddInMemoryCollection(new Dictionary<string, string?>
        {
            { "Database:ConnectionString", "factory-default" }
        });
    });
}

// Test overrides - this WILL work because it runs after
protected override void ConfigureTestConfiguration(IConfigurationBuilder config)
{
    config.AddInMemoryCollection(new Dictionary<string, string?>
    {
        { "Database:ConnectionString", "test-specific-value" }  // This wins!
    });
}
```

### Why can't I access SetupAsync results in ConfigureTestOptions?

**Problem:** You want to use a value from `SetupAsync` in `ConfigureTestOptions`, but `ConfigureTestOptions` runs first.

**Solution:** This is by design. `ConfigureTestOptions` runs before `SetupAsync` because test options affect how the infrastructure is set up. If you need async setup before options, consider:

1. Moving the logic to a `[Before(HookType.Test)]` method that runs even earlier
2. Using lazy initialization in `SetupAsync`

### Why are my parallel tests interfering with each other?

**Problem:** Tests that pass individually fail when run in parallel.

**Solution:** You're sharing resources without isolation. Use `GetIsolatedName()` and `GetIsolatedPrefix()`:

```csharp
// BAD: All parallel tests share the same table
var tableName = "todos";

// GOOD: Each test gets its own table
var tableName = GetIsolatedName("todos");  // "Test_42_todos", "Test_43_todos", etc.
```

### Can I have different factory configurations for different test classes?

**Problem:** Test class A needs PostgreSQL, test class B needs SQLite.

**Solution:** Create different factory classes:

```csharp
public class PostgresFactory : TestWebApplicationFactory<Program>
{
    protected override void ConfigureWebHost(IWebHostBuilder builder)
    {
        // PostgreSQL configuration
    }
}

public class SqliteFactory : TestWebApplicationFactory<Program>
{
    protected override void ConfigureWebHost(IWebHostBuilder builder)
    {
        // SQLite configuration
    }
}

public class PostgresTests : WebApplicationTest<PostgresFactory, Program> { }
public class SqliteTests : WebApplicationTest<SqliteFactory, Program> { }
```

### What's the difference between Factory and GlobalFactory?

| Property | Type | Scope | Use Case |
|----------|------|-------|----------|
| `Factory` | `WebApplicationFactory<TEntryPoint>` | Per-test | Creating HTTP clients, accessing services |
| `GlobalFactory` | `TFactory` (your custom type) | Shared | Accessing custom factory properties (containers, etc.) |

```csharp
public class MyTests : WebApplicationTest<WebApplicationFactory, Program>
{
    [Test]
    public async Task Example()
    {
        // Use Factory for per-test operations
        var client = Factory.CreateClient();
        var services = Factory.Services;

        // Use GlobalFactory to access custom properties
        var connectionString = GlobalFactory.Database.Container.GetConnectionString();
    }
}
```

### Why does my service registration not work?

**Problem:** You register a service in `ConfigureTestServices` but the old implementation is still used.

**Solution:** Use `ReplaceService` instead of `AddSingleton`:

```csharp
protected override void ConfigureTestServices(IServiceCollection services)
{
    // BAD: Adds a second registration, original may still be resolved
    services.AddSingleton<IEmailService, FakeEmailService>();

    // GOOD: Removes existing registration and adds new one
    services.ReplaceService<IEmailService>(new FakeEmailService());
}
```

### How do I debug lifecycle issues?

Create a test that logs all lifecycle events:

```csharp
public class LifecycleDebugTest : WebApplicationTest<WebApplicationFactory, Program>
{
    protected override void ConfigureTestOptions(WebApplicationTestOptions options)
    {
        Console.WriteLine("1. ConfigureTestOptions");
    }

    protected override async Task SetupAsync()
    {
        Console.WriteLine("2. SetupAsync");
        await base.SetupAsync();
    }

    protected override void ConfigureTestConfiguration(IConfigurationBuilder config)
    {
        Console.WriteLine("5. ConfigureTestConfiguration");
    }

    protected override void ConfigureWebHostBuilder(IWebHostBuilder builder)
    {
        Console.WriteLine("6. ConfigureWebHostBuilder");
    }

    protected override void ConfigureTestServices(IServiceCollection services)
    {
        Console.WriteLine("7. ConfigureTestServices");
    }

    [Test]
    public async Task Debug_Lifecycle()
    {
        Console.WriteLine("9. Test executing");
        _ = Factory.CreateClient();
        await Assert.That(true).IsTrue();
    }
}
```

### Can I run async code in ConfigureTestServices?

**Problem:** ASP.NET Core's configuration methods are synchronous, but you need async initialization.

**Solution:** Do async work in `SetupAsync`, then use the results in sync methods:

```csharp
public class MyTest : TestsBase
{
    private string _authToken = null!;

    protected override async Task SetupAsync()
    {
        // Async work here
        _authToken = await GetAuthTokenAsync();
    }

    protected override void ConfigureTestServices(IServiceCollection services)
    {
        // Use the result from SetupAsync
        services.AddSingleton(new AuthConfig { Token = _authToken });
    }
}
```

### Why does my Program.cs run before ConfigureWebHost's ConfigureAppConfiguration?

**Problem:** You set configuration values in `ConfigureWebHost` using `ConfigureAppConfiguration`, but your app's `Program.cs` doesn't see them during startup. Your breakpoint in Program.cs hits **before** the `ConfigureAppConfiguration` callback.

```csharp
// Factory - this approach has a timing issue!
protected override void ConfigureWebHost(IWebHostBuilder builder)
{
    Console.WriteLine("ConfigureWebHost called");  // This runs first...

    builder.ConfigureAppConfiguration((_, config) =>
    {
        Console.WriteLine("ConfigureAppConfiguration callback");  // ...but THIS runs AFTER Program.cs!
        config.AddInMemoryCollection(new Dictionary<string, string?>
        {
            { "SomeKey", "SomeValue" }
        });
    });
}

// Program.cs - this runs BEFORE ConfigureAppConfiguration callback!
var builder = WebApplication.CreateBuilder(args);
if (builder.Configuration["SomeKey"] != "SomeValue")
{
    throw new InvalidOperationException("SomeKey not found!");  // This throws!
}
```

**Root Cause:** This is **expected behavior** of ASP.NET Core's `WebApplicationFactory`. The `ConfigureAppConfiguration` callbacks registered in `ConfigureWebHost` are **deferred** and run **after** your app's `Program.cs` code, not before.

**Solution:** Use `ConfigureStartupConfiguration` instead, which uses `builder.UseSetting()` to apply configuration **before** your app's `Program.cs` runs:

```csharp
public class WebApplicationFactory : TestWebApplicationFactory<Program>
{
    /// <summary>
    /// Use ConfigureStartupConfiguration for configuration your Program.cs needs during startup.
    /// This runs BEFORE Program.cs.
    /// </summary>
    protected override void ConfigureStartupConfiguration(IConfigurationBuilder configurationBuilder)
    {
        configurationBuilder.AddInMemoryCollection(new Dictionary<string, string?>
        {
            { "SomeKey", "SomeValue" },  // Available when Program.cs runs!
            { "Database:ConnectionString", "..." }
        });
    }

    /// <summary>
    /// ConfigureWebHost can still be used for other customizations,
    /// but NOT for configuration that Program.cs needs during startup.
    /// </summary>
    protected override void ConfigureWebHost(IWebHostBuilder builder)
    {
        // Safe to use ConfigureAppConfiguration for config that's only
        // needed AFTER the app has started (e.g., in controllers, services)
    }
}
```

**When to use each method:**

| Method | Runs When | Use For |
|--------|-----------|---------|
| `ConfigureStartupConfiguration` | Before Program.cs | Configuration needed during app startup |
| `ConfigureWebHost` + `ConfigureAppConfiguration` | After Program.cs | Configuration only needed after app starts |

## API Reference

### WebApplicationTest Properties

| Property | Type | Description |
|----------|------|-------------|
| `UniqueId` | `int` | Unique identifier for this test instance |
| `GlobalFactory` | `TFactory` | Shared factory (your custom type) |
| `Factory` | `WebApplicationFactory<TEntryPoint>` | Per-test isolated factory |
| `Services` | `IServiceProvider` | DI container from per-test factory |
| `HttpCapture` | `HttpExchangeCapture?` | Captured HTTP exchanges (if enabled) |

### WebApplicationTest Methods

| Method | Description |
|--------|-------------|
| `GetIsolatedName(string baseName)` | Returns `"Test_{UniqueId}_{baseName}"` |
| `GetIsolatedPrefix(string separator = "_")` | Returns `"test{separator}{UniqueId}{separator}"` |

### WebApplicationTestOptions

| Property | Type | Default | Description |
|----------|------|---------|-------------|
| `EnableHttpExchangeCapture` | `bool` | `false` | Capture HTTP requests/responses |

### Service Collection Extensions

| Method | Description |
|--------|-------------|
| `ReplaceService<T>(instance)` | Replace service with instance |
| `ReplaceService<T>(factory)` | Replace service with factory |
| `ReplaceService<TService, TImpl>()` | Replace service with implementation |
| `RemoveService<T>()` | Remove service registration |
| `AddTUnitLogging(context)` | Add TUnit logging provider |

---

## Complex Test Infrastructure Orchestration


TUnit provides a property injection system that can help orchestrate complex test infrastructure setups. This page demonstrates how TUnit handles test setups that typically require manual coordination in traditional testing approaches.

## Real-World Example: Full Stack Integration Testing

The `TUnit.Example.Asp.Net.TestProject` showcases how to spin up an entire test environment including Docker networks, Kafka, PostgreSQL, Redis, and even a Kafka UI - all with minimal code and automatic lifecycle management.

## Property Injection Chains

TUnit allows properties to be injected into other properties, creating dependency chains that are resolved and initialized in the correct order.

### Example: Docker Network Orchestration

```csharp
// Step 1: Create a shared Docker network
public class DockerNetwork : IAsyncInitializer, IAsyncDisposable
{
    public INetwork Instance { get; } = new NetworkBuilder()
        .WithName($"tunit-{Guid.NewGuid():N}")
        .Build();

    public async Task InitializeAsync() => await Instance.CreateAsync();
    public async ValueTask DisposeAsync() => await Instance.DisposeAsync();
}
```

### Example: Kafka Container with Network Injection

```csharp
// Step 2: Kafka needs the Docker network
public class InMemoryKafka : IAsyncInitializer, IAsyncDisposable
{
    // This property is automatically injected BEFORE InitializeAsync runs!
    [ClassDataSource<DockerNetwork>(Shared = SharedType.PerTestSession)]
    public required DockerNetwork DockerNetwork { get; init; }

    public KafkaContainer Container => field ??= new KafkaBuilder()
        .WithNetwork(DockerNetwork.Instance)  // Uses the injected network
        .Build();

    public async Task InitializeAsync() => await Container.StartAsync();
    public async ValueTask DisposeAsync() => await Container.DisposeAsync();
}
```

### Example: Kafka UI Depending on Kafka Container

```csharp
// Step 3: Kafka UI needs both the network AND the Kafka container
public class KafkaUI : IAsyncInitializer, IAsyncDisposable
{
    // Both dependencies are injected and initialized automatically!
    [ClassDataSource<DockerNetwork>(Shared = SharedType.PerTestSession)]
    public required DockerNetwork DockerNetwork { get; init; }

    [ClassDataSource<InMemoryKafka>(Shared = SharedType.PerTestSession)]
    public required InMemoryKafka Kafka { get; init; }

    public IContainer Container => field ??= new ContainerBuilder()
        .WithNetwork(DockerNetwork.Instance)
        .WithImage("provectuslabs/kafka-ui:latest")
        .WithPortBinding(8080, 8080)
        .WithEnvironment(new Dictionary<string, string>
        {
            // Can reference the Kafka container that was injected!
            ["KAFKA_CLUSTERS_0_NAME"] = "tunit_tests",
            ["KAFKA_CLUSTERS_0_BOOTSTRAPSERVERS"] = $"{Kafka.Container.Name}:9093",
        })
        .Build();

    public async Task InitializeAsync() => await Container.StartAsync();
    public async ValueTask DisposeAsync() => await Container.DisposeAsync();
}
```

## Complete Integration: Web Application with Multiple Dependencies

Here's how everything comes together in a WebApplicationFactory that needs multiple infrastructure components:

```csharp
public class WebApplicationFactory : WebApplicationFactory<Program>, IAsyncInitializer
{
    // All these dependencies are automatically initialized in dependency order!
    [ClassDataSource<InMemoryKafka>(Shared = SharedType.PerTestSession)]
    public required InMemoryKafka Kafka { get; init; }

    [ClassDataSource<KafkaUI>(Shared = SharedType.PerTestSession)]
    public required KafkaUI KafkaUI { get; init; }

    [ClassDataSource<InMemoryRedis>(Shared = SharedType.PerTestSession)]
    public required InMemoryRedis Redis { get; init; }

    [ClassDataSource<InMemoryPostgreSqlDatabase>(Shared = SharedType.PerTestSession)]
    public required InMemoryPostgreSqlDatabase PostgreSql { get; init; }

    public Task InitializeAsync()
    {
        _ = Server;  // Force initialization
        return Task.CompletedTask;
    }

    protected override void ConfigureWebHost(IWebHostBuilder builder)
    {
        builder.ConfigureAppConfiguration((context, configBuilder) =>
        {
            // All containers are already running when this executes!
            configBuilder.AddInMemoryCollection(new Dictionary<string, string?>
            {
                { "Redis:ConnectionString", Redis.Container.GetConnectionString() },
                { "PostgreSql:ConnectionString", PostgreSql.Container.GetConnectionString() },
                { "Kafka:ConnectionString", Kafka.Container.GetBootstrapAddress() },
            });
        });
    }
}
```

## Writing Clean Tests

Your actual test code remains clean and focused:

```csharp
public class Tests : TestsBase
{
    [ClassDataSource<WebApplicationFactory>(Shared = SharedType.PerTestSession)]
    public required WebApplicationFactory WebApplicationFactory { get; init; }

    [Test]
    public async Task Test()
    {
        // Everything is already initialized and running!
        var client = WebApplicationFactory.CreateClient();
        var response = await client.GetAsync("/ping");
        var content = await response.Content.ReadAsStringAsync();

        await Assert.That(content).IsEqualTo("Hello, World!");
    }
}
```

## Key Benefits

### 1. **Automatic Dependency Resolution**
TUnit determines the initialization order:
- Docker Network → Kafka Container → Kafka UI
- Docker Network → PostgreSQL Container
- Docker Network → Redis Container
- All containers → WebApplicationFactory

### 2. **Reduced Boilerplate**
Traditional approaches often require:
- Manual initialization order management
- Complex setup/teardown methods
- Careful coordination of shared resources
- Manual dependency injection wiring

### 3. **Resource Sharing**
Using `SharedType.PerTestSession` helps:
- Expensive resources (containers) are created once
- They're shared across all tests in the session
- Automatic cleanup when tests complete
- No resource leaks or orphaned containers

### 4. **Clean Separation of Concerns**
Each class has a single responsibility:
- `DockerNetwork` - manages the network
- `InMemoryKafka` - manages Kafka container
- `KafkaUI` - manages the UI container
- `WebApplicationFactory` - orchestrates the web app

## Advanced Scenarios

### Database Migrations
```csharp
public class InMemoryPostgreSqlDatabase : IAsyncInitializer, IAsyncDisposable
{
    [ClassDataSource<DockerNetwork>(Shared = SharedType.PerTestSession)]
    public required DockerNetwork DockerNetwork { get; init; }

    public PostgreSqlContainer Container => field ??= new PostgreSqlBuilder()
        .WithUsername("User")
        .WithPassword("Password")
        .WithDatabase("TestDatabase")
        .WithNetwork(DockerNetwork.Instance)
        .Build();

    public async Task InitializeAsync()
    {
        await Container.StartAsync();

        // Run migrations after container starts
        using var connection = new NpgsqlConnection(Container.GetConnectionString());
        await connection.OpenAsync();
        // Run your migration logic here
    }

    public async ValueTask DisposeAsync() => await Container.DisposeAsync();
}
```

## Comparison with Other Frameworks

### Without TUnit (Traditional Approach)
```csharp
public class TestFixture : IAsyncLifetime
{
    private INetwork? _network;
    private KafkaContainer? _kafka;
    private IContainer? _kafkaUi;

    public async Task InitializeAsync()
    {
        // Manual orchestration required
        _network = new NetworkBuilder().Build();
        await _network.CreateAsync();

        _kafka = new KafkaBuilder()
            .WithNetwork(_network)
            .Build();
        await _kafka.StartAsync();

        _kafkaUi = new ContainerBuilder()
            .WithNetwork(_network)
            .WithEnvironment("KAFKA_CLUSTERS_0_BOOTSTRAPSERVERS",
                $"{_kafka.Name}:9093")  // Manual wiring
            .Build();
        await _kafkaUi.StartAsync();
    }

    public async Task DisposeAsync()
    {
        // Manual cleanup in reverse order
        if (_kafkaUi != null) await _kafkaUi.DisposeAsync();
        if (_kafka != null) await _kafka.DisposeAsync();
        if (_network != null) await _network.DisposeAsync();
    }
}
```

### With TUnit
Declare your dependencies with attributes and TUnit manages the orchestration.

## Best Practices

1. **Use `SharedType.PerTestSession`** for expensive resources like containers
2. **Implement `IAsyncInitializer`** for async initialization logic
3. **Implement `IAsyncDisposable`** for proper cleanup
4. **Use `required` properties** to ensure compile-time safety
5. **Keep classes focused** - one responsibility per class
6. **Use TUnit's orchestration** - avoid manual dependency management

## Multiple Test Projects and SharedType.PerTestSession
In larger solutions, it is often beneficial to structure tests into different test projects, sometimes alongside a common test library for shared  common code like infrastructure orchestration. Test runners like `dotnet test`, typically launch separate .NET processes for each test project. And because each test project runs as its own process, they cant share the dependencies.

This means that classes configured with a `SharedType.PerTestSession` lifetime will be **initialized once per test project**, rather than once for the entire test session.

If you intend for services or data to be shared across those separate test projects, you will need to consolidate the execution using a Test Orchestrator approach to load all projects into a single process and run `dotnet test` directly on that. 

## Summary

TUnit's property injection system helps simplify complex test infrastructure setup through a declarative, type-safe approach. By handling initialization order, lifecycle management, and dependency injection, TUnit allows you to focus on writing tests that validate your application's behavior.

The framework manages the orchestration that would otherwise require manual coordination, helping to create cleaner, more maintainable test code with less boilerplate.

---

## File based C# application


Starting with dotnet 10 (preview 4), you can use the new file-based C# application feature to run tests in a more straightforward way.

## Using File-Based C# Application with TUnit

To use TUnit with a file-based C# application, you can follow these steps:

1.  **Create a new C# file**: Create a new file with a `.cs` extension, for example, `Program.cs`.
2.  **Add TUnit to your project**: You can add TUnit as a package reference in your file. At the top of your `Program.cs`, add the following line:

    ```csharp
    #:package TUnit@0.*
    ```

    -   Alternatively, you can specify a specific version:

        ```csharp
        #:package TUnit@0.25.0
        ```

    -   You can also use msbuild props files to include TUnit. By creating a `Directory.build.props` file in the same directory as the csharp file.

        ```xml
        <Project>
            <ItemGroup>
                <PackageReference Include="TUnit" Version="*" />
            </ItemGroup>
        </Project>
        ```

3.  **Write your tests**: You can write your tests in the same way you would in a regular C# project. For example:

        ```csharp
        #:package TUnit@0.*

        using TUnit;
        public class Tests
        {
            [Test]
            public void Basic()
            {
                Console.WriteLine("This is a basic test");
            }

            [Test]
            [Arguments(1, 2, 3)]
            [Arguments(2, 3, 5)]
            public async Task DataDrivenArguments(int a, int b, int c)
            {
                Console.WriteLine("This one can accept arguments from an attribute");
                var result = a + b;
                await Assert.That(result).IsEqualTo(c);
            }

        }

        ```

4.  **Run your tests**: You can run your tests by executing the script using `dotnet run`. The results will be printed to the console.
    To run the script, you can use the following command

    ```powershell
    dotnet run Program.cs
    ```

If you need to convert the file based application to a regular C# project, you can run the following command:

    ```powershell
    dotnet project convert Program.cs
    ```

## Using msbuild props with File-Based C# Application

Single file csharp applications can also be used with msbuild props files. You can create a `*.props` file and the dotnet sdk will automatically include it when running the file-based application.

1. Create a file named `Directory.build.props` with the following content:

    ```xml
    <Project>
        <ItemGroup>
        <PackageReference Include="TUnit" Version="*" />
        </ItemGroup>
    </Project>
    ```

2. Create a csharp file with the following content:

    ```csharp
    using TUnit;
    public class Tests
    {
        [Test]
        public void Basic()
        {
            Console.WriteLine("This is a basic test");
        }

        [Test]
        [Arguments(1, 2, 3)]
        [Arguments(2, 3, 5)]
        public async Task DataDrivenArguments(int a, int b, int c)
        {
            Console.WriteLine("This one can accept arguments from an attribute");
            var result = a + b;
            await Assert.That(result).IsEqualTo(c);
        }
    }
    ```

3. Run the script using the following command:

    ```powershell
    dotnet run file.cs
    ```

This will automatically include the `Directory.build.props` file as long as it is in the same directory as the csharp file, and you will be able to run your tests with TUnit.

---

## FsCheck (Property-Based Testing)


[FsCheck](https://fscheck.github.io/FsCheck/) is a property-based testing framework for .NET. Property-based testing generates random test data to verify that properties (invariants) hold true across many inputs.

There is a NuGet package to help integrate FsCheck with TUnit: `TUnit.FsCheck`

## Installation

```bash
dotnet add package TUnit.FsCheck
```

## Basic Usage

Use the `[Test, FsCheckProperty]` attributes together to create a property-based test:

```csharp
using TUnit.FsCheck;

public class PropertyTests
{
    [Test, FsCheckProperty]
    public bool ReverseReverseIsOriginal(int[] array)
    {
        var reversed = array.Reverse().Reverse().ToArray();
        return array.SequenceEqual(reversed);
    }

    [Test, FsCheckProperty]
    public bool AdditionIsCommutative(int a, int b)
    {
        return a + b == b + a;
    }
}
```

## Return Types

Property tests can return:

- **`bool`** - The test passes if the property returns `true`
- **`void`** - The test passes if no exception is thrown
- **`Task` / `ValueTask`** - For async properties
- **`Property`** - For advanced FsCheck properties with custom generators

```csharp
// Boolean property
[Test, FsCheckProperty]
public bool StringConcatLength(string a, string b)
{
    if (a == null || b == null) return true; // Skip null cases
    return (a + b).Length == a.Length + b.Length;
}

// Void property (throws on failure)
[Test, FsCheckProperty]
public void MultiplicationByZeroIsZero(int value)
{
    if (value * 0 != 0)
        throw new InvalidOperationException("Expected zero");
}

// Async property
[Test, FsCheckProperty]
public async Task AsyncPropertyTest(int value)
{
    await Task.Delay(1);
    if (value * 0 != 0)
        throw new InvalidOperationException("Expected zero");
}

// FsCheck Property type for advanced scenarios
[Test, FsCheckProperty]
public Property StringReversalProperty()
{
    return Prop.ForAll<string>(str =>
    {
        var reversed = new string(str.Reverse().ToArray());
        var doubleReversed = new string(reversed.Reverse().ToArray());
        return str == doubleReversed;
    });
}
```

## Configuration Options

The `[FsCheckProperty]` attribute supports several configuration options:

| Property | Default | Description |
|----------|---------|-------------|
| `MaxTest` | 100 | Maximum number of tests to run |
| `MaxFail` | 1000 | Maximum rejected tests before failing |
| `StartSize` | 1 | Starting size for test generation |
| `EndSize` | 100 | Ending size for test generation |
| `Replay` | null | Seed to replay a specific test run |
| `Verbose` | false | Output all generated arguments |
| `QuietOnSuccess` | false | Suppress output on passing tests |
| `Arbitrary` | null | Types containing custom Arbitrary instances |

### Example with Configuration

```csharp
[Test, FsCheckProperty(MaxTest = 50, StartSize = 1, EndSize = 50)]
public bool ListConcatenationPreservesElements(int[] first, int[] second)
{
    var combined = first.Concat(second).ToArray();
    return combined.Length == first.Length + second.Length;
}
```

## Reproducing Failures

When a property test fails, FsCheck reports the seed that can be used to reproduce the failure. Use the `Replay` property to run the test with a specific seed:

```csharp
[Test, FsCheckProperty(Replay = "12345,67890")]
public bool MyProperty(int value)
{
    return value >= 0; // Will reproduce the same failing case
}
```

## Custom Generators

You can provide custom `Arbitrary` implementations for generating test data. FsCheck 3.x uses `ArbMap.Default` to access default arbitraries:

```csharp
using FsCheck;
using FsCheck.Fluent;

public class PositiveIntArbitrary
{
    public static Arbitrary<int> PositiveInt()
    {
        // Use ArbMap.Default to get a generator for a type,
        // then filter with Where() and convert to Arbitrary
        return ArbMap.Default.GeneratorFor<int>()
            .Where(x => x > 0)
            .ToArbitrary();
    }
}

[Test, FsCheckProperty(Arbitrary = new[] { typeof(PositiveIntArbitrary) })]
public bool PositiveNumbersArePositive(int value)
{
    return value > 0;
}
```

### Alternative: Using Gen.Choose

For simple ranges, use `Gen.Choose` directly:

```csharp
public class PositiveIntArbitrary
{
    public static Arbitrary<int> PositiveInt()
    {
        // Generate integers in a specific range
        return Gen.Choose(1, int.MaxValue).ToArbitrary();
    }
}
```

### Custom types

For custom types, compose generators using LINQ:

```csharp
public class Person
{
    public string Name { get; set; }
    public int Age { get; set; }
}

public class PersonArbitrary
{
    public static Arbitrary<Person> Person()
    {
        var gen = from name in ArbMap.Default.GeneratorFor<string>()
                  from age in Gen.Choose(0, 120)
                  select new Person { Name = name, Age = age };
        return gen.ToArbitrary();
    }
}
```

## Limitations

- **Native AOT**: TUnit.FsCheck is not compatible with Native AOT publishing because FsCheck requires reflection and dynamic code generation
- **Parameter count**: Properties can have any number of parameters that FsCheck can generate

## When to Use Property-Based Testing

Property-based testing is particularly useful for:

- Testing mathematical properties (commutativity, associativity, etc.)
- Serialization/deserialization round-trips
- Data structure invariants
- Parsing and formatting functions
- Any code where you can express general rules that should always hold

---

## F# Interactive


F# Interactive (FSI) is a REPL (Read-Eval-Print Loop) for F#. It allows you to execute F# code interactively, making it a powerful tool for testing and prototyping.
It is included with the F# compiler and can be used in various development environments, including Visual Studio and Visual Studio Code.

## Using F# Interactive with TUnit

TUnit can be used with F# Interactive to run tests interactively. This is particularly useful for rapid prototyping, testing small code snippets, and running tests in an easy script
format. To use TUnit with F# Interactive, follow these steps:

1. **Add TUnit to your fsx script**: You need to reference the TUnit library in your F# script. You can do this by adding the following line at the top of your `.fsx` file:
   The following will add the latest version of TUnit to your script:

   ```fsharp
   #r "nuget: TUnit"
   ```

   Alternatively, you can specify a specific version:

   ```fsharp
   #r "nuget: TUnit, 0.20.16"
   ```

2. **Write your tests**: You can write your tests in the same way you would in a regular F# project. For example:

   ```fsharp
      #r "nuget: TUnit, 0.20.16"
      #r "nuget: TUnit.Assertions.Fsharp, 0.20.16"

      open System
      open TUnit
      open TUnit.Engine
      open TUnit.Core
      open TUnit.Assertions
      open TUnit.Assertions
      open TUnit.Assertions.Extensions
      open TUnit.Assertions.FSharp.Operations
      open TUnit.Engine.Services
      open System.Collections.Generic

      type tests() =
         [<Test>]
         member _.Basic() =
            Console.WriteLine("This is a basic test")

         [<Test>]
         [<Arguments(1, 2, 3)>]
         [<Arguments(2, 3, 5)>]
         member _.DataDrivenArguments(a: int, b: int, c: int) =
            async {
                  Console.WriteLine("This one can accept arguments from an attribute")
                  let result = a + b
                  do! check (Assert.That(result).IsEqualTo(c))
            }

         [<DynamicTestBuilder>]
         member _.BuildTests(context: DynamicTestBuilderContext) =
            context.AddTest(DynamicTest<tests>(TestMethod = fun instance -> instance.Basic()))

            context.AddTest(
                  DynamicTest<tests>(
                     TestMethod = fun instance -> instance.DataDrivenArguments(1, 2, 3) |> Async.RunSynchronously
                  )
            )

      // Instantiate your test class
      let testInstance = tests ()

      testInstance.BuildTests

      // Create a test runner and get the results
      let resultsTask =
         task {
            // Set results directory to current working directory
            let args = [| "--results-directory"; System.IO.Directory.GetCurrentDirectory() |]
            let! testResults = TUnitRunner.RunTests(args)
            return testResults
         }

      printf "Running tests..."

      resultsTask |> Async.AwaitTask |> Async.RunSynchronously
   ```

3. **Run your tests**: You can run your tests by executing the script in F# Interactive. The results will be printed to the console.
   To run the script, you can use the following command

   ```powershell
   dotnet fsi your_script.fsx
   ```

---

## Instrumenting: Global Test IDs


There are plenty use cases for having a unique identifier for each test in your test suite. If you're engineering tests that connect to a data source, you might want to ensure data isolation between the tests. One way to do that is cleaning up the data source after each test, but that prevents you from running tests cleanly in parallel, and it requires you to write either very intelligent or a lot of cleanup code. Additionally, bugs can cause data to leak between tests and make your tests flaky.

A straightforward way to ensure data isolation is to connect to a different data source for each test. To isolate, you need a unique identifier to differentiate between the tests. This identifier should be known before the test starts, so you can use it to provision the data source and build the connection string. For Redis, you would typically use a different database number for each test. For SQL databases, you would typically use a different table or database name for each test.

We can hook into TUnit's test discovery process and assign unique identifiers to tests by implementing `OnTestDiscovered(DiscoveredTestContext discoveredTestContext)` in `ITestDiscoveryEventReceiver`. Here's an example implementation that is tailored for contrived test cases involving Redis databases:

```csharp
class AssignTestIdentifiersAttribute : Attribute, ITestDiscoveryEventReceiver
{
    public const string TestIdObjectBagKey = "\u0001TestId";

    public static int TestId { get; private set; } = 0;

    public ValueTask OnTestDiscovered(DiscoveredTestContext discoveredTestContext)
    {
        discoveredTestContext.TestContext.StateBag[TestIdObjectBagKey] = TestId++;
        return ValueTask.CompletedTask;
    }
}
```

`TestIdObjectBagKey` is a unique key that we use to store the test identifier in the `StateBag` of TUnit's `TestContext`.

`TestId` is a static integer that we increment for each test. We use this to assign a unique identifier to each test.

In `OnTestDiscovered`, we assign the test identifier to the `StateBag` using the `TestIdObjectBagKey`. The use of `StateBag` exposes the test identifier to hooks and tests.

Before we demonstrate how to use this attribute, let's create a simple extension method for `TestContext` to retrieve the test identifier swiftly:

```csharp
static class TestContextExtensions
{
    public static int GetTestId(this TestContext? testContext)
    {
        // Retrieve the test identifier from the StateBag
        return (int)testContext!.StateBag[AssignTestIdentifiersAttribute.TestIdObjectBagKey]!;
    }
}
```

Assign unique identifiers to all tests in the assembly by decorating in `AssemblyInfo.cs`:

```csharp
[assembly: AssignTestIdentifiers]
```

And then use the unique identifier in your tests:

```csharp
class MyTestClassThatNeedsUniqueTestIds
{
    private IDatabase isolatedRedisDb = null!;

    [Before(HookType.Test)]
    public void BeforeEach()
    {
        // Call the extension method to retrieve the unique test id:
        int currentTestId = TestContext.Current.GetTestId();

        // Connect to the Redis database using the test id:
        this.isolatedRedisDb = StackExchange.Redis.ConnectionMultiplexer
                                .Connect("localhost")
                                .GetDatabase(currentTestId);
    }

    [Test]
    public void MyTestCase()
    {
        // Do stuff with isolatedRedisDb
    }

    [Test]
    public void MyOtherTestCase()
    {
        // Do stuff with isolatedRedisDb
    }

    [Test]
    public void YetAnotherTestCase()
    {
        // Do stuff with isolatedRedisDb
    }
}
```

The test identifier for each test is assigned in the order that TUnit discovers the tests. The test identifier is unique for each test and is guaranteed to be assigned before the test starts. For other uses cases, you would need to adjust the implementation of `AssignTestIdentifiersAttribute` to suit your needs. For example, you could choose to use GUIDs instead of integers. We've only used integers to match the Redis database number example.

---

## Examples


This can serve as a place to show how to use TUnit to test more complex systems, utilising advanced features like ClassData sources with IAsyncInitializers and IAsyncDisposables, or utilising test events to drive things.

As tests come in all shapes and sizes, this is a good place for community contributions. If you have a good example for showing other users how to setup a specific testing scenario, then please submit a pull request with code examples.

---

## Playwright


There is a NuGet package to help with Playwright: `TUnit.Playwright`

Once that is installed, a test can be as simple as:

```csharp
public class Tests : PageTest
{
    [Test]
    public async Task Test()
    {
        await Page.GotoAsync("https://www.github.com/thomhurst/TUnit");
    }
}
```

By inheriting from `PageTest`, the base class handles setting up and disposing your playwright objects for you.

The following properties are available to use:

- `Page`
- `Context`
- `Browser`
- `Playwright`

You can override the `BrowserName` to control which browser you want to launch.

The possible values are:
- chromium
- firefox
- webkit

---

## TUnit in CI/CD Pipelines


When using TUnit in a CI/CD pipeline, you'll want to run tests, collect results, and publish reports for visibility. This guide provides complete, production-ready pipeline configurations for popular CI/CD platforms.

The best practice is to use the .NET SDK CLI (`dotnet test` or `dotnet run`) directly to maintain full control over execution, ensure reproducibility across environments, and allow for local debugging.

> **Note**: The `--` separator is required to pass arguments to the test runner when using `dotnet test`. CLI flags/args from extension packages (such as `--coverage`, `--report-trx`, `--results-directory`) must come after the `--` separator so they are parsed as program arguments to the TUnit test runner, not as `dotnet test` arguments. For example: `dotnet test -- --coverage --report-trx` instead of `dotnet test --coverage --report-trx`.

## GitHub Actions

### Complete Workflow with Matrix Strategy

This workflow tests multiple .NET versions across different operating systems, collects code coverage, and publishes results:

```yaml
name: CI

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    name: Test on ${{ matrix.os }} - .NET ${{ matrix.dotnet-version }}
    runs-on: ${{ matrix.os }}

    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest, macos-latest]
        dotnet-version: ['8.0.x', '9.0.x']
      fail-fast: false  # Continue running other jobs if one fails

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup .NET ${{ matrix.dotnet-version }}
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: ${{ matrix.dotnet-version }}

    - name: Restore dependencies
      run: dotnet restore

    - name: Build
      run: dotnet build --configuration Release --no-restore

    - name: Run tests with coverage
      run: dotnet test --configuration Release --no-build -- --coverage --report-trx --results-directory ./TestResults

    - name: Upload test results
      if: always()  # Run even if tests fail
      uses: actions/upload-artifact@v4
      with:
        name: test-results-${{ matrix.os }}-${{ matrix.dotnet-version }}
        path: ./TestResults/*.trx

    - name: Upload coverage
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: coverage-${{ matrix.os }}-${{ matrix.dotnet-version }}
        path: ./TestResults/*.coverage

  publish-results:
    name: Publish Test Results
    needs: test
    runs-on: ubuntu-latest
    if: always()

    steps:
    - name: Download all test results
      uses: actions/download-artifact@v4
      with:
        pattern: test-results-*
        path: ./TestResults

    - name: Publish test results
      uses: EnricoMi/publish-unit-test-result-action@v2
      with:
        files: ./TestResults/**/*.trx
```

### Workflow with AOT Testing

Test your code with Native AOT compilation:

```yaml
name: AOT Tests

on: [push, pull_request]

jobs:
  test-aot:
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v4

    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: '9.0.x'

    - name: Restore
      run: dotnet restore

    - name: Publish with AOT
      run: dotnet publish -c Release -p:PublishAot=true --use-current-runtime

    - name: Run AOT tests
      run: ./bin/Release/net9.0/linux-x64/publish/YourTestProject
```

### PR Comment with Test Results

Post test results as a comment on pull requests:

```yaml
name: PR Tests

on:
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    permissions:
      pull-requests: write  # Required to comment on PRs

    steps:
    - uses: actions/checkout@v4

    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: '9.0.x'

    - name: Run tests
      run: dotnet test --configuration Release -- --report-trx --results-directory ./TestResults

    - name: Comment PR with results
      if: always()
      uses: EnricoMi/publish-unit-test-result-action@v2
      with:
        files: ./TestResults/*.trx
        comment_mode: always
```

## Azure DevOps

### Complete Pipeline with Stages

```yaml
trigger:
  branches:
    include:
    - main
    - develop

pr:
  branches:
    include:
    - main

pool:
  vmImage: 'ubuntu-latest'

variables:
  buildConfiguration: 'Release'
  dotnetSdkVersion: '9.0.x'

stages:
- stage: Build
  displayName: 'Build Stage'
  jobs:
  - job: Build
    displayName: 'Build Job'
    steps:
    - task: UseDotNet@2
      displayName: 'Install .NET SDK'
      inputs:
        packageType: 'sdk'
        version: '$(dotnetSdkVersion)'

    - script: dotnet restore
      displayName: 'Restore dependencies'

    - script: dotnet build --configuration $(buildConfiguration) --no-restore
      displayName: 'Build solution'

    - script: dotnet publish --configuration $(buildConfiguration) --no-build --output $(Build.ArtifactStagingDirectory)
      displayName: 'Publish artifacts'

    - publish: $(Build.ArtifactStagingDirectory)
      artifact: drop
      displayName: 'Publish build artifacts'

- stage: Test
  displayName: 'Test Stage'
  dependsOn: Build
  jobs:
  - job: Test
    displayName: 'Run Tests'
    steps:
    - task: UseDotNet@2
      displayName: 'Install .NET SDK'
      inputs:
        packageType: 'sdk'
        version: '$(dotnetSdkVersion)'

    - script: dotnet restore
      displayName: 'Restore dependencies'

    - script: dotnet build --configuration $(buildConfiguration) --no-restore
      displayName: 'Build solution'

    - script: |
        dotnet test --configuration $(buildConfiguration) --no-build -- \
          --coverage --coverage-output-format cobertura \
          --report-trx --results-directory $(Agent.TempDirectory)
      displayName: 'Run tests with coverage'
      continueOnError: true

    - task: PublishTestResults@2
      displayName: 'Publish test results'
      condition: always()
      inputs:
        testResultsFormat: 'VSTest'
        testResultsFiles: '**/*.trx'
        searchFolder: '$(Agent.TempDirectory)'
        failTaskOnFailedTests: true
        testRunTitle: 'TUnit Test Results'

    - task: PublishCodeCoverageResults@2
      displayName: 'Publish code coverage'
      condition: always()
      inputs:
        codeCoverageTool: 'Cobertura'
        summaryFileLocation: '$(Agent.TempDirectory)/**/coverage.cobertura.xml'
```

### Multi-Platform Testing Matrix

```yaml
strategy:
  matrix:
    linux_net8:
      vmImage: 'ubuntu-latest'
      dotnetVersion: '8.0.x'
    linux_net9:
      vmImage: 'ubuntu-latest'
      dotnetVersion: '9.0.x'
    windows_net8:
      vmImage: 'windows-latest'
      dotnetVersion: '8.0.x'
    windows_net9:
      vmImage: 'windows-latest'
      dotnetVersion: '9.0.x'
    macos_net9:
      vmImage: 'macos-latest'
      dotnetVersion: '9.0.x'

pool:
  vmImage: $(vmImage)

steps:
- task: UseDotNet@2
  inputs:
    version: '$(dotnetVersion)'

- script: dotnet test --configuration Release -- --report-trx
  displayName: 'Run tests on $(vmImage) with .NET $(dotnetVersion)'
```

## GitLab CI

### Complete Pipeline with Stages

```yaml
image: mcr.microsoft.com/dotnet/sdk:9.0

variables:
  BUILD_CONFIGURATION: Release
  COVERAGE_THRESHOLD: 80

stages:
  - build
  - test
  - report

before_script:
  - dotnet --version

build:
  stage: build
  script:
    - dotnet restore
    - dotnet build --configuration $BUILD_CONFIGURATION --no-restore
  artifacts:
    paths:
      - "*/bin/$BUILD_CONFIGURATION/"
      - "*/obj/$BUILD_CONFIGURATION/"
    expire_in: 1 hour

test:unit:
  stage: test
  dependencies:
    - build
  script:
    - dotnet test --configuration $BUILD_CONFIGURATION --no-build --
      --coverage --coverage-output-format cobertura
      --report-trx --results-directory ./TestResults
  coverage: '/Total\s+\|\s+(\d+\.?\d*)%/'
  artifacts:
    when: always
    paths:
      - TestResults/
    reports:
      junit: TestResults/*.trx
      coverage_report:
        coverage_format: cobertura
        path: TestResults/coverage.cobertura.xml

test:integration:
  stage: test
  dependencies:
    - build
  script:
    - dotnet test --configuration $BUILD_CONFIGURATION --no-build --
      --treenode-filter "/*/*/*/*[Category=Integration]"
      --report-trx --results-directory ./TestResults
  artifacts:
    when: always
    paths:
      - TestResults/
    reports:
      junit: TestResults/*.trx

coverage-report:
  stage: report
  dependencies:
    - test:unit
  script:
    - dotnet tool install -g dotnet-reportgenerator-globaltool
    - reportgenerator
      "-reports:TestResults/coverage.cobertura.xml"
      "-targetdir:coverage"
      "-reporttypes:Html;Badges"
    - echo "Coverage report generated"
  coverage: '/Total\s+\|\s+(\d+\.?\d*)%/'
  artifacts:
    paths:
      - coverage/
```

### Matrix Testing Multiple .NET Versions

```yaml
.test-template:
  stage: test
  script:
    - dotnet test --configuration Release -- --report-trx

test:net8:
  extends: .test-template
  image: mcr.microsoft.com/dotnet/sdk:8.0

test:net9:
  extends: .test-template
  image: mcr.microsoft.com/dotnet/sdk:9.0
```

## CircleCI

### Complete Configuration

```yaml
version: 2.1

orbs:
  dotnet: circleci/dotnet@2.0

executors:
  dotnet-executor:
    docker:
      - image: mcr.microsoft.com/dotnet/sdk:9.0

jobs:
  build:
    executor: dotnet-executor
    steps:
      - checkout

      - run:
          name: Restore dependencies
          command: dotnet restore

      - run:
          name: Build
          command: dotnet build --configuration Release --no-restore

      - persist_to_workspace:
          root: .
          paths:
            - "*/bin/Release/"
            - "*/obj/Release/"

  test:
    executor: dotnet-executor
    steps:
      - checkout

      - attach_workspace:
          at: .

      - run:
          name: Run tests
          command: |
            dotnet test --configuration Release --no-build -- \
              --coverage --coverage-output-format cobertura \
              --report-trx --results-directory ./TestResults

      - run:
          name: Process test results
          when: always
          command: |
            dotnet tool install -g trx2junit
            trx2junit TestResults/*.trx

      - store_test_results:
          path: ./TestResults

      - store_artifacts:
          path: ./TestResults
          destination: test-results

  test-matrix:
    parameters:
      dotnet-version:
        type: string
    docker:
      - image: mcr.microsoft.com/dotnet/sdk:<< parameters.dotnet-version >>
    steps:
      - checkout
      - run: dotnet test --configuration Release

workflows:
  version: 2
  build-and-test:
    jobs:
      - build
      - test:
          requires:
            - build
      - test-matrix:
          name: test-net8
          dotnet-version: "8.0"
      - test-matrix:
          name: test-net9
          dotnet-version: "9.0"
```

## Docker

### Dockerfile for Running Tests

```dockerfile
FROM mcr.microsoft.com/dotnet/sdk:9.0 AS build
WORKDIR /src

# Copy solution and project files
COPY *.sln .
COPY src/**/*.csproj ./src/
COPY tests/**/*.csproj ./tests/

# Restore dependencies
RUN dotnet restore

# Copy all source code
COPY . .

# Build
RUN dotnet build --configuration Release --no-restore

# Run tests
FROM build AS test
WORKDIR /src
RUN dotnet test --configuration Release --no-build -- \
    --coverage --report-trx --results-directory /testresults

# Export test results
FROM scratch AS export
COPY --from=test /testresults /
```

### Docker Compose for Integration Tests

```yaml
version: '3.8'

services:
  tests:
    build:
      context: .
      dockerfile: Dockerfile
      target: test
    environment:
      - DOTNET_ENVIRONMENT=Test
      - ConnectionStrings__Database=Host=postgres;Database=testdb;Username=test;Password=test
    depends_on:
      - postgres
      - redis
    volumes:
      - ./TestResults:/testresults

  postgres:
    image: postgres:15
    environment:
      POSTGRES_DB: testdb
      POSTGRES_USER: test
      POSTGRES_PASSWORD: test
    ports:
      - "5432:5432"

  redis:
    image: redis:7
    ports:
      - "6379:6379"
```

Run tests with:

```bash
docker-compose up --build tests
```

## Best Practices

### Separate Restore, Build, and Test

For efficiency and clarity, separate these steps:

```yaml
# GitHub Actions
- name: Restore
  run: dotnet restore

- name: Build
  run: dotnet build --no-restore --configuration Release

- name: Test
  run: dotnet test --no-build --configuration Release
```

### Use Caching

Cache NuGet packages to speed up builds:

```yaml
# GitHub Actions
- name: Cache NuGet packages
  uses: actions/cache@v3
  with:
    path: ~/.nuget/packages
    key: ${{ runner.os }}-nuget-${{ hashFiles('**/*.csproj') }}
    restore-keys: |
      ${{ runner.os }}-nuget-
```

### Parallel Test Execution

Configure parallelism based on available resources:

```bash
# Default: Use all available cores
dotnet test

# Limit parallelism in resource-constrained environments
dotnet test -- --maximum-parallel-tests 4
```

### Filter Tests by Category

Run different test categories in separate jobs:

```yaml
# Unit tests (fast)
- name: Unit Tests
  run: dotnet test -- --treenode-filter "/*/*/*/*[Category=Unit]"

# Integration tests (slower)
- name: Integration Tests
  run: dotnet test -- --treenode-filter "/*/*/*/*[Category=Integration]"
```

> **Note**: The `--` separator is always required when passing TUnit-specific arguments like `--treenode-filter` to ensure they are parsed correctly as program arguments rather than `dotnet test` arguments.

### Fail Fast in PRs

Use fail-fast mode for quick feedback in pull requests:

```bash
dotnet test -- --fail-fast
```

## Troubleshooting

### Tests Timing Out

Increase the test timeout:

```bash
dotnet test -- --timeout 5m  # 5 minutes
```

### Coverage Files Not Generated

Ensure you're using the TUnit meta package (not just TUnit.Engine):

```xml
<PackageReference Include="TUnit" Version="*" />
```

### Out of Memory in CI

Limit parallel test execution:

```bash
dotnet test -- --maximum-parallel-tests 2
```

Or increase the heap size:

```bash
export DOTNET_GCHeapHardLimit=0x40000000  # 1GB
dotnet test
```

---

## CI/CD Reporting


TUnit provides built-in integration with continuous integration and deployment platforms, automatically detecting and adapting to various CI environments.

## GitHub Actions Reporter

When running in GitHub Actions, TUnit automatically generates a test summary that appears in the workflow run summary. This feature activates when the `GITHUB_ACTIONS` environment variable is detected.

### Automatic Detection

The GitHub reporter automatically enables when:
- The `GITHUB_ACTIONS` environment variable is set
- The `GITHUB_STEP_SUMMARY` environment variable points to a valid file

No additional configuration is required for basic functionality.

### Reporter Styles

TUnit's GitHub reporter supports two output styles:

#### Collapsible Style (Default)

The collapsible style provides a clean, concise summary with expandable details:

```markdown
### TestAssembly (.NET 9.0)

| Test Count | Status |
| --- | --- |
| 95 | Passed |
| 5 | Failed |

<details>
<summary>📊 Test Details (click to expand)</summary>

### Details
| Test | Status | Details | Duration |
| --- | --- | --- | --- |
| MyTest.ShouldFail | Failed | Expected: true, Actual: false | 123ms |
| ... | ... | ... | ... |

</details>
```

This is the **default style** as of TUnit v1.0.0, designed to:
- Keep workflow summaries clean and navigable
- Allow quick overview of test results
- Provide full details on demand
- Work well with large test suites

#### Full Style (Legacy)

The full style displays all test details directly in the summary:

```markdown
### TestAssembly (.NET 9.0)

| Test Count | Status |
| --- | --- |
| 95 | Passed |
| 5 | Failed |

### Details
| Test | Status | Details | Duration |
| --- | --- | --- | --- |
| MyTest.ShouldFail | Failed | Expected: true, Actual: false | 123ms |
| ... | ... | ... | ... |
```

### Configuration Options

You can control the GitHub reporter style using either command-line arguments or environment variables:

#### Command Line

```bash
# Use collapsible style (default)
dotnet test -- --github-reporter-style collapsible

# Use full style (legacy behavior)
dotnet test -- --github-reporter-style full
```

#### Environment Variable

```bash
# Set reporter style via environment variable
export TUNIT_GITHUB_REPORTER_STYLE=collapsible  # or 'full'
dotnet test
```

```yaml
# In GitHub Actions workflow
- name: Run Tests
  env:
    TUNIT_GITHUB_REPORTER_STYLE: collapsible
  run: dotnet test
```

### GitHub Actions Workflow Example

```yaml
name: Test

on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Setup .NET
      uses: actions/setup-dotnet@v3
      with:
        dotnet-version: '9.0.x'
    
    - name: Run Tests with Collapsible Reporter
      run: dotnet test --logger "console;verbosity=normal"
      # GitHub reporter auto-detects and uses collapsible style by default
    
    - name: Run Tests with Full Reporter
      run: dotnet test -- --github-reporter-style full
      # Explicitly use full style for all details
```

### Disabling the GitHub Reporter

If you need to disable the GitHub reporter entirely:

#### Via Environment Variable

```bash
export TUNIT_DISABLE_GITHUB_REPORTER=true
# or
export DISABLE_GITHUB_REPORTER=true
```

```yaml
# In GitHub Actions workflow
- name: Run Tests Without GitHub Reporter
  env:
    TUNIT_DISABLE_GITHUB_REPORTER: true
  run: dotnet test
```

### File Size Limitations

The GitHub reporter respects GitHub's file size limits:
- Maximum summary file size: 1MB
- If the output would exceed this limit, the reporter will skip writing to prevent errors
- Consider using the collapsible style for large test suites to reduce summary size

### Filtering Test Output

When using the GitHub reporter, only non-passing tests are included in the details section:
- Failed tests
- Skipped tests
- Timed out tests
- Cancelled tests
- Tests that never completed (in progress)

Passed tests are counted but not listed in details to keep the summary focused on actionable items.

## Other CI Platforms

While TUnit currently provides specialized support for GitHub Actions, it works with all CI/CD platforms through standard test output formats:

### Azure DevOps

Use TRX reporting for Azure DevOps integration:

```bash
dotnet test -- --report-trx --report-trx-filename TestResults.trx
```

### Jenkins

Jenkins can consume various test output formats:

```bash
# Generate TRX report for Jenkins
dotnet test -- --report-trx

# Or use console output with appropriate verbosity
dotnet test --logger "console;verbosity=detailed"
```

### GitLab CI

GitLab can parse test results in various formats:

```yaml
test:
  script:
    - dotnet test -- --report-trx
  artifacts:
    reports:
      junit:
        - TestResults/*.trx
```

## Environment Detection

TUnit automatically detects common CI environments through environment variables:

| Platform | Detection Variables |
| --- | --- |
| GitHub Actions | `GITHUB_ACTIONS` |
| Azure DevOps | `AZURE_PIPELINES` |
| Jenkins | `JENKINS_URL` |
| GitLab CI | `GITLAB_CI` |
| CircleCI | `CIRCLECI` |
| Travis CI | `TRAVIS` |
| AppVeyor | `APPVEYOR` |
| TeamCity | `TEAMCITY_VERSION` |
| Generic CI | `CI`, `CONTINUOUS_INTEGRATION` |

This detection helps TUnit optimize its behavior for each platform.

## Best Practices

1. **Use Collapsible Style for Large Test Suites**: The default collapsible style keeps summaries manageable
2. **Filter Tests in CI**: Use `--treenode-filter` to run specific test subsets in different CI jobs
3. **Set Appropriate Timeouts**: Use `--timeout` to prevent hanging builds
4. **Enable Fail-Fast for Quick Feedback**: Use `--fail-fast` in PR validation builds
5. **Customize Verbosity**: Adjust `--output` based on your debugging needs

## Troubleshooting

### GitHub Reporter Not Working

If the GitHub reporter isn't generating summaries:

1. **Check Environment Variables**:
   ```bash
   echo $GITHUB_ACTIONS  # Should output 'true'
   echo $GITHUB_STEP_SUMMARY  # Should point to a file
   ```

2. **Verify Not Disabled**:
   ```bash
   # Ensure these are not set
   echo $TUNIT_DISABLE_GITHUB_REPORTER
   echo $DISABLE_GITHUB_REPORTER
   ```

3. **Check File Permissions**: Ensure the process can write to `GITHUB_STEP_SUMMARY` file

4. **Review Test Output**: Run with `--diagnostic` to see detailed logs

### Summary Not Appearing

If tests run but no summary appears:

- Check if all tests passed (summaries may be minimal for all-passing runs)
- Verify the workflow has completed (summaries appear after job completion)
- Check the "Summary" section of the GitHub Actions run page

### Large Summary Files

If you encounter file size issues:

- Switch to collapsible style: `--github-reporter-style collapsible`
- Filter tests to reduce output: `--treenode-filter "critical-tests"`
- Run tests in separate jobs with focused test subsets

---

## Engine Modes


TUnit supports two execution modes, providing flexibility for different development and deployment scenarios.

## Execution Modes

TUnit can run in two modes:

- **Source Generation Mode** (Default): Uses compile-time source generation for test discovery and execution, providing optimal performance and compile-time safety
- **Reflection Mode**: Traditional runtime reflection-based test discovery and execution, enabled with the `--reflection` command-line flag

When publishing with Native AOT, the source generation mode provides additional performance benefits and full AOT compatibility.

The Reflection mode allows discovery of test cases that have been source generated by something other than TUnit, though, for example .razor files in bUnit.

## Source Generation Mode (Default)

By default, TUnit always uses source generation for test discovery and execution:

- **Compile-Time Generation**: All test discovery logic is generated at compile time
- **Better Performance**: Faster than reflection-based execution
- **Type Safety**: Compile-time validation of test configurations and data sources
- **No Runtime Reflection**: Eliminates the overhead of runtime type discovery

This is the standard mode used for all builds, whether debugging, running tests, or publishing. When you publish with Native AOT, you get additional performance benefits, but the underlying source generation logic remains the same.

## Reflection Mode

Reflection mode can be explicitly enabled in several ways:

- **Runtime Discovery**: Tests are discovered at runtime using reflection
- **Dynamic Execution**: Uses traditional reflection-based test invocation
- **Compatibility**: Useful for scenarios where source generation may not be suitable (e.g., bUnit with Razor components)
- **Legacy Support**: Maintains compatibility with reflection-dependent test patterns

### Enabling Reflection Mode

There are three ways to enable reflection mode, listed in priority order:

#### 1. Command-Line Flag (Highest Priority)
```bash
dotnet test -- --reflection
```

#### 2. Assembly Attribute (Recommended for Per-Project Configuration)
Add to any `.cs` file in your test project (e.g., `AssemblyInfo.cs`):
```csharp
using TUnit.Core;

[assembly: ReflectionMode]
```

This is the recommended approach when you need reflection mode for a specific test assembly, such as bUnit projects that test Razor components. The configuration is version-controlled and doesn't require external configuration files.

**Example: bUnit Test Project**
```csharp
// Add this to enable reflection mode for your bUnit tests
[assembly: ReflectionMode]

namespace MyApp.Tests;

public class CounterComponentTests : TestContext
{
    [Test]
    public void CounterStartsAtZero()
    {
        // Test Razor components that are source-generated at compile time
        var cut = RenderComponent<Counter>();
        cut.Find("p").TextContent.ShouldBe("Current count: 0");
    }
}
```

#### 3. Environment Variable (Global Configuration)
```bash
# Windows
set TUNIT_EXECUTION_MODE=reflection

# Linux/macOS
export TUNIT_EXECUTION_MODE=reflection
```

Alternatively, you can configure this in a `testconfig.json` file:
```json
{
  "testingPlatform": {
    "environmentVariables": {
      "TUNIT_EXECUTION_MODE": "reflection"
    }
  }
}
```

### Optimizing Build Performance in Reflection Mode

When using reflection mode exclusively (via `[assembly: ReflectionMode]`), you can improve build performance by disabling source generation entirely. Since the generated code won't be used at runtime in reflection mode, skipping source generation reduces compile times.

Add this MSBuild property to your test project file (`.csproj`):

```xml
<PropertyGroup>
    <EnableTUnitSourceGeneration>false</EnableTUnitSourceGeneration>
</PropertyGroup>
```

**Example: bUnit Test Project with Optimized Build**
```xml
<Project Sdk="Microsoft.NET.Sdk.Razor">
  <PropertyGroup>
    <TargetFramework>net10.0</TargetFramework>
    <!-- Disable source generation since we're using reflection mode -->
    <EnableTUnitSourceGeneration>false</EnableTUnitSourceGeneration>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="bunit" Version="1.x.x" />
    <PackageReference Include="TUnit" Version="1.x.x" />
  </ItemGroup>
</Project>
```

Then in your code:
```csharp
// Enable reflection mode for Razor component testing
[assembly: ReflectionMode]

namespace MyApp.Tests;

public class CounterComponentTests : TestContext
{
    [Test]
    public void CounterStartsAtZero()
    {
        var cut = RenderComponent<Counter>();
        cut.Find("p").TextContent.ShouldBe("Current count: 0");
    }
}
```

**Benefits:**
- **Faster Builds**: Eliminates source generator execution at compile time
- **Reduced Compiler Overhead**: Less work for the compiler to do
- **Clear Intent**: Explicitly indicates the project uses reflection mode

**Note:** This optimization is only beneficial when you're exclusively using reflection mode. If you're using source generation mode (the default), keep `EnableTUnitSourceGeneration` set to `true` (or omit it entirely, as `true` is the default).

## Native AOT Support

When publishing with Native AOT, TUnit's source generation mode provides additional benefits:

- **Full AOT Compatibility**: The source-generated code is fully compatible with Native AOT compilation
- **Enhanced Performance**: Better performance compared to reflection-based execution
- **Reduced Binary Size**: No reflection metadata needed, resulting in smaller executables
- **Faster Startup**: No runtime type discovery overhead

Note: These AOT-specific benefits only apply when actually publishing with Native AOT. Regular builds use the same source generation logic but without the native compilation optimizations.

## How Source Generation Works

TUnit's source generation creates strongly-typed delegates for all test operations at compile time:

- **Test Invocation**: Type-specific delegates instead of generic object arrays
- **Data Sources**: Specialized factory methods with exact return types
- **Property Injection**: Generated property setters with dependency resolution
- **Hook Methods**: Strongly-typed hook delegates with proper async support

## Publishing with Native AOT

To use TUnit with Native AOT:

```xml
<PropertyGroup>
    <PublishAot>true</PublishAot>
</PropertyGroup>
```

Then publish your project:
```bash
dotnet publish -c Release
```

## Configuration

TUnit uses optimized defaults for all features. The only configurable option is verbose diagnostics for troubleshooting source generation issues:

### EditorConfig (.editorconfig)
```ini
# Enable verbose diagnostics (default: false)
tunit.enable_verbose_diagnostics = true
```

### MSBuild Property
```xml
<PropertyGroup>
    <TUnitEnableVerboseDiagnostics>true</TUnitEnableVerboseDiagnostics>
</PropertyGroup>
```

## Compatibility

**C# Projects**: Full support with source generation
**F# Projects**: Falls back to reflection mode (source generation not supported)
**VB.NET Projects**: Falls back to reflection mode (source generation not supported)

For F# and VB.NET projects, TUnit automatically uses reflection mode since source generation is only available for C# projects. For better performance with F# or VB.NET code, create a separate C# test project that references your F#/VB.NET libraries and write tests there.

---

## Executors


In some advanced cases, you may need to control how a test or hook is executed.
There are two interfaces that you can implement to control this:
- `IHookExecutor`
- `ITestExecutor`

You will be given a delegate, and some context about what is executing, and you can control how to invoke it.

To register your executor, on your test/hook, you can place an attribute of either:
- `[HookExecutor<...>]`
- `[TestExecutor<...>]`

An example of where you might need this is running in a STA Thread.

Here's an example:

```csharp
using TUnit.Core;

namespace MyTestProject;

public class MyTestClass
{
    [Test]
    [TestExecutor<STAThreadExecutor>]
    public async Task With_STA()
    {
        await Assert.That(Thread.CurrentThread.GetApartmentState()).IsEqualTo(ApartmentState.STA);
    }
    
    [Test]
    public async Task Without_STA()
    {
        await Assert.That(Thread.CurrentThread.GetApartmentState()).IsEqualTo(ApartmentState.MTA);
    }
}
```

---

## Repeating


If you want to repeat a test, add a `[RepeatAttribute]` onto your test method or class. This takes an `int` of how many times you'd like to repeat. Each repeat will show in the test explorer as a new test.

This can be used on base classes and inherited to affect all tests in sub-classes.

```csharp
using TUnit.Core;

namespace MyTestProject;

public class MyTestClass
{
    [Test]
    [Repeat(3)]
    public async Task MyTest()
    {
        
    }
}
```

## Global Repeat

In case you want to apply the repeat logic to all tests in a project, you can add the attribute on the assembly level.

```csharp
[assembly: Repeat(3)]
```

Or you can apply the repeat policy on all the tests in a class like this:

```csharp
[Repeat(3)]
public class MyTestClass
{
}
```

The more specific attribute will always override the more general one.
For example, the `[Repeat(3)]` on a method will override the `[Repeat(5)]` on the class,
which in turn will override the `[Repeat(7)]` on the assembly.

So the order of precedence is:
1. Method
1. Class
1. Assembly

---

## Retrying


Unfortunately sometimes our tests hit issues. It could be a blip on the network, but that could cause our entire test suite to fail which is frustrating.

If you want to retry a test, add a `[RetryAttribute]` onto your test method or class. This takes an `int` of how many times you'd like to retry.

This can be used on base classes and inherited to affect all tests in sub-classes.

```csharp
using TUnit.Core;

namespace MyTestProject;

public class MyTestClass
{
    [Test]
    [Retry(3)]
    public async Task MyTest()
    {
        
    }
}
```

The basic `RetryAttribute` will retry on any exception.

If you only want to retry on certain conditions, you can create your own attribute that inherits from `RetryAttribute`. There's a `ShouldRetry` method that can be overridden, where you can access the test information and the type of exception that was thrown.

If this method returns true, the test can be retried, otherwise it'll fail.

```csharp
using TUnit.Core;

namespace MyTestProject;

public class RetryTransientHttpAttribute : RetryAttribute
{
    public RetryTransientHttpAttribute(int times) : base(times)
    {
    }

    public override Task<bool> ShouldRetry(TestContext context, Exception exception, int currentRetryCount)
    {
        if (exception is HttpRequestException requestException)
        {
            return Task.FromResult(requestException.StatusCode is
                HttpStatusCode.BadGateway
                or HttpStatusCode.TooManyRequests
                or HttpStatusCode.GatewayTimeout
                or HttpStatusCode.RequestTimeout);
        }

        return Task.FromResult(false);
    }
}

public class MyTestClass
{
    [Test]
    [RetryTransientHttp(3)]
    public async Task MyTest()
    {
        
    }
}
```

## Global Retry Policy

In case you want to apply the retry logic to all tests in a project, you can add the attribute on the assembly level.

```csharp
[assembly: Retry(3)]
```

Or you can apply the retry policy on all the tests in a class like this:

```csharp
[Retry(3)]
public class MyTestClass
{
}
```

The more specific attribute will always override the more general one.
For example, the `[Retry(3)]` on a method will override the `[Retry(5)]` on the class,
which in turn will override the `[Retry(7)]` on the assembly.

So the order of precedence is:
1. Method
1. Class
1. Assembly

---

## Test Filters


Running TUnit via `dotnet run` supports test filters.

TUnit can select tests by:

- Assembly
- Namespace
- Class name
- Test name

You must use the `--treenode-filter` flag on the command line.

The syntax for the filter value is (without the angled brackets) `/<Assembly>/<Namespace>/<Class name>/<Test name>`

Wildcards are also supported with `*`

## Filter Operators

TUnit supports several operators for building complex filters:

- **Wildcard matching:** Use `*` for pattern matching (e.g., `LoginTests*` matches `LoginTests`, `LoginTestsSuite`, etc.)
- **Equality:** Use `=` for exact match (e.g., `[Category=Unit]`)
- **Negation:** Use `!=` for excluding values (e.g., `[Category!=Performance]`)
- **AND operator:** Use `&` to combine conditions (e.g., `[Category=Unit]&[Priority=High]`)
- **OR operator:** Use `|` to match either condition within a single path segment - requires parentheses (e.g., `/*/*/(Class1)|(Class2)/*`)

For full information on the treenode filters, see [Microsoft's documentation](https://github.com/microsoft/testfx/blob/main/docs/mstest-runner-graphqueryfiltering/graph-query-filtering.md)

So an example could be:

`dotnet run --treenode-filter /*/*/LoginTests/*` - To run all tests in the class `LoginTests`

or

`dotnet run --treenode-filter /*/*/*/AcceptCookiesTest` - To run all tests with the name `AcceptCookiesTest`

TUnit also supports filtering by your own [properties](../test-lifecycle/properties.md). So you could do:

`dotnet run --treenode-filter /*/*/*/*[MyFilterName=*SomeValue*]`

And if your test had a property with the name "MyFilterName" and its value contained "SomeValue", then your test would be executed.

---

## Timeouts


If you want to stop a test after a specified amount of time, add a `[Timeout]` attribute onto your test method or class. This takes an `int` of how many milliseconds a test can execute for.

A cancellation token will be passed to tests too, which should be used where appropriate. This ensures that after the timeout is reached, operations are cancelled properly, and not wasting system resources.

This can be used on base classes and inherited to affect all tests in sub-classes.

```csharp
using TUnit.Core;

namespace MyTestProject;

public class MyTestClass
{
    [Test]
    [Timeout(30_000)]
    public async Task MyTest(CancellationToken cancellationToken)
    {
        
    }
}
```

## Global Timeout

In case you want to apply the timeout to all tests in a project, you can add the attribute on the assembly level.

```csharp
[assembly: Timeout(3000)]
```

Or you can apply the Timeout on all the tests in a class like this:

```csharp
[Timeout(3000)]
public class MyTestClass
{
}
```

The more specific attribute will always override the more general one.
For example, the `[Timeout(3000)]` on a method will override the `[Timeout(5000)]` on the class,
which in turn will override the `[Timeout(7000)]` on the assembly.

So the order of precedence is:
1. Method
1. Class
1. Assembly

---

## Dynamically Created Tests


TUnit offers the ability to create your tests via dynamic code, as opposed to the standard `[Test]` attribute and data attributes.

To do this, create a new class with a public parameterless constructor.

Then, create a public method, called whatever you like, with a single parameter of `DynamicTestBuilderContext`, and place the `[DynamicTestBuilder]` attribute on that method.

On the `context` parameter, you can call `.AddTest(...)`, and pass it a `new DynamicTest<T>`.

`T` is the class containing the method you want to invoke.
If your class contains parameters or properties, or your method contains parameters, you can pass these into the test parameter

For simple tests, there is not much point using this feature. But it may be helpful when wanting to generate lots of test cases with different data.

Here's an example:

```csharp
public class Basic
{
    public void SomeMethod(string name)
    {
        Console.WriteLine($"Hello, {name}!");
    }

    [DynamicTestBuilder]
    public void BuildTests(DynamicTestBuilderContext context)
    {
        context.AddTest(new DynamicTest<Basic>
        {
            TestMethod = @class => @class.SomeMethod(DynamicTestHelper.Argument<string>()),
            TestMethodArguments = ["Tom"],
            Attributes = [new RepeatAttribute(5)]
        });
    }
}
```

The test method body is used as an `Expression` - Not as a `delegate`. This means that arguments passed to it within the lambda will be ignored. And if the method is async, it does not need to be awaited.
Arguments must be provided via the `TestMethodArguments` property.

To make this clearer, it's recommended to use the `DynamicTestHelper.Argument<T>()` helper.

It is also possible to build a test from within another test:

```csharp
[Arguments(1, 2, 3)]
[Arguments(101, 202, 303)]
public class Runtime(int a, int b, int c)
{
    public void SomeMethod(int arg1, int arg2, int arg3)
    {
        Console.WriteLine("SomeMethod called with:");
        Console.WriteLine($"Class args: {a}, {b}, {c}");
        Console.WriteLine($"Method args: {arg1}, {arg2}, {arg3}");
    }

    [Test]
    [Arguments(4, 5, 6)]
    [Arguments(404, 505, 606)]
    public async Task BuildTests(int d, int e, int f)
    {
        var context = TestContext.Current!;

        await context.AddDynamicTest(new DynamicTest<Runtime>
        {
            TestMethod = @class => @class.SomeMethod(0, 0, 0),
            TestClassArguments = [a + 10, b + 10, c + 10],
            TestMethodArguments = [d + 10, e + 10, f + 10],
            Attributes = [new RepeatAttribute(5)]
        });
    }
}
```

---

## Extensions


As TUnit is built on top of Microsoft.Testing.Platform, it can tap into generic testing extension packages.

## Built-In Extensions

The following extensions are **automatically included** when you install the **TUnit** meta package:

- **Code Coverage** - via `Microsoft.Testing.Extensions.CodeCoverage`
- **TRX Test Reports** - via `Microsoft.Testing.Extensions.TrxReport`
- **Telemetry** - via `Microsoft.Testing.Extensions.Telemetry`

:::tip Opting Out of Built-In Extensions
If you don't want these extensions, you can reference `TUnit.Engine` and `TUnit.Assertions` packages separately instead of the `TUnit` meta package.

```xml
<!-- Instead of the TUnit meta package -->
<PackageReference Include="TUnit.Engine" Version="x.x.x" />
<PackageReference Include="TUnit.Assertions" Version="x.x.x" />
```
:::

### Code Coverage

Code coverage is provided via the `Microsoft.Testing.Extensions.CodeCoverage` NuGet package.

**✅ Included automatically with the TUnit package** - No manual installation needed!

#### Usage

Run your tests with the `--coverage` flag:
```bash
# Basic coverage
dotnet run --configuration Release --coverage

# Specify output location
dotnet run --configuration Release --coverage --coverage-output ./coverage/

# Specify output format (cobertura is default)
dotnet run --configuration Release --coverage --coverage-output-format cobertura

# Multiple formats
dotnet run --configuration Release --coverage \
  --coverage-output-format cobertura \
  --coverage-output-format xml
```

#### Important: Coverlet Incompatibility ⚠️

**If you're migrating from xUnit, NUnit, or MSTest:**

- **Remove Coverlet** (`coverlet.collector` or `coverlet.msbuild`) from your project
- TUnit uses Microsoft.Testing.Platform (not VSTest), which is incompatible with Coverlet
- Microsoft.Testing.Extensions.CodeCoverage is the modern replacement and provides the same functionality

**Migration Example:**
```xml
<!-- Remove from your .csproj -->
<PackageReference Include="coverlet.collector" Version="x.x.x" />
<PackageReference Include="coverlet.msbuild" Version="x.x.x" />

<!-- Already included with TUnit meta package -->
<PackageReference Include="TUnit" Version="0.x.x" />
```

See the migration guides for detailed instructions:
- [xUnit Migration Guide - Code Coverage](../migration/xunit.md#code-coverage)
- [NUnit Migration Guide - Code Coverage](../migration/nunit.md#code-coverage)
- [MSTest Migration Guide - Code Coverage](../migration/mstest.md#code-coverage)

#### Advanced Configuration

You can customize coverage with a `testconfig.json` file:

**testconfig.json:**
```json
{
  "codeCoverage": {
    "Configuration": {
      "CodeCoverage": {
        "ModulePaths": {
          "Include": [".*\\.dll$"],
          "Exclude": [".*tests\\.dll$"]
        }
      }
    }
  }
}
```

Place the `testconfig.json` file in the same directory as your test project. It will be picked up automatically when running tests.

**Alternatively, you can use an XML coverage settings file:**
```bash
dotnet run --configuration Release --coverage --coverage-settings coverage.config
```

**📚 More Resources:**
- [Microsoft's Code Coverage Documentation](https://learn.microsoft.com/en-us/dotnet/core/testing/unit-testing-platform-extensions-code-coverage)
- [Unit Testing Code Coverage Guide](https://learn.microsoft.com/en-us/dotnet/core/testing/unit-testing-code-coverage)

---

### TRX Test Reports

TRX reports are provided via the `Microsoft.Testing.Extensions.TrxReport` NuGet package.

**✅ Included automatically with the TUnit package** - No manual installation needed!

#### Usage

Run your tests with the `--report-trx` flag:
```bash
# Generate TRX report
dotnet run --configuration Release --report-trx

# Specify output location
dotnet run --configuration Release --results-directory ./reports --report-trx --report-trx-filename testresults.trx
```

**📚 More Resources:**
- [Microsoft's TRX Report Documentation](https://learn.microsoft.com/en-us/dotnet/core/testing/unit-testing-platform-extensions-test-reports)

---

### Telemetry

Telemetry is provided via the `Microsoft.Testing.Extensions.Telemetry` NuGet package.

**✅ Included automatically with the TUnit package**

This extension enables Microsoft to collect anonymous usage metrics to help improve the testing platform. No personal data or source code is collected.

#### Opting Out

You can disable telemetry by setting an environment variable:

```bash
# Linux/macOS
export TESTINGPLATFORM_TELEMETRY_OPTOUT=1

# Windows
set TESTINGPLATFORM_TELEMETRY_OPTOUT=1
```

Alternatively, you can use `DOTNET_CLI_TELEMETRY_OPTOUT=1` which also disables .NET SDK telemetry.

**📚 More Resources:**
- [Microsoft.Testing.Platform Telemetry Documentation](https://learn.microsoft.com/en-us/dotnet/core/testing/microsoft-testing-platform-telemetry)

---

## Optional Extensions

These extensions are **not** included with the TUnit package and must be installed manually if needed.

## Crash Dump
Crash dump is an extension to help diagnose unexplained crashes, provided via the `Microsoft.Testing.Extensions.CrashDump` NuGet package.

[More information can be found here](https://learn.microsoft.com/en-us/dotnet/core/testing/unit-testing-platform-extensions-diagnostics)

## Hang Dump
Hang dump is an extension to help diagnose unexplained hanging in your test suite, provided via the `Microsoft.Testing.Extensions.HangDump` NuGet package.

[More information can be found here](https://learn.microsoft.com/en-us/dotnet/core/testing/unit-testing-platform-extensions-diagnostics)

---

## Installing TUnit


## Easily

Assuming you have the .NET SDK installed, simply run:

`dotnet new install TUnit.Templates`

`dotnet new TUnit -n "YourProjectName"`

A new test project will be created for you with some samples of different test types and tips. When you're ready to get going, delete them and create your own!

## Manually

First create an empty .NET console application:

```powershell
dotnet new console --name YourTestProjectNameHere
```

To that project add the `TUnit` package:

```powershell
cd YourTestProjectNameHere
dotnet add package TUnit --prerelease
```

And then remove any automatically generated `Program.cs` or main method, as this'll be taken care of by the TUnit package.

### Global Usings

The TUnit package automatically configures global usings for common TUnit namespaces, so your test files don't need to include using statements for:

- `TUnit.Core` (for `[Test]` attribute)
- `TUnit.Assertions` (for `Assert.That()`)
- `TUnit.Assertions.Extensions` (for assertion methods)

This means your test files can be as simple as:

```csharp
namespace MyTests;

public class MyTests  // No [TestClass] needed!
{
    [Test]  // Available without explicit using statement
    public async Task MyTest()
    {
        await Assert.That(true).IsTrue();  // Assert is available automatically
    }
}
```

### What's Included in the TUnit Package

When you install the **TUnit** meta package, you automatically get several useful extensions without any additional installation:

#### ✅ Built-In Extensions

**Microsoft.Testing.Extensions.CodeCoverage**
- 📊 Code coverage support via `--coverage` flag
- 📈 Outputs Cobertura and XML formats
- 🔄 Replacement for Coverlet (which is **not compatible** with TUnit)

**Microsoft.Testing.Extensions.TrxReport**
- 📝 TRX test report generation via `--report-trx` flag
- 🤝 Compatible with Azure DevOps and other CI/CD systems

This means you can run tests with coverage and reports right away:

```bash
# Run tests with code coverage
dotnet run --configuration Release --coverage

# Run tests with TRX report
dotnet run --configuration Release --report-trx

# Both coverage and report
dotnet run --configuration Release --coverage --report-trx
```

**Important:** Do **not** install `coverlet.collector` or `coverlet.msbuild`. These packages are incompatible with TUnit because they require the VSTest platform, while TUnit uses the modern Microsoft.Testing.Platform.

For more details, see:
- [Code Coverage Documentation](../extensions/extensions.md#code-coverage)
- [Extensions Overview](../extensions/extensions.md)

That's it. We're ready to write our first test.

Your `.csproj` should be as simple as something like:

```xml
<Project Sdk="Microsoft.NET.Sdk">

    <PropertyGroup>
        <OutputType>Exe</OutputType>
        <TargetFramework>net8.0</TargetFramework>
        <ImplicitUsings>enable</ImplicitUsings>
        <Nullable>enable</Nullable>
    </PropertyGroup>

    <ItemGroup>
      <PackageReference Include="TUnit" Version="*" />
    </ItemGroup>

</Project>
```

:::danger

If you're used to other testing frameworks, you're probably used to the package `Microsoft.NET.Test.Sdk`.
This should NOT be used with TUnit. It'll stop test discovery from working properly.

:::

## .NET Framework
If you are still targeting .NET Framework, TUnit will try to Polyfill some missing types that are used by the compiler, such as the `ModuleInitialiserAttribute`.

If you have issues with other Polyfill libraries also defining them, in your project files, you can define the property `<EnableTUnitPolyfills>false</EnableTUnitPolyfills>` to stop TUnit generating them for you.

### Central Package Management (CPM)
TUnit is fully compatible with NuGet Central Package Management. When CPM is enabled (via `Directory.Packages.props`), TUnit will automatically inject the Polyfill package using `VersionOverride`, so you don't need to manually add it to your `Directory.Packages.props` file.

If you prefer to manage the Polyfill version yourself, you can:
- Add `<PackageVersion Include="Polyfill" Version="x.x.x" />` to your `Directory.Packages.props`, OR
- Disable automatic injection with `<EnableTUnitPolyfills>false</EnableTUnitPolyfills>` and add it manually

### Embedded Polyfill Attributes
TUnit automatically sets `<PolyUseEmbeddedAttribute>true</PolyUseEmbeddedAttribute>` to ensure that Polyfill types are embedded in each project. This prevents type conflicts when using `InternalsVisibleTo` or when multiple projects in your solution reference Polyfill. Each project gets its own isolated copy of the polyfill types, following the [recommended Polyfill consuming pattern](https://github.com/SimonCropp/Polyfill/blob/main/consuming.md#recommended-consuming-pattern).

You can override this behavior by setting `<PolyUseEmbeddedAttribute>false</PolyUseEmbeddedAttribute>` in your project file if needed.

---

## Running your tests


As TUnit is built on-top of the newer Microsoft.Testing.Platform, and combined with the fact that TUnit tests are source generated, running your tests is available in a variety of ways.

:::info

Please note that for the coverage and trx report, you need to install [additional extensions](../extensions/extensions.md)

:::

## [dotnet run](https://learn.microsoft.com/en-us/dotnet/core/tools/dotnet-run)

For a simple execution of a project, `dotnet run` is the preferred method, allowing easier passing in of command line flags.

```powershell
cd 'C:/Your/Test/Directory'
dotnet run -c Release
# or with flags
dotnet run -c Release --report-trx --coverage
```

## [dotnet test](https://learn.microsoft.com/en-us/dotnet/core/tools/dotnet-test)

`dotnet test` requires any command line flags to be specified as application arguments, meaning after a `--` - Otherwise you'll get an error about unknown switches.

```powershell
cd 'C:/Your/Test/Directory'
dotnet test -c Release
# or with flags
dotnet test -c Release -- --report-trx --coverage
```

## [dotnet exec](https://learn.microsoft.com/en-us/dotnet/core/tools/dotnet)

If your test project has already been built, you can use `dotnet exec` or just `dotnet` with the `.dll` path

```powershell
cd 'C:/Your/Test/Directory/bin/Release/net8.0'
dotnet exec YourTestProject.dll
# or with flags
dotnet exec YourTestProject.dll --report-trx --coverage
```

or

```powershell
cd 'C:/Your/Test/Directory/bin/Release/net8.0'
dotnet YourTestProject.dll
# or with flags
dotnet YourTestProject.dll --report-trx --coverage
```

## Published Test Project

When you publish your test project, you'll be given an executable.
On windows this'll be a `.exe` and on Linux/MacOS there'll be no extension.

This can be invoked directly and passed any flags.

```powershell
cd 'C:/Your/Test/Directory/bin/Release/net8.0/win-x64/publish'
./YourTestProject.exe
# or with flags
./YourTestProject.exe --report-trx --coverage
```

# IDE Support

## Visual Studio
Visual Studio is supported. The "Use testing platform server mode" option must be selected in Tools > Manage Preview Features.

![Visual Studio Settings](../../static/img/visual-studio.png)

## Rider
Rider is supported.

The Enable Testing Platform support option must be selected in Settings > Build, Execution, Deployment > Unit Testing > Testing Platform.

![Rider Settings](../../static/img/rider.png)

## VS Code
Visual Studio Code is supported.

- Install the extension Name: [C# Dev Kit](https://marketplace.visualstudio.com/items?itemName=ms-dotnettools.csdevkit)
- Go to the C# Dev Kit extension's settings
- Enable Dotnet > Test Window > Use Testing Platform Protocol

![Visual Studio Code Settings](../../static/img/visual-studio-code.png)

## What's Next?

You've successfully learned the basics of TUnit! You can now:
- Write tests with the `[Test]` attribute
- Run them via command line or your IDE
- See your test results

To continue your journey with TUnit, explore these topics:

**Core Testing Concepts:**
- **[Assertions](../assertions/getting-started.md)** - Learn TUnit's fluent assertion syntax
- **[Test Lifecycle](../test-lifecycle/setup.md)** - Set up and tear down test state with hooks
- **[Data-Driven Testing](../test-authoring/arguments.md)** - Run tests with multiple input values

**Common Tasks:**
- **[Mocking](../test-authoring/mocking.md)** - Use mocks and fakes in your tests
- **[Best Practices](../guides/best-practices.md)** - Write maintainable, reliable tests
- **[Cookbook](../guides/cookbook.md)** - Common testing patterns and recipes

**Advanced Features:**
- **[Parallelism](../parallelism/not-in-parallel.md)** - Control how tests run in parallel
- **[CI/CD Integration](../execution/ci-cd-reporting.md)** - Integrate TUnit into your pipeline

Need help? Check the [Troubleshooting & FAQ](../troubleshooting.md) guide.

---

## Writing your first test


## Quick Start: Complete Example

Here's a complete TUnit test class with all necessary using statements:

```csharp
using TUnit.Assertions;
using TUnit.Assertions.Extensions;
using TUnit.Core;

namespace MyTestProject;

public class CalculatorTests
{
    [Test]
    public async Task Add_WithTwoNumbers_ReturnsSum()
    {
        // Arrange
        var calculator = new Calculator();

        // Act
        var result = calculator.Add(2, 3);

        // Assert
        await Assert.That(result).IsEqualTo(5);
    }
}
```

**Important**: TUnit does **not** require a `[TestClass]` attribute. Unlike MSTest or NUnit, you only need the `[Test]` attribute on your test methods.

## Step-by-Step Guide

Start by creating a new class:

```csharp
namespace MyTestProject;

public class MyTestClass
{

}
```

Now add a method with a `[Test]` attribute on it:

```csharp
using TUnit.Core;

namespace MyTestProject;

public class MyTestClass
{
    [Test]
    public async Task MyTest()
    {

    }
}
```

That's it. That is your runnable test.

We haven't actually made it do anything yet, but we should be able to build our project and run that test.

Tests will pass if they execute successfully without any exceptions.

## Test Method Signatures

Test methods can be either synchronous or asynchronous:

```csharp
[Test]
public void SynchronousTest()  // ✅ Valid - synchronous test
{
    var result = Calculate(2, 3);
    // Simple synchronous test without assertions
}

[Test]
public async Task AsyncTestWithAssertions()  // ✅ Recommended - asynchronous test
{
    var result = Calculate(2, 3);
    await Assert.That(result).IsEqualTo(5);  // Assertions must be awaited
}
```

**Important Notes:**
- If you use TUnit's assertion library (`Assert.That(...)`), your test **must** be `async Task` because assertions return awaitable objects that must be awaited to execute
- Synchronous `void` tests are allowed but cannot use assertions
- `async void` tests are **not allowed** and will cause a compiler error
- **Best Practice**: Use `async Task` for all tests to enable TUnit's assertion library
- **Technical Detail**: Assertions return custom assertion builder objects with a `GetAwaiter()` method, making them awaitable

Let's add some code to show you how a test might look once finished:

```csharp
using TUnit.Assertions;
using TUnit.Assertions.Extensions;
using TUnit.Core;

namespace MyTestProject;

public class MyTestClass
{
    [Test]
    public async Task MyTest()
    {
        var result = Add(1, 2);

        await Assert.That(result).IsEqualTo(3);
    }

    private int Add(int x, int y)
    {
        return x + y;
    }
}
```

Here you can see we've executed some code and added an assertion. We'll go more into that later.

## Common Test Patterns

### Testing Boolean Returns

When testing methods that return boolean values, use `IsTrue()` or `IsFalse()`:

```csharp
using TUnit.Assertions;
using TUnit.Assertions.Extensions;
using TUnit.Core;

namespace MyTestProject;

public class ValidatorTests
{
    [Test]
    public async Task IsPositive_WithNegativeNumber_ReturnsFalse()
    {
        // Arrange & Act
        var result = Validator.IsPositive(-1);

        // Assert
        await Assert.That(result).IsFalse();
    }

    [Test]
    public async Task IsPositive_WithPositiveNumber_ReturnsTrue()
    {
        // Arrange & Act
        var result = Validator.IsPositive(5);

        // Assert
        await Assert.That(result).IsTrue();
    }
}

public static class Validator
{
    public static bool IsPositive(int number)
    {
        return number > 0;
    }
}
```

### Testing with Multiple Assertions

```csharp
using TUnit.Assertions;
using TUnit.Assertions.Extensions;
using TUnit.Core;

namespace MyTestProject;

public class StringTests
{
    [Test]
    public async Task ProcessString_WithValidInput_ReturnsExpectedResult()
    {
        // Arrange
        var input = "hello";

        // Act
        var result = input.ToUpper();

        // Assert
        await Assert.That(result).IsEqualTo("HELLO");
        await Assert.That(result).Length().IsEqualTo(5);
        await Assert.That(result.StartsWith("HE")).IsTrue();
    }
}
```

### Using Statements

The examples above show explicit using statements for clarity:

```csharp
using TUnit.Core;                    // For [Test] attribute
using TUnit.Assertions;              // For Assert.That()
using TUnit.Assertions.Extensions;   // For assertion methods like IsEqualTo(), IsTrue(), etc.
```

**However**, the TUnit package automatically configures these namespaces as global usings, so in practice you don't need to include them in each test file. Your test classes can be as simple as:

```csharp
namespace MyTestProject;

public class ValidatorTests
{
    [Test]
    public async Task IsPositive_WithNegativeNumber_ReturnsFalse()
    {
        var result = Validator.IsPositive(-1);
        await Assert.That(result).IsFalse();
    }
}
```

---

## Best Practices


This guide covers best practices for writing clean, maintainable, and robust tests with TUnit. Following these patterns will help you create a test suite that's easy to understand and maintain over time.

## Test Naming

### Use Descriptive Names

Good test names clearly describe what's being tested and what's expected. A common pattern is `Method_Scenario_ExpectedBehavior`:

```csharp
// ✅ Good: Clearly describes what's being tested
[Test]
public async Task CalculateTotal_WithDiscount_ReturnsReducedPrice()
{
    var calculator = new PriceCalculator();
    var result = calculator.CalculateTotal(100, discount: 0.2);
    await Assert.That(result).IsEqualTo(80);
}

// ❌ Bad: Vague and unclear
[Test]
public async Task Test1()
{
    var calculator = new PriceCalculator();
    var result = calculator.CalculateTotal(100, 0.2);
    await Assert.That(result).IsEqualTo(80);
}
```

### Alternative Naming Patterns

You can also use sentence-like names that read naturally:

```csharp
[Test]
public async Task When_discount_is_applied_total_is_reduced()
{
    // Test implementation
}

[Test]
public async Task Should_return_reduced_price_when_discount_applied()
{
    // Test implementation
}
```

Pick a naming convention and stick to it throughout your project for consistency.

## Test Organization

### One Test Class Per Production Class

Organize your tests to mirror your production code structure:

```
MyApp/
  Services/
    OrderService.cs
    PaymentService.cs

MyApp.Tests/
  Services/
    OrderServiceTests.cs
    PaymentServiceTests.cs
```

This makes it easy to find tests and keeps your test suite organized as your codebase grows.

### Group Related Tests

Use nested classes or separate test classes to group related test scenarios:

```csharp
public class OrderServiceTests
{
    public class CreateOrder
    {
        [Test]
        public async Task Creates_order_with_valid_data()
        {
            // Test implementation
        }

        [Test]
        public async Task Throws_exception_when_user_not_found()
        {
            // Test implementation
        }
    }

    public class CancelOrder
    {
        [Test]
        public async Task Cancels_order_successfully()
        {
            // Test implementation
        }

        [Test]
        public async Task Throws_when_order_already_shipped()
        {
            // Test implementation
        }
    }
}
```

### Keep Test Files Focused

Each test file should focus on testing a single class or component. If your test file is getting large (>500 lines), consider splitting it into multiple files or using nested classes.

## Assertion Best Practices

### Prefer Specific Assertions

Use the most specific assertion available for better failure messages:

```csharp
// ✅ Good: Specific assertion with clear failure message
await Assert.That(result).IsEqualTo(5);
// Failure: Expected 5 but was 3

// ❌ Okay but less helpful: Generic boolean assertion
await Assert.That(result == 5).IsTrue();
// Failure: Expected true but was false
```

### One Logical Assertion Per Test

Each test should verify one specific behavior. Multiple assertions are fine if they're testing different aspects of the same behavior:

```csharp
// ✅ Good: Multiple assertions testing one behavior (user creation)
[Test]
public async Task CreateUser_SetsAllProperties()
{
    var user = await userService.CreateUser("john@example.com", "John Doe");

    await Assert.That(user.Email).IsEqualTo("john@example.com");
    await Assert.That(user.Name).IsEqualTo("John Doe");
    await Assert.That(user.CreatedAt).IsNotEqualTo(default(DateTime));
}

// ❌ Bad: Testing multiple unrelated behaviors
[Test]
public async Task UserService_Works()
{
    var user = await userService.CreateUser("john@example.com", "John");
    await Assert.That(user.Email).IsEqualTo("john@example.com");

    await userService.DeleteUser(user.Id);
    var deleted = await userService.GetUser(user.Id);
    await Assert.That(deleted).IsNull();
}
```

### Always Await Assertions

TUnit assertions are async and must be awaited. Forgetting `await` means the assertion never runs:

```csharp
// ❌ Wrong: Assertion returns Task that's never awaited
[Test]
public async Task MyTest()
{
    Assert.That(result).IsEqualTo(5);  // Test passes without checking!
}

// ✅ Correct: Assertion is awaited and executed
[Test]
public async Task MyTest()
{
    await Assert.That(result).IsEqualTo(5);
}
```

The compiler will warn you about unawaited tasks, but watch for this common mistake.

## Test Lifecycle Management

### Use Hooks for Setup and Cleanup

TUnit provides several hooks for test lifecycle management. Use them to keep your test logic clean:

```csharp
public class DatabaseTests
{
    private TestDatabase? _database;

    [Before(Test)]
    public async Task SetupDatabase()
    {
        _database = await TestDatabase.CreateAsync();
    }

    [After(Test)]
    public async Task CleanupDatabase()
    {
        if (_database != null)
            await _database.DisposeAsync();
    }

    [Test]
    public async Task Can_insert_record()
    {
        // Database is ready to use
        await _database!.InsertAsync(new Record { Id = 1 });
        var result = await _database.GetAsync(1);
        await Assert.That(result).IsNotNull();
    }
}
```

### Choose the Right Hook Level

- `[Before(Test)]` / `[After(Test)]`: Runs before/after each test (most common)
- `[Before(Class)]` / `[After(Class)]`: Runs once per test class
- `[Before(Assembly)]` / `[After(Assembly)]`: Runs once per test assembly

### Sharing Expensive Resources

For expensive setup that needs to be shared across tests (like web servers, databases, or containers), use `[ClassDataSource<>]` with shared types and `IAsyncInitializer`/`IAsyncDisposable`:

```csharp
// ✅ Best: Shared resource with ClassDataSource
public class TestWebServer : IAsyncInitializer, IAsyncDisposable
{
    public WebApplicationFactory<Program>? Factory { get; private set; }

    public async Task InitializeAsync()
    {
        Factory = new WebApplicationFactory<Program>();
        await Task.CompletedTask;
    }

    public async ValueTask DisposeAsync()
    {
        if (Factory != null)
            await Factory.DisposeAsync();
    }
}

[ClassDataSource<TestWebServer>(Shared = SharedType.PerTestSession)]
public class ApiTests(TestWebServer server)
{
    [Test]
    public async Task Can_call_endpoint()
    {
        var client = server.Factory!.CreateClient();
        var response = await client.GetAsync("/api/health");
        await Assert.That(response.IsSuccessStatusCode).IsTrue();
    }

    [Test]
    public async Task Can_get_users()
    {
        var client = server.Factory!.CreateClient();
        var response = await client.GetAsync("/api/users");
        await Assert.That(response.IsSuccessStatusCode).IsTrue();
    }
}
```

**Why this is better:**
- Keeps test files simpler (no static fields or Before/After hooks)
- Shared resources work across multiple test classes
- Can share across assemblies using `SharedType.PerTestSession`
- Cleaner lifecycle management with `IAsyncInitializer`/`IAsyncDisposable`
- Type-safe dependency injection into test constructors

**Shared Type Options:**
- `SharedType.PerTestSession`: One instance for entire test run, shared across assemblies (best for expensive resources)
- `SharedType.PerClass`: One instance per test class
- `SharedType.None`: New instance per test (default)

You can also use hooks, but they're less flexible:

```csharp
// ❌ Less flexible: Using hooks for shared setup
public class ApiTests
{
    private static WebApplicationFactory<Program>? _factory;

    [Before(Class)]
    public static async Task StartServer()
    {
        _factory = new WebApplicationFactory<Program>();
    }

    [After(Class)]
    public static async Task StopServer()
    {
        _factory?.Dispose();
    }

    // Tests use static _factory field
}
```

### Avoid Complex Setup Logic

Keep your setup code simple and focused. If setup is complex, extract it to helper methods:

```csharp
// ✅ Good: Simple setup with extracted helpers
[Before(Test)]
public async Task Setup()
{
    _database = await CreateTestDatabase();
    _testUser = await CreateTestUser();
}

private async Task<TestDatabase> CreateTestDatabase()
{
    var db = await TestDatabase.CreateAsync();
    await db.SeedDefaultData();
    return db;
}

// ❌ Bad: Complex setup logic in hook
[Before(Test)]
public async Task Setup()
{
    _database = await TestDatabase.CreateAsync();
    await _database.ExecuteAsync("CREATE TABLE Users (...)");
    await _database.ExecuteAsync("INSERT INTO Users VALUES (...)");
    await _database.ExecuteAsync("CREATE TABLE Orders (...)");
    // ... lots more setup code
}
```

## Parallelism Guidance

### Tests Run in Parallel By Default

TUnit runs tests in parallel for better performance. Write your tests to be independent:

```csharp
// ✅ Good: Test is self-contained and independent
[Test]
public async Task Can_create_order()
{
    var orderId = Guid.NewGuid();  // Unique ID
    var order = new Order { Id = orderId, Total = 100 };
    await orderService.CreateAsync(order);

    var result = await orderService.GetAsync(orderId);
    await Assert.That(result).IsNotNull();
}
```

### Use NotInParallel When Needed

Some tests can't run in parallel (database tests, file system tests). Use `[NotInParallel]`:

```csharp
// Tests that modify shared state
[Test, NotInParallel]
public async Task Updates_configuration_file()
{
    await ConfigurationManager.SetAsync("key", "value");
    var result = await ConfigurationManager.GetAsync("key");
    await Assert.That(result).IsEqualTo("value");
}
```

### Control Execution Order

When tests need to run in a specific order, use `[DependsOn]` instead of `NotInParallel` with `Order`:

```csharp
// ✅ Good: Use DependsOn for ordering while maintaining parallelism
[Test]
public async Task Step1_CreateUser()
{
    // Runs first
}

[Test]
[DependsOn(nameof(Step1_CreateUser))]
public async Task Step2_UpdateUser()
{
    // Runs after Step1_CreateUser completes
    // Other unrelated tests can still run in parallel
}

[Test]
[DependsOn(nameof(Step2_UpdateUser))]
public async Task Step3_DeleteUser()
{
    // Runs after Step2_UpdateUser completes
}
```

**Why `[DependsOn]` is better:**
- More intuitive: explicitly declares dependencies between tests
- More flexible: tests can depend on multiple other tests
- Maintains parallelism: unrelated tests still run in parallel
- Better for complex workflows: clear dependency chains

You can also use `NotInParallel` with `Order`, but this forces sequential execution:

```csharp
// ❌ Less flexible: Forces all tests to run sequentially
[Test, NotInParallel(Order = 1)]
public async Task Step1_CreateUser()
{
    // Runs first
}

[Test, NotInParallel(Order = 2)]
public async Task Step2_UpdateUser()
{
    // Runs second, but blocks all other tests
}
```

**Important:** If tests need ordering, they might be too tightly coupled. Consider:
- Refactoring into a single test
- Using proper setup/teardown
- Making tests truly independent

### Use Parallel Groups

Group related tests that can't run in parallel with each other but can run in parallel with other groups:

```csharp
public class FileSystemTests
{
    // These tests can't run in parallel with each other
    // but can run in parallel with DatabaseTests

    [Test, NotInParallel("FileGroup")]
    public async Task Test1_WritesFile()
    {
        // Test implementation
    }

    [Test, NotInParallel("FileGroup")]
    public async Task Test2_ReadsFile()
    {
        // Test implementation
    }
}

public class DatabaseTests
{
    [Test, NotInParallel("DbGroup")]
    public async Task Test1_InsertsRecord()
    {
        // Runs in parallel with FileSystemTests
    }
}
```

## Common Anti-Patterns to Avoid

### Avoid Test Interdependence

Each test should be completely independent and not rely on other tests:

```csharp
// ❌ Bad: Tests depend on execution order
private static User? _user;

[Test]
public async Task Test1_CreateUser()
{
    _user = await userService.CreateAsync("john@example.com");
}

[Test]
public async Task Test2_UpdateUser()
{
    // Assumes Test1 ran first!
    _user!.Name = "Jane Doe";
    await userService.UpdateAsync(_user);
}

// ✅ Good: Each test is independent
[Test]
public async Task Can_create_user()
{
    var user = await userService.CreateAsync("john@example.com");
    await Assert.That(user.Email).IsEqualTo("john@example.com");
}

[Test]
public async Task Can_update_user()
{
    var user = await userService.CreateAsync("jane@example.com");
    user.Name = "Jane Doe";
    await userService.UpdateAsync(user);

    var updated = await userService.GetAsync(user.Id);
    await Assert.That(updated.Name).IsEqualTo("Jane Doe");
}
```

### Avoid Shared Instance State

**Important:** TUnit creates a new instance of your test class for each test method. Don't rely on instance fields to share state:

```csharp
// ❌ Bad: Trying to share instance state between tests
public class MyTests
{
    private int _value;  // Different instance per test!

    [Test, NotInParallel]
    public void Test1()
    {
        _value = 99;
    }

    [Test, NotInParallel]
    public async Task Test2()
    {
        await Assert.That(_value).IsEqualTo(99);  // Fails! _value is 0
    }
}

// ✅ Good: Use static fields if you really need shared state
public class MyTests
{
    private static int _value;  // Shared across all tests

    [Test, NotInParallel]
    public void Test1()
    {
        _value = 99;
    }

    [Test, NotInParallel]
    public async Task Test2()
    {
        await Assert.That(_value).IsEqualTo(99);  // Works!
    }
}
```

But seriously: if tests need to share state, reconsider your design. It's usually better to make tests independent.

### Avoid Complex Test Logic

Tests should be simple and easy to understand. Avoid complex conditionals, loops, or calculations:

```csharp
// ❌ Bad: Complex logic in test
[Test]
public async Task CalculatesTotals()
{
    var items = await GetItems();
    decimal expected = 0;
    foreach (var item in items)
    {
        if (item.IsDiscounted)
            expected += item.Price * 0.8m;
        else
            expected += item.Price;
    }

    var result = calculator.CalculateTotal(items);
    await Assert.That(result).IsEqualTo(expected);
}

// ✅ Good: Simple, explicit test
[Test]
public async Task CalculateTotal_WithMixedItems()
{
    var items = new[]
    {
        new Item { Price = 100, IsDiscounted = false },  // 100
        new Item { Price = 50, IsDiscounted = true }     // 40
    };

    var result = calculator.CalculateTotal(items);
    await Assert.That(result).IsEqualTo(140);
}
```

If your test has complex logic, you're essentially writing code to test code. Keep it simple!

### Avoid Over-Mocking

Don't mock everything. Use real implementations when they're fast and reliable:

```csharp
// ❌ Bad: Mocking things that don't need mocking
[Test]
public async Task ProcessOrder()
{
    var mockLogger = new Mock<ILogger>();
    var mockValidator = new Mock<IValidator>();
    var mockCalculator = new Mock<IPriceCalculator>();
    var mockRepository = new Mock<IOrderRepository>();

    // So much setup...
}

// ✅ Good: Only mock expensive or external dependencies
[Test]
public async Task ProcessOrder()
{
    var logger = new NullLogger();  // Real lightweight implementation
    var validator = new OrderValidator();  // Real validator is fast
    var calculator = new PriceCalculator();  // Simple calculations
    var mockRepository = new Mock<IOrderRepository>();  // Mock database

    // Much simpler!
}
```

Mock external dependencies (databases, APIs, file systems) but use real implementations for simple logic.

### Avoid Testing Implementation Details

Test behavior, not implementation. Your tests should verify what the code does, not how it does it:

```csharp
// ❌ Bad: Testing internal implementation
[Test]
public async Task ProcessOrder_CallsRepositorySaveMethod()
{
    var mockRepository = new Mock<IOrderRepository>();
    var service = new OrderService(mockRepository.Object);

    await service.ProcessOrder(order);

    // Verifying method calls instead of behavior
    mockRepository.Verify(r => r.Save(It.IsAny<Order>()), Times.Once);
}

// ✅ Good: Testing actual behavior
[Test]
public async Task ProcessOrder_SavesOrderToDatabase()
{
    var repository = new InMemoryOrderRepository();
    var service = new OrderService(repository);

    await service.ProcessOrder(order);

    // Verifying the result
    var saved = await repository.GetAsync(order.Id);
    await Assert.That(saved).IsNotNull();
    await Assert.That(saved.Status).IsEqualTo(OrderStatus.Processed);
}
```

Tests that verify implementation details are brittle and break when you refactor.

## Performance Considerations

TUnit is designed for performance at scale. Follow these guidelines to keep your test suite fast:

### Optimize Test Discovery

- Use AOT mode for faster test discovery and lower memory usage
- Keep data sources lightweight (see [Performance Best Practices](../advanced/performance-best-practices.md))
- Limit matrix test combinations to avoid test explosion

### Optimize Test Execution

- Let tests run in parallel (it's fast!)
- Only use `[NotInParallel]` when absolutely necessary
- Configure parallelism using the `--maximum-parallel-tests` CLI flag or `[assembly: ParallelLimiter<T>]` attribute
- Avoid expensive setup in `[Before(Test)]` hooks - use class or assembly-level hooks for shared resources

### Avoid Slow Operations in Tests

Tests should be fast. If a test takes more than a few seconds, look for optimization opportunities:

```csharp
// ❌ Slow: Real HTTP calls
[Test]
public async Task GetUserData()
{
    var client = new HttpClient();
    var response = await client.GetAsync("https://api.example.com/users");
    // Slow and unreliable
}

// ✅ Fast: Use in-memory test doubles
[Test]
public async Task GetUserData()
{
    var client = new TestHttpClient();  // In-memory fake
    var response = await client.GetAsync("/users");
    // Fast and reliable
}
```

For detailed performance guidance, see [Performance Best Practices](../advanced/performance-best-practices.md).

## Summary

Following these best practices will help you:

- Write tests that are easy to understand and maintain
- Create a fast, reliable test suite that scales
- Catch bugs without introducing brittle tests
- Make your codebase more maintainable over time

Remember: good tests are simple, focused, independent, and fast. When in doubt, ask yourself: "Will someone else understand what this test is doing and why it might fail?"

---

## Testing Cookbook


This cookbook provides practical, copy-paste examples for common testing scenarios with TUnit. Each recipe is a complete, working example you can adapt for your own tests.

## Dependency Injection Testing

### Testing with Microsoft.Extensions.DependencyInjection

```csharp
using Microsoft.Extensions.DependencyInjection;
using TUnit.Core;

public class UserServiceTests
{
    private ServiceProvider? _serviceProvider;
    private IUserService? _userService;

    [Before(Test)]
    public async Task Setup()
    {
        // Create a service collection and register dependencies
        var services = new ServiceCollection();

        // Register services
        services.AddSingleton<IUserRepository, InMemoryUserRepository>();
        services.AddScoped<IUserService, UserService>();
        services.AddLogging();

        _serviceProvider = services.BuildServiceProvider();
        _userService = _serviceProvider.GetRequiredService<IUserService>();
    }

    [After(Test)]
    public async Task Cleanup()
    {
        _serviceProvider?.Dispose();
    }

    [Test]
    public async Task CreateUser_RegistersNewUser()
    {
        var email = "test@example.com";
        var name = "Test User";

        var user = await _userService!.CreateAsync(email, name);

        await Assert.That(user.Email).IsEqualTo(email);
        await Assert.That(user.Name).IsEqualTo(name);
        await Assert.That(user.Id).IsNotEqualTo(Guid.Empty);
    }
}
```

### Testing with Scoped Services

```csharp
public class OrderServiceTests
{
    private ServiceProvider? _serviceProvider;

    [Before(Test)]
    public async Task Setup()
    {
        var services = new ServiceCollection();
        services.AddDbContext<OrderDbContext>(options =>
            options.UseInMemoryDatabase("TestDb"));
        services.AddScoped<IOrderService, OrderService>();

        _serviceProvider = services.BuildServiceProvider();
    }

    [After(Test)]
    public async Task Cleanup()
    {
        _serviceProvider?.Dispose();
    }

    [Test]
    public async Task CreateOrder_UsesScop​edDbContext()
    {
        // Create a scope for this test
        using var scope = _serviceProvider!.CreateScope();
        var orderService = scope.ServiceProvider.GetRequiredService<IOrderService>();

        var order = await orderService.CreateAsync(new CreateOrderRequest
        {
            CustomerId = 1,
            Items = new[] { new OrderItem { ProductId = 1, Quantity = 2 } }
        });

        await Assert.That(order.Id).IsGreaterThan(0);
        await Assert.That(order.Items).Count().IsEqualTo(1);
    }
}
```

## API Testing with WebApplicationFactory

### Testing a Minimal API Endpoint (Shared Server)

For API tests, it's more efficient to share a single WebApplicationFactory across all tests:

```csharp
using Microsoft.AspNetCore.Mvc.Testing;
using System.Net;
using System.Net.Http.Json;
using TUnit.Core;

// Shared web server for all API tests
public class TestWebServer : IAsyncInitializer, IAsyncDisposable
{
    public WebApplicationFactory<Program>? Factory { get; private set; }

    public async Task InitializeAsync()
    {
        Factory = new WebApplicationFactory<Program>();
        await Task.CompletedTask;
    }

    public async ValueTask DisposeAsync()
    {
        if (Factory != null)
            await Factory.DisposeAsync();
    }
}

[ClassDataSource<TestWebServer>(Shared = SharedType.PerTestSession)]
public class UserApiTests(TestWebServer server)
{
    [Test]
    public async Task GetUsers_ReturnsSuccessStatus()
    {
        var client = server.Factory!.CreateClient();
        var response = await client.GetAsync("/api/users");

        await Assert.That(response.StatusCode).IsEqualTo(HttpStatusCode.OK);
    }

    [Test]
    public async Task CreateUser_ReturnsCreatedUser()
    {
        var client = server.Factory!.CreateClient();
        var newUser = new CreateUserRequest
        {
            Email = "test@example.com",
            Name = "Test User"
        };

        var response = await client.PostAsJsonAsync("/api/users", newUser);

        await Assert.That(response.StatusCode).IsEqualTo(HttpStatusCode.Created);

        var user = await response.Content.ReadFromJsonAsync<UserResponse>();
        await Assert.That(user).IsNotNull();
        await Assert.That(user!.Email).IsEqualTo(newUser.Email);
    }

    [Test]
    public async Task GetUser_WithInvalidId_ReturnsNotFound()
    {
        var client = server.Factory!.CreateClient();
        var response = await client.GetAsync("/api/users/99999");

        await Assert.That(response.StatusCode).IsEqualTo(HttpStatusCode.NotFound);
    }
}
```

### Testing with Authentication (Per-Test Setup)

When each test needs different configuration (like different auth setups), use per-test hooks:

```csharp
public class AuthenticatedApiTests
{
    private WebApplicationFactory<Program>? _factory;
    private HttpClient? _client;

    [Before(Test)]
    public async Task Setup()
    {
        _factory = new WebApplicationFactory<Program>()
            .WithWebHostBuilder(builder =>
            {
                builder.ConfigureServices(services =>
                {
                    // Configure test authentication
                    services.AddAuthentication("Test")
                        .AddScheme<TestAuthenticationOptions, TestAuthenticationHandler>(
                            "Test", options => { });
                });
            });

        _client = _factory.CreateClient();

        // Add auth header
        _client.DefaultRequestHeaders.Authorization =
            new System.Net.Http.Headers.AuthenticationHeaderValue("Test");
    }

    [After(Test)]
    public async Task Cleanup()
    {
        _client?.Dispose();
        if (_factory != null)
            await _factory.DisposeAsync();
    }

    [Test]
    public async Task GetProfile_WithAuth_ReturnsUserProfile()
    {
        var response = await _client!.GetAsync("/api/profile");

        await Assert.That(response.StatusCode).IsEqualTo(HttpStatusCode.OK);
        var profile = await response.Content.ReadFromJsonAsync<UserProfile>();
        await Assert.That(profile).IsNotNull();
    }

    [Test]
    public async Task GetProfile_WithoutAuth_ReturnsUnauthorized()
    {
        _client!.DefaultRequestHeaders.Authorization = null;

        var response = await _client.GetAsync("/api/profile");

        await Assert.That(response.StatusCode).IsEqualTo(HttpStatusCode.Unauthorized);
    }
}
```

> **Tip**: Use per-test setup (hooks) when tests need different configurations. Use shared setup (`ClassDataSource` with `SharedType.PerTestSession`) when all tests can use the same configuration.

## Mocking Patterns

### Using Moq

```csharp
using Moq;
using TUnit.Core;

public class OrderServiceMoqTests
{
    [Test]
    public async Task ProcessOrder_CallsPaymentService()
    {
        // Arrange
        var mockPaymentService = new Mock<IPaymentService>();
        mockPaymentService
            .Setup(p => p.ProcessPaymentAsync(It.IsAny<decimal>(), It.IsAny<string>()))
            .ReturnsAsync(new PaymentResult { Success = true, TransactionId = "TX123" });

        var orderService = new OrderService(mockPaymentService.Object);
        var order = new Order { Total = 100.00m, PaymentMethod = "Credit Card" };

        // Act
        var result = await orderService.ProcessAsync(order);

        // Assert
        await Assert.That(result.IsSuccess).IsTrue();
        mockPaymentService.Verify(
            p => p.ProcessPaymentAsync(100.00m, "Credit Card"),
            Times.Once);
    }

    [Test]
    public async Task ProcessOrder_HandlesPaymentFailure()
    {
        // Arrange
        var mockPaymentService = new Mock<IPaymentService>();
        mockPaymentService
            .Setup(p => p.ProcessPaymentAsync(It.IsAny<decimal>(), It.IsAny<string>()))
            .ThrowsAsync(new PaymentException("Insufficient funds"));

        var orderService = new OrderService(mockPaymentService.Object);
        var order = new Order { Total = 1000.00m, PaymentMethod = "Credit Card" };

        // Act & Assert
        await Assert.That(async () => await orderService.ProcessAsync(order))
            .ThrowsExactly<PaymentException>()
            .WithMessage("Insufficient funds");
    }
}
```

### Using NSubstitute

```csharp
using NSubstitute;
using NSubstitute.ExceptionExtensions;
using TUnit.Core;

public class OrderServiceNSubstituteTests
{
    [Test]
    public async Task ProcessOrder_CallsPaymentService()
    {
        // Arrange
        var paymentService = Substitute.For<IPaymentService>();
        paymentService
            .ProcessPaymentAsync(Arg.Any<decimal>(), Arg.Any<string>())
            .Returns(new PaymentResult { Success = true, TransactionId = "TX123" });

        var orderService = new OrderService(paymentService);
        var order = new Order { Total = 100.00m, PaymentMethod = "Credit Card" };

        // Act
        var result = await orderService.ProcessAsync(order);

        // Assert
        await Assert.That(result.IsSuccess).IsTrue();
        await paymentService.Received(1).ProcessPaymentAsync(100.00m, "Credit Card");
    }

    [Test]
    public async Task ProcessOrder_HandlesPaymentFailure()
    {
        // Arrange
        var paymentService = Substitute.For<IPaymentService>();
        paymentService
            .ProcessPaymentAsync(Arg.Any<decimal>(), Arg.Any<string>())
            .Throws(new PaymentException("Insufficient funds"));

        var orderService = new OrderService(paymentService);
        var order = new Order { Total = 1000.00m, PaymentMethod = "Credit Card" };

        // Act & Assert
        await Assert.That(async () => await orderService.ProcessAsync(order))
            .ThrowsExactly<PaymentException>()
            .WithMessage("Insufficient funds");
    }
}
```

### Partial Mocks and Spy Pattern

```csharp
using Moq;

public class NotificationServiceTests
{
    [Test]
    public async Task SendNotification_LogsAttempt()
    {
        // Arrange - create a partial mock that calls real methods
        var mockLogger = new Mock<ILogger>();
        var notificationService = new Mock<NotificationService>(mockLogger.Object)
        {
            CallBase = true  // Call real implementation
        };

        // Override only the SendEmail method
        notificationService
            .Setup(n => n.SendEmailAsync(It.IsAny<string>(), It.IsAny<string>()))
            .ReturnsAsync(true);

        // Act
        await notificationService.Object.NotifyUserAsync("user@example.com", "Hello");

        // Assert - verify the real method called SendEmail
        notificationService.Verify(
            n => n.SendEmailAsync("user@example.com", It.IsAny<string>()),
            Times.Once);
    }
}
```

## Data-Driven Test Patterns

### Using MethodDataSource

```csharp
using TUnit.Core;

public class CalculatorDataDrivenTests
{
    [Test]
    [MethodDataSource(nameof(GetCalculationTestCases))]
    public async Task Add_ReturnsCorrectSum(int a, int b, int expected)
    {
        var calculator = new Calculator();
        var result = calculator.Add(a, b);
        await Assert.That(result).IsEqualTo(expected);
    }

    public static IEnumerable<(int, int, int)> GetCalculationTestCases()
    {
        yield return (1, 2, 3);
        yield return (0, 0, 0);
        yield return (-1, 1, 0);
        yield return (100, 200, 300);
    }
}
```

### Using MethodDataSource with Complex Objects

```csharp
public class OrderValidationTests
{
    [Test]
    [MethodDataSource(nameof(GetInvalidOrders))]
    public async Task ValidateOrder_WithInvalidData_ReturnsErrors(
        Order order,
        string expectedError)
    {
        var validator = new OrderValidator();

        var result = await validator.ValidateAsync(order);

        await Assert.That(result.IsValid).IsFalse();
        await Assert.That(result.Errors).Contains(e => e.Message.Contains(expectedError));
    }

    public static IEnumerable<(Order, string)> GetInvalidOrders()
    {
        yield return (
            new Order { Total = 0, Items = new List<OrderItem>() },
            "Order must have at least one item"
        );

        yield return (
            new Order { Total = -10, Items = new List<OrderItem> { new() { Quantity = 1 } } },
            "Total must be positive"
        );

        yield return (
            new Order { Total = 100, CustomerId = 0, Items = new List<OrderItem> { new() } },
            "Customer ID is required"
        );
    }
}
```

### Using DataSourceGenerator

```csharp
using TUnit.Core;

public class UserTestDataGenerator : DataSourceGeneratorAttribute<User>
{
    public override IEnumerable<User> GenerateDataSources(DataGeneratorMetadata dataGeneratorMetadata)
    {
        yield return new User { Id = 1, Email = "user1@example.com", Role = "Admin" };
        yield return new User { Id = 2, Email = "user2@example.com", Role = "User" };
        yield return new User { Id = 3, Email = "user3@example.com", Role = "Guest" };
    }
}

public class UserPermissionTests
{
    [Test]
    [UserTestDataGenerator]
    public async Task CheckPermissions_ReturnsCorrectAccess(User user)
    {
        var permissionService = new PermissionService();

        var canDelete = await permissionService.CanDeleteAsync(user);

        if (user.Role == "Admin")
            await Assert.That(canDelete).IsTrue();
        else
            await Assert.That(canDelete).IsFalse();
    }
}
```

## Exception Testing

### Testing for Specific Exceptions

```csharp
using TUnit.Core;

public class ExceptionTests
{
    [Test]
    public async Task Divide_ByZero_ThrowsException()
    {
        var calculator = new Calculator();

        await Assert.That(() => calculator.Divide(10, 0))
            .ThrowsExactly<DivideByZeroException>();
    }

    [Test]
    public async Task CreateUser_WithInvalidEmail_ThrowsValidationException()
    {
        var userService = new UserService();

        await Assert.That(async () => await userService.CreateAsync("invalid-email", "John"))
            .ThrowsExactly<ValidationException>()
            .WithMessage("Invalid email format");
    }
}
```

### Testing Exception Messages and Properties

```csharp
public class DetailedExceptionTests
{
    [Test]
    public async Task ProcessPayment_InsufficientFunds_ThrowsWithDetails()
    {
        var paymentService = new PaymentService();
        var payment = new Payment { Amount = 1000, AccountBalance = 100 };

        var exception = await Assert.That(async () => await paymentService.ProcessAsync(payment))
            .ThrowsExactly<PaymentException>();

        await Assert.That(exception.Message).Contains("Insufficient funds");
        await Assert.That(exception.RequiredAmount).IsEqualTo(1000);
        await Assert.That(exception.AvailableAmount).IsEqualTo(100);
    }
}
```

### Testing Async Exceptions

```csharp
public class AsyncExceptionTests
{
    [Test]
    public async Task FetchData_WithInvalidUrl_ThrowsHttpException()
    {
        var apiClient = new ApiClient();

        // Test async method that throws
        await Assert.That(async () => await apiClient.GetDataAsync("invalid-url"))
            .ThrowsExactly<HttpRequestException>();
    }

    [Test]
    public async Task ProcessBatch_WithTimeout_ThrowsTaskCanceledException()
    {
        var processor = new BatchProcessor();
        using var cts = new CancellationTokenSource(TimeSpan.FromMilliseconds(100));

        await Assert.That(async () => await processor.ProcessAsync(1000, cts.Token))
            .Throws<TaskCanceledException>();
    }
}
```

## Integration Test Patterns

### Testing with In-Memory Database

```csharp
using Microsoft.EntityFrameworkCore;
using TUnit.Core;

public class OrderRepositoryIntegrationTests
{
    private DbContextOptions<OrderDbContext>? _options;
    private OrderDbContext? _context;

    [Before(Test)]
    public async Task Setup()
    {
        _options = new DbContextOptionsBuilder<OrderDbContext>()
            .UseInMemoryDatabase(databaseName: Guid.NewGuid().ToString())
            .Options;

        _context = new OrderDbContext(_options);
        await _context.Database.EnsureCreatedAsync();
    }

    [After(Test)]
    public async Task Cleanup()
    {
        if (_context != null)
        {
            await _context.Database.EnsureDeletedAsync();
            await _context.DisposeAsync();
        }
    }

    [Test]
    public async Task SaveOrder_PersistsToDatabase()
    {
        var repository = new OrderRepository(_context!);
        var order = new Order
        {
            CustomerId = 1,
            Total = 100.00m,
            Status = OrderStatus.Pending
        };

        await repository.SaveAsync(order);
        await _context!.SaveChangesAsync();

        var saved = await _context.Orders.FirstOrDefaultAsync(o => o.Id == order.Id);
        await Assert.That(saved).IsNotNull();
        await Assert.That(saved!.Total).IsEqualTo(100.00m);
    }

    [Test]
    public async Task GetOrder_WithRelatedData_LoadsNavigationProperties()
    {
        // Seed data
        var order = new Order
        {
            CustomerId = 1,
            Items = new List<OrderItem>
            {
                new() { ProductId = 1, Quantity = 2, Price = 10.00m },
                new() { ProductId = 2, Quantity = 1, Price = 20.00m }
            }
        };
        _context!.Orders.Add(order);
        await _context.SaveChangesAsync();

        // Test
        var repository = new OrderRepository(_context);
        var loaded = await repository.GetWithItemsAsync(order.Id);

        await Assert.That(loaded).IsNotNull();
        await Assert.That(loaded!.Items).Count().IsEqualTo(2);
    }
}
```

### Testing with Test Containers (Docker)

```csharp
using Testcontainers.PostgreSql;
using TUnit.Core;

public class PostgresIntegrationTests
{
    private PostgreSqlContainer? _container;
    private string? _connectionString;

    [Before(Test)]
    public async Task Setup()
    {
        _container = new PostgreSqlBuilder()
            .WithImage("postgres:15")
            .WithDatabase("testdb")
            .WithUsername("test")
            .WithPassword("test")
            .Build();

        await _container.StartAsync();
        _connectionString = _container.GetConnectionString();
    }

    [After(Test)]
    public async Task Cleanup()
    {
        if (_container != null)
            await _container.DisposeAsync();
    }

    [Test]
    public async Task CanConnectToPostgres()
    {
        using var connection = new NpgsqlConnection(_connectionString);
        await connection.OpenAsync();

        await Assert.That(connection.State).IsEqualTo(ConnectionState.Open);
    }
}
```

### Testing HTTP Client Integration

```csharp
using System.Net;
using TUnit.Core;

public class HttpClientIntegrationTests
{
    private HttpClient? _httpClient;

    [Before(Test)]
    public async Task Setup()
    {
        var handler = new HttpClientHandler
        {
            ServerCertificateCustomValidationCallback = (message, cert, chain, errors) => true
        };

        _httpClient = new HttpClient(handler)
        {
            BaseAddress = new Uri("https://api.example.com"),
            Timeout = TimeSpan.FromSeconds(30)
        };

        _httpClient.DefaultRequestHeaders.Add("Authorization", "Bearer test-token");
    }

    [After(Test)]
    public void Cleanup()
    {
        _httpClient?.Dispose();
    }

    [Test]
    public async Task GetUser_ReturnsValidResponse()
    {
        var response = await _httpClient!.GetAsync("/users/1");

        await Assert.That(response.StatusCode).IsEqualTo(HttpStatusCode.OK);

        var user = await response.Content.ReadFromJsonAsync<User>();
        await Assert.That(user).IsNotNull();
        await Assert.That(user!.Id).IsEqualTo(1);
    }

    [Test]
    public async Task GetUser_HandlesRateLimiting()
    {
        // Make multiple requests to trigger rate limiting
        var tasks = Enumerable.Range(1, 100)
            .Select(i => _httpClient!.GetAsync($"/users/{i}"));

        var responses = await Task.WhenAll(tasks);

        var rateLimited = responses.Count(r => r.StatusCode == HttpStatusCode.TooManyRequests);
        await Assert.That(rateLimited).IsGreaterThan(0);
    }
}
```

### Testing File System Operations

```csharp
using TUnit.Core;

public class FileServiceTests
{
    private string? _testDirectory;

    [Before(Test)]
    public async Task Setup()
    {
        _testDirectory = Path.Combine(Path.GetTempPath(), Guid.NewGuid().ToString());
        Directory.CreateDirectory(_testDirectory);
    }

    [After(Test)]
    public async Task Cleanup()
    {
        if (_testDirectory != null && Directory.Exists(_testDirectory))
        {
            Directory.Delete(_testDirectory, recursive: true);
        }
    }

    [Test]
    public async Task SaveFile_CreatesFileWithContent()
    {
        var fileService = new FileService();
        var fileName = "test.txt";
        var content = "Hello, World!";
        var filePath = Path.Combine(_testDirectory!, fileName);

        await fileService.SaveAsync(filePath, content);

        await Assert.That(File.Exists(filePath)).IsTrue();
        var savedContent = await File.ReadAllTextAsync(filePath);
        await Assert.That(savedContent).IsEqualTo(content);
    }

    [Test, NotInParallel("FileSystem")]
    public async Task DeleteFile_RemovesFile()
    {
        var filePath = Path.Combine(_testDirectory!, "delete-me.txt");
        await File.WriteAllTextAsync(filePath, "content");

        var fileService = new FileService();
        await fileService.DeleteAsync(filePath);

        await Assert.That(File.Exists(filePath)).IsFalse();
    }
}
```

## Summary

These cookbook recipes cover the most common testing scenarios. You can adapt these patterns for your specific needs:

- **Dependency Injection**: Use service collections for realistic testing with dependencies
- **API Testing**: Use `WebApplicationFactory` for end-to-end API tests
- **Mocking**: Choose Moq or NSubstitute based on your preference
- **Data-Driven Tests**: Use `MethodDataSource` or `DataSourceGenerator` for parameterized tests
- **Exception Testing**: Use TUnit's fluent exception assertions
- **Integration Tests**: Test with real databases, containers, or file systems

For more examples, check out the [examples section](../examples/intro) in the documentation.

---

## TUnit Philosophy & Design Decisions


If you're wondering why TUnit does things differently from other testing frameworks, this page has the answers. Understanding the reasoning behind TUnit's design will help you use it effectively and decide if it's right for your project.

## Core Principles

### Performance First

TUnit is built for speed at any scale. Whether you have 100 tests or 100,000, they should run as fast as possible. Tests run in parallel by default, using Roslyn source generators to discover tests at compile time instead of expensive runtime reflection. You can choose between source-generated mode (fastest) or reflection mode (more flexible) depending on your needs.

Fast tests create faster feedback loops. When tests run quickly, developers actually run them more often. They catch bugs earlier and stay in flow instead of context-switching while waiting for test results.

### Modern .NET First

TUnit embraces modern .NET without compromises. Everything is async by default. Assertions, hooks, all of it. It uses C# 12+ features like collection expressions and file-scoped namespaces. Native AOT and trimming work out of the box. It's built on Microsoft.Testing.Platform instead of the legacy VSTest infrastructure.

Modern .NET applications deserve a modern testing framework. While TUnit supports .NET Standard 2.0 (including .NET Framework), it's designed around modern patterns and idioms, not legacy approaches from a decade ago.

### Test Isolation

Every test should be completely independent. TUnit creates a new instance of your test class for each test method, so instance fields can't leak between tests. Tests can run in any order, on any thread, without affecting each other. If you need shared state, you make it explicit with the `static` keyword.

Isolated tests are reliable tests. You never get those mysterious failures where Test B only fails when Test A runs first. Everything is deterministic.

But what about when tests really do need to depend on each other? Use `[DependsOn]` to enforce ordering. It ensures the dependency always runs first, and if it fails, the dependent test gets skipped instead of running with bad state. This reduces flakiness compared to hoping tests run in the right order by accident.

### Developer Experience

Writing tests should be pleasant, not painful. TUnit has minimal boilerplate—just put `[Test]` on your methods, no class attributes needed. Assertions read naturally: `await Assert.That(value).IsEqualTo(expected)`. Error messages are clear and actionable. You can access test metadata through `TestContext` whenever you need it.

Developers spend a lot of time writing and debugging tests. Small improvements in ergonomics really do add up over time.

## Key Design Decisions

### Why Dual-Mode Execution?

TUnit offers two ways to discover and run tests: source generation (the default) and reflection mode.

Source-generated mode discovers tests at compile time using Roslyn source generators. It generates explicit test registration code, which makes it the fastest option. The downside is you need to recompile when tests change, but that's usually not a problem.

Reflection mode discovers tests at runtime. It's slightly slower but more flexible for dynamic scenarios. No code generation means it's simpler in some ways, but you lose the performance benefits.

Why support both? Different scenarios need different trade-offs. CI/CD pipelines benefit from maximum speed with source generation. AOT scenarios require it. But if you're doing something dynamic or just want the simplicity of runtime discovery, reflection mode is there. Users aren't locked into one approach.

### Why All Assertions Must Be Awaited

This is probably TUnit's most controversial decision: all assertions return `Task` and must be awaited.

```csharp
// TUnit - must await
await Assert.That(result).IsEqualTo(expected);

// Other frameworks - no await
Assert.Equal(expected, result);
```

The reasoning: consistency and extensibility. If all assertions work the same way, you never have to remember which ones need await and which don't. Custom assertions can do async work like database queries or HTTP calls. You can chain assertions naturally without blocking threads. And you avoid all the sync-over-async deadlock problems.

Yes, it's more verbose. Yes, there's a learning curve. But it enables patterns that just aren't possible with sync assertions:

```csharp
// Custom async assertion
await Assert.That(async () => await GetUserAsync(id))
    .ThrowsAsync<UserNotFoundException>();

// Chained assertions without blocking
await Assert.That(user.Email)
    .IsNotNull()
    .And.Contains("@example.com");
```

The benefits outweigh the extra `await` keyword. Plus, the code fixers handle most of the migration work automatically anyway.

### Why Microsoft.Testing.Platform?

TUnit is built on Microsoft.Testing.Platform instead of the legacy VSTest infrastructure.

The new platform was designed for .NET 5+ from scratch. It's faster, more extensible, and both `dotnet test` and `dotnet run` work well with it. More importantly, it's where Microsoft is investing going forward.

The downside? Some older tools only work with VSTest. Coverlet is the most notable example. But Microsoft provides `Microsoft.Testing.Extensions.CodeCoverage` as the modern alternative, and it actually works better with the new platform anyway.

### Why Parallel by Default?

Most testing frameworks make you opt-in to parallelism. TUnit flips that around.

Running tests in parallel can improve execution time. Modern CPUs have many cores—TUnit uses them by default. And here's the thing: tests that are safe to run in parallel are usually well-isolated tests. Making parallelism the default encourages better test design.

When do you opt-out? Use `[NotInParallel]` for tests that modify shared files or databases, use global state, must run in a specific order, or access hardware like cameras or GPIO pins.

```csharp
[Test, NotInParallel]
public async Task ModifiesConfigFile()
{
    // This test modifies a shared config file
}
```

### Why New Instance Per Test?

TUnit creates a new instance of your test class for each test method.

```csharp
public class MyTests
{
    private int _counter = 0;  // Fresh for each test

    [Test]
    public async Task Test1()
    {
        _counter++;
        await Assert.That(_counter).IsEqualTo(1);  // Always passes
    }

    [Test]
    public async Task Test2()
    {
        _counter++;
        await Assert.That(_counter).IsEqualTo(1);  // Always passes
    }
}
```

This prevents instance fields from leaking between tests. No race conditions on instance data. No mysterious "Test B fails when Test A runs first" issues. If you need shared state, you use `static`, which makes it explicit and obvious in the code.

Coming from NUnit (which shares instances by default)? Yes, this is a breaking change. But it's the right default for test isolation.

### Why Source Generators?

TUnit uses Roslyn source generators for test discovery. No runtime reflection means better performance and Native AOT compatibility. You get compile-time errors for test configuration issues instead of runtime surprises. IDEs understand the generated code, so IntelliSense and refactoring work better.

Source generators do add complexity and can make debugging trickier. But for most users, the performance and AOT benefits are worth it. If you really need more flexibility, reflection mode is always available with `dotnet test -- --reflection`.

## What Problems Does TUnit Solve?

### Slow Test Suites

Traditional frameworks run tests sequentially by default and use runtime reflection for discovery. TUnit runs tests in parallel by default and discovers them at compile time with source generators. This can significantly reduce test suite execution time, especially for large test suites.

### Flaky Tests from State Leaks

NUnit shares test class instances. xUnit allows state in constructors. It's easy to accidentally share state and get those frustrating "works alone, fails in the suite" bugs. TUnit creates a new instance per test with no way to opt out. If you need shared state, you use `static`, making it explicit. Parallel execution catches state problems early instead of hiding them.

### Limited Async Support

Older frameworks have a mix of sync and async APIs. You need `IAsyncLifetime` for async setup. Some parts do sync-over-async. TUnit is async everywhere—hooks, assertions, all of it. No deadlocks, clean code throughout.

### Poor AOT Support

Heavy runtime reflection doesn't work with Native AOT. TUnit uses source generation, supports AOT from day one, and has proper trimming annotations. Your tests work with Native AOT deployments.

## Comparison with Other Frameworks

### TUnit vs xUnit

xUnit and TUnit have a lot in common—neither requires class attributes, both have modern extensible designs. The main differences: TUnit runs parallel by default with better async control, uses source generation for discovery, has a richer hook system instead of constructor/IDisposable patterns, and uses fluent assertions instead of static methods.

### TUnit vs NUnit

Both use `[Test]` attributes and have rich assertion libraries. The biggest difference is isolation: TUnit creates a new instance per test, NUnit shares by default. TUnit also defaults to parallel execution (NUnit defaults to sequential), has async assertions (NUnit is sync), and doesn't need the `[TestFixture]` attribute.

### TUnit vs MSTest

Both are Microsoft-backed with good IDE integration. TUnit drops the class attribute requirement (MSTest needs `[TestClass]`), runs on the modern testing platform, defaults to parallel execution, and has better async support throughout.

For detailed comparisons, check out [Framework Differences](../comparison/framework-differences.md).

## When to Choose TUnit

TUnit is a good fit when performance matters—you have large test suites that need to run fast. It supports .NET Standard 2.0, so it works with .NET Framework and all modern .NET versions. It works great with Native AOT, and shines when you want parallel test execution. If you're starting a new project without legacy constraints, TUnit is worth considering.

When might you want alternatives? If you have an existing huge test suite, migration costs might outweigh the benefits. If your team strongly prefers another framework's style, that's a legitimate reason to stick with what works for you. Or if you absolutely need a tool that only works with VSTest, you'll need to use something else.

## The Bottom Line

TUnit exists because modern .NET deserves a modern testing framework. One that prioritizes performance, isolation, and developer experience without carrying the baggage of legacy compromises.

Every decision—async assertions, parallel-by-default, source generation—flows from wanting tests to be fast, isolated, modern, and pleasant to write. Tests should run in parallel, create new instances per test, support async naturally, and minimize boilerplate.

If that resonates with you, TUnit is probably a good fit for your project.

For migration details, check out:
- [xUnit Migration](../migration/xunit.md)
- [NUnit Migration](../migration/nunit.md)
- [MSTest Migration](../migration/mstest.md)

---

## Intro


**TUnit** is another testing framework for C# / .NET.
It can be used for unit testing, integration testing, acceptance testing, you name it.

It provides you a skeleton framework to write, execute and assert tests, with little opinion on how your tests should be. In fact, it aims to be flexible, giving you various ways to inject test data, such as options for new data or shared instances, and a variety of hooks to run before and after tests.

That means you get more control over your setup, execution, and style of tests.

It is also built on top of the newer Microsoft Testing Platform, which was rewritten to make .NET testing simpler and more extensible.

:::performance
TUnit is designed for speed. Through source generation and compile-time optimizations, TUnit significantly outperforms traditional testing frameworks. See the [performance benchmarks](/docs/benchmarks) for real-world speed comparisons.
:::

---

## Migrating from MSTest


:::from-mstest Performance Boost
Migrating from MSTest to TUnit can improve test execution speed. Check the [benchmarks](/docs/benchmarks) to see how TUnit compares.
:::

## Quick Reference

| MSTest | TUnit |
|--------|-------|
| `[TestClass]` | *(remove - not needed)* |
| `[TestMethod]` | `[Test]` |
| `[DataRow(...)]` | `[Arguments(...)]` |
| `[DynamicData(nameof(...), ...)]` | `[MethodDataSource(nameof(...))]` |
| `[TestCategory("value")]` | `[Property("Category", "value")]` |
| `[Ignore]` | `[Skip]` |
| `[Priority(n)]` | `[Property("Priority", "n")]` |
| `[Owner("value")]` | `[Property("Owner", "value")]` |
| `[TestInitialize]` | `[Before(Test)]` |
| `[TestCleanup]` | `[After(Test)]` |
| `[ClassInitialize]` | `[Before(Class)]` *(remove TestContext parameter)* |
| `[ClassCleanup]` | `[After(Class)]` |
| `[AssemblyInitialize]` | `[Before(Assembly)]` *(remove TestContext parameter)* |
| `[AssemblyCleanup]` | `[After(Assembly)]` |
| `[Timeout(ms)]` | `[Timeout(ms)]` |
| `[DataTestMethod]` | `[Test]` |
| `public TestContext TestContext { get; set; }` | `TestContext` method parameter |
| `Assert.AreEqual(expected, actual)` | `await Assert.That(actual).IsEqualTo(expected)` |
| `Assert.IsTrue(condition)` | `await Assert.That(condition).IsTrue()` |
| `Assert.IsNull(value)` | `await Assert.That(value).IsNull()` |
| `Assert.ThrowsException<T>(() => ...)` | `await Assert.ThrowsAsync<T>(() => ...)` |
| `Assert.Inconclusive("reason")` | `Skip.Test("reason")` |
| `CollectionAssert.Contains(collection, item)` | `await Assert.That(collection).Contains(item)` |
| `StringAssert.Contains(text, substring)` | `await Assert.That(text).Contains(substring)` |
| `Assert.AreSame(expected, actual)` | `await Assert.That(actual).IsSameReference(expected)` |

## Automated Migration with Code Fixers

TUnit includes Roslyn analyzers and code fixers that automate most of the migration work. The `TUMS0001` diagnostic identifies MSTest code patterns and provides automatic fixes to convert them to TUnit equivalents.

**What gets converted automatically:**
- `[TestClass]` → removed (not needed in TUnit)
- `[TestMethod]` → `[Test]`
- `[DataTestMethod]` → `[Test]`
- `[DataRow(...)]` → `[Arguments(...)]`
- `[DynamicData(nameof(...), ...)]` → `[MethodDataSource(nameof(...))]`
- `[TestInitialize]` → `[Before(Test)]`
- `[TestCleanup]` → `[After(Test)]`
- `[ClassInitialize]` → `[Before(Class)]` (removes `TestContext` parameter)
- `[ClassCleanup]` → `[After(Class)]`
- `[AssemblyInitialize]` → `[Before(Assembly)]` (removes `TestContext` parameter)
- `[AssemblyCleanup]` → `[After(Assembly)]`
- `[Ignore]` → `[Skip]`
- `[TestCategory("...")]` → `[Property("Category", "...")]`
- `[Priority(n)]` → `[Property("Priority", "n")]`
- `[Owner("...")]` → `[Property("Owner", "...")]`
- `Assert.AreEqual(expected, actual)` → `await Assert.That(actual).IsEqualTo(expected)`
- `Assert.IsTrue(condition)` → `await Assert.That(condition).IsTrue()`
- `Assert.ThrowsException<T>(...)` → `await Assert.ThrowsAsync<T>(...)`
- Test methods converted to `async Task` with `await` on assertions

The code fixer handles roughly 80-90% of typical test suites automatically.

**What requires manual adjustment:**
- `public TestContext TestContext { get; set; }` property → inject `TestContext` as method parameter instead
- `[ClassInitialize]` / `[AssemblyInitialize]` methods that use the `TestContext` parameter
- Custom `[DynamicData]` return types (convert `IEnumerable<object[]>` to `IEnumerable<(...)>` tuples)
- `[DeploymentItem]` attributes → configure file copying in `.csproj` instead
- `Assert.Inconclusive("...")` → `Skip.Test("...")`
- `[ExpectedException]` attribute (deprecated) → `await Assert.ThrowsAsync<T>(...)`
- Complex `TestContext` property access patterns

If you find a common pattern that should be automated but isn't, please [open an issue](https://github.com/thomhurst/TUnit/issues).

### Prerequisites

- .NET SDK 8.0 or later (for `dotnet format` with analyzer support)
- TUnit packages installed in your test project

### Step-by-Step Migration

:::tip Safety First
Commit your changes or create a backup before running the code fixer. This allows you to review changes and revert if needed.
:::

**1. Install TUnit packages**

Add the TUnit packages to your test project alongside MSTest (temporarily):

```bash
dotnet add package TUnit
```

**2. Disable TUnit's implicit usings (temporary)**

Add these properties to your `.csproj` to prevent type name conflicts between MSTest and TUnit:

```xml
<PropertyGroup>
    <TUnitImplicitUsings>false</TUnitImplicitUsings>
    <TUnitAssertionsImplicitUsings>false</TUnitAssertionsImplicitUsings>
</PropertyGroup>
```

This allows the code fixer to distinguish between `Microsoft.VisualStudio.TestTools.UnitTesting.Assert` and `TUnit.Assertions.Assert`.

**3. Rebuild the project**

```bash
dotnet build
```

This restores packages and loads the TUnit analyzers. 

:::note Optional: Verify analyzer is working
The `TUMS0001` diagnostic is information-level and won't appear in standard build output. If you want to verify the analyzer is detecting MSTest code before applying changes, run:

```bash
dotnet format analyzers --severity info --diagnostics TUMS0001 --verify-no-changes
```

This command checks for `TUMS0001` diagnostics without modifying any files. If MSTest code is detected, you'll see messages like "Would fix N files" or specific file paths that would be changed.
:::

**4. Run the automated code fixer**

```bash
dotnet format analyzers --severity info --diagnostics TUMS0001
```

This command applies all available fixes for the `TUMS0001` diagnostic. You'll see output indicating which files were modified.

:::warning Multi-targeting Projects
If your project targets multiple .NET versions (e.g., `net8.0;net9.0;net10.0`), you **must** specify a single target framework when running the code fixer. Multi-targeting can cause the code fixer to crash with the error `Changes must be within bounds of SourceText` due to a limitation in Roslyn's linked file handling.

**Option 1:** Specify a single framework via command line:
```bash
dotnet format analyzers --severity info --diagnostics TUMS0001 --framework net10.0
```

**Option 2:** Temporarily modify your project file to single-target:
```xml
<!-- Before migration -->
<TargetFramework>net10.0</TargetFramework>
<!-- <TargetFrameworks>net8.0;net9.0;net10.0</TargetFrameworks> -->
```

Run the code fixer, then restore multi-targeting afterward. Replace `net10.0` with your project's highest supported target framework.
:::

**5. Remove the implicit usings workaround**

Remove or comment out the properties you added in step 2:

```xml
<!-- Remove these lines -->
<PropertyGroup>
    <TUnitImplicitUsings>false</TUnitImplicitUsings>
    <TUnitAssertionsImplicitUsings>false</TUnitAssertionsImplicitUsings>
</PropertyGroup>
```

**6. Fix remaining issues manually**

Build the project and address any remaining compilation errors:

```bash
dotnet build
```

Common manual fixes needed:
- Replace `public TestContext TestContext { get; set; }` with `TestContext` method parameter
- Remove `TestContext` parameter from `[ClassInitialize]` and `[AssemblyInitialize]` methods
- Convert data source methods to return tuples instead of `object[]`
- Replace `[DeploymentItem]` with `.csproj` file copy configuration
- Replace `Assert.Inconclusive(...)` with `Skip.Test(...)`
- Add `using TUnit.Core;` and `using TUnit.Assertions;` if not using implicit usings

**7. Remove MSTest packages**

Once everything compiles and tests pass:

```bash
dotnet remove package MSTest.TestFramework
dotnet remove package MSTest.TestAdapter
```

**8. Verify the migration**

```bash
dotnet build
dotnet run -- --list-tests
```

### Troubleshooting

**Code fixer doesn't run / no files changed:**
- Ensure you rebuilt after adding TUnit packages
- Check that `TUMS0001` warnings appear in build output
- Try running with verbose output: `dotnet format analyzers --severity info --diagnostics TUMS0001 --verbosity detailed`

**Build errors after running code fixer:**
- Missing `await` keywords: ensure test methods are `async Task`
- Ambiguous `Assert`: remove MSTest usings or fully qualify types
- Type mismatch in data sources: convert `IEnumerable<object[]>` returns to `IEnumerable<(...)>` tuples

**TestContext errors:**
- Remove the `public TestContext TestContext { get; set; }` property
- Add `TestContext context` parameter to test methods that need it
- Access output via `context.OutputWriter.WriteLine(...)` instead of `TestContext.WriteLine(...)`

**ClassInitialize/AssemblyInitialize errors:**
- Remove the `TestContext context` parameter from these methods
- If you need test context in setup, use `[Before(Test)]` instead which can receive `TestContext`

**Analyzers not loading:**
- Verify TUnit package is installed: `dotnet list package`
- Try cleaning and rebuilding: `dotnet clean && dotnet build`

## Manual Migration Guide

### Test Attributes

`[TestClass]` - Remove this attribute (not needed in TUnit)

`[TestMethod]` becomes `[Test]`

`[DataRow]` becomes `[Arguments]`

`[DynamicData]` becomes `[MethodDataSource]`

`[TestCategory]` becomes `[Property("Category", "value")]`

`[Ignore]` becomes `[Skip]`

`[Priority]` becomes `[Property("Priority", "value")]`

`[Owner]` becomes `[Property("Owner", "value")]`

### Setup and Teardown

`[TestInitialize]` becomes `[Before(HookType.Test)]`

`[TestCleanup]` becomes `[After(HookType.Test)]`

`[ClassInitialize]` becomes `[Before(HookType.Class)]` and remove the TestContext parameter

`[ClassCleanup]` becomes `[After(HookType.Class)]`

`[AssemblyInitialize]` becomes `[Before(HookType.Assembly)]` and remove the TestContext parameter

`[AssemblyCleanup]` becomes `[After(HookType.Assembly)]`

### Assertions

#### Basic Assertions
```csharp
// MSTest
Assert.AreEqual(expected, actual);
Assert.AreNotEqual(expected, actual);
Assert.IsTrue(condition);
Assert.IsFalse(condition);
Assert.IsNull(value);
Assert.IsNotNull(value);

// TUnit
await Assert.That(actual).IsEqualTo(expected);
await Assert.That(actual).IsNotEqualTo(expected);
await Assert.That(condition).IsTrue();
await Assert.That(condition).IsFalse();
await Assert.That(value).IsNull();
await Assert.That(value).IsNotNull();
```

#### Reference Assertions
```csharp
// MSTest
Assert.AreSame(expected, actual);
Assert.AreNotSame(expected, actual);

// TUnit
await Assert.That(actual).IsSameReference(expected);
await Assert.That(actual).IsNotSameReference(expected);
```

#### Type Assertions
```csharp
// MSTest
Assert.IsInstanceOfType(value, typeof(string));
Assert.IsNotInstanceOfType(value, typeof(int));

// TUnit
await Assert.That(value).IsAssignableTo<string>();
await Assert.That(value).IsNotAssignableTo<int>();
```

### Collection Assertions

```csharp
// MSTest
CollectionAssert.AreEqual(expected, actual);
CollectionAssert.AreNotEqual(expected, actual);
CollectionAssert.Contains(collection, item);
CollectionAssert.DoesNotContain(collection, item);
CollectionAssert.AllItemsAreNotNull(collection);

// TUnit
await Assert.That(actual).IsEquivalentTo(expected);
await Assert.That(actual).IsNotEquivalentTo(expected);
await Assert.That(collection).Contains(item);
await Assert.That(collection).DoesNotContain(item);
await Assert.That(collection).AllSatisfy(x => x != null);
```

### String Assertions

```csharp
// MSTest
StringAssert.Contains(text, substring);
StringAssert.StartsWith(text, prefix);
StringAssert.EndsWith(text, suffix);
StringAssert.Matches(text, pattern);

// TUnit
await Assert.That(text).Contains(substring);
await Assert.That(text).StartsWith(prefix);
await Assert.That(text).EndsWith(suffix);
await Assert.That(text).Matches(pattern);
```

### Exception Testing

```csharp
// MSTest
Assert.ThrowsException<InvalidOperationException>(() => DoSomething());
await Assert.ThrowsExceptionAsync<InvalidOperationException>(() => DoSomethingAsync());

// TUnit
await Assert.ThrowsAsync<InvalidOperationException>(() => DoSomething());
await Assert.ThrowsAsync<InvalidOperationException>(() => DoSomethingAsync());
```

### Test Data Sources

#### DataRow
```csharp
// MSTest
[TestMethod]
[DataRow(1, 2, 3)]
[DataRow(10, 20, 30)]
public void AdditionTest(int a, int b, int expected)
{
    Assert.AreEqual(expected, a + b);
}

// TUnit
[Test]
[Arguments(1, 2, 3)]
[Arguments(10, 20, 30)]
public async Task AdditionTest(int a, int b, int expected)
{
    await Assert.That(a + b).IsEqualTo(expected);
}
```

#### DynamicData
```csharp
// MSTest
[TestMethod]
[DynamicData(nameof(TestData), DynamicDataSourceType.Method)]
public void TestMethod(int value, string text)
{
    // Test implementation
}

private static IEnumerable<object[]> TestData()
{
    yield return new object[] { 1, "one" };
    yield return new object[] { 2, "two" };
}

// TUnit
[Test]
[MethodDataSource(nameof(TestData))]
public async Task TestMethod(int value, string text)
{
    // Test implementation
}

private static IEnumerable<(int, string)> TestData()
{
    yield return (1, "one");
    yield return (2, "two");
}
```

### TestContext Usage

```csharp
// MSTest
[TestClass]
public class MyTests
{
    public TestContext TestContext { get; set; }
    
    [TestMethod]
    public void MyTest()
    {
        TestContext.WriteLine("Test output");
    }
    
    [ClassInitialize]
    public static void ClassInit(TestContext context)
    {
        // Setup code
    }
}

// TUnit
public class MyTests
{
    [Test]
    public async Task MyTest(TestContext context)
    {
        context.OutputWriter.WriteLine("Test output");
    }
    
    [Before(HookType.Class)]
    public static async Task ClassInit()
    {
        // Setup code - no TestContext parameter needed
    }
}
```

### Test Attachments

```csharp
// MSTest
[TestMethod]
public void TestWithAttachment()
{
    // Test logic
    var logPath = "test-log.txt";
    File.WriteAllText(logPath, "test logs");
    
    TestContext.AddResultFile(logPath);
}

// TUnit
[Test]
public async Task TestWithAttachment()
{
    // Test logic
    var logPath = "test-log.txt";
    await File.WriteAllTextAsync(logPath, "test logs");
    
    TestContext.Current!.Output.AttachArtifact(new Artifact
    {
        File = new FileInfo(logPath),
        DisplayName = "Test Log",
        Description = "Logs captured during test execution"  // Optional
    });
}
```

For more information about working with test artifacts, including session-level artifacts and best practices, see the [Test Artifacts guide](../test-lifecycle/artifacts.md).

### Assert.Fail

```csharp
// MSTest
Assert.Fail("Test failed with reason");

// TUnit
Assert.Fail("Test failed with reason");
```

### Inconclusive Tests

```csharp
// MSTest
Assert.Inconclusive("Test is inconclusive");

// TUnit
Skip.Test("Test is inconclusive");
```

### Complete Test Class Transformation

**MSTest Code:**
```csharp
[TestClass]
public class OrderServiceTests
{
    private static IDatabase _sharedDatabase;
    private IOrderService _orderService;

    public TestContext TestContext { get; set; }

    [AssemblyInitialize]
    public static void AssemblyInit(TestContext context)
    {
        // Runs once per assembly
        Console.WriteLine("Assembly initialization");
    }

    [ClassInitialize]
    public static void ClassInit(TestContext context)
    {
        // Runs once per test class
        _sharedDatabase = new InMemoryDatabase();
        _sharedDatabase.Initialize();
    }

    [TestInitialize]
    public void TestInit()
    {
        // Runs before each test
        _orderService = new OrderService(_sharedDatabase);
        TestContext.WriteLine("Starting test");
    }

    [TestMethod]
    [TestCategory("Unit")]
    [DataRow(1, "Product A", 10.00)]
    [DataRow(2, "Product B", 20.00)]
    public void CreateOrder_WithValidData_Succeeds(int productId, string productName, double price)
    {
        var order = _orderService.CreateOrder(productId, productName, (decimal)price);

        Assert.IsNotNull(order);
        Assert.AreEqual(productId, order.ProductId);
        Assert.AreEqual(productName, order.ProductName);
        Assert.AreEqual((decimal)price, order.Price);

        TestContext.WriteLine($"Order created: {order.Id}");
    }

    [TestMethod]
    [DynamicData(nameof(GetInvalidOrders), DynamicDataSourceType.Method)]
    public void CreateOrder_WithInvalidData_ThrowsException(int productId, string productName, double price)
    {
        Assert.ThrowsException<ArgumentException>(() =>
            _orderService.CreateOrder(productId, productName, (decimal)price));
    }

    private static IEnumerable<object[]> GetInvalidOrders()
    {
        yield return new object[] { 0, "Product", 10.00 };
        yield return new object[] { 1, "", 10.00 };
        yield return new object[] { 1, "Product", -5.00 };
    }

    [TestMethod]
    [Ignore("Not implemented yet")]
    public void CancelOrder_ValidOrder_Succeeds()
    {
        // Test implementation
    }

    [TestCleanup]
    public void TestCleanup()
    {
        // Runs after each test
        _orderService?.Dispose();
        TestContext.WriteLine("Test completed");
    }

    [ClassCleanup]
    public static void ClassCleanup()
    {
        // Runs once after all tests in class
        _sharedDatabase?.Dispose();
    }

    [AssemblyCleanup]
    public static void AssemblyCleanup()
    {
        // Runs once after all tests in assembly
        Console.WriteLine("Assembly cleanup");
    }
}
```

**TUnit Equivalent:**
```csharp
public class OrderServiceTests
{
    private static IDatabase _sharedDatabase = null!;
    private IOrderService _orderService = null!;

    [Before(Assembly)]
    public static async Task AssemblyInit()
    {
        // Runs once per assembly
        Console.WriteLine("Assembly initialization");
    }

    [Before(Class)]
    public static async Task ClassInit()
    {
        // Runs once per test class
        _sharedDatabase = new InMemoryDatabase();
        await _sharedDatabase.InitializeAsync();
    }

    [Before(Test)]
    public async Task TestInit(TestContext context)
    {
        // Runs before each test
        _orderService = new OrderService(_sharedDatabase);
        context.OutputWriter.WriteLine("Starting test");
    }

    [Test]
    [Property("Category", "Unit")]
    [Arguments(1, "Product A", 10.00)]
    [Arguments(2, "Product B", 20.00)]
    public async Task CreateOrder_WithValidData_Succeeds(int productId, string productName, double price, TestContext context)
    {
        var order = _orderService.CreateOrder(productId, productName, (decimal)price);

        await Assert.That(order).IsNotNull();
        await Assert.That(order.ProductId).IsEqualTo(productId);
        await Assert.That(order.ProductName).IsEqualTo(productName);
        await Assert.That(order.Price).IsEqualTo((decimal)price);

        context.OutputWriter.WriteLine($"Order created: {order.Id}");
    }

    [Test]
    [MethodDataSource(nameof(GetInvalidOrders))]
    public async Task CreateOrder_WithInvalidData_ThrowsException(int productId, string productName, double price)
    {
        await Assert.ThrowsAsync<ArgumentException>(() =>
            _orderService.CreateOrder(productId, productName, (decimal)price));
    }

    private static IEnumerable<(int productId, string productName, double price)> GetInvalidOrders()
    {
        yield return (0, "Product", 10.00);
        yield return (1, "", 10.00);
        yield return (1, "Product", -5.00);
    }

    [Test]
    [Skip("Not implemented yet")]
    public async Task CancelOrder_ValidOrder_Succeeds()
    {
        // Test implementation
    }

    [After(Test)]
    public async Task TestCleanup(TestContext context)
    {
        // Runs after each test
        _orderService?.Dispose();
        context.OutputWriter.WriteLine("Test completed");
    }

    [After(Class)]
    public static async Task ClassCleanup()
    {
        // Runs once after all tests in class
        _sharedDatabase?.Dispose();
    }

    [After(Assembly)]
    public static async Task AssemblyCleanup()
    {
        // Runs once after all tests in assembly
        Console.WriteLine("Assembly cleanup");
    }
}
```

**Key Changes:**
- `[TestClass]` removed (not required in TUnit)
- `TestContext` property → injected as method parameter when needed
- `[AssemblyInitialize]` → `[Before(Assembly)]` (no TestContext parameter)
- `[ClassInitialize]` → `[Before(Class)]` (no TestContext parameter)
- `[TestInitialize]` → `[Before(Test)]`
- `[TestCleanup]` → `[After(Test)]`
- `[ClassCleanup]` → `[After(Class)]`
- `[AssemblyCleanup]` → `[After(Assembly)]`
- `[TestMethod]` → `[Test]`
- `[DataRow(...)]` → `[Arguments(...)]`
- `[DynamicData(...)]` → `[MethodDataSource(...)]`
- Data sources return tuples instead of `object[]`
- All lifecycle methods can be async
- All assertions are awaited

### DataTestMethod with Multiple Sources

**MSTest Code:**
```csharp
[TestClass]
public class CalculatorTests
{
    [DataTestMethod]
    [DataRow(2, 3, 5)]
    [DataRow(10, 15, 25)]
    [DataRow(-5, 5, 0)]
    public void Add_ValidNumbers_ReturnsSum(int a, int b, int expected)
    {
        var calculator = new Calculator();
        var result = calculator.Add(a, b);
        Assert.AreEqual(expected, result);
    }

    [DataTestMethod]
    [DynamicData(nameof(GetMultiplicationData), DynamicDataSourceType.Method)]
    public void Multiply_ValidNumbers_ReturnsProduct(int a, int b, int expected)
    {
        var calculator = new Calculator();
        var result = calculator.Multiply(a, b);
        Assert.AreEqual(expected, result);
    }

    private static IEnumerable<object[]> GetMultiplicationData()
    {
        yield return new object[] { 2, 3, 6 };
        yield return new object[] { 4, 5, 20 };
        yield return new object[] { 0, 10, 0 };
    }
}
```

**TUnit Equivalent:**
```csharp
public class CalculatorTests
{
    [Test]
    [Arguments(2, 3, 5)]
    [Arguments(10, 15, 25)]
    [Arguments(-5, 5, 0)]
    public async Task Add_ValidNumbers_ReturnsSum(int a, int b, int expected)
    {
        var calculator = new Calculator();
        var result = calculator.Add(a, b);
        await Assert.That(result).IsEqualTo(expected);
    }

    [Test]
    [MethodDataSource(nameof(GetMultiplicationData))]
    public async Task Multiply_ValidNumbers_ReturnsProduct(int a, int b, int expected)
    {
        var calculator = new Calculator();
        var result = calculator.Multiply(a, b);
        await Assert.That(result).IsEqualTo(expected);
    }

    private static IEnumerable<(int a, int b, int expected)> GetMultiplicationData()
    {
        yield return (2, 3, 6);
        yield return (4, 5, 20);
        yield return (0, 10, 0);
    }
}
```

### Timeout Handling

**MSTest Code:**
```csharp
[TestClass]
public class TimeoutTests
{
    [TestMethod]
    [Timeout(5000)] // 5 seconds
    public async Task LongRunningOperation_CompletesInTime()
    {
        await Task.Delay(2000);
        Assert.IsTrue(true);
    }
}
```

**TUnit Equivalent:**
```csharp
public class TimeoutTests
{
    [Test]
    [Timeout(5000)] // 5 seconds in milliseconds
    public async Task LongRunningOperation_CompletesInTime()
    {
        await Task.Delay(2000);
        await Assert.That(true).IsTrue();
    }
}
```

**Key Changes:**
- Timeout attribute works similarly in both frameworks
- TUnit's timeout is also in milliseconds

### Expected Exception (Obsolete Pattern)

**MSTest Code (Old Style):**
```csharp
[TestClass]
public class ValidationTests
{
    [TestMethod]
    [ExpectedException(typeof(ArgumentNullException))]
    public void ValidateInput_NullInput_ThrowsException()
    {
        Validator.ValidateInput(null);
    }
}
```

**TUnit Equivalent:**
```csharp
public class ValidationTests
{
    [Test]
    public async Task ValidateInput_NullInput_ThrowsException()
    {
        await Assert.ThrowsAsync<ArgumentNullException>(() =>
            Validator.ValidateInput(null));
    }
}
```

**Key Changes:**
- `[ExpectedException]` is obsolete even in MSTest
- Use `Assert.ThrowsAsync` for better control and assertions
- Can capture and assert on the thrown exception

### DeploymentItem Pattern

**MSTest Code:**
```csharp
[TestClass]
[DeploymentItem("testdata.json")]
public class FileBasedTests
{
    public TestContext TestContext { get; set; }

    [TestMethod]
    public void LoadTestData_ValidFile_Succeeds()
    {
        var filePath = Path.Combine(TestContext.DeploymentDirectory, "testdata.json");
        var data = File.ReadAllText(filePath);
        Assert.IsNotNull(data);
    }
}
```

**TUnit Equivalent:**
```csharp
public class FileBasedTests
{
    [Test]
    public async Task LoadTestData_ValidFile_Succeeds()
    {
        // TUnit doesn't have DeploymentItem - use relative paths or copy files in build
        var filePath = Path.Combine(Directory.GetCurrentDirectory(), "testdata.json");
        var data = await File.ReadAllTextAsync(filePath);
        await Assert.That(data).IsNotNull();
    }
}
```

**Key Changes:**
- TUnit doesn't have `[DeploymentItem]`
- Configure file copying in your .csproj instead:
```xml
<ItemGroup>
  <None Update="testdata.json">
    <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
  </None>
</ItemGroup>
```

### Owner and Priority Properties

**MSTest Code:**
```csharp
[TestClass]
public class FeatureTests
{
    [TestMethod]
    [Owner("John Doe")]
    [Priority(1)]
    [TestCategory("Critical")]
    public void CriticalFeature_WorksCorrectly()
    {
        // Test implementation
    }

    [TestMethod]
    [Owner("Jane Smith")]
    [Priority(3)]
    [TestCategory("Enhancement")]
    public void Enhancement_WorksCorrectly()
    {
        // Test implementation
    }
}
```

**TUnit Equivalent:**
```csharp
public class FeatureTests
{
    [Test]
    [Property("Owner", "John Doe")]
    [Property("Priority", "1")]
    [Property("Category", "Critical")]
    public async Task CriticalFeature_WorksCorrectly()
    {
        // Test implementation
    }

    [Test]
    [Property("Owner", "Jane Smith")]
    [Property("Priority", "3")]
    [Property("Category", "Enhancement")]
    public async Task Enhancement_WorksCorrectly()
    {
        // Test implementation
    }
}
```

**Key Changes:**
- `[Owner("value")]` → `[Property("Owner", "value")]`
- `[Priority(n)]` → `[Property("Priority", "n")]`
- `[TestCategory("value")]` → `[Property("Category", "value")]`
- Can filter by properties: `--treenode-filter "/*/*/*/*[Priority=1]"`

### Advanced Assertions Comparison

**MSTest Code:**
```csharp
[TestMethod]
public void AdvancedAssertions_Examples()
{
    var value = 42;
    var text = "Hello, World!";
    var list = new List<int> { 1, 2, 3 };
    var person = new Person { Name = "John", Age = 30 };

    // Numeric assertions
    Assert.AreEqual(42, value);
    Assert.AreNotEqual(0, value);

    // String assertions with custom messages
    StringAssert.Contains(text, "World", "Should contain 'World'");
    StringAssert.StartsWith(text, "Hello");
    StringAssert.EndsWith(text, "!");
    StringAssert.Matches(text, new Regex(@"^\w+"));

    // Collection assertions
    CollectionAssert.Contains(list, 2);
    CollectionAssert.DoesNotContain(list, 5);
    CollectionAssert.AreEqual(new[] { 1, 2, 3 }, list);
    CollectionAssert.AreEquivalent(new[] { 3, 1, 2 }, list);
    CollectionAssert.AllItemsAreUnique(list);

    // Conditional assertions
    if (value > 40)
    {
        Assert.Inconclusive("Value is too high for this test");
    }

    Assert.Fail("Intentional failure for demonstration");
}
```

**TUnit Equivalent:**
```csharp
[Test]
public async Task AdvancedAssertions_Examples()
{
    var value = 42;
    var text = "Hello, World!";
    var list = new List<int> { 1, 2, 3 };
    var person = new Person { Name = "John", Age = 30 };

    // Numeric assertions
    await Assert.That(value).IsEqualTo(42);
    await Assert.That(value).IsNotEqualTo(0);

    // String assertions with custom messages
    await Assert.That(text).Contains("World").WithMessage("Should contain 'World'");
    await Assert.That(text).StartsWith("Hello");
    await Assert.That(text).EndsWith("!");
    await Assert.That(text).Matches(@"^\w+");

    // Collection assertions
    await Assert.That(list).Contains(2);
    await Assert.That(list).DoesNotContain(5);
    await Assert.That(list).IsEquivalentTo(new[] { 1, 2, 3 });
    await Assert.That(list).IsEquivalentTo(new[] { 3, 1, 2 }); // Order doesn't matter
    await Assert.That(list).HasDistinctItems();

    // Conditional test skipping
    if (value > 40)
    {
        Skip.Test("Value is too high for this test");
    }

    Assert.Fail("Intentional failure for demonstration");
}
```

### TestContext Usage Patterns

**MSTest Code:**
```csharp
[TestClass]
public class ContextTests
{
    public TestContext TestContext { get; set; }

    [TestMethod]
    public void UsingTestContext_AllProperties()
    {
        // Writing output
        TestContext.WriteLine($"Test: {TestContext.TestName}");
        TestContext.WriteLine($"Result: {TestContext.CurrentTestOutcome}");

        // Accessing test properties
        TestContext.WriteLine($"Fully Qualified Name: {TestContext.FullyQualifiedTestClassName}");

        // Custom properties
        TestContext.Properties["CustomKey"] = "CustomValue";
        var customValue = TestContext.Properties["CustomKey"];

        Assert.IsTrue(true);
    }

    [TestMethod]
    [TestProperty("Browser", "Chrome")]
    [TestProperty("Environment", "Staging")]
    public void TestWithProperties()
    {
        var browser = TestContext.Properties["Browser"];
        var environment = TestContext.Properties["Environment"];

        TestContext.WriteLine($"Running on {browser} in {environment}");
    }
}
```

**TUnit Equivalent:**
```csharp
public class ContextTests
{
    [Test]
    public async Task UsingTestContext_AllProperties(TestContext context)
    {
        // Writing output
        context.OutputWriter.WriteLine($"Test: {context.Metadata.TestName}");
        context.OutputWriter.WriteLine($"Test ID: {context.Metadata.TestDetails.TestId}");

        // Accessing test details
        context.OutputWriter.WriteLine($"Class: {context.Metadata.TestDetails.ClassType.Name}");
        context.OutputWriter.WriteLine($"Method: {context.Metadata.TestDetails.MethodInfo.Name}");

        // Accessing attributes and properties
        var properties = context.Metadata.TestDetails.Attributes.OfType<PropertyAttribute>();
        foreach (var prop in properties)
        {
            context.OutputWriter.WriteLine($"{prop.Key}: {prop.Value}");
        }

        await Assert.That(true).IsTrue();
    }

    [Test]
    [Property("Browser", "Chrome")]
    [Property("Environment", "Staging")]
    public async Task TestWithProperties(TestContext context)
    {
        var browserProp = context.Metadata.TestDetails.Attributes
            .OfType<PropertyAttribute>()
            .FirstOrDefault(p => p.Key == "Browser");

        var envProp = context.Metadata.TestDetails.Attributes
            .OfType<PropertyAttribute>()
            .FirstOrDefault(p => p.Key == "Environment");

        context.OutputWriter.WriteLine($"Running on {browserProp?.Value} in {envProp?.Value}");
    }
}
```

**Key Changes:**
- TestContext is injected as parameter, not a property
- Access output via `context.OutputWriter.WriteLine()`
- Test metadata available via `context.Metadata.TestDetails`
- Properties accessed through attributes rather than dictionary
- More type-safe property access

## Key Differences to Note

1. **Async by Default**: TUnit tests and assertions are async by default. Add `async Task` to your test methods and `await` assertions.

2. **No TestClass Required**: TUnit doesn't require a `[TestClass]` attribute on test classes.

3. **Fluent Assertions**: TUnit uses a fluent assertion style with `Assert.That()` as the starting point.

4. **TestContext Changes**:
   - TestContext is injected as a parameter rather than a property
   - ClassInitialize and AssemblyInitialize don't receive TestContext parameters
   - Access metadata via `context.Metadata.TestDetails` instead of various TestContext properties

5. **Dependency Injection**: TUnit has built-in support for dependency injection in test classes and methods.

6. **Hooks Instead of Initialize/Cleanup**: TUnit uses `[Before]` and `[After]` attributes with `HookType` to specify when they run.

7. **Static Class-Level Hooks**: Class-level and assembly-level setup/teardown methods must be static in TUnit.

8. **No DeploymentItem**: Configure file copying in your .csproj instead of using `[DeploymentItem]`.

9. **Property-Based Metadata**: Use `[Property("key", "value")]` for all metadata (Owner, Priority, Category, custom properties).

## Code Coverage

### Important: Coverlet is Not Compatible with TUnit

If you're using **Coverlet** (`coverlet.collector` or `coverlet.msbuild`) for code coverage in your MSTest projects, you'll need to migrate to **Microsoft.Testing.Extensions.CodeCoverage**.

**Why?** TUnit uses the modern `Microsoft.Testing.Platform` instead of VSTest, and Coverlet only works with the legacy VSTest platform.

### Good News: Coverage is Built In! 🎉

When you install the **TUnit** meta package, it automatically includes `Microsoft.Testing.Extensions.CodeCoverage` for you. You don't need to install it separately!

### Migration Steps

#### 1. Remove Coverlet Packages

Remove any Coverlet packages from your project file:

**Remove these lines from your `.csproj`:**
```xml
<!-- Remove these -->
<PackageReference Include="coverlet.collector" Version="x.x.x" />
<PackageReference Include="coverlet.msbuild" Version="x.x.x" />
```

#### 2. Verify TUnit Meta Package

Ensure you're using the **TUnit** meta package (not just TUnit.Core):

**Your `.csproj` should have:**
```xml
<PackageReference Include="TUnit" Version="0.x.x" />
```

This automatically brings in:
- `Microsoft.Testing.Extensions.CodeCoverage` (coverage support)
- `Microsoft.Testing.Extensions.TrxReport` (test result reports)

#### 3. Update Your Coverage Commands

Replace your old Coverlet commands with the new Microsoft coverage syntax:

**Old (Coverlet with MSTest):**
```bash
# With coverlet.collector
dotnet test --collect:"XPlat Code Coverage"

# With coverlet.msbuild
dotnet test /p:CollectCoverage=true /p:CoverletOutputFormat=cobertura
```

**New (TUnit with Microsoft Coverage):**
```bash
# Run tests with coverage
dotnet run --configuration Release --coverage

# Specify output location
dotnet run --configuration Release --coverage --coverage-output ./coverage/

# Specify coverage format (default is cobertura)
dotnet run --configuration Release --coverage --coverage-output-format cobertura

# Multiple formats
dotnet run --configuration Release --coverage --coverage-output-format cobertura --coverage-output-format xml
```

#### 4. Update CI/CD Pipelines

If you have CI/CD pipelines that reference Coverlet, update them to use the new commands:

**GitHub Actions Example:**
```yaml
# Old (MSTest with Coverlet)
- name: Run tests with coverage
  run: dotnet test --collect:"XPlat Code Coverage"

# New (TUnit with Microsoft Coverage)
- name: Run tests with coverage
  run: dotnet run --project ./tests/MyProject.Tests --configuration Release --coverage
```

**Azure Pipelines Example:**
```yaml
# Old (MSTest with Coverlet)
- task: DotNetCoreCLI@2
  inputs:
    command: 'test'
    arguments: '--collect:"XPlat Code Coverage"'

# New (TUnit with Microsoft Coverage)
- task: DotNetCoreCLI@2
  inputs:
    command: 'run'
    arguments: '--configuration Release --coverage --coverage-output $(Agent.TempDirectory)/coverage/'
```

### Coverage Output Formats

The Microsoft coverage tool supports multiple output formats:

```bash
# Cobertura (default, widely supported)
dotnet run --configuration Release --coverage --coverage-output-format cobertura

# XML (Visual Studio format)
dotnet run --configuration Release --coverage --coverage-output-format xml

# Cobertura + XML
dotnet run --configuration Release --coverage \
  --coverage-output-format cobertura \
  --coverage-output-format xml
```

### Viewing Coverage Results

Coverage files are generated in your test output directory:

```
TestResults/
  ├── coverage.cobertura.xml
  └── <guid>/
      └── coverage.xml
```

You can view these with:
- **Visual Studio** - Built-in coverage viewer (MSTest users will find this familiar)
- **VS Code** - Extensions like "Coverage Gutters"
- **ReportGenerator** - Generate HTML reports: `reportgenerator -reports:coverage.cobertura.xml -targetdir:coveragereport`
- **CI Tools** - Most CI systems can parse Cobertura format natively (same as before)

### Advanced Coverage Configuration

You can customize coverage behavior with a `testconfig.json` file:

**testconfig.json:**
```json
{
  "codeCoverage": {
    "Configuration": {
      "CodeCoverage": {
        "ModulePaths": {
          "Include": [".*\\.dll$"],
          "Exclude": [".*tests\\.dll$"]
        }
      }
    }
  }
}
```

Place the `testconfig.json` file in the same directory as your test project. It will be picked up automatically when running tests.

**Alternatively, you can use an XML coverage settings file:**
```bash
dotnet run --configuration Release --coverage --coverage-settings coverage.config
```

### Troubleshooting

**Coverage files not generated?**
- Ensure you're using the TUnit meta package, not just TUnit.Engine
- Verify you have a recent .NET SDK installed

**Missing coverage for some assemblies?**
- Use a `testconfig.json` file to explicitly include/exclude modules
- See [Microsoft's documentation](https://github.com/microsoft/codecoverage/blob/main/docs/configuration.md)

**Need help?**
- See [TUnit Code Coverage Documentation](../extensions/extensions.md#code-coverage)
- Check [Microsoft's Code Coverage Guide](https://learn.microsoft.com/en-us/dotnet/core/testing/unit-testing-code-coverage)

---

## Migrating from NUnit


:::from-nunit Performance Boost
Migrating from NUnit to TUnit can improve test execution speed. Check the [benchmarks](/docs/benchmarks) to see how TUnit compares.
:::

## Quick Reference

| NUnit | TUnit |
|-------|-------|
| `[TestFixture]` | *(remove - not needed)* |
| `[Test]` | `[Test]` |
| `[TestCase(...)]` | `[Arguments(...)]` |
| `[TestCaseSource(nameof(...))]` | `[MethodDataSource(nameof(...))]` |
| `[Category("value")]` | `[Category("value")]` *(same)* or `[Property("Category", "value")]` |
| `[Ignore]` | `[Skip]` |
| `[Explicit]` | `[Explicit]` |
| `[SetUp]` | `[Before(Test)]` |
| `[TearDown]` | `[After(Test)]` |
| `[OneTimeSetUp]` | `[Before(Class)]` |
| `[OneTimeTearDown]` | `[After(Class)]` |
| `[SetUpFixture]` + `[OneTimeSetUp]` | `[Before(Assembly)]` on static method |
| `[Values(...)]` on parameter | `[Matrix(...)]` on each parameter |
| `Assert.AreEqual(expected, actual)` | `await Assert.That(actual).IsEqualTo(expected)` |
| `Assert.That(actual, Is.EqualTo(expected))` | `await Assert.That(actual).IsEqualTo(expected)` |
| `Assert.Throws<T>(() => ...)` | `await Assert.ThrowsAsync<T>(() => ...)` |
| `TestContext.WriteLine(...)` | `TestContext` parameter with `context.OutputWriter.WriteLine(...)` |
| `TestContext.AddTestAttachment(path, name)` | `TestContext.Current!.Output.AttachArtifact(new Artifact { File = new FileInfo(path), DisplayName = name })` |
| `CollectionAssert.AreEqual(expected, actual)` | `await Assert.That(actual).IsEquivalentTo(expected)` |
| `StringAssert.Contains(substring, text)` | `await Assert.That(text).Contains(substring)` |

## Automated Migration with Code Fixers

TUnit includes Roslyn analyzers and code fixers that automate most of the migration work. The `TUNU0001` diagnostic identifies NUnit code patterns and provides automatic fixes to convert them to TUnit equivalents.

**What gets converted automatically:**
- `[TestFixture]` → removed (not needed in TUnit)
- `[Test]` → `[Test]` (stays the same)
- `[TestCase(...)]` → `[Arguments(...)]`
- `[TestCaseSource(nameof(...))]` → `[MethodDataSource(nameof(...))]`
- `[SetUp]` → `[Before(Test)]`
- `[TearDown]` → `[After(Test)]`
- `[OneTimeSetUp]` → `[Before(Class)]`
- `[OneTimeTearDown]` → `[After(Class)]`
- `[Ignore]` → `[Skip]`
- `[Category("...")]` → `[Property("Category", "...")]`
- Classic assertions: `Assert.AreEqual(expected, actual)` → `await Assert.That(actual).IsEqualTo(expected)`
- Constraint assertions: `Assert.That(actual, Is.EqualTo(expected))` → `await Assert.That(actual).IsEqualTo(expected)`
- Test methods converted to `async Task` with `await` on assertions

The code fixer handles roughly 80-90% of typical test suites automatically.

**What requires manual adjustment:**
- Custom `[TestCaseSource]` return types (convert `object[]` to tuples)
- Complex async patterns or custom awaitable types
- Custom fixtures or test base classes
- `[SetUpFixture]` with namespace-scoped setup (convert to assembly hooks)
- `TestContext.CurrentContext` static access (inject `TestContext` as parameter instead)
- `Assert.Multiple` blocks (use assertion groups or multiple awaited assertions)

If you find a common pattern that should be automated but isn't, please [open an issue](https://github.com/thomhurst/TUnit/issues).

### Prerequisites

- .NET SDK 8.0 or later (for `dotnet format` with analyzer support)
- TUnit packages installed in your test project

### Step-by-Step Migration

:::tip Safety First
Commit your changes or create a backup before running the code fixer. This allows you to review changes and revert if needed.
:::

**1. Install TUnit packages**

Add the TUnit packages to your test project alongside NUnit (temporarily):

```bash
dotnet add package TUnit
```

**2. Disable TUnit's implicit usings (temporary)**

Add these properties to your `.csproj` to prevent type name conflicts between NUnit and TUnit:

```xml
<PropertyGroup>
    <TUnitImplicitUsings>false</TUnitImplicitUsings>
    <TUnitAssertionsImplicitUsings>false</TUnitAssertionsImplicitUsings>
</PropertyGroup>
```

This allows the code fixer to distinguish between `NUnit.Framework.Assert` and `TUnit.Assertions.Assert`.

**3. Rebuild the project**

```bash
dotnet build
```

This restores packages and loads the TUnit analyzers. 

:::note Optional: Verify analyzer is working
The `TUNU0001` diagnostic is information-level and won't appear in standard build output. If you want to verify the analyzer is detecting NUnit code before applying changes, run:

```bash
dotnet format analyzers --severity info --diagnostics TUNU0001 --verify-no-changes
```

This command checks for `TUNU0001` diagnostics without modifying any files. If NUnit code is detected, you'll see messages like "Would fix N files" or specific file paths that would be changed.
:::

**4. Run the automated code fixer**

```bash
dotnet format analyzers --severity info --diagnostics TUNU0001
```

This command applies all available fixes for the `TUNU0001` diagnostic. You'll see output indicating which files were modified.

:::warning Multi-targeting Projects
If your project targets multiple .NET versions (e.g., `net8.0;net9.0;net10.0`), you **must** specify a single target framework when running the code fixer. Multi-targeting can cause the code fixer to crash with the error `Changes must be within bounds of SourceText` due to a limitation in Roslyn's linked file handling.

**Option 1:** Specify a single framework via command line:
```bash
dotnet format analyzers --severity info --diagnostics TUNU0001 --framework net10.0
```

**Option 2:** Temporarily modify your project file to single-target:
```xml
<!-- Before migration -->
<TargetFramework>net10.0</TargetFramework>
<!-- <TargetFrameworks>net8.0;net9.0;net10.0</TargetFrameworks> -->
```

Run the code fixer, then restore multi-targeting afterward. Replace `net10.0` with your project's highest supported target framework.
:::

**5. Remove the implicit usings workaround**

Remove or comment out the properties you added in step 2:

```xml
<!-- Remove these lines -->
<PropertyGroup>
    <TUnitImplicitUsings>false</TUnitImplicitUsings>
    <TUnitAssertionsImplicitUsings>false</TUnitAssertionsImplicitUsings>
</PropertyGroup>
```

**6. Fix remaining issues manually**

Build the project and address any remaining compilation errors:

```bash
dotnet build
```

Common manual fixes needed:
- Add `using TUnit.Core;` and `using TUnit.Assertions;` if not using implicit usings
- Convert data source methods to return tuples instead of `object[]`
- Replace `TestContext.CurrentContext` with injected `TestContext` parameter
- Update any custom assertion extensions

**7. Remove NUnit packages**

Once everything compiles and tests pass:

```bash
dotnet remove package NUnit
dotnet remove package NUnit3TestAdapter
```

**8. Verify the migration**

```bash
dotnet build
dotnet run -- --list-tests
```

### Troubleshooting

**Code fixer doesn't run / no files changed:**
- Ensure you rebuilt after adding TUnit packages
- Check that `TUNU0001` warnings appear in build output
- Try running with verbose output: `dotnet format analyzers --severity info --diagnostics TUNU0001 --verbosity detailed`

**Build errors after running code fixer:**
- Missing `await` keywords: ensure test methods are `async Task`
- Ambiguous `Assert`: remove NUnit usings or fully qualify types
- Type mismatch in data sources: convert `object[]` returns to tuples

**Analyzers not loading:**
- Verify TUnit package is installed: `dotnet list package`
- Try cleaning and rebuilding: `dotnet clean && dotnet build`

## Manual Migration Guide

### Test Attributes

`[TestFixture]` - Remove this attribute (not needed in TUnit)

`[Test]` remains `[Test]`

`[TestCase]` becomes `[Arguments]`

`[TestCaseSource]` becomes `[MethodDataSource]`

`[Category]` becomes `[Property("Category", "value")]`

`[Ignore]` becomes `[Skip]`

`[Explicit]` becomes `[Explicit]`

### Setup and Teardown

`[SetUp]` becomes `[Before(HookType.Test)]`

`[TearDown]` becomes `[After(HookType.Test)]`

`[OneTimeSetUp]` becomes `[Before(HookType.Class)]`

`[OneTimeTearDown]` becomes `[After(HookType.Class)]`

### Assertions

#### Classic Assertions
```csharp
// NUnit
Assert.AreEqual(expected, actual);
Assert.IsTrue(condition);
Assert.IsNull(value);
Assert.Greater(value1, value2);

// TUnit
await Assert.That(actual).IsEqualTo(expected);
await Assert.That(condition).IsTrue();
await Assert.That(value).IsNull();
await Assert.That(value1).IsGreaterThan(value2);
```

#### Constraint-Based Assertions
```csharp
// NUnit
Assert.That(actual, Is.EqualTo(expected));
Assert.That(value, Is.True);
Assert.That(value, Is.Null);
Assert.That(text, Does.Contain("substring"));
Assert.That(collection, Has.Count.EqualTo(5));

// TUnit
await Assert.That(actual).IsEqualTo(expected);
await Assert.That(value).IsTrue();
await Assert.That(value).IsNull();
await Assert.That(text).Contains("substring");
await Assert.That(collection).Count().IsEqualTo(5);
```

### Collection Assertions

```csharp
// NUnit
CollectionAssert.AreEqual(expected, actual);
CollectionAssert.Contains(collection, item);
CollectionAssert.IsEmpty(collection);

// TUnit
await Assert.That(actual).IsEquivalentTo(expected);
await Assert.That(collection).Contains(item);
await Assert.That(collection).IsEmpty();
```

### String Assertions

```csharp
// NUnit
StringAssert.Contains(substring, text);
StringAssert.StartsWith(prefix, text);
StringAssert.EndsWith(suffix, text);

// TUnit
await Assert.That(text).Contains(substring);
await Assert.That(text).StartsWith(prefix);
await Assert.That(text).EndsWith(suffix);
```

### Exception Testing

```csharp
// NUnit
Assert.Throws<InvalidOperationException>(() => DoSomething());
Assert.ThrowsAsync<InvalidOperationException>(async () => await DoSomethingAsync());

// TUnit
await Assert.ThrowsAsync<InvalidOperationException>(() => DoSomething());
await Assert.ThrowsAsync<InvalidOperationException>(async () => await DoSomethingAsync());
```

### Test Data Sources

#### TestCaseSource
```csharp
// NUnit
[TestCaseSource(nameof(TestData))]
public void TestMethod(int value, string text)
{
    // Test implementation
}

private static IEnumerable TestData()
{
    yield return new object[] { 1, "one" };
    yield return new object[] { 2, "two" };
}

// TUnit
[MethodDataSource(nameof(TestData))]
public async Task TestMethod(int value, string text)
{
    // Test implementation
}

private static IEnumerable<(int, string)> TestData()
{
    yield return (1, "one");
    yield return (2, "two");
}
```

### Parameterized Tests

```csharp
// NUnit
[TestCase(1, 2, 3)]
[TestCase(10, 20, 30)]
public void AdditionTest(int a, int b, int expected)
{
    Assert.AreEqual(expected, a + b);
}

// TUnit
[Test]
[Arguments(1, 2, 3)]
[Arguments(10, 20, 30)]
public async Task AdditionTest(int a, int b, int expected)
{
    await Assert.That(a + b).IsEqualTo(expected);
}
```

### Test Output

```csharp
// NUnit
TestContext.WriteLine("Test output");
TestContext.Out.WriteLine("More output");

// TUnit (inject TestContext)
public async Task MyTest(TestContext context)
{
    context.OutputWriter.WriteLine("Test output");
    context.OutputWriter.WriteLine("More output");
}
```

### Test Attachments

```csharp
// NUnit
[Test]
public void TestWithAttachment()
{
    // Test logic
    var logPath = "test-log.txt";
    File.WriteAllText(logPath, "test logs");
    
    TestContext.AddTestAttachment(logPath, "Test Log");
}

// TUnit
[Test]
public async Task TestWithAttachment()
{
    // Test logic
    var logPath = "test-log.txt";
    await File.WriteAllTextAsync(logPath, "test logs");
    
    TestContext.Current!.Output.AttachArtifact(new Artifact
    {
        File = new FileInfo(logPath),
        DisplayName = "Test Log",
        Description = "Logs captured during test execution"  // Optional
    });
}
```

For more information about working with test artifacts, including session-level artifacts and best practices, see the [Test Artifacts guide](../test-lifecycle/artifacts.md).

### Combinatorial Testing

#### Values and Combinatorial → Matrix

**NUnit Code:**
```csharp
public class CombinationTests
{
    [Test]
    public void TestCombinations(
        [Values(1, 2, 3)] int x,
        [Values("a", "b")] string y)
    {
        Assert.That(x, Is.GreaterThan(0));
        Assert.That(y, Is.Not.Null);
    }
}
```

**TUnit Equivalent:**
```csharp
public class CombinationTests
{
    [Test]
    public async Task TestCombinations(
        [Matrix(1, 2, 3)] int x,
        [Matrix("a", "b")] string y)
    {
        await Assert.That(x).IsGreaterThan(0);
        await Assert.That(y).IsNotNull();
    }
}
```

**Key Changes:**
- `[Values(...)]` attributes on parameters → `[Matrix(...)]` attributes on parameters
- All combinations are automatically generated (3 × 2 = 6 test cases)
- Each parameter gets its own `[Matrix]` attribute with the values to test

### Test Fixture with Parameters

#### Parameterized TestFixture

**NUnit Code:**
```csharp
[TestFixture("Development")]
[TestFixture("Staging")]
[TestFixture("Production")]
public class EnvironmentTests
{
    private readonly string _environment;

    public EnvironmentTests(string environment)
    {
        _environment = environment;
    }

    [Test]
    public void ConfigurationIsValid()
    {
        var config = LoadConfiguration(_environment);
        Assert.That(config, Is.Not.Null);
        Assert.That(config.IsValid, Is.True);
    }
}
```

**TUnit Equivalent:**
```csharp
[Arguments("Development")]
[Arguments("Staging")]
[Arguments("Production")]
public class EnvironmentTests(string environment)
{
    [Test]
    public async Task ConfigurationIsValid()
    {
        var config = LoadConfiguration(environment);
        await Assert.That(config).IsNotNull();
        await Assert.That(config.IsValid).IsTrue();
    }
}
```

**Key Changes:**
- `[TestFixture(...)]` with parameters → `[Arguments(...)]` on the class
- Primary constructor for cleaner syntax
- All tests in the class are repeated for each argument set

### Complete Test Class Example

**NUnit Code:**
```csharp
[TestFixture]
public class ProductServiceTests
{
    private IDatabase _database;
    private ProductService _productService;

    [OneTimeSetUp]
    public void OneTimeSetup()
    {
        // Runs once before all tests in the class
        _database = new InMemoryDatabase();
        _database.Initialize();
    }

    [SetUp]
    public void Setup()
    {
        // Runs before each test
        _productService = new ProductService(_database);
    }

    [Test]
    [Category("Unit")]
    [TestCase("Widget", 10.99)]
    [TestCase("Gadget", 25.50)]
    public void CreateProduct_WithValidData_Succeeds(string name, decimal price)
    {
        var product = _productService.CreateProduct(name, price);

        Assert.That(product, Is.Not.Null);
        Assert.That(product.Name, Is.EqualTo(name));
        Assert.That(product.Price, Is.EqualTo(price));
    }

    [Test]
    [Category("Unit")]
    public void GetProduct_WhenNotFound_ReturnsNull()
    {
        var product = _productService.GetProduct(999);
        Assert.That(product, Is.Null);
    }

    [Test]
    [TestCaseSource(nameof(InvalidProductData))]
    public void CreateProduct_WithInvalidData_ThrowsException(string name, decimal price)
    {
        Assert.Throws<ArgumentException>(() => _productService.CreateProduct(name, price));
    }

    private static IEnumerable InvalidProductData()
    {
        yield return new object[] { "", 10.00 };
        yield return new object[] { "Product", -5.00 };
        yield return new object[] { null, 10.00 };
    }

    [TearDown]
    public void TearDown()
    {
        // Runs after each test
        _productService?.Dispose();
    }

    [OneTimeTearDown]
    public void OneTimeTearDown()
    {
        // Runs once after all tests in the class
        _database?.Dispose();
    }
}
```

**TUnit Equivalent:**
```csharp
public class ProductServiceTests
{
    private IDatabase _database = null!;
    private ProductService _productService = null!;

    [Before(Class)]
    public async Task ClassSetup()
    {
        // Runs once before all tests in the class
        _database = new InMemoryDatabase();
        await _database.InitializeAsync();
    }

    [Before(Test)]
    public async Task Setup()
    {
        // Runs before each test
        _productService = new ProductService(_database);
    }

    [Test]
    [Property("Category", "Unit")]
    [Arguments("Widget", 10.99)]
    [Arguments("Gadget", 25.50)]
    public async Task CreateProduct_WithValidData_Succeeds(string name, decimal price)
    {
        var product = _productService.CreateProduct(name, price);

        await Assert.That(product).IsNotNull();
        await Assert.That(product.Name).IsEqualTo(name);
        await Assert.That(product.Price).IsEqualTo(price);
    }

    [Test]
    [Property("Category", "Unit")]
    public async Task GetProduct_WhenNotFound_ReturnsNull()
    {
        var product = _productService.GetProduct(999);
        await Assert.That(product).IsNull();
    }

    [Test]
    [MethodDataSource(nameof(InvalidProductData))]
    public async Task CreateProduct_WithInvalidData_ThrowsException(string name, decimal price)
    {
        await Assert.ThrowsAsync<ArgumentException>(
            () => _productService.CreateProduct(name, price));
    }

    private static IEnumerable<(string name, decimal price)> InvalidProductData()
    {
        yield return ("", 10.00m);
        yield return ("Product", -5.00m);
        yield return (null!, 10.00m);
    }

    [After(Test)]
    public async Task Cleanup()
    {
        // Runs after each test
        _productService?.Dispose();
    }

    [After(Class)]
    public async Task ClassCleanup()
    {
        // Runs once after all tests in the class
        _database?.Dispose();
    }
}
```

**Key Changes:**
- `[TestFixture]` attribute removed (not needed)
- `[OneTimeSetUp]` → `[Before(Class)]` (and can be async)
- `[SetUp]` → `[Before(Test)]`
- `[TearDown]` → `[After(Test)]`
- `[OneTimeTearDown]` → `[After(Class)]`
- `[TestCase(...)]` → `[Arguments(...)]`
- Data sources return tuples instead of `object[]`
- All assertions are awaited

### Range Testing

**NUnit Code:**
```csharp
[Test]
public void ProcessValue_WithRange([Range(1, 10)] int value)
{
    var result = ProcessValue(value);
    Assert.That(result, Is.GreaterThan(0));
}
```

**TUnit Equivalent:**
```csharp
[Test]
[MethodDataSource(nameof(GetRange))]
public async Task ProcessValue_WithRange(int value)
{
    var result = ProcessValue(value);
    await Assert.That(result).IsGreaterThan(0);
}

private static IEnumerable<int> GetRange()
{
    return Enumerable.Range(1, 10);
}
```

### Custom Test Context Properties

**NUnit Code:**
```csharp
[Test]
public void Test_WithContextProperties()
{
    TestContext.WriteLine($"Test Name: {TestContext.CurrentContext.Test.Name}");
    TestContext.WriteLine($"Test Status: {TestContext.CurrentContext.Result.Outcome.Status}");

    // Test implementation
}
```

**TUnit Equivalent:**
```csharp
[Test]
public async Task Test_WithContextProperties(TestContext context)
{
    context.OutputWriter.WriteLine($"Test Name: {context.Metadata.TestName}");
    context.OutputWriter.WriteLine($"Test ID: {context.Metadata.TestDetails.TestId}");
    context.OutputWriter.WriteLine($"Class Name: {context.Metadata.TestDetails.ClassType.Name}");

    // Test implementation
}
```

### Assertion Constraint Mapping

**NUnit Code:**
```csharp
[Test]
public void ComplexAssertions()
{
    var value = 42;
    var text = "Hello World";
    var list = new[] { 1, 2, 3, 4, 5 };

    // Comparison assertions
    Assert.That(value, Is.EqualTo(42));
    Assert.That(value, Is.Not.EqualTo(0));
    Assert.That(value, Is.GreaterThan(40));
    Assert.That(value, Is.LessThanOrEqualTo(50));
    Assert.That(value, Is.InRange(40, 45));

    // String assertions
    Assert.That(text, Does.StartWith("Hello"));
    Assert.That(text, Does.EndWith("World"));
    Assert.That(text, Does.Contain("llo Wor"));
    Assert.That(text, Does.Match(@"^Hello"));

    // Collection assertions
    Assert.That(list, Has.Count.EqualTo(5));
    Assert.That(list, Has.Member(3));
    Assert.That(list, Has.All.GreaterThan(0));
    Assert.That(list, Is.Ordered);

    // Compound assertions
    Assert.That(value, Is.GreaterThan(40).And.LessThan(50));
    Assert.That(text, Is.Not.Null.And.Not.Empty);
}
```

**TUnit Equivalent:**
```csharp
[Test]
public async Task ComplexAssertions()
{
    var value = 42;
    var text = "Hello World";
    var list = new[] { 1, 2, 3, 4, 5 };

    // Comparison assertions
    await Assert.That(value).IsEqualTo(42);
    await Assert.That(value).IsNotEqualTo(0);
    await Assert.That(value).IsGreaterThan(40);
    await Assert.That(value).IsLessThanOrEqualTo(50);
    await Assert.That(value).IsBetween(40, 45);

    // String assertions
    await Assert.That(text).StartsWith("Hello");
    await Assert.That(text).EndsWith("World");
    await Assert.That(text).Contains("llo Wor");
    await Assert.That(text).Matches(@"^Hello");

    // Collection assertions
    await Assert.That(list).Count().IsEqualTo(5);
    await Assert.That(list).Contains(3);
    await Assert.That(list).AllSatisfy(x => x > 0);
    await Assert.That(list).IsInAscendingOrder();

    // Compound assertions (using And/Or)
    await Assert.That(value).IsGreaterThan(40).And.IsLessThan(50);
    await Assert.That(text).IsNotNull().And.IsNotEmpty();
}
```

### SetUpFixture for Assembly-Level Hooks

**NUnit Code:**
```csharp
[SetUpFixture]
public class AssemblySetup
{
    [OneTimeSetUp]
    public void RunBeforeAnyTests()
    {
        // Initialize resources needed by all tests
        Console.WriteLine("Assembly setup running");
    }

    [OneTimeTearDown]
    public void RunAfterAllTests()
    {
        // Cleanup resources
        Console.WriteLine("Assembly cleanup running");
    }
}
```

**TUnit Equivalent:**
```csharp
public static class AssemblyHooks
{
    [Before(Assembly)]
    public static async Task AssemblySetup()
    {
        // Initialize resources needed by all tests
        Console.WriteLine("Assembly setup running");
    }

    [After(Assembly)]
    public static async Task AssemblyCleanup()
    {
        // Cleanup resources
        Console.WriteLine("Assembly cleanup running");
    }
}
```

**Key Changes:**
- `[SetUpFixture]` → simple static class
- `[OneTimeSetUp]` → `[Before(Assembly)]`
- `[OneTimeTearDown]` → `[After(Assembly)]`
- Methods must be static
- Can be async

## Key Differences to Note

1. **Async by Default**: TUnit tests and assertions are async by default. Add `async Task` to your test methods and `await` assertions.

2. **No TestFixture Required**: TUnit doesn't require a `[TestFixture]` attribute on test classes.

3. **Fluent Assertions**: TUnit uses a fluent assertion style with `Assert.That()` as the starting point.

4. **Dependency Injection**: TUnit has built-in support for dependency injection in test classes and methods.

5. **Hooks Instead of Setup/Teardown**: TUnit uses `[Before]` and `[After]` attributes with `HookType` to specify when they run.

6. **TestContext Injection**: Instead of a static `TestContext`, TUnit injects it as a parameter where needed.

7. **Isolated Test Instances**: Each test runs in its own class instance (NUnit's default behavior can be different).

## Code Coverage

### Important: Coverlet is Not Compatible with TUnit

If you're using **Coverlet** (`coverlet.collector` or `coverlet.msbuild`) for code coverage in your NUnit projects, you'll need to migrate to **Microsoft.Testing.Extensions.CodeCoverage**.

**Why?** TUnit uses the modern `Microsoft.Testing.Platform` instead of VSTest, and Coverlet only works with the legacy VSTest platform.

### Good News: Coverage is Built In! 🎉

When you install the **TUnit** meta package, it automatically includes `Microsoft.Testing.Extensions.CodeCoverage` for you. You don't need to install it separately!

### Migration Steps

#### 1. Remove Coverlet Packages

Remove any Coverlet packages from your project file:

**Remove these lines from your `.csproj`:**
```xml
<!-- Remove these -->
<PackageReference Include="coverlet.collector" Version="x.x.x" />
<PackageReference Include="coverlet.msbuild" Version="x.x.x" />
```

#### 2. Verify TUnit Meta Package

Ensure you're using the **TUnit** meta package (not just TUnit.Core):

**Your `.csproj` should have:**
```xml
<PackageReference Include="TUnit" Version="0.x.x" />
```

This automatically brings in:
- `Microsoft.Testing.Extensions.CodeCoverage` (coverage support)
- `Microsoft.Testing.Extensions.TrxReport` (test result reports)

#### 3. Update Your Coverage Commands

Replace your old Coverlet commands with the new Microsoft coverage syntax:

**Old (Coverlet with NUnit):**
```bash
# With coverlet.collector
dotnet test --collect:"XPlat Code Coverage"

# With coverlet.msbuild
dotnet test /p:CollectCoverage=true /p:CoverletOutputFormat=cobertura
```

**New (TUnit with Microsoft Coverage):**
```bash
# Run tests with coverage
dotnet run --configuration Release --coverage

# Specify output location
dotnet run --configuration Release --coverage --coverage-output ./coverage/

# Specify coverage format (default is cobertura)
dotnet run --configuration Release --coverage --coverage-output-format cobertura

# Multiple formats
dotnet run --configuration Release --coverage --coverage-output-format cobertura --coverage-output-format xml
```

#### 4. Update CI/CD Pipelines

If you have CI/CD pipelines that reference Coverlet, update them to use the new commands:

**GitHub Actions Example:**
```yaml
# Old (NUnit with Coverlet)
- name: Run tests with coverage
  run: dotnet test --collect:"XPlat Code Coverage"

# New (TUnit with Microsoft Coverage)
- name: Run tests with coverage
  run: dotnet run --project ./tests/MyProject.Tests --configuration Release --coverage
```

**Azure Pipelines Example:**
```yaml
# Old (NUnit with Coverlet)
- task: DotNetCoreCLI@2
  inputs:
    command: 'test'
    arguments: '--collect:"XPlat Code Coverage"'

# New (TUnit with Microsoft Coverage)
- task: DotNetCoreCLI@2
  inputs:
    command: 'run'
    arguments: '--configuration Release --coverage --coverage-output $(Agent.TempDirectory)/coverage/'
```

### Coverage Output Formats

The Microsoft coverage tool supports multiple output formats:

```bash
# Cobertura (default, widely supported)
dotnet run --configuration Release --coverage --coverage-output-format cobertura

# XML (Visual Studio format)
dotnet run --configuration Release --coverage --coverage-output-format xml

# Cobertura + XML
dotnet run --configuration Release --coverage \
  --coverage-output-format cobertura \
  --coverage-output-format xml
```

### Viewing Coverage Results

Coverage files are generated in your test output directory:

```
TestResults/
  ├── coverage.cobertura.xml
  └── <guid>/
      └── coverage.xml
```

You can view these with:
- **Visual Studio** - Built-in coverage viewer
- **VS Code** - Extensions like "Coverage Gutters"
- **ReportGenerator** - Generate HTML reports: `reportgenerator -reports:coverage.cobertura.xml -targetdir:coveragereport`
- **CI Tools** - Most CI systems can parse Cobertura format natively

### Advanced Coverage Configuration

You can customize coverage behavior with a `testconfig.json` file:

**testconfig.json:**
```json
{
  "codeCoverage": {
    "Configuration": {
      "CodeCoverage": {
        "ModulePaths": {
          "Include": [".*\\.dll$"],
          "Exclude": [".*tests\\.dll$"]
        }
      }
    }
  }
}
```

Place the `testconfig.json` file in the same directory as your test project. It will be picked up automatically when running tests.

**Alternatively, you can use an XML coverage settings file:**
```bash
dotnet run --configuration Release --coverage --coverage-settings coverage.config
```

### Troubleshooting

**Coverage files not generated?**
- Ensure you're using the TUnit meta package, not just TUnit.Engine
- Verify you have a recent .NET SDK installed

**Missing coverage for some assemblies?**
- Use a `testconfig.json` file to explicitly include/exclude modules
- See [Microsoft's documentation](https://github.com/microsoft/codecoverage/blob/main/docs/configuration.md)

**Need help?**
- See [TUnit Code Coverage Documentation](../extensions/extensions.md#code-coverage)
- Check [Microsoft's Code Coverage Guide](https://learn.microsoft.com/en-us/dotnet/core/testing/unit-testing-code-coverage)

---

## TestContext Interface Organization Migration Guide


## Overview

TUnit has reorganized the `TestContext` API to provide a cleaner, more discoverable interface structure. Properties and methods are now organized into logical, focused interfaces that group related functionality together.

This migration guide helps you update code that directly accesses `TestContext` properties to use the new interface-based API.

## What Changed

### New Interface Organization

`TestContext` now exposes its API through focused interface properties:

```csharp
public partial class TestContext :
    ITestExecution,
    ITestParallelization,
    ITestOutput,
    ITestMetadata,
    ITestDependencies,
    ITestStateBag,
    ITestEvents
{
    // Organized API access through interface properties
    public ITestExecution Execution => this;
    public ITestParallelization Parallelism => this;
    public ITestOutput Output => this;
    public ITestMetadata Metadata => this;
    public ITestDependencies Dependencies => this;
    public ITestStateBag StateBag => this;
    public ITestEvents Events => this;

    // Note: Services property is internal - use dependency injection instead
}
```

### Property Reorganization

Several properties have been moved from the main `TestContext` class into their appropriate interfaces:

#### `ITestExecution` - Execution State and Lifecycle

**New members:**
- `CustomHookExecutor` - Custom hook executor for test-level hooks
- `ReportResult` - Whether test results should be reported
- `AddLinkedCancellationToken()` - Link external cancellation tokens

**Existing members:**
- `Phase` - Current test phase (Discovery, Execution, Cleanup, etc.)
- `Result` - Test result after execution completes
- `CancellationToken` - Cancellation token for this test
- `TestStart` - Test execution start timestamp
- `TestEnd` - Test execution end timestamp
- `CurrentRetryAttempt` - Current retry attempt number
- `SkipReason` - Reason why test was skipped
- `RetryFunc` - Retry function for failed tests
- `OverrideResult()` - Override test result methods

#### `ITestMetadata` - Test Identity and Metadata

**New member:**
- `DisplayNameFormatter` - Custom display name formatter type

**Existing members:**
- `TestDetails` - Detailed metadata about the test
- `TestName` - Base name of the test method
- `DisplayName` - Display name for the test (get/set)

**Note:** `Id` is now a public property directly on `TestContext`, not on `ITestMetadata`.

#### `ITestEvents` - Test Event Integration

**New interface** exposing nullable event properties for lazy initialization:
- `OnDispose` - Event raised when test context is disposed
- `OnTestRegistered` - Event raised when test is registered
- `OnInitialize` - Event raised before test initialization
- `OnTestStart` - Event raised before test method execution
- `OnTestEnd` - Event raised after test method completion
- `OnTestSkipped` - Event raised when test is skipped
- `OnTestRetry` - Event raised before test retry

All events are nullable (`AsyncEvent<T>?`) to avoid allocating unused event handlers.

## Migration Steps

### Direct Property Access

If you were directly accessing properties on `TestContext`, they now need to be accessed through the appropriate interface property.

#### Execution-Related Properties

**Before:**
```csharp
// ❌ Old - Direct access
var customExecutor = TestContext.Current.CustomHookExecutor;
TestContext.Current.ReportResult = false;
TestContext.Current.AddLinkedCancellationToken(externalToken);
```

**After:**
```csharp
// ✅ New - Through Execution interface
var customExecutor = TestContext.Current.Execution.CustomHookExecutor;
TestContext.Current.Execution.ReportResult = false;
TestContext.Current.Execution.AddLinkedCancellationToken(externalToken);
```

#### Metadata-Related Properties

**Before:**
```csharp
// ❌ Old - Direct access
var formatter = TestContext.Current.DisplayNameFormatter;
TestContext.Current.DisplayNameFormatter = typeof(MyFormatter);
```

**After:**
```csharp
// ✅ New - Through Metadata interface
var formatter = TestContext.Current.Metadata.DisplayNameFormatter;
TestContext.Current.Metadata.DisplayNameFormatter = typeof(MyFormatter);
```

#### Event Access

Events are now accessed directly through the `Events` interface property, and all events are nullable for lazy initialization:

**Before:**
```csharp
// ❌ Old - Accessing through a nested Events property
TestContext.Current.Events.OnTestStart += handler;
```

**After:**
```csharp
// ✅ New - Direct access to nullable event properties
TestContext.Current.Events.OnTestStart += handler;

// Events are nullable and lazily initialized
if (TestContext.Current.Events.OnTestStart != null)
{
    await TestContext.Current.Events.OnTestStart.InvokeAsync(testContext, testContext);
}
```

### Custom Hook Executors

If you're implementing custom hook executors that access these properties:

**Before:**
```csharp
public class MyHookExecutor : IHookExecutor
{
    public async Task ExecuteAsync(TestContext context, Func<Task> hookBody)
    {
        // ❌ Old - Direct property access
        if (context.ReportResult)
        {
            await hookBody();
        }
    }
}
```

**After:**
```csharp
public class MyHookExecutor : IHookExecutor
{
    public async Task ExecuteAsync(TestContext context, Func<Task> hookBody)
    {
        // ✅ New - Through Execution interface
        if (context.Execution.ReportResult)
        {
            await hookBody();
        }
    }
}
```

### Test Registration/Building

If you're setting custom hook executors during test registration:

**Before:**
```csharp
public class CustomTestBuilder
{
    public void ConfigureTest(TestContext context)
    {
        // ❌ Old - Direct property access
        context.CustomHookExecutor = new MyCustomExecutor();
        context.DisplayNameFormatter = typeof(MyFormatter);
    }
}
```

**After:**
```csharp
public class CustomTestBuilder
{
    public void ConfigureTest(TestContext context)
    {
        // ✅ New - Through appropriate interfaces
        context.Execution.CustomHookExecutor = new MyCustomExecutor();
        context.Metadata.DisplayNameFormatter = typeof(MyFormatter);
    }
}
```

### Cancellation Token Linking

**Before:**
```csharp
[Before(HookType.Test)]
public void Setup()
{
    var externalCts = new CancellationTokenSource();

    // ❌ Old - Direct method call
    TestContext.Current.AddLinkedCancellationToken(externalCts.Token);
}
```

**After:**
```csharp
[Before(HookType.Test)]
public void Setup()
{
    var externalCts = new CancellationTokenSource();

    // ✅ New - Through Execution interface
    TestContext.Current.Execution.AddLinkedCancellationToken(externalCts.Token);
}
```

## Benefits of the New Organization

### 1. Better Discoverability

IntelliSense now groups related functionality together, making it easier to find what you need:

```csharp
TestContext.Current.Execution.  // Shows only execution-related members
TestContext.Current.Metadata.   // Shows only metadata-related members
TestContext.Current.Output.     // Shows only output-related members
```

### 2. Clearer Intent

Code that accesses interface-specific properties communicates its intent more clearly:

```csharp
// Clear that we're dealing with execution lifecycle
context.Execution.OverrideResult(TestState.Passed, "Mocked result");

// Clear that we're configuring metadata
context.Metadata.DisplayName = "Custom Test Name";

// Clear that we're working with test output
context.Output.WriteLine("Debug information");
```

### 3. Interface Segregation Principle

Consumers can depend on specific interfaces instead of the full `TestContext`:

```csharp
// Before: Depends on entire TestContext
public class MyService
{
    public void ProcessTest(TestContext context) { }
}

// After: Depends only on what's needed
public class MyService
{
    public void ProcessTest(ITestMetadata metadata) { }
    public void HandleExecution(ITestExecution execution) { }
}
```

### 4. Zero-Allocation Design

The interface properties return `this` cast to the appropriate interface type, ensuring zero allocation overhead:

```csharp
// No new objects created - just interface casting
ITestExecution execution = testContext.Execution;  // Zero allocations
```

## Complete Interface Reference

### ITestExecution

Test execution state and lifecycle management:

```csharp
public interface ITestExecution
{
    TestPhase Phase { get; }
    TestResult? Result { get; }
    CancellationToken CancellationToken { get; }
    DateTimeOffset? TestStart { get; }
    DateTimeOffset? TestEnd { get; }
    int CurrentRetryAttempt { get; }
    string? SkipReason { get; }
    Func<TestContext, Exception, int, Task<bool>>? RetryFunc { get; }
    IHookExecutor? CustomHookExecutor { get; set; }
    bool ReportResult { get; set; }

    void OverrideResult(string reason);
    void OverrideResult(TestState state, string reason);
    void AddLinkedCancellationToken(CancellationToken cancellationToken);
}
```

### ITestMetadata

Test metadata and identity:

```csharp
public interface ITestMetadata
{
    TestDetails TestDetails { get; }
    string TestName { get; }
    string DisplayName { get; set; }
    Type? DisplayNameFormatter { get; set; }
}
```

**Note:** `Id` is available only through the `ITestMetadata` interface (accessed via `TestContext.Metadata.Id`), not as a direct property on `TestContext`.

### ITestEvents

Test event integration with nullable lazy-initialized event properties:

```csharp
public interface ITestEvents
{
    AsyncEvent<TestContext>? OnDispose { get; }
    AsyncEvent<TestContext>? OnTestRegistered { get; }
    AsyncEvent<TestContext>? OnInitialize { get; }
    AsyncEvent<TestContext>? OnTestStart { get; }
    AsyncEvent<TestContext>? OnTestEnd { get; }
    AsyncEvent<TestContext>? OnTestSkipped { get; }
    AsyncEvent<(TestContext TestContext, int RetryAttempt)>? OnTestRetry { get; }
}
```

**Important:** All event properties are nullable to enable lazy initialization. Events are only allocated when subscribers are added, avoiding unnecessary allocations for unused events.

### Other Interfaces

For completeness, here are the other interface properties available:

#### ITestOutput

```csharp
public interface ITestOutput
{
    void WriteLine(string message);
    void WriteError(string message);
    string GetOutput();
    string GetErrorOutput();
}
```

#### ITestParallelization

```csharp
public interface ITestParallelization
{
    IReadOnlyList<IParallelConstraint> Constraints { get; }
    Priority ExecutionPriority { get; set; }
    IParallelLimit? Limiter { get; }  // Read-only - use TestRegisteredContext to set
    void AddConstraint(IParallelConstraint constraint);
}
```

**Important:** The `Limiter` property is **read-only** on the public interface. To set the parallel limiter, use the phase-specific `TestRegisteredContext.SetParallelLimiter()` method during test registration:

```csharp
[TestRegistered]
public static void OnTestRegistered(TestRegisteredContext context)
{
    // ✅ Correct - Use phase-specific context
    context.SetParallelLimiter(new ParallelLimit3());
}
```

#### ITestDependencies

```csharp
public interface ITestDependencies
{
    IReadOnlyList<TestContext> GetTests(Func<TestContext, bool> predicate);
    IReadOnlyList<TestContext> GetTests(string testName);
    IReadOnlyList<TestContext> GetTests(string testName, Type classType);
}
```

**Changed:** All `GetTests` methods now return `IReadOnlyList<TestContext>` for consistency and to better express the immutable nature of the returned collection.

#### ITestStateBag

```csharp
public interface ITestStateBag
{
    ConcurrentDictionary<string, object?> Items { get; }
    object? this[string key] { get; set; }
    int Count { get; }
    bool ContainsKey(string key);
    T GetOrAdd<T>(string key, Func<string, T> valueFactory);
    bool TryGetValue<T>(string key, out T value);
    bool TryRemove(string key, out object? value);
}
```

The `StateBag` interface provides both direct dictionary access via `Items` and type-safe helper methods for common operations.

## Summary

The TestContext interface organization provides:
- ✅ **Better discoverability** through grouped functionality
- ✅ **Clearer code intent** with semantic interface names
- ✅ **Zero performance overhead** with allocation-free design
- ✅ **Backwards compatibility** with direct property access
- ✅ **Future flexibility** for interface-based dependencies

Update your code incrementally, starting with new code and high-value refactorings, while legacy code continues to work unchanged.

---

## Migrating from xUnit.net


:::from-xunit Performance Boost
Migrating from xUnit to TUnit can improve test execution speed. Check the [benchmarks](/docs/benchmarks) to see how TUnit compares.
:::

## Quick Reference

| xUnit | TUnit |
|-------|-------|
| `[Fact]` | `[Test]` |
| `[Theory]` | `[Test]` |
| `[InlineData(...)]` | `[Arguments(...)]` |
| `[MemberData(nameof(...))]` | `[MethodDataSource(nameof(...))]` |
| `[ClassData(typeof(...))]` | `[MethodDataSource(nameof(ClassName.Method))]` |
| `[Trait("key", "value")]` | `[Property("key", "value")]` |
| `IClassFixture<T>` | `[ClassDataSource<T>(Shared = SharedType.PerClass)]` |
| `[Collection("name")]` | `[ClassDataSource<T>(Shared = SharedType.Keyed, Key = "name")]` |
| Constructor | Constructor or `[Before(Test)]` |
| `IDisposable` | `IDisposable` or `[After(Test)]` |
| `IAsyncLifetime` | `[Before(Test)]` / `[After(Test)]` |
| `ITestOutputHelper` | `TestContext` parameter |
| `Assert.Equal(expected, actual)` | `await Assert.That(actual).IsEqualTo(expected)` |
| `Assert.Throws<T>(() => ...)` | `await Assert.ThrowsAsync<T>(() => ...)` |

## Automated Migration with Code Fixers

TUnit includes Roslyn analyzers and code fixers that automate most of the migration work. The `TUXU0001` diagnostic identifies xUnit code patterns and provides automatic fixes to convert them to TUnit equivalents.

**What gets converted automatically:**
- `[Fact]` → `[Test]`
- `[Theory]` → `[Test]`
- `[InlineData(...)]` → `[Arguments(...)]`
- `[MemberData(nameof(...))]` → `[MethodDataSource(nameof(...))]`
- `[Trait("key", "value")]` → `[Property("key", "value")]`
- `Assert.Equal(expected, actual)` → `await Assert.That(actual).IsEqualTo(expected)`
- `Assert.True(condition)` → `await Assert.That(condition).IsTrue()`
- `Assert.Throws<T>(...)` → `await Assert.ThrowsAsync<T>(...)`
- `Assert.Contains(item, collection)` → `await Assert.That(collection).Contains(item)`
- Test methods converted to `async Task` with `await` on assertions

The code fixer handles roughly 80-90% of typical test suites automatically.

**What requires manual adjustment:**
- `IClassFixture<T>` → `[ClassDataSource<T>(Shared = SharedType.PerClass)]` on the class
- `ICollectionFixture<T>` and `[Collection("name")]` → `[ClassDataSource<T>(Shared = SharedType.Keyed, Key = "name")]`
- `IAsyncLifetime` → `[Before(Test)]` and `[After(Test)]` methods
- `ITestOutputHelper` → `TestContext` parameter injection
- Custom `MemberData` return types (convert `IEnumerable<object[]>` to `IEnumerable<(...)>` tuples)
- `[ClassData(typeof(...))]` → `[MethodDataSource(nameof(ClassName.Method))]`
- Constructor injection of fixtures → primary constructor with `[ClassDataSource<T>]` attribute
- Collection definitions → remove `ICollectionFixture` classes entirely

If you find a common pattern that should be automated but isn't, please [open an issue](https://github.com/thomhurst/TUnit/issues).

### Prerequisites

- .NET SDK 8.0 or later (for `dotnet format` with analyzer support)
- TUnit packages installed in your test project

### Step-by-Step Migration

:::tip Safety First
Commit your changes or create a backup before running the code fixer. This allows you to review changes and revert if needed.
:::

**1. Install TUnit packages**

Add the TUnit packages to your test project alongside xUnit (temporarily):

```bash
dotnet add package TUnit
```

**2. Disable TUnit's implicit usings (temporary)**

Add these properties to your `.csproj` to prevent type name conflicts between xUnit and TUnit:

```xml
<PropertyGroup>
    <TUnitImplicitUsings>false</TUnitImplicitUsings>
    <TUnitAssertionsImplicitUsings>false</TUnitAssertionsImplicitUsings>
</PropertyGroup>
```

This allows the code fixer to distinguish between `Xunit.Assert` and `TUnit.Assertions.Assert`.

**3. Rebuild the project**

```bash
dotnet build
```

This restores packages and loads the TUnit analyzers. 

:::note Optional: Verify analyzer is working
The `TUXU0001` diagnostic is information-level and won't appear in standard build output. If you want to verify the analyzer is detecting xUnit code before applying changes, run:

```bash
dotnet format analyzers --severity info --diagnostics TUXU0001 --verify-no-changes
```

This command checks for `TUXU0001` diagnostics without modifying any files. If xUnit code is detected, you'll see messages like "Would fix N files" or specific file paths that would be changed.
:::

**4. Run the automated code fixer**

```bash
dotnet format analyzers --severity info --diagnostics TUXU0001
```

This command applies all available fixes for the `TUXU0001` diagnostic. You'll see output indicating which files were modified.

:::warning Multi-targeting Projects
If your project targets multiple .NET versions (e.g., `net8.0;net9.0;net10.0`), you **must** specify a single target framework when running the code fixer. Multi-targeting can cause the code fixer to crash with the error `Changes must be within bounds of SourceText` due to a limitation in Roslyn's linked file handling.

**Option 1:** Specify a single framework via command line:
```bash
dotnet format analyzers --severity info --diagnostics TUXU0001 --framework net10.0
```

**Option 2:** Temporarily modify your project file to single-target:
```xml
<!-- Before migration -->
<TargetFramework>net10.0</TargetFramework>
<!-- <TargetFrameworks>net8.0;net9.0;net10.0</TargetFrameworks> -->
```

Run the code fixer, then restore multi-targeting afterward. Replace `net10.0` with your project's highest supported target framework.
:::

**5. Remove the implicit usings workaround**

Remove or comment out the properties you added in step 2:

```xml
<!-- Remove these lines -->
<PropertyGroup>
    <TUnitImplicitUsings>false</TUnitImplicitUsings>
    <TUnitAssertionsImplicitUsings>false</TUnitAssertionsImplicitUsings>
</PropertyGroup>
```

**6. Fix remaining issues manually**

Build the project and address any remaining compilation errors:

```bash
dotnet build
```

Common manual fixes needed:
- Replace `IClassFixture<T>` with `[ClassDataSource<T>(Shared = SharedType.PerClass)]` attribute
- Replace `IAsyncLifetime` with `[Before(Test)]`/`[After(Test)]` methods
- Replace `ITestOutputHelper` constructor parameter with `TestContext` method parameter
- Convert data source methods to return tuples instead of `object[]`
- Add `using TUnit.Core;` and `using TUnit.Assertions;` if not using implicit usings
- Remove `ICollectionFixture` and collection definition classes

**7. Remove xUnit packages**

Once everything compiles and tests pass:

```bash
dotnet remove package xunit
dotnet remove package xunit.runner.visualstudio
```

**8. Verify the migration**

```bash
dotnet build
dotnet run -- --list-tests
```

### Troubleshooting

**Code fixer doesn't run / no files changed:**
- Ensure you rebuilt after adding TUnit packages
- Check that `TUXU0001` warnings appear in build output
- Try running with verbose output: `dotnet format analyzers --severity info --diagnostics TUXU0001 --verbosity detailed`

**Build errors after running code fixer:**
- Missing `await` keywords: ensure test methods are `async Task`
- Ambiguous `Assert`: remove xUnit usings or fully qualify types
- Type mismatch in data sources: convert `IEnumerable<object[]>` returns to `IEnumerable<(...)>` tuples

**IClassFixture not converted:**
- This requires manual conversion - add `[ClassDataSource<T>(Shared = SharedType.PerClass)]` to the class
- Use a primary constructor to receive the fixture: `public class MyTests(MyFixture fixture)`

**Analyzers not loading:**
- Verify TUnit package is installed: `dotnet list package`
- Try cleaning and rebuilding: `dotnet clean && dotnet build`

## Manual Migration Guide

### Basic Test Structure

#### Simple Test (Fact → Test)

**xUnit Code:**
```csharp
public class CalculatorTests
{
    [Fact]
    public void Add_TwoNumbers_ReturnsSum()
    {
        var calculator = new Calculator();
        var result = calculator.Add(2, 3);
        Assert.Equal(5, result);
    }
}
```

**TUnit Equivalent:**
```csharp
public class CalculatorTests
{
    [Test]
    public async Task Add_TwoNumbers_ReturnsSum()
    {
        var calculator = new Calculator();
        var result = calculator.Add(2, 3);
        await Assert.That(result).IsEqualTo(5);
    }
}
```

**Key Changes:**
- `[Fact]` → `[Test]`
- Test method returns `async Task`
- Assertions use fluent syntax with `await Assert.That(...)`

### Parameterized Tests

#### Theory with InlineData → Arguments

**xUnit Code:**
```csharp
public class StringTests
{
    [Theory]
    [InlineData("hello", 5)]
    [InlineData("world", 5)]
    [InlineData("", 0)]
    public void Length_ReturnsCorrectValue(string input, int expectedLength)
    {
        Assert.Equal(expectedLength, input.Length);
    }
}
```

**TUnit Equivalent:**
```csharp
public class StringTests
{
    [Test]
    [Arguments("hello", 5)]
    [Arguments("world", 5)]
    [Arguments("", 0)]
    public async Task Length_ReturnsCorrectValue(string input, int expectedLength)
    {
        await Assert.That(input.Length).IsEqualTo(expectedLength);
    }
}
```

**Key Changes:**
- `[Theory]` → `[Test]`
- `[InlineData(...)]` → `[Arguments(...)]`
- Method is async and assertions are awaited

### Data Sources

#### MemberData → MethodDataSource

**xUnit Code:**
```csharp
public class DataDrivenTests
{
    [Theory]
    [MemberData(nameof(GetTestData))]
    public void ProcessData_WithVariousInputs(int value, string text, bool expected)
    {
        var result = SomeLogic(value, text);
        Assert.Equal(expected, result);
    }

    public static IEnumerable<object[]> GetTestData()
    {
        yield return new object[] { 1, "test", true };
        yield return new object[] { 2, "demo", false };
        yield return new object[] { 3, "example", true };
    }
}
```

**TUnit Equivalent:**
```csharp
public class DataDrivenTests
{
    [Test]
    [MethodDataSource(nameof(GetTestData))]
    public async Task ProcessData_WithVariousInputs(int value, string text, bool expected)
    {
        var result = SomeLogic(value, text);
        await Assert.That(result).IsEqualTo(expected);
    }

    public static IEnumerable<(int value, string text, bool expected)> GetTestData()
    {
        yield return (1, "test", true);
        yield return (2, "demo", false);
        yield return (3, "example", true);
    }
}
```

**Key Changes:**
- `[MemberData(nameof(...))]` → `[MethodDataSource(nameof(...))]`
- Data source returns tuples instead of `object[]` (strongly typed)
- No need for boxing/unboxing values

#### ClassData → MethodDataSource

**xUnit Code:**
```csharp
public class TestDataGenerator : IEnumerable<object[]>
{
    public IEnumerator<object[]> GetEnumerator()
    {
        yield return new object[] { 1, "one" };
        yield return new object[] { 2, "two" };
    }

    IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();
}

public class MyTests
{
    [Theory]
    [ClassData(typeof(TestDataGenerator))]
    public void TestWithClassData(int number, string text)
    {
        Assert.NotNull(text);
    }
}
```

**TUnit Equivalent:**
```csharp
public class MyTests
{
    [Test]
    [MethodDataSource(nameof(TestDataGenerator.GetTestData))]
    public async Task TestWithClassData(int number, string text)
    {
        await Assert.That(text).IsNotNull();
    }
}

public class TestDataGenerator
{
    public static IEnumerable<(int, string)> GetTestData()
    {
        yield return (1, "one");
        yield return (2, "two");
    }
}
```

**Key Changes:**
- `[ClassData(typeof(...))]` → `[MethodDataSource(nameof(ClassName.MethodName))]`
- Point to a static method rather than implementing IEnumerable
- Use tuples for type safety

### Setup and Teardown

#### Constructor and IDisposable → Before/After Hooks

**xUnit Code:**
```csharp
public class DatabaseTests : IDisposable
{
    private readonly DatabaseConnection _connection;

    public DatabaseTests()
    {
        _connection = new DatabaseConnection();
        _connection.Open();
    }

    [Fact]
    public void Query_ReturnsData()
    {
        var result = _connection.Query("SELECT * FROM Users");
        Assert.NotNull(result);
    }

    public void Dispose()
    {
        _connection?.Close();
        _connection?.Dispose();
    }
}
```

**TUnit Equivalent (Option 1: Using IDisposable):**
```csharp
public class DatabaseTests : IDisposable
{
    private DatabaseConnection _connection = null!;

    public DatabaseTests()
    {
        _connection = new DatabaseConnection();
        _connection.Open();
    }

    [Test]
    public async Task Query_ReturnsData()
    {
        var result = _connection.Query("SELECT * FROM Users");
        await Assert.That(result).IsNotNull();
    }

    public void Dispose()
    {
        _connection?.Close();
        _connection?.Dispose();
    }
}
```

**TUnit Equivalent (Option 2: Using Hooks):**
```csharp
public class DatabaseTests
{
    private DatabaseConnection _connection = null!;

    [Before(Test)]
    public async Task Setup()
    {
        _connection = new DatabaseConnection();
        await _connection.OpenAsync();
    }

    [Test]
    public async Task Query_ReturnsData()
    {
        var result = _connection.Query("SELECT * FROM Users");
        await Assert.That(result).IsNotNull();
    }

    [After(Test)]
    public async Task Cleanup()
    {
        if (_connection != null)
        {
            await _connection.CloseAsync();
            _connection.Dispose();
        }
    }
}
```

**Key Changes:**
- Constructor setup can remain, or use `[Before(Test)]`
- IDisposable can remain, or use `[After(Test)]`
- Hooks support async operations natively
- Multiple `[After(Test)]` methods are guaranteed to run even if one fails

#### IAsyncLifetime → Before/After Hooks

**xUnit Code:**
```csharp
public class AsyncSetupTests : IAsyncLifetime
{
    private HttpClient _client = null!;

    public async Task InitializeAsync()
    {
        _client = new HttpClient();
        await _client.GetAsync("https://api.example.com/warm-up");
    }

    [Fact]
    public async Task FetchData_ReturnsSuccess()
    {
        var response = await _client.GetAsync("https://api.example.com/data");
        Assert.True(response.IsSuccessStatusCode);
    }

    public async Task DisposeAsync()
    {
        _client?.Dispose();
        await Task.CompletedTask;
    }
}
```

**TUnit Equivalent:**
```csharp
public class AsyncSetupTests
{
    private HttpClient _client = null!;

    [Before(Test)]
    public async Task Setup()
    {
        _client = new HttpClient();
        await _client.GetAsync("https://api.example.com/warm-up");
    }

    [Test]
    public async Task FetchData_ReturnsSuccess()
    {
        var response = await _client.GetAsync("https://api.example.com/data");
        await Assert.That(response.IsSuccessStatusCode).IsTrue();
    }

    [After(Test)]
    public async Task Cleanup()
    {
        _client?.Dispose();
    }
}
```

**Key Changes:**
- `IAsyncLifetime.InitializeAsync()` → `[Before(Test)]`
- `IAsyncLifetime.DisposeAsync()` → `[After(Test)]`
- More explicit and easier to understand at a glance

### Shared Context and Fixtures

#### IClassFixture → ClassDataSource

**xUnit Code:**
```csharp
public class DatabaseFixture : IDisposable
{
    public DatabaseConnection Connection { get; }

    public DatabaseFixture()
    {
        Connection = new DatabaseConnection();
        Connection.Open();
    }

    public void Dispose()
    {
        Connection?.Close();
        Connection?.Dispose();
    }
}

public class UserRepositoryTests : IClassFixture<DatabaseFixture>
{
    private readonly DatabaseFixture _fixture;

    public UserRepositoryTests(DatabaseFixture fixture)
    {
        _fixture = fixture;
    }

    [Fact]
    public void GetUser_ReturnsUser()
    {
        var repo = new UserRepository(_fixture.Connection);
        var user = repo.GetUser(1);
        Assert.NotNull(user);
    }

    [Fact]
    public void GetAllUsers_ReturnsUsers()
    {
        var repo = new UserRepository(_fixture.Connection);
        var users = repo.GetAllUsers();
        Assert.NotEmpty(users);
    }
}
```

**TUnit Equivalent:**
```csharp
public class DatabaseFixture : IDisposable
{
    public DatabaseConnection Connection { get; }

    public DatabaseFixture()
    {
        Connection = new DatabaseConnection();
        Connection.Open();
    }

    public void Dispose()
    {
        Connection?.Close();
        Connection?.Dispose();
    }
}

[ClassDataSource<DatabaseFixture>(Shared = SharedType.PerClass)]
public class UserRepositoryTests(DatabaseFixture fixture)
{
    [Test]
    public async Task GetUser_ReturnsUser()
    {
        var repo = new UserRepository(fixture.Connection);
        var user = repo.GetUser(1);
        await Assert.That(user).IsNotNull();
    }

    [Test]
    public async Task GetAllUsers_ReturnsUsers()
    {
        var repo = new UserRepository(fixture.Connection);
        var users = repo.GetAllUsers();
        await Assert.That(users).IsNotEmpty();
    }
}
```

**Key Changes:**
- `IClassFixture<T>` interface → `[ClassDataSource<T>(Shared = SharedType.PerClass)]` attribute
- Fixture injected via primary constructor
- `Shared = SharedType.PerClass` ensures one instance per test class

#### Collection Fixtures → Shared ClassDataSource

**xUnit Code:**
```csharp
[CollectionDefinition("Database collection")]
public class DatabaseCollection : ICollectionFixture<DatabaseFixture>
{
}

public class DatabaseFixture : IDisposable
{
    public DatabaseConnection Connection { get; }

    public DatabaseFixture()
    {
        Connection = new DatabaseConnection();
        Connection.Open();
    }

    public void Dispose() => Connection?.Dispose();
}

[Collection("Database collection")]
public class UserTests : IClassFixture<DatabaseFixture>
{
    private readonly DatabaseFixture _fixture;

    public UserTests(DatabaseFixture fixture)
    {
        _fixture = fixture;
    }

    [Fact]
    public void CreateUser_Succeeds()
    {
        // Test using _fixture.Connection
    }
}

[Collection("Database collection")]
public class ProductTests : IClassFixture<DatabaseFixture>
{
    private readonly DatabaseFixture _fixture;

    public ProductTests(DatabaseFixture fixture)
    {
        _fixture = fixture;
    }

    [Fact]
    public void CreateProduct_Succeeds()
    {
        // Test using _fixture.Connection
    }
}
```

**TUnit Equivalent:**
```csharp
public class DatabaseFixture : IDisposable
{
    public DatabaseConnection Connection { get; }

    public DatabaseFixture()
    {
        Connection = new DatabaseConnection();
        Connection.Open();
    }

    public void Dispose() => Connection?.Dispose();
}

[ClassDataSource<DatabaseFixture>(Shared = SharedType.Keyed, Key = "DatabaseCollection")]
public class UserTests(DatabaseFixture fixture)
{
    [Test]
    public async Task CreateUser_Succeeds()
    {
        // Test using fixture.Connection
    }
}

[ClassDataSource<DatabaseFixture>(Shared = SharedType.Keyed, Key = "DatabaseCollection")]
public class ProductTests(DatabaseFixture fixture)
{
    [Test]
    public async Task CreateProduct_Succeeds()
    {
        // Test using fixture.Connection
    }
}
```

**Key Changes:**
- `[Collection("name")]` → `[ClassDataSource<T>(Shared = SharedType.Keyed, Key = "name")]`
- No need for CollectionDefinition class
- All classes with same Key share the fixture instance

#### Assembly Fixture → ClassDataSource with PerAssembly

**xUnit doesn't have native assembly fixtures, but TUnit does:**

**TUnit Example:**
```csharp
public class ApplicationFixture : IDisposable
{
    public IServiceProvider ServiceProvider { get; }

    public ApplicationFixture()
    {
        // Setup once for entire assembly
        ServiceProvider = ConfigureServices();
    }

    public void Dispose()
    {
        // Cleanup once after all tests
    }
}

[ClassDataSource<ApplicationFixture>(Shared = SharedType.PerAssembly)]
public class IntegrationTests(ApplicationFixture fixture)
{
    [Test]
    public async Task Test1()
    {
        var service = fixture.ServiceProvider.GetService<IMyService>();
        await Assert.That(service).IsNotNull();
    }
}
```

### Test Output

#### ITestOutputHelper → TestContext

**xUnit Code:**
```csharp
public class LoggingTests
{
    private readonly ITestOutputHelper _output;

    public LoggingTests(ITestOutputHelper output)
    {
        _output = output;
    }

    [Fact]
    public void Test_WithLogging()
    {
        _output.WriteLine("Starting test");

        var result = PerformOperation();

        _output.WriteLine($"Result: {result}");
        Assert.True(result > 0);
    }
}
```

**TUnit Equivalent:**
```csharp
public class LoggingTests
{
    [Test]
    public async Task Test_WithLogging(TestContext context)
    {
        context.OutputWriter.WriteLine("Starting test");

        var result = PerformOperation();

        context.OutputWriter.WriteLine($"Result: {result}");
        await Assert.That(result).IsGreaterThan(0);
    }
}
```

**Key Changes:**
- `ITestOutputHelper` injected in constructor → `TestContext` injected as method parameter
- Access output via `context.OutputWriter.WriteLine()`
- TestContext provides additional test metadata

#### Test Attachments

xUnit v3 introduced test attachments. TUnit also supports this capability:

**xUnit v3 Code:**
```csharp
public class TestWithAttachments
{
    private readonly ITestContextAccessor _testContextAccessor;
    
    public TestWithAttachments(ITestContextAccessor testContextAccessor)
    {
        _testContextAccessor = testContextAccessor;
    }
    
    [Fact]
    public async Task Test_WithAttachment()
    {
        // Test logic
        var logPath = "test-log.txt";
        await File.WriteAllTextAsync(logPath, "test logs");
        
        _testContextAccessor.Current!.Attachments.Add(
            new FileAttachment(logPath, "Test Log"));
    }
}
```

**TUnit Equivalent:**
```csharp
public class TestWithAttachments
{
    [Test]
    public async Task Test_WithAttachment()
    {
        // Test logic
        var logPath = "test-log.txt";
        await File.WriteAllTextAsync(logPath, "test logs");
        
        TestContext.Current!.Output.AttachArtifact(new Artifact
        {
            File = new FileInfo(logPath),
            DisplayName = "Test Log",
            Description = "Logs captured during test execution"  // Optional
        });
    }
}
```

For more information about working with test artifacts, including session-level artifacts and best practices, see the [Test Artifacts guide](../test-lifecycle/artifacts.md).

### Traits and Categories

#### Trait → Property

**xUnit Code:**
```csharp
public class FeatureTests
{
    [Fact]
    [Trait("Category", "Integration")]
    [Trait("Priority", "High")]
    public void ImportantIntegrationTest()
    {
        // Test implementation
    }
}
```

**TUnit Equivalent:**
```csharp
public class FeatureTests
{
    [Test]
    [Property("Category", "Integration")]
    [Property("Priority", "High")]
    public async Task ImportantIntegrationTest()
    {
        // Test implementation
    }
}
```

**Key Changes:**
- `[Trait("key", "value")]` → `[Property("key", "value")]`
- Can be used for filtering: `--treenode-filter "/*/*/*/*[Category=Integration]"`

### Assertions

#### Basic Assertions

**xUnit Code:**
```csharp
[Fact]
public void Assertions_Examples()
{
    Assert.Equal(5, 2 + 3);
    Assert.NotEqual(5, 2 + 2);
    Assert.True(5 > 3);
    Assert.False(5 < 3);
    Assert.Null(null);
    Assert.NotNull("value");
    Assert.Same(obj1, obj2);
    Assert.NotSame(obj1, obj3);
}
```

**TUnit Equivalent:**
```csharp
[Test]
public async Task Assertions_Examples()
{
    await Assert.That(2 + 3).IsEqualTo(5);
    await Assert.That(2 + 2).IsNotEqualTo(5);
    await Assert.That(5 > 3).IsTrue();
    await Assert.That(5 < 3).IsFalse();
    await Assert.That((object?)null).IsNull();
    await Assert.That("value").IsNotNull();
    await Assert.That(obj1).IsSameReference(obj2);
    await Assert.That(obj1).IsNotSameReference(obj3);
}
```

#### Collection Assertions

**xUnit Code:**
```csharp
[Fact]
public void Collection_Assertions()
{
    var list = new[] { 1, 2, 3 };

    Assert.Contains(2, list);
    Assert.DoesNotContain(5, list);
    Assert.Empty(Array.Empty<int>());
    Assert.NotEmpty(list);
    Assert.Equal(3, list.Length);
}
```

**TUnit Equivalent:**
```csharp
[Test]
public async Task Collection_Assertions()
{
    var list = new[] { 1, 2, 3 };

    await Assert.That(list).Contains(2);
    await Assert.That(list).DoesNotContain(5);
    await Assert.That(Array.Empty<int>()).IsEmpty();
    await Assert.That(list).IsNotEmpty();
    await Assert.That(list).Count().IsEqualTo(3);
}
```

#### String Assertions

**xUnit Code:**
```csharp
[Fact]
public void String_Assertions()
{
    var text = "Hello, World!";

    Assert.Contains("World", text);
    Assert.DoesNotContain("xyz", text);
    Assert.StartsWith("Hello", text);
    Assert.EndsWith("!", text);
    Assert.Matches(@"H\w+", text);
}
```

**TUnit Equivalent:**
```csharp
[Test]
public async Task String_Assertions()
{
    var text = "Hello, World!";

    await Assert.That(text).Contains("World");
    await Assert.That(text).DoesNotContain("xyz");
    await Assert.That(text).StartsWith("Hello");
    await Assert.That(text).EndsWith("!");
    await Assert.That(text).Matches(@"H\w+");
}
```

#### Exception Assertions

**xUnit Code:**
```csharp
[Fact]
public void Exception_Assertions()
{
    Assert.Throws<ArgumentException>(() => ThrowsException());

    var ex = Assert.Throws<ArgumentException>(() => ThrowsException());
    Assert.Equal("paramName", ex.ParamName);
}

[Fact]
public async Task Async_Exception_Assertions()
{
    await Assert.ThrowsAsync<InvalidOperationException>(() => ThrowsExceptionAsync());
}
```

**TUnit Equivalent:**
```csharp
[Test]
public async Task Exception_Assertions()
{
    await Assert.ThrowsAsync<ArgumentException>(() => ThrowsException());

    var ex = await Assert.ThrowsAsync<ArgumentException>(() => ThrowsException());
    await Assert.That(ex.ParamName).IsEqualTo("paramName");
}

[Test]
public async Task Async_Exception_Assertions()
{
    await Assert.ThrowsAsync<InvalidOperationException>(() => ThrowsExceptionAsync());
}
```

**Key Changes:**
- Both sync and async use `Assert.ThrowsAsync` in TUnit
- Returned exception can be further asserted on

### Complete Example: Real-World Test Class

**xUnit Code:**
```csharp
public class UserServiceTests : IClassFixture<DatabaseFixture>, IAsyncLifetime
{
    private readonly DatabaseFixture _dbFixture;
    private readonly ITestOutputHelper _output;
    private UserService _userService = null!;

    public UserServiceTests(DatabaseFixture dbFixture, ITestOutputHelper output)
    {
        _dbFixture = dbFixture;
        _output = output;
    }

    public async Task InitializeAsync()
    {
        _userService = new UserService(_dbFixture.Connection);
        await _userService.InitializeAsync();
    }

    public Task DisposeAsync() => Task.CompletedTask;

    [Theory]
    [InlineData("john@example.com", "John")]
    [InlineData("jane@example.com", "Jane")]
    public async Task CreateUser_WithValidData_Succeeds(string email, string name)
    {
        _output.WriteLine($"Creating user: {name}");

        var user = await _userService.CreateUserAsync(email, name);

        Assert.NotNull(user);
        Assert.Equal(email, user.Email);
        Assert.Equal(name, user.Name);

        _output.WriteLine($"User created with ID: {user.Id}");
    }

    [Fact]
    public async Task GetUser_WhenNotFound_ThrowsException()
    {
        await Assert.ThrowsAsync<UserNotFoundException>(
            () => _userService.GetUserAsync(99999));
    }

    [Theory]
    [MemberData(nameof(GetInvalidEmails))]
    public async Task CreateUser_WithInvalidEmail_ThrowsException(string invalidEmail)
    {
        await Assert.ThrowsAsync<ArgumentException>(
            () => _userService.CreateUserAsync(invalidEmail, "Test"));
    }

    public static IEnumerable<object[]> GetInvalidEmails()
    {
        yield return new object[] { "" };
        yield return new object[] { "not-an-email" };
        yield return new object[] { "@example.com" };
    }
}
```

**TUnit Equivalent:**
```csharp
[ClassDataSource<DatabaseFixture>(Shared = SharedType.PerClass)]
public class UserServiceTests(DatabaseFixture dbFixture)
{
    private UserService _userService = null!;

    [Before(Test)]
    public async Task Setup()
    {
        _userService = new UserService(dbFixture.Connection);
        await _userService.InitializeAsync();
    }

    [Test]
    [Arguments("john@example.com", "John")]
    [Arguments("jane@example.com", "Jane")]
    public async Task CreateUser_WithValidData_Succeeds(string email, string name, TestContext context)
    {
        context.OutputWriter.WriteLine($"Creating user: {name}");

        var user = await _userService.CreateUserAsync(email, name);

        await Assert.That(user).IsNotNull();
        await Assert.That(user.Email).IsEqualTo(email);
        await Assert.That(user.Name).IsEqualTo(name);

        context.OutputWriter.WriteLine($"User created with ID: {user.Id}");
    }

    [Test]
    public async Task GetUser_WhenNotFound_ThrowsException()
    {
        await Assert.ThrowsAsync<UserNotFoundException>(
            () => _userService.GetUserAsync(99999));
    }

    [Test]
    [MethodDataSource(nameof(GetInvalidEmails))]
    public async Task CreateUser_WithInvalidEmail_ThrowsException(string invalidEmail)
    {
        await Assert.ThrowsAsync<ArgumentException>(
            () => _userService.CreateUserAsync(invalidEmail, "Test"));
    }

    public static IEnumerable<string> GetInvalidEmails()
    {
        yield return "";
        yield return "not-an-email";
        yield return "@example.com";
    }
}
```

**Key Differences Summary:**
- Class-level fixtures use attributes instead of interfaces
- Setup/teardown use `[Before]`/`[After]` attributes instead of IAsyncLifetime
- Primary constructor for fixture injection
- TestContext injected as method parameter when needed
- All tests are async by default
- Data sources return strongly-typed values (not object[])
- Fluent assertion syntax

## Code Coverage

### Important: Coverlet is Not Compatible with TUnit

If you're using **Coverlet** (`coverlet.collector` or `coverlet.msbuild`) for code coverage in your xUnit projects, you'll need to migrate to **Microsoft.Testing.Extensions.CodeCoverage**.

**Why?** TUnit uses the modern `Microsoft.Testing.Platform` instead of VSTest, and Coverlet only works with the legacy VSTest platform.

### Good News: Coverage is Built In! 🎉

When you install the **TUnit** meta package, it automatically includes `Microsoft.Testing.Extensions.CodeCoverage` for you. You don't need to install it separately!

### Migration Steps

#### 1. Remove Coverlet Packages

Remove any Coverlet packages from your project file:

**Remove these lines from your `.csproj`:**
```xml
<!-- Remove these -->
<PackageReference Include="coverlet.collector" Version="x.x.x" />
<PackageReference Include="coverlet.msbuild" Version="x.x.x" />
```

#### 2. Verify TUnit Meta Package

Ensure you're using the **TUnit** meta package (not just TUnit.Core):

**Your `.csproj` should have:**
```xml
<PackageReference Include="TUnit" Version="0.x.x" />
```

This automatically brings in:
- `Microsoft.Testing.Extensions.CodeCoverage` (coverage support)
- `Microsoft.Testing.Extensions.TrxReport` (test result reports)

#### 3. Update Your Coverage Commands

Replace your old Coverlet commands with the new Microsoft coverage syntax:

**Old (Coverlet with xUnit):**
```bash
# With coverlet.collector
dotnet test --collect:"XPlat Code Coverage"

# With coverlet.msbuild
dotnet test /p:CollectCoverage=true /p:CoverletOutputFormat=cobertura
```

**New (TUnit with Microsoft Coverage):**
```bash
# Run tests with coverage
dotnet run --configuration Release --coverage

# Specify output location
dotnet run --configuration Release --coverage --coverage-output ./coverage/

# Specify coverage format (default is cobertura)
dotnet run --configuration Release --coverage --coverage-output-format cobertura

# Multiple formats
dotnet run --configuration Release --coverage --coverage-output-format cobertura --coverage-output-format xml
```

#### 4. Update CI/CD Pipelines

If you have CI/CD pipelines that reference Coverlet, update them to use the new commands:

**GitHub Actions Example:**
```yaml
# Old (xUnit with Coverlet)
- name: Run tests with coverage
  run: dotnet test --collect:"XPlat Code Coverage"

# New (TUnit with Microsoft Coverage)
- name: Run tests with coverage
  run: dotnet run --project ./tests/MyProject.Tests --configuration Release --coverage
```

**Azure Pipelines Example:**
```yaml
# Old (xUnit with Coverlet)
- task: DotNetCoreCLI@2
  inputs:
    command: 'test'
    arguments: '--collect:"XPlat Code Coverage"'

# New (TUnit with Microsoft Coverage)
- task: DotNetCoreCLI@2
  inputs:
    command: 'run'
    arguments: '--configuration Release --coverage --coverage-output $(Agent.TempDirectory)/coverage/'
```

### Coverage Output Formats

The Microsoft coverage tool supports multiple output formats:

```bash
# Cobertura (default, widely supported)
dotnet run --configuration Release --coverage --coverage-output-format cobertura

# XML (Visual Studio format)
dotnet run --configuration Release --coverage --coverage-output-format xml

# Cobertura + XML
dotnet run --configuration Release --coverage \
  --coverage-output-format cobertura \
  --coverage-output-format xml
```

### Viewing Coverage Results

Coverage files are generated in your test output directory:

```
TestResults/
  ├── coverage.cobertura.xml
  └── <guid>/
      └── coverage.xml
```

You can view these with:
- **Visual Studio** - Built-in coverage viewer
- **VS Code** - Extensions like "Coverage Gutters"
- **ReportGenerator** - Generate HTML reports: `reportgenerator -reports:coverage.cobertura.xml -targetdir:coveragereport`
- **CI Tools** - Most CI systems can parse Cobertura format natively

### Advanced Coverage Configuration

You can customize coverage behavior with a `testconfig.json` file:

**testconfig.json:**
```json
{
  "codeCoverage": {
    "Configuration": {
      "CodeCoverage": {
        "ModulePaths": {
          "Include": [".*\\.dll$"],
          "Exclude": [".*tests\\.dll$"]
        }
      }
    }
  }
}
```

Place the `testconfig.json` file in the same directory as your test project. It will be picked up automatically when running tests.

**Alternatively, you can use an XML coverage settings file:**
```bash
dotnet run --configuration Release --coverage --coverage-settings coverage.config
```

### Troubleshooting

**Coverage files not generated?**
- Ensure you're using the TUnit meta package, not just TUnit.Engine
- Verify you have a recent .NET SDK installed

**Missing coverage for some assemblies?**
- Use a `testconfig.json` file to explicitly include/exclude modules
- See [Microsoft's documentation](https://github.com/microsoft/codecoverage/blob/main/docs/configuration.md)

**Need help?**
- See [TUnit Code Coverage Documentation](../extensions/extensions.md#code-coverage)
- Check [Microsoft's Code Coverage Guide](https://learn.microsoft.com/en-us/dotnet/core/testing/unit-testing-code-coverage)

---

## Not in Parallel


By default, TUnit tests will run in parallel.

:::performance
Parallel execution is a major contributor to TUnit's speed advantage. Running tests in parallel can dramatically reduce total test suite execution time. See the [performance benchmarks](/docs/benchmarks) for real-world performance data.
::: 

To remove this behaviour, we can add a `[NotInParallel]` attribute to our test methods or classes.

This also takes an optional array of constraint keys.

If no constraint keys are supplied, then the test will only be run by itself.
If any constraint keys are set, the test will not be run alongside any other tests with any of those same keys. However it may still run in parallel alongside tests with other constraint keys.

For the example below, `MyTest` and `MyTest2` will not run in parallel with each other because of the common `DatabaseTest` constraint key, but `MyTest3` may run in parallel with the other two.

```csharp
using TUnit.Core;

namespace MyTestProject;

public class MyTestClass
{
    private const string DatabaseTest = "DatabaseTest";
    private const string RegistrationTest = "RegistrationTest";
    private const string ParallelTest = "ParallelTest";

    [Test]
    [NotInParallel(DatabaseTest)]
    public async Task MyTest()
    {
        
    }

    [Test]
    [NotInParallel(new[] { DatabaseTest, RegistrationTest })]
    public async Task MyTest2()
    {

    }

    [Test]
    [NotInParallel(ParallelTest)]
    public async Task MyTest3()
    {
        
    }
}
```

## Global [NotInParallel]

If you want to disable parallelism for all tests in an assembly (To run tests sequentially),
you can add the following:

```csharp
[assembly: NotInParallel]
```

---

## Parallel Groups


Parallel Groups are an alternative parallel mechanism to [NotInParallel].

Instead, classes that share a [ParallelGroup("")] attribute with the same key, may all run together in parallel, and nothing else will run alongside them.

For the example below, all `MyTestClass` tests may run in parallel, and all `MyTestClass2` tests may run in parallel. But they should not overlap and execute both classes at the same time.

```csharp
using TUnit.Core;

namespace MyTestProject;

[ParallelGroup("Group1")]
public class MyTestClass
{
    [Test]
    public async Task MyTest()
    {
        
    }

    [Test]
    public async Task MyTest2()
    {
        
    }

    [Test]
    public async Task MyTest3()
    {
        
    }
}

[ParallelGroup("Group2")]
public class MyTestClass2
{
    [Test]
    public async Task MyTest()
    {
        
    }

    [Test]
    public async Task MyTest2()
    {
        
    }

    [Test]
    public async Task MyTest3()
    {
        
    }
}
```

---

## Parallel Limiter


TUnit allows the user to control the parallel limit on a test, class or assembly level.

To do this, we add a `[ParallelLimiter<>]` attribute.

You'll notice this has a generic type argument - You must give it a type that implements `IParallelLimit` and has a public empty constructor. That interface requires you to define what the limit is for those tests.

If a class doesn't have a parallel limit defined, it'll try and eagerly run when the .NET thread pool allows it to do so, so the upper limit is unknown.

If it does have a parallel limit defined, be aware that that parallel limit is shared for any tests with that same `Type` of parallel limit. 

In the example below, `MyParallelLimit` has a limit of `2`. Now any test, anywhere in your test suite, that has this parallel limit attribute applied to it, will shared this limit, and so only 2 can be processed at a time. 

Other tests without this attribute may run alongside them still. 

And other tests with a different `Type` of parallel limit may also run alongside them still, but limited amongst themselves by their shared `Type` and limit.

So be aware that limits are only shared among tests with that same `IParallelLimit` `Type`.

So if you wanted to do a global limit on an assembly, you could do:

```csharp
[assembly: ParallelLimiter<MyParallelLimit>]
```

And as long as that isn't overridden on a test or class, then that will apply to all tests in an assembly and be shared among them all, limiting how many run in parallel.

## Example

```csharp
using TUnit.Core;

namespace MyTestProject;

[ParallelLimiter<MyParallelLimit>]
public class MyTestClass
{
    [Test, Repeat(10)]
    public async Task MyTest()
    {
        
    }

    [Test, Repeat(10)]
    public async Task MyTest2()
    {
        
    }
}

public record MyParallelLimit : IParallelLimit
{
    public int Limit => 2;
}
```

## Caveats
If a test uses `[DependsOn(nameof(OtherTest))]` and the other test has its own different parallel limit, this isn't guaranteed to be honoured.

## Global Parallel Limit

In case you want to apply the Parallel Limit logic to all tests in a project, you can add the attribute on the assembly level.

```csharp
[assembly: ParallelLimiter<MyParallelLimit>]
```

The more specific attribute will always override the more general one.
For example, the `[ParallelLimiter<MethodParallelLimit>]` on a method will override the `[ParallelLimiter<ClassParallelLimit>]` on the class,
which in turn will override the `[ParallelLimiter<AssemblyParallelLimit>]` on the assembly.

So the order of precedence is:
1. Method
1. Class
1. Assembly

---

## Command Line Flags


:::info

Please note that for the coverage and trx report, you need to install [additional extensions](../extensions/extensions.md)

:::

<pre>
    --diagnostic
        Enable the diagnostic logging. The default log level is 'Trace'.
        The file will be written in the output directory with the name log_[MMddHHssfff].diag

    --diagnostic-filelogger-synchronouswrite
        Force the built-in file logger to write the log synchronously.
        Useful for scenario where you don't want to lose any log (i.e. in case of crash).
        Note that this is slowing down the test execution.

    --diagnostic-output-directory
        Output directory of the diagnostic logging.
        If not specified the file will be generated inside the default 'TestResults' directory.

    --diagnostic-file-prefix
        Prefix for the log file name that will replace '[log]_.'

    --diagnostic-verbosity
        Define the level of the verbosity for the --diagnostic.
        The available values are 'Trace', 'Debug', 'Information', 'Warning', 'Error', and 'Critical'.

    --exit-on-process-exit
        Exit the test process if dependent process exits. PID must be provided.

    --help
        Show the command line help.

    --ignore-exit-code
        Do not report non successful exit value for specific exit codes
        (e.g. '--ignore-exit-code 8;9' ignore exit code 8 and 9 and will return 0 in these case)

    --info
        Display .NET test application information.

    --list-tests
        List available tests.

    --log-level
        Controls framework logging and diagnostic features.
        The available values are:
        - 'Trace' or 'Debug': Enable detailed stack traces, discovery diagnostics, timing details
        - 'Information' (default): Normal framework behavior
        - 'Warning', 'Error', 'Critical', or 'None': Minimal framework output

    --minimum-expected-tests
        Specifies the minimum number of tests that are expected to run.

    --results-directory
        The directory where the test results are going to be placed.
        If the specified directory doesn't exist, it's created.
        The default is TestResults in the directory that contains the test application.

    --timeout
        A global test execution timeout.
        Takes one argument as string in the format [h|m|s] where 'value' is float.

    --coverage
        Collect the code coverage using dotnet-coverage tool

    --coverage-output
        Output file

    --coverage-output-format
        Output file format. Supported values: 'coverage', 'xml' and 'cobertura'

    --coverage-settings
        XML code coverage settings

    --disable-logo
        Disables the TUnit logo when starting a test session.
        Can also be set via TUNIT_DISABLE_LOGO environment variable.

    --fail-fast
        Cancel the test run after the first test failure

    --maximum-parallel-tests
        Maximum Parallel Tests

    --no-ansi
        Disable outputting ANSI escape characters to screen.

    --no-progress
        Disable reporting progress to screen.

    --output
        Controls test result detail level AND real-time console output buffering.
        - 'Normal': Show failures only + buffer test output (no real-time spam)
        - 'Detailed': Show all tests + real-time test output

        Smart defaults: 'Normal' for console environments, 'Detailed' for IDE environments.
        This prevents console spam while keeping IDEs responsive (each test has its own output window).

    --reflection
        Enable reflection mode for test discovery and execution (defaults to source generation mode)

    --report-trx
        Enable generating TRX report

    --report-trx-filename
        The name of the generated TRX report

    --test-parameter
        Custom parameters to pass to TUnit

    --treenode-filter
        Use a tree filter to filter down the tests to execute

    --github-reporter-style
        Style for GitHub Actions test reporter output.
        Valid values are 'collapsible' (default) or 'full'.
        'collapsible' wraps detailed test results in expandable HTML blocks.
        'full' displays all test details directly.
</pre>

---

## Environment Variables


TUnit supports configuration through environment variables, allowing you to set defaults without modifying command-line arguments. This is particularly useful for CI/CD pipelines and development environments.

## TUnit-Specific Environment Variables

### TUNIT_DISABLE_LOGO

Disables the TUnit ASCII art logo when starting a test session.

```bash
# Bash/Linux/macOS
export TUNIT_DISABLE_LOGO=true

# PowerShell
$env:TUNIT_DISABLE_LOGO = "true"

# Windows Command Prompt
set TUNIT_DISABLE_LOGO=true
```

**Equivalent to:** `--disable-logo`

**Use case:** Reduces output noise in CI/CD logs or when using AI/LLM coding assistants that parse test output.

### TUNIT_DISABLE_GITHUB_REPORTER

Disables the automatic GitHub Actions test summary reporter.

```bash
export TUNIT_DISABLE_GITHUB_REPORTER=true
```

**Use case:** When you want to use a custom reporting solution instead of the built-in GitHub Actions integration.

### TUNIT_GITHUB_REPORTER_STYLE

Controls the style of the GitHub Actions test reporter output.

```bash
export TUNIT_GITHUB_REPORTER_STYLE=collapsible  # default
export TUNIT_GITHUB_REPORTER_STYLE=full
```

**Values:**
- `collapsible` (default): Wraps detailed test results in expandable HTML blocks
- `full`: Displays all test details directly

**Equivalent to:** `--github-reporter-style`

### TUNIT_DISABLE_JUNIT_REPORTER

Disables the JUnit XML reporter.

```bash
export TUNIT_DISABLE_JUNIT_REPORTER=true
```

### TUNIT_ENABLE_JUNIT_REPORTER

Explicitly enables the JUnit XML reporter.

```bash
export TUNIT_ENABLE_JUNIT_REPORTER=true
```

### JUNIT_XML_OUTPUT_PATH

Sets the output path for JUnit XML reports.

```bash
export JUNIT_XML_OUTPUT_PATH=/path/to/output.xml
```

### TUNIT_MAX_PARALLEL_TESTS

Sets the maximum number of tests that can run in parallel.

```bash
export TUNIT_MAX_PARALLEL_TESTS=4    # Limit to 4 concurrent tests
export TUNIT_MAX_PARALLEL_TESTS=0    # Unlimited parallelism
```

**Equivalent to:** `--maximum-parallel-tests`

**Note:** Command-line arguments take precedence over environment variables.

### TUNIT_ENABLE_IDE_STREAMING

Enables real-time output streaming to IDE test explorers (Rider, VS Code, Visual Studio).

```bash
# Bash/Linux/macOS
export TUNIT_ENABLE_IDE_STREAMING=1

# PowerShell
$env:TUNIT_ENABLE_IDE_STREAMING = "1"

# Windows Command Prompt
set TUNIT_ENABLE_IDE_STREAMING=1
```

**Default:** Disabled

**Use case:** When running tests in an IDE, this enables real-time streaming of test output (e.g. `Console.WriteLine`) to the test explorer while tests are still running. Without this, output is shown after each test completes.

**Note:** This feature is disabled by default due to known compatibility issues with the Microsoft Testing Platform that can cause test runner crashes in some IDEs. Enable it only if you want real-time output streaming and are not experiencing issues.

## Microsoft Testing Platform Environment Variables

These environment variables are provided by the underlying Microsoft Testing Platform:

### TESTINGPLATFORM_TELEMETRY_OPTOUT

Disables telemetry collection.

```bash
export TESTINGPLATFORM_TELEMETRY_OPTOUT=1
```

### TESTINGPLATFORM_UI_LANGUAGE

Sets the language for platform messages and logs.

```bash
export TESTINGPLATFORM_UI_LANGUAGE=en-us
```

## Platform-Level Flags

Some command-line flags are handled by the Microsoft Testing Platform rather than TUnit directly. These flags currently do not have environment variable equivalents:

- `--no-progress` - Disables progress reporting to screen
- `--no-ansi` - Disables ANSI escape characters

### Workarounds for --no-progress

While there's no environment variable for `--no-progress`, you can use these alternatives:

**1. MSBuild Property (with `dotnet test`):**

```xml
<PropertyGroup>
  <TestingPlatformCommandLineArguments>--no-progress</TestingPlatformCommandLineArguments>
</PropertyGroup>
```

**2. Shell Wrapper:**

```bash
#!/bin/bash
# run-tests.sh
./MyTestProject.exe --no-progress "$@"
```

**3. Direct Command Line:**

```bash
./MyTestProject.exe --no-progress
```

## CI/CD Examples

### GitHub Actions

```yaml
- name: Run Tests
  env:
    TUNIT_DISABLE_LOGO: true
    TUNIT_GITHUB_REPORTER_STYLE: collapsible
  run: dotnet test
```

### Azure DevOps

```yaml
- task: DotNetCoreCLI@2
  env:
    TUNIT_DISABLE_LOGO: true
  inputs:
    command: 'test'
```

### GitLab CI

```yaml
test:
  variables:
    TUNIT_DISABLE_LOGO: "true"
  script:
    - dotnet test
```

### Docker

```dockerfile
ENV TUNIT_DISABLE_LOGO=true
ENV TUNIT_MAX_PARALLEL_TESTS=4
```

## Priority Order

When the same setting is configured in multiple places, TUnit follows this priority order (highest to lowest):

1. **Command-line arguments** - Always take precedence
2. **Environment variables** - Applied when command-line argument is not provided
3. **Configuration files** - Applied as defaults

## Summary Table

| Environment Variable | Equivalent Flag | Description |
|---------------------|-----------------|-------------|
| `TUNIT_DISABLE_LOGO` | `--disable-logo` | Disables ASCII art logo |
| `TUNIT_GITHUB_REPORTER_STYLE` | `--github-reporter-style` | GitHub reporter style |
| `TUNIT_DISABLE_GITHUB_REPORTER` | - | Disables GitHub reporter |
| `TUNIT_DISABLE_JUNIT_REPORTER` | - | Disables JUnit reporter |
| `TUNIT_ENABLE_JUNIT_REPORTER` | - | Enables JUnit reporter |
| `JUNIT_XML_OUTPUT_PATH` | - | JUnit output path |
| `TUNIT_MAX_PARALLEL_TESTS` | `--maximum-parallel-tests` | Max parallel tests |
| `TUNIT_ENABLE_IDE_STREAMING` | - | Enable real-time IDE output streaming |

---

## Test Configuration


TUnit supports having a `testconfig.json` file within your test project.

This can be used to store key-value configuration pairs.

To retrieve these within your tests, you can use the static method `TestContext.Configuration.Get(key)`

`testconfig.json`
```json
{
  "MyKey1": "MyValue1",
  "Nested": {
    "MyKey2": "MyValue2"
  }
}
```

`Tests.cs`
```csharp
    [Test]
    public async Task Test()
    {
        var value1 = TestContext.Configuration.Get("MyKey1"); // MyValue1 - As defined above
        var value2 = TestContext.Configuration.Get("Nested:MyKey2"); // MyValue2 - As defined above
        
        ...
    }
```

---

## AOT Compatibility and Generic Tests


TUnit's source generation mode provides compile-time safety and performance benefits, but requires specific patterns for advanced scenarios like generic tests and complex data sources.

## Generic Test Instantiation

Generic test classes and methods require explicit type instantiation for AOT compatibility.

### Generic Test Methods

Use the `[GenerateGenericTest]` attribute to specify which type combinations to generate:

```csharp
using TUnit.Core;

namespace MyTestProject;

public class GenericTests
{
    [Test]
    [GenerateGenericTest(typeof(int), typeof(string))]
    [GenerateGenericTest(typeof(long), typeof(bool))]
    [GenerateGenericTest(typeof(double), typeof(char))]
    public async Task GenericTestMethod<T1, T2>()
    {
        // Test logic using T1 and T2
        var value1 = default(T1);
        var value2 = default(T2);
        
        await Assert.That(value1).IsNotNull().Or.IsEqualTo(default(T1));
        await Assert.That(value2).IsNotNull().Or.IsEqualTo(default(T2));
    }
}
```

### Generic Test Classes

Apply `[GenerateGenericTest]` to the class to generate all test methods for specified types:

```csharp
using TUnit.Core;

namespace MyTestProject;

[GenerateGenericTest(typeof(int))]
[GenerateGenericTest(typeof(string))]
[GenerateGenericTest(typeof(DateTime))]
public class GenericTestClass<T>
{
    [Test]
    public async Task TestDefaultValue()
    {
        var defaultValue = default(T);
        
        // For reference types, default should be null
        // For value types, default should be the type's default value
        if (typeof(T).IsValueType)
        {
            await Assert.That(defaultValue).IsNotNull();
        }
        else
        {
            await Assert.That(defaultValue).IsNull();
        }
    }

    [Test]
    [Arguments("test data")]
    public async Task TestWithGenericAndArguments(string input)
    {
        var value = default(T);
        
        await Assert.That(input).IsEqualTo("test data");
        // Can use both generic type T and regular parameters
    }
}
```

## AOT-Compatible Data Sources

### Static Data Sources

Use static methods and properties for AOT-compatible data sources:

```csharp
using TUnit.Core;

namespace MyTestProject;

public class AotDataSourceTests
{
    // Static method data source - AOT compatible
    [Test]
    [MethodDataSource(nameof(GetTestData))]
    public async Task TestWithStaticData(int value, string name)
    {
        await Assert.That(value).IsGreaterThan(0);
        await Assert.That(name).IsNotEmpty();
    }

    public static IEnumerable<object[]> GetTestData()
    {
        yield return new object[] { 1, "first" };
        yield return new object[] { 2, "second" };
        yield return new object[] { 3, "third" };
    }

    // Static property data source - AOT compatible
    [Test]
    [MethodDataSource(nameof(PropertyTestData))]
    public async Task TestWithPropertyData(bool flag, double number)
    {
        await Assert.That(flag).IsTrue().Or.IsFalse(); // Either is valid
        await Assert.That(number).IsGreaterThanOrEqualTo(0.0);
    }

    public static IEnumerable<object[]> PropertyTestData => new[]
    {
        new object[] { true, 1.5 },
        new object[] { false, 2.7 },
        new object[] { true, 0.0 }
    };
}
```

### Async Data Sources with Cancellation

AOT mode supports async data sources with proper cancellation token handling:

```csharp
using TUnit.Core;
using System.Runtime.CompilerServices;

namespace MyTestProject;

public class AsyncDataSourceTests
{
    [Test]
    [MethodDataSource(nameof(GetAsyncTestData))]
    public async Task TestWithAsyncData(int id, string data)
    {
        await Assert.That(id).IsGreaterThan(0);
        await Assert.That(data).StartsWith("data");
    }

    public static async IAsyncEnumerable<object[]> GetAsyncTestData(
        [EnumeratorCancellation] CancellationToken ct = default)
    {
        for (int i = 1; i <= 3; i++)
        {
            ct.ThrowIfCancellationRequested();
            
            // Simulate async work
            await Task.Delay(10, ct);
            
            yield return new object[] { i, $"data_{i}" };
        }
    }
}
```

## Advanced Property Injection

### Service Provider Integration

AOT mode includes a built-in service provider for dependency injection:

```csharp
using TUnit.Core;
using TUnit.Core.Services;

namespace MyTestProject;

public class ServiceInjectionTests
{
    [ClassDataSource<DatabaseService>(Shared = SharedType.PerTestSession)]
    public required DatabaseService Database { get; init; }

    [ClassDataSource<LoggingService>]
    public required LoggingService Logger { get; init; }

    [Test]
    public async Task TestWithInjectedServices()
    {
        // Services are automatically injected before test execution
        await Assert.That(Database).IsNotNull();
        await Assert.That(Logger).IsNotNull();
        
        var result = await Database.QueryAsync("SELECT 1");
        Logger.Log($"Query result: {result}");
        
        await Assert.That(result).IsEqualTo(1);
    }
}

// Example service classes
public class DatabaseService
{
    public async Task<int> QueryAsync(string sql)
    {
        await Task.Delay(1); // Simulate async database call
        return 1;
    }
}

public class LoggingService
{
    public void Log(string message)
    {
        Console.WriteLine($"[LOG] {message}");
    }
}
```

### Async Property Initialization

Properties can implement `IAsyncInitializable` for complex setup:

```csharp
using TUnit.Core;

namespace MyTestProject;

public class AsyncInitializationTests
{
    [ClassDataSource<AsyncContainer>]
    public required AsyncContainer Container { get; init; }

    [Test]
    public async Task TestWithAsyncInitializedProperty()
    {
        // Container.InitializeAsync() is called automatically before test
        await Assert.That(Container.IsInitialized).IsTrue();
        await Assert.That(Container.ConnectionString).IsNotEmpty();
    }
}

public class AsyncContainer : IAsyncInitializable, IAsyncDisposable
{
    public bool IsInitialized { get; private set; }
    public string ConnectionString { get; private set; } = "";

    public async Task InitializeAsync()
    {
        // Simulate async initialization
        await Task.Delay(10);
        ConnectionString = "Server=localhost;Database=test";
        IsInitialized = true;
    }

    public async ValueTask DisposeAsync()
    {
        // Cleanup is called automatically after test
        await Task.Delay(1);
        IsInitialized = false;
        ConnectionString = "";
    }
}
```

## Compile-Time Diagnostics

AOT mode provides helpful compile-time diagnostics for common issues:

### Generic Test Diagnostics

```csharp
// ❌ This will generate TUnit0058 error
[Test]
public async Task GenericTest<T>() // Missing [GenerateGenericTest]
{
    var value = default(T);
    await Assert.That(value).IsNotNull().Or.IsNull();
}

// ✅ Correct usage
[Test]
[GenerateGenericTest(typeof(int))]
[GenerateGenericTest(typeof(string))]
public async Task GenericTest<T>()
{
    var value = default(T);
    await Assert.That(value).IsNotNull().Or.IsNull();
}
```

### Data Source Diagnostics

```csharp
public class DataSourceDiagnostics
{
    // ❌ This will generate TUnit0059 error - dynamic data source
    [Test]
    [MethodDataSource(nameof(GetDynamicData))]
    public async Task TestWithDynamicDataSource(object value)
    {
        await Assert.That(value).IsNotNull();
    }

    public IEnumerable<object[]> GetDynamicData()
    {
        // This method uses reflection internally - not AOT compatible
        return SomeReflectionBasedDataGenerator.GetData();
    }

    // ✅ Use static, compile-time known data sources
    [Test]
    [MethodDataSource(nameof(GetStaticData))]
    public async Task TestWithStaticDataSource(string value)
    {
        await Assert.That(value).IsNotNull();
    }

    public static IEnumerable<object[]> GetStaticData()
    {
        yield return new object[] { "static1" };
        yield return new object[] { "static2" };
    }
}
```

## Benefits

The source generation mode provides several advantages:

- **Improved test execution performance** compared to reflection-based approaches
- **Zero runtime type introspection** - all types resolved at compile time
- **Reduced memory allocations** through strongly-typed delegates
- **Better code optimization** from the compiler and runtime

## Configuration Reference

Configure AOT behavior through your `.editorconfig` file:

```ini
# TUnit Configuration
# The only configurable option for troubleshooting:
tunit.enable_verbose_diagnostics = false # Verbose diagnostics (default: false)
```

These settings help balance compilation time, binary size, and functionality based on your project's needs.

---

## Data Driven Tests


It's common to want to repeat tests but pass in different values on each execution.
We can do that with a data driven test.

Compile-time known data can be injected via `[Arguments(...)]` attributes.
This attribute takes an array of arguments. It can take as many as you like, but your test method has to have the same number of parameters and they must be the same type.
If you include multiple `[Arguments]` attributes, your test will be repeated that many times, containing the data passed into the attribute.

When your test is executed, TUnit will pass the values provided in the attribute, into the test by the parameters.
Here's an example:

```csharp
using TUnit.Assertions;
using TUnit.Assertions.Extensions;
using TUnit.Core;

namespace MyTestProject;

public class MyTestClass
{
    [Test]
    [Arguments(1, 1, 2)]
    [Arguments(1, 2, 3)]
    [Arguments(2, 2, 4)]
    [Arguments(4, 3, 7)]
    [Arguments(5, 5, 10)]
    public async Task MyTest(int value1, int value2, int expectedResult)
    {
        var result = Add(value1, value2);

        await Assert.That(result).IsEqualTo(expectedResult);
    }

    private int Add(int x, int y)
    {
        return x + y;
    }
}
```

## Test Case Metadata

The `[Arguments]` attribute supports optional properties to customize individual test cases:

### Custom Display Names

Use the `DisplayName` property to provide a human-readable name for each test case:

```csharp
[Test]
[Arguments(1, 1, 2, DisplayName = "One plus one equals two")]
[Arguments(0, 0, 0, DisplayName = "Zero plus zero equals zero")]
[Arguments(-1, 1, 0, DisplayName = "Negative and positive cancel out")]
public async Task Addition(int a, int b, int expected)
{
    await Assert.That(a + b).IsEqualTo(expected);
}
```

Display names support parameter substitution using `$paramName` or positional `$arg1`, `$arg2` syntax:

```csharp
[Test]
[Arguments(2, 3, 5, DisplayName = "Adding $a + $b = $expected")]
[Arguments(10, 5, 15, DisplayName = "$arg1 + $arg2 = $arg3")]
public async Task AdditionWithSubstitution(int a, int b, int expected)
{
    await Assert.That(a + b).IsEqualTo(expected);
}
```

### Categories

Apply categories to specific test cases for filtering:

```csharp
[Test]
[Arguments(100, 50, Categories = new[] { "LargeNumbers", "Performance" })]
[Arguments(1, 1, Categories = new[] { "SmallNumbers", "Smoke" })]
public async Task CategorizedTests(int a, int b)
{
    await Assert.That(a + b).IsGreaterThan(0);
}
```

### Skipping Test Cases

Use the `Skip` property to skip specific test cases:

```csharp
[Test]
[Arguments("Chrome", "120")]
[Arguments("Firefox", "121")]
[Arguments("Safari", "17", Skip = "Safari testing not available in CI")]
public async Task BrowserTest(string browser, string version)
{
    // Test implementation
}
```

### Combining Properties

All properties can be combined:

```csharp
[Test]
[Arguments("admin", "secret123", DisplayName = "Admin login", Categories = new[] { "Auth", "Admin" })]
[Arguments("guest", "guest", DisplayName = "Guest login", Categories = new[] { "Auth" })]
[Arguments("", "", DisplayName = "Empty credentials", Skip = "Edge case not implemented")]
public async Task LoginTest(string username, string password)
{
    // Test implementation
}
```

:::tip
For dynamic test data or complex objects, use [Method Data Sources](./method-data-source.md) with [TestDataRow](./test-data-row.md) for the same metadata capabilities.
:::

---

## Injectable Class Data Source


The `ClassDataSource` attribute is used to instantiate and inject in new classes as parameters to your tests and/or test classes.

The attribute takes a generic type argument, which is the type of data you want to inject into your test.

It also takes an optional `Shared` argument, controlling whether you want to share the instance among other tests.
This could be useful for times where it's very intensive to spin up lots of objects, and you instead want to share that same instance across many tests.

Ideally don't manipulate the state of this object within your tests if your object is shared. Because of concurrency, it's impossible to know which test will run in which order, and so your tests could become flaky and undeterministic.

Options are:

### Shared = SharedType.None (Default)
The instance is not shared ever. A new one will be created for you. This is the default if `Shared` is not specified.

### Shared = SharedType.PerClass
The instance is shared for every test in the same class as itself, that also has this setting.

### Shared = SharedType.PerAssembly
The instance is shared for every test in the same assembly as itself, that also has this setting.

### Shared = SharedType.PerTestSession
The instance is shared for every test in the current test session, meaning it'll always be the same instance.

### Shared = SharedType.Keyed
When using this, you must also populate the `Key` argument on the attribute.

The instance is shared for every test that also has this setting, and also uses the same key.

## Initialization and TearDown
If you need to do some initialization or teardown for when this object is created/disposed, simply implement the `IAsyncInitializer` and/or `IAsyncDisposable` interfaces

# Example

```csharp
public class MyTestClass
{
    [Test]
    [ClassDataSource<WebApplicationFactory>(Shared = SharedType.PerTestSession)]
    public void MyTest(WebApplicationFactory webApplicationFactory)
    {
    }

    public record WebApplicationFactory : IAsyncInitializer, IAsyncDisposable
    {
        // Some properties/methods/whatever!

        public async Task InitializeAsync()
        {
            await StartServer();
        }

        public async ValueTask DisposeAsync()
        {
            await StopServer();
        }
    }
}
```

# Class Data Source Overloads

If you are using an overload that supports injecting multiple classes at once (e.g. `ClassDataSource<T1, T2, T3>`) then you should specify multiple SharedTypes in an array and keys where applicable.

**Important:** The `Keys` array is **positional** - each index corresponds to the type at that position in the generic parameters. Only types with `SharedType.Keyed` need keys; other positions can be empty strings or omitted.

E.g.

```csharp
[Test]
    [ClassDataSource<Value1, Value2, Value3, Value4, Value5>
        (
        Shared = [SharedType.PerTestSession, SharedType.Keyed, SharedType.PerClass, SharedType.Keyed, SharedType.None],
        Keys = ["", "Value2Key", "", "Value4Key", ""]
        // Index 0: Value1 (PerTestSession) - empty string (no key needed)
        // Index 1: Value2 (Keyed) - "Value2Key"
        // Index 2: Value3 (PerClass) - empty string (no key needed)
        // Index 3: Value4 (Keyed) - "Value4Key"
        // Index 4: Value5 (None) - empty string (no key needed)
        )]
    public class MyType(Value1 value1, Value2 value2, Value3 value3, Value4 value4, Value5 value5)
    {

    }
```

---

## CombinedDataSources - Quick Reference


## What is it?

`[CombinedDataSources]` allows you to apply different data source attributes to individual test method parameters, automatically generating all possible combinations (Cartesian product).

## Quick Start

```csharp
[Test]
[CombinedDataSources]
public async Task MyTest(
    [Arguments(1, 2, 3)] int x,
    [MethodDataSource(nameof(GetStrings))] string y)
{
    // Automatically creates 3 × 2 = 6 test cases
    await Assert.That(x).IsIn([1, 2, 3]);
    await Assert.That(y).IsIn(["Hello", "World"]);
}

public static IEnumerable<string> GetStrings()
{
    yield return "Hello";
    yield return "World";
}
```

## Key Benefits

✅ **Maximum Flexibility** - Mix ANY data source types on different parameters
✅ **Automatic Combinations** - Generates Cartesian product automatically
✅ **Clean Syntax** - Data sources defined right on the parameters
✅ **Type Safe** - Full compile-time type checking
✅ **AOT Compatible** - Works with Native AOT compilation

## Supported Data Sources

Apply these to individual parameters:

- `[Arguments(1, 2, 3)]` - Inline values
- `[MethodDataSource(nameof(Method))]` - From method
- `[ClassDataSource<T>]` - Generate instances
- `[CustomDataSource]` - Any `IDataSourceAttribute`

## Cartesian Product

With 3 parameters:
- Parameter A: 2 values
- Parameter B: 3 values
- Parameter C: 4 values

**Result**: 2 × 3 × 4 = **24 test cases**

## Common Patterns

### Pattern 1: All Arguments
```csharp
[Test]
[CombinedDataSources]
public void Test(
    [Arguments(1, 2)] int a,
    [Arguments("x", "y")] string b)
{
    // 2 × 2 = 4 tests
}
```

### Pattern 2: Mixed Sources
```csharp
[Test]
[CombinedDataSources]
public void Test(
    [Arguments(1, 2)] int a,
    [MethodDataSource(nameof(GetData))] string b,
    [ClassDataSource<MyClass>] MyClass c)
{
    // 2 × N × 1 = 2N tests
}
```

### Pattern 3: Multiple Per Parameter
```csharp
[Test]
[CombinedDataSources]
public void Test(
    [Arguments(1, 2)]
    [Arguments(3, 4)] int a,  // Combines to 4 values
    [Arguments("x")] string b)
{
    // 4 × 1 = 4 tests
}
```

## When to Use

✅ **Use CombinedDataSources when:**
- Different parameters need different data sources
- You want maximum flexibility in data generation
- You need to test all combinations of inputs

❌ **Use alternatives when:**
- All parameters use same type of data source → Consider `[Matrix]`
- You only need specific combinations → Use multiple `[Test]` methods with `[Arguments]`
- Test count would be excessive → Break into smaller tests

## Performance Warning

⚠️ **Be mindful of exponential growth!**

| Params | Values Each | Total Tests |
|--------|-------------|-------------|
| 2 | 3 | 9 |
| 3 | 3 | 27 |
| 4 | 3 | 81 |
| 5 | 3 | 243 |
| 3 | 10 | 1,000 |
| 4 | 10 | 10,000 |

## Full Documentation

See [CombinedDataSources](combined-data-source.md) for complete documentation including:
- Advanced scenarios
- Error handling
- AOT compilation details
- Troubleshooting guide
- Real-world examples

---

## CombinedDataSources


## Overview

The `[CombinedDataSources]` attribute enables you to apply different data source attributes to individual parameters, creating test cases through Cartesian product combination. This provides maximum flexibility when you need different parameters to be generated by different data sources.

## Key Features

- ✅ Apply ANY `IDataSourceAttribute` to individual parameters
- ✅ Mix `[Arguments]`, `[MethodDataSource]`, `[ClassDataSource]`, and custom data sources
- ✅ Automatic Cartesian product generation
- ✅ Full AOT/Native compilation support
- ✅ Works in both source-generated and reflection modes

## Comparison with MatrixDataSource

| Feature | MatrixDataSource | CombinedDataSources |
|---------|-----------------|---------------------------|
| Parameter-level attributes | `[Matrix]` only | ANY `IDataSourceAttribute` |
| Combination strategy | Cartesian product | Cartesian product |
| Data source types | Matrix-specific | All TUnit data sources |
| Use case | Simple matrix combinations | Complex, mixed data scenarios |

## Basic Usage

### Simple Arguments Mixing

```csharp
[Test]
[CombinedDataSources]
public async Task SimpleTest(
    [Arguments(1, 2, 3)] int x,
    [Arguments("a", "b")] string y)
{
    // Creates 3 × 2 = 6 test cases:
    // (1, "a"), (1, "b"), (2, "a"), (2, "b"), (3, "a"), (3, "b")

    await Assert.That(x).IsIn([1, 2, 3]);
    await Assert.That(y).IsIn(["a", "b"]);
}
```

### Mixing Arguments with MethodDataSource

```csharp
public static IEnumerable<string> GetStrings()
{
    yield return "Hello";
    yield return "World";
}

[Test]
[CombinedDataSources]
public async Task MixedDataSources(
    [Arguments(1, 2)] int x,
    [MethodDataSource(nameof(GetStrings))] string y)
{
    // Creates 2 × 2 = 4 test cases:
    // (1, "Hello"), (1, "World"), (2, "Hello"), (2, "World")

    await Assert.That(x).IsIn([1, 2]);
    await Assert.That(y).IsIn(["Hello", "World"]);
}
```

## Advanced Scenarios

### Three Parameters from Different Sources

```csharp
public static IEnumerable<int> GetNumbers()
{
    yield return 10;
    yield return 20;
    yield return 30;
}

[Test]
[CombinedDataSources]
public async Task ThreeWayMix(
    [Arguments(1, 2)] int x,
    [MethodDataSource(nameof(GetNumbers))] int y,
    [Arguments(true, false)] bool z)
{
    // Creates 2 × 3 × 2 = 12 test cases
    await Assert.That(x).IsIn([1, 2]);
    await Assert.That(y).IsIn([10, 20, 30]);
    await Assert.That(z).IsIn([true, false]);
}
```

### Multiple Data Sources on Same Parameter

You can apply multiple data source attributes to a single parameter - all values will be combined:

```csharp
[Test]
[CombinedDataSources]
public async Task MultipleSourcesPerParameter(
    [Arguments(1, 2)]
    [Arguments(3, 4)] int x,
    [Arguments("a")] string y)
{
    // Creates (2 + 2) × 1 = 4 test cases
    // x can be: 1, 2, 3, or 4
    await Assert.That(x).IsIn([1, 2, 3, 4]);
    await Assert.That(y).IsEqualTo("a");
}
```

### Using ClassDataSource

```csharp
public class MyTestData
{
    public int Value { get; set; }
    public string Name { get; set; } = string.Empty;
}

[Test]
[CombinedDataSources]
public async Task WithClassDataSource(
    [Arguments(1, 2)] int x,
    [ClassDataSource<MyTestData>] MyTestData obj)
{
    // Creates 2 × 1 = 2 test cases
    await Assert.That(x).IsIn([1, 2]);
    await Assert.That(obj).IsNotNull();
}
```

### Complex Type Combinations

```csharp
[Test]
[CombinedDataSources]
public async Task DifferentTypes(
    [Arguments(1, 2)] int intVal,
    [Arguments("a", "b")] string stringVal,
    [Arguments(1.5, 2.5)] double doubleVal,
    [Arguments(true, false)] bool boolVal,
    [Arguments('x', 'y')] char charVal)
{
    // Creates 2 × 2 × 2 × 2 × 2 = 32 test cases
    // All combinations of the parameter values
}
```

## Cartesian Product Behavior

The `[CombinedDataSources]` generates test cases using **Cartesian product** - every combination of parameter values is tested.

### Example Calculation

Given:
- Parameter `a`: `[Arguments(1, 2, 3)]` → 3 values
- Parameter `b`: `[Arguments("x", "y")]` → 2 values
- Parameter `c`: `[Arguments(true, false)]` → 2 values

Total test cases: **3 × 2 × 2 = 12**

Generated combinations:
```
(1, "x", true), (1, "x", false), (1, "y", true), (1, "y", false),
(2, "x", true), (2, "x", false), (2, "y", true), (2, "y", false),
(3, "x", true), (3, "x", false), (3, "y", true), (3, "y", false)
```

## Supported Data Source Attributes

The following attributes can be applied to parameters with `[CombinedDataSources]`:

### Built-in Attributes

| Attribute | Description | Example |
|-----------|-------------|---------|
| `[Arguments]` | Inline values | `[Arguments(1, 2, 3)]` |
| `[MethodDataSource]` | Values from a method | `[MethodDataSource(nameof(GetData))]` |
| `[MethodDataSource<T>]` | Typed method data source | `[MethodDataSource<MyClass>(nameof(GetData))]` |
| `[ClassDataSource<T>]` | Instance generation | `[ClassDataSource<MyClass>]` |
| `[ClassDataSource]` | Dynamic type instances | `[ClassDataSource(typeof(MyClass))]` |

### Custom Data Sources

Any attribute implementing `IDataSourceAttribute` can be used:

```csharp
public class CustomDataSourceAttribute : DataSourceGeneratorAttribute<string>
{
    protected override IEnumerable<Func<string>> GenerateDataSources(
        DataGeneratorMetadata metadata)
    {
        yield return () => "Custom1";
        yield return () => "Custom2";
    }
}

[Test]
[CombinedDataSources]
public async Task WithCustomDataSource(
    [Arguments(1, 2)] int x,
    [CustomDataSource] string y)
{
    // Creates 2 × 2 = 4 test cases
}
```

## Best Practices

### ✅ DO

- **Use descriptive parameter names** to make test output clear
- **Keep parameter counts reasonable** (< 5 parameters typically)
- **Be mindful of Cartesian product size** - 5 params × 10 values each = 100,000 tests!
- **Group related tests** in the same test class
- **Use assertions to validate parameter values** when debugging

### ❌ DON'T

- **Don't create excessive test cases** - Be aware of exponential growth
- **Don't mix with method-level data sources** - Use one approach per test method
- **Don't forget to test edge cases** like null values
- **Don't leave parameters without data sources** - All parameters must have at least one data source attribute

## Performance Considerations

### Test Case Growth

Be aware of exponential growth with multiple parameters:

| Parameters | Values Each | Total Tests |
|------------|-------------|-------------|
| 2 | 3 | 9 |
| 3 | 3 | 27 |
| 4 | 3 | 81 |
| 5 | 3 | 243 |
| 3 | 10 | 1,000 |
| 4 | 10 | 10,000 |

### Optimization Tips

1. **Reduce parameter value sets** when possible
2. **Use focused test methods** - test one concept per method
3. **Consider using `[Matrix]` for simpler scenarios** if you don't need mixed data sources
4. **Leverage test parallelization** - TUnit runs tests in parallel by default

## Edge Cases and Error Handling

### Missing Data Source

```csharp
// ❌ ERROR: Parameter 'y' has no data source
[Test]
[CombinedDataSources]
public async Task MissingDataSource(
    [Arguments(1, 2)] int x,
    int y) // No data source attribute!
{
    // This will fail during test initialization
}
```

**Error**: `Parameter 'y' has no data source attributes. All parameters must have at least one IDataSourceAttribute when using [CombinedDataSources].`

### No Parameters

```csharp
// ❌ ERROR: No parameters with data sources
[Test]
[CombinedDataSources]
public async Task NoParameters()
{
    // This will fail
}
```

**Error**: `[CombinedDataSources] only supports parameterised tests`

### Nullable Types

Nullable types are fully supported:

```csharp
[Test]
[CombinedDataSources]
public async Task NullableTypes(
    [Arguments(1, 2, null)] int? nullableInt,
    [Arguments("a", null)] string? nullableString)
{
    // Creates 3 × 2 = 6 test cases including nulls
    if (nullableInt.HasValue)
    {
        await Assert.That(nullableInt.Value).IsIn([1, 2]);
    }
}
```

## Comparison with Other Approaches

### vs. Method-Level [Arguments]

**Method-Level:**
```csharp
[Test]
[Arguments(1, "a")]
[Arguments(2, "b")]
public async Task OldWay(int x, string y)
{
    // Must manually specify every combination
    // Only creates 2 test cases
}
```

**MixedParameters:**
```csharp
[Test]
[CombinedDataSources]
public async Task NewWay(
    [Arguments(1, 2)] int x,
    [Arguments("a", "b")] string y)
{
    // Automatically creates all 4 combinations
}
```

### vs. MatrixDataSource

**Matrix:**
```csharp
[Test]
[MatrixDataSource]
public async Task MatrixWay(
    [Matrix(1, 2)] int x,
    [Matrix("a", "b")] string y)
{
    // Limited to Matrix attribute only
}
```

**MixedParameters:**
```csharp
[Test]
[CombinedDataSources]
public async Task MixedWay(
    [Arguments(1, 2)] int x,
    [MethodDataSource(nameof(GetStrings))] string y)
{
    // Can mix any data source types!
}
```

## AOT/Native Compilation

`[CombinedDataSources]` is fully compatible with AOT and Native compilation. The attribute uses proper trimming annotations and works in both source-generated and reflection modes.

## Examples from Real-World Scenarios

### Testing API Endpoints with Different Configurations

```csharp
public static IEnumerable<HttpMethod> GetHttpMethods()
{
    yield return HttpMethod.Get;
    yield return HttpMethod.Post;
    yield return HttpMethod.Put;
}

[Test]
[CombinedDataSources]
public async Task ApiEndpoint_ResponseCodes(
    [MethodDataSource(nameof(GetHttpMethods))] HttpMethod method,
    [Arguments("/api/users", "/api/products")] string endpoint,
    [Arguments(200, 404)] int expectedStatusCode)
{
    // Tests all combinations of HTTP methods, endpoints, and expected codes
    // 3 × 2 × 2 = 12 test cases
}
```

### Database Query Testing

```csharp
public class QueryParameters
{
    public int PageSize { get; set; }
    public string SortOrder { get; set; } = string.Empty;
}

[Test]
[CombinedDataSources]
public async Task Database_Pagination(
    [Arguments(10, 20, 50)] int pageSize,
    [Arguments("asc", "desc")] string sortOrder,
    [Arguments(true, false)] bool includeDeleted)
{
    // Tests all pagination combinations
    // 3 × 2 × 2 = 12 test cases
}
```

## Troubleshooting

### Issue: Too Many Test Cases Generated

**Problem**: Test run takes too long due to exponential growth

**Solution**:
- Reduce the number of values per parameter
- Split into multiple focused test methods
- Use more specific test scenarios

### Issue: Data Source Returns No Values

**Problem**: A parameter's data source returns an empty enumerable

**Solution**:
- Ensure data source methods return at least one value
- Check that the method is static/accessible
- Verify method signature matches expected format

### Issue: Parameter Type Mismatch

**Problem**: Data source returns wrong type for parameter

**Solution**:
- Ensure data source return type matches parameter type
- Use typed data sources: `[MethodDataSource<MyClass>]`
- Check that generated values can be cast to parameter type

## See Also

- [MatrixDataSource Documentation](matrix-tests.md)
- [MethodDataSource Documentation](method-data-source.md)
- [ClassDataSource Documentation](class-data-source.md)
- [Arguments Attribute Documentation](arguments.md)

## Version History

- **v1.0.0** - Initial release
  - Parameter-level data source support
  - Cartesian product generation
  - Support for all `IDataSourceAttribute` implementations
  - Full AOT compatibility

---

## Culture


The `[Culture]` attribute is used to set the [current Culture](https://learn.microsoft.com/en-us/dotnet/api/system.globalization.cultureinfo.currentculture) for the duration of a test. It may be specified at the level of a test, fixture or assembly.
The culture remains set until the test or fixture completes and is then reset to its original value.

Specifying the culture is useful for comparing against expected output
that depends on the culture, e.g. decimal separators, etc.

Only one culture may be specified. If you wish to run the same test under multiple cultures,
you can achieve the same result by factoring out your test code into a private method
that is called by each individual test method.

## Examples

```csharp
using TUnit.Core;

namespace MyTestProject;

public class MyTestClass
{
    [Test, Culture("de-AT")]
    public async Task Test3()
    {
        await Assert.That(double.Parse("3,5")).IsEqualTo(3.5);
    }
}
```

---

## Depends On


:::warning Test Isolation Best Practice
**Important**: Tests should ideally be self-contained, isolated, and side-effect free. This ensures they are:
- Reliable and repeatable
- Can run in any order
- Easy to understand and maintain
- Fast to execute

The `[DependsOn]` feature should only be used for systems where creating stateless tests is:
- Impossible (e.g., testing deployment pipelines)
- Extremely difficult (e.g., complex multi-step workflows)
- Too slow (e.g., expensive setup that must be shared)

Before using `[DependsOn]`, consider if you can refactor your tests to be independent by using proper setup/teardown methods or test fixtures.
:::

A test can depend on another test. This means that your test will not start unless the other test has finished.

To do this, add a  `[DependsOn]` to your test.

This takes a test name, which you can easily reference by using the `nameof(TestMethod)` keyword.

:::info

If you have multiple tests with the same name, but different parameter types, then you must include the types of parameters in the `[DependsOn]` attribute too so TUnit can locate the correct test.

:::

e.g.:
```csharp
public void Test1(string value1, int value2) { ... }

[DependsOn(nameof(Test1), new[] { typeof(string), typeof(int) })]
public void Test2() { ... }
```

This means you can create more complex test suites, without having to compromise on parallelism or speed.

For example, performing some operations on a database and asserting a count at the end:

```csharp
[Test]
public async Task AddUser1() 
{
    ...
}

[Test]
public async Task AddUser2() 
{
    ...
}

[Test]
public async Task AddUser3() 
{
    ...
}

[Test]
public async Task AddUser4() 
{
    ...
}

[Test]
public async Task AddUser5() 
{
    ...
}

[Test, DependsOn(nameof(AddUser1))]
public async Task AddItemToBagForUser1() 
{
    ...
}

[Test, DependsOn(nameof(AddUser2))]
public async Task AddItemToBagForUser2() 
{
    ...
}

[Test, DependsOn(nameof(AddUser3))]
public async Task AddItemToBagForUser3() 
{
    ...
}

[Test]
[DependsOn(nameof(AddUser4))]
[DependsOn(nameof(AddUser5))]
[DependsOn(nameof(AddItemToBagForUser1))]
[DependsOn(nameof(AddItemToBagForUser2))]
[DependsOn(nameof(AddItemToBagForUser3))]
public async Task AssertItemsInDatabase() 
{
    ...
}
```

## Getting other tests
If your tests depends on another test, it's possible to retrieve that test's context. This allows you to do things like check its result, or retrieve objects from its state bag.

This is done by calling the `GetTests` method on the `TestContext.Dependencies` property. It takes the test's method name (so you can use `nameof(...)`) and optionally the parameter types for if there's multiple overloads.

You'll notice this returns an array - This is because tests may be data driven and be invoked multiple times - If this is the case you'll have to find the one you want yourself.

:::info
For data-driven tests (e.g., with `[Arguments]` or `[MethodDataSource]`), `GetTests` returns all invocations.  
Use argument values or other properties to select the specific test context you need.
:::

Example:

```csharp
[Test]
public async Task AddItemToBag() 
{
    var itemId = await AddToBag();
    TestContext.Current!.StateBag.Items["ItemId"] = itemId;
}

[Test]
[DependsOn(nameof(AddItemToBag))]
public async Task DeleteItemFromBag() 
{
    var addToBagTestContext = TestContext.Current!.Dependencies.GetTests(nameof(AddItemToBag)).First();
    var itemId = addToBagTestContext.StateBag.Items["ItemId"];
    await DeleteFromBag(itemId);
}
```

## Failures

If your test depends on another test, by default, if that dependency fails, then your test that depends on it will not start. This can be bypassed by adding the property `ProceedOnFailure = true` to the `DependsOnAttribute`. Your test suite will still fail due to that test, but it allows you to proceed with other tests if you require it. For example, CRUD testing, and wanting to perform a delete after all your other tests, regardless of if they passed.

```csharp
[Test]
public async Task Test1() 
{
    ...
}

[Test]
[DependsOn(nameof(Test1), ProceedOnFailure = true)]
public async Task Test2() 
{
    ...
}
```

---

## Explicit


If you want a test to only be run explicitly (and not part of all general tests) then you can add the `[ExplicitAttribute]`.

This can be added to a test method or a test class.

A test is considered 'explicitly' run when all filtered tests have an explicit attribute on them. 

That means that you could run all tests in a class with an `[Explicit]` attribute. Or you could run a single method with an `[Explicit]` attribute. But if you try to run a mix of explicit and non-explicit tests, then the ones with an `[Explicit]` attribute will be excluded from the run.

This can be useful for 'Tests' that make sense in a local environment, and maybe not part of your CI builds. Or they could be helpers that ping things to warm them up, and by making them explicit tests, they are easily runnable, but don't affect your overall test suite.

> **Tip:**  
> To run explicit tests, use a filter to select only those tests (e.g., by name or category), or run them directly from your IDE's test explorer.

```csharp
using TUnit.Core;

namespace MyTestProject;

public class MyTestClass
{
    [Test]
    [Explicit]
    public async Task MyTest()
    {
        
    }
}
```

---

## Generic Attributes


TUnit provides generic versions of several attributes that offer enhanced type safety and better IDE support. These attributes allow you to specify types at compile time, reducing errors and improving code maintainability.

## Generic Test Attributes

### MethodDataSourceAttribute&lt;T&gt;

The generic version of `MethodDataSource` provides type safety for the class containing the data source method.

```csharp
public class TestDataProviders
{
    public static IEnumerable<(int, int, int)> AdditionTestCases()
    {
        yield return (1, 2, 3);
        yield return (5, 5, 10);
        yield return (-1, 1, 0);
    }
}

public class CalculatorTests
{
    [Test]
    [MethodDataSource<TestDataProviders>(nameof(TestDataProviders.AdditionTestCases))]
    public void Add_ShouldReturnCorrectSum(int a, int b, int expected)
    {
        var result = Calculator.Add(a, b);
        Assert.That(result).IsEqualTo(expected);
    }
}
```

Benefits over non-generic version:
- Compile-time type checking
- IDE refactoring support
- Prevents typos in class names

### ClassDataSourceAttribute&lt;T&gt;

The generic version ensures type safety when referencing data source classes.

```csharp
public class UserTestData : IEnumerable<User>
{
    public IEnumerator<User> GetEnumerator()
    {
        yield return new User { Id = 1, Name = "Alice" };
        yield return new User { Id = 2, Name = "Bob" };
    }
    
    IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();
}

public class UserTests
{
    [Test]
    [ClassDataSource<UserTestData>]
    public async Task ValidateUser_ShouldPass(User user)
    {
        var isValid = await UserValidator.ValidateAsync(user);
        await Assert.That(isValid).IsTrue();
    }
}
```

### DependsOnAttribute&lt;T&gt;

The generic `DependsOn` attribute provides type-safe test dependency declarations.

```csharp
public class OrderProcessingTests
{
    [Test]
    public async Task CreateOrder()
    {
        // Create order logic
    }
    
    [Test]
    [DependsOn<OrderProcessingTests>(nameof(CreateOrder))]
    public async Task ProcessPayment()
    {
        // This test depends on CreateOrder from the same class
    }
}

public class ShippingTests
{
    [Test]
    [DependsOn<OrderProcessingTests>(nameof(OrderProcessingTests.ProcessPayment))]
    public async Task ShipOrder()
    {
        // This test depends on ProcessPayment from another class
    }
}
```

## Generic Data Source Attributes

### DataSourceGeneratorAttribute&lt;T&gt;

Create strongly-typed data source generators:

```csharp
public abstract class DataSourceGeneratorAttribute<T> : Attribute
{
    public abstract IEnumerable<T> GenerateData();
}

// Custom implementation
public class RandomNumbersAttribute : DataSourceGeneratorAttribute<int>
{
    private readonly int _count;
    private readonly int _min;
    private readonly int _max;
    
    public RandomNumbersAttribute(int count, int min = 0, int max = 100)
    {
        _count = count;
        _min = min;
        _max = max;
    }
    
    public override IEnumerable<int> GenerateData()
    {
        var random = new Random();
        for (int i = 0; i < _count; i++)
        {
            yield return random.Next(_min, _max);
        }
    }
}

// Usage
[Test]
[RandomNumbers(5, min: 1, max: 10)]
public void TestWithRandomNumbers(int number)
{
    Assert.That(number).IsBetween(1, 10);
}
```

### AsyncDataSourceGeneratorAttribute&lt;T&gt;

For asynchronous data generation:

```csharp
public abstract class AsyncDataSourceGeneratorAttribute<T> : Attribute
{
    public abstract Task<IEnumerable<T>> GenerateDataAsync();
}

// Custom implementation
public class DatabaseUsersAttribute : AsyncDataSourceGeneratorAttribute<User>
{
    private readonly string _role;
    
    public DatabaseUsersAttribute(string role)
    {
        _role = role;
    }
    
    public override async Task<IEnumerable<User>> GenerateDataAsync()
    {
        using var db = new DatabaseContext();
        return await db.Users
            .Where(u => u.Role == _role)
            .ToListAsync();
    }
}

// Usage
[Test]
[DatabaseUsers("Admin")]
public async Task AdminUser_ShouldHaveFullPermissions(User adminUser)
{
    var permissions = await GetUserPermissions(adminUser);
    await Assert.That(permissions).Contains(Permission.FullAccess);
}
```

### TypedDataSourceAttribute&lt;T&gt;

Base class for creating custom typed data sources:

```csharp
public abstract class TypedDataSourceAttribute<T> : DataSourceAttribute
{
    public abstract IEnumerable<T> GetData();
}

// Implementation example
public class FibonacciDataAttribute : TypedDataSourceAttribute<int>
{
    private readonly int _count;
    
    public FibonacciDataAttribute(int count)
    {
        _count = count;
    }
    
    public override IEnumerable<int> GetData()
    {
        int a = 0, b = 1;
        yield return a;
        
        if (_count > 1) yield return b;
        
        for (int i = 2; i < _count; i++)
        {
            int temp = a + b;
            yield return temp;
            a = b;
            b = temp;
        }
    }
}

// Usage
[Test]
[FibonacciData(7)]
public void TestFibonacciNumber(int fibNumber)
{
    // Test with Fibonacci sequence: 0, 1, 1, 2, 3, 5, 8
    Assert.That(fibNumber).IsGreaterThanOrEqualTo(0);
}
```

## Complex Generic Scenarios

### Combining Multiple Generic Attributes

```csharp
public interface ITestScenario<TInput, TExpected>
{
    TInput Input { get; }
    TExpected Expected { get; }
}

public class CalculationScenario : ITestScenario<(int, int), int>
{
    public (int, int) Input { get; set; }
    public int Expected { get; set; }
}

public class ScenarioDataSource<TScenario> : TypedDataSourceAttribute<TScenario>
    where TScenario : ITestScenario<(int, int), int>, new()
{
    public override IEnumerable<TScenario> GetData()
    {
        yield return new TScenario { Input = (1, 2), Expected = 3 };
        yield return new TScenario { Input = (5, 5), Expected = 10 };
    }
}

[Test]
[ScenarioDataSource<CalculationScenario>]
public void TestCalculation(CalculationScenario scenario)
{
    var (a, b) = scenario.Input;
    var result = Calculator.Add(a, b);
    Assert.That(result).IsEqualTo(scenario.Expected);
}
```

### Generic Test Base Classes

⚠️ **Important Limitation**: C# does not allow generic type parameters to be used as attribute arguments. This is a known language limitation (see [dotnet/csharplang#124](https://github.com/dotnet/csharplang/issues/124)).

The following code **WILL NOT COMPILE** due to error CS8968:

```csharp
// ❌ This does NOT work - CS8968 error
public abstract class EntityTestBase<TEntity, TId>
    where TEntity : IEntity<TId>
{
    [Test]
    [MethodDataSource<EntityTestBase<TEntity, TId>>(nameof(GetTestIds))]  // ❌ Error!
    public async Task Entity_ShouldBeRetrievable(TId id) { }
}
```

#### Workaround 1: Use InstanceMethodDataSource

The recommended approach is to use `InstanceMethodDataSource` instead:

```csharp
public abstract class EntityTestBase<TEntity, TId>
    where TEntity : IEntity<TId>
    where TId : IEquatable<TId>
{
    protected abstract TEntity CreateEntity(TId id);
    protected abstract Task<TEntity> GetEntityAsync(TId id);

    // ✅ This works - instance method data source
    [Test]
    [InstanceMethodDataSource(nameof(GetTestIds))]
    public async Task Entity_ShouldBeRetrievable(TId id)
    {
        var entity = CreateEntity(id);
        await SaveEntityAsync(entity);

        var retrieved = await GetEntityAsync(id);
        await Assert.That(retrieved.Id).IsEqualTo(id);
    }

    // Instance method (not static)
    public IEnumerable<TId> GetTestIds()
    {
        return GetTestIdsCore();
    }

    protected abstract IEnumerable<TId> GetTestIdsCore();
}

public class UserEntityTests : EntityTestBase<User, Guid>
{
    protected override User CreateEntity(Guid id) =>
        new User { Id = id, Name = "Test User" };

    protected override Task<User> GetEntityAsync(Guid id) =>
        UserRepository.GetByIdAsync(id);

    protected override IEnumerable<Guid> GetTestIdsCore()
    {
        yield return Guid.NewGuid();
        yield return Guid.NewGuid();
    }
}
```

#### Workaround 2: Create Concrete Base Classes

For a limited set of types, create non-generic derived classes:

```csharp
// Base generic class (no data source attributes using generics)
public abstract class EntityTestBase<TEntity, TId>
    where TEntity : IEntity<TId>
    where TId : IEquatable<TId>
{
    protected abstract TEntity CreateEntity(TId id);
    protected abstract Task<TEntity> GetEntityAsync(TId id);

    protected async Task Entity_ShouldBeRetrievable(TId id)
    {
        var entity = CreateEntity(id);
        await SaveEntityAsync(entity);

        var retrieved = await GetEntityAsync(id);
        await Assert.That(retrieved.Id).IsEqualTo(id);
    }
}

// Concrete base class for Guid-based entities
public abstract class GuidEntityTestBase<TEntity> : EntityTestBase<TEntity, Guid>
    where TEntity : IEntity<Guid>
{
    [Test]
    [MethodDataSource<GuidEntityTestBase<TEntity>>(nameof(GetTestIds))]
    public async Task TestEntity(Guid id)
    {
        await Entity_ShouldBeRetrievable(id);
    }

    public static IEnumerable<Guid> GetTestIds()
    {
        yield return Guid.NewGuid();
        yield return Guid.NewGuid();
    }
}

// Your test class
public class UserEntityTests : GuidEntityTestBase<User>
{
    protected override User CreateEntity(Guid id) =>
        new User { Id = id, Name = "Test User" };

    protected override Task<User> GetEntityAsync(Guid id) =>
        UserRepository.GetByIdAsync(id);
}
```

## AOT Compatibility

Generic attributes work well with AOT compilation, but there are some considerations:

### DynamicallyAccessedMembers

When creating generic attributes that use reflection, add appropriate attributes:

```csharp
public class ReflectiveDataSource<[DynamicallyAccessedMembers(
    DynamicallyAccessedMemberTypes.PublicConstructors | 
    DynamicallyAccessedMemberTypes.PublicProperties)] T> 
    : TypedDataSourceAttribute<T> where T : new()
{
    public override IEnumerable<T> GetData()
    {
        var type = typeof(T);
        var properties = type.GetProperties();
        
        // Create instances with different property values
        foreach (var prop in properties)
        {
            var instance = new T();
            // Set property values...
            yield return instance;
        }
    }
}
```

### Generic Constraints for AOT

Use constraints to ensure AOT compatibility:

```csharp
public class SerializableDataSource<T> : TypedDataSourceAttribute<T>
    where T : IJsonSerializable<T> // Ensures T can be serialized
{
    private readonly string _jsonFile;
    
    public SerializableDataSource(string jsonFile)
    {
        _jsonFile = jsonFile;
    }
    
    public override IEnumerable<T> GetData()
    {
        var json = File.ReadAllText(_jsonFile);
        var items = JsonSerializer.Deserialize<List<T>>(json);
        return items ?? Enumerable.Empty<T>();
    }
}
```

## Best Practices

### 1. Use Generic Attributes for Type Safety

```csharp
// ❌ Non-generic - prone to errors
[MethodDataSource(typeof(DataProvider), "GetData")]

// ✅ Generic - compile-time safety
[MethodDataSource<DataProvider>(nameof(DataProvider.GetData))]
```

### 2. Leverage Constraints

```csharp
public class ValidatableDataSource<T> : TypedDataSourceAttribute<T>
    where T : IValidatable
{
    public override IEnumerable<T> GetData()
    {
        // Only return valid instances
        return GenerateInstances().Where(x => x.IsValid());
    }
}
```

### 3. Create Reusable Generic Base Attributes

```csharp
public abstract class JsonFileDataSource<T> : TypedDataSourceAttribute<T>
{
    protected abstract string FilePath { get; }
    
    public override IEnumerable<T> GetData()
    {
        var json = File.ReadAllText(FilePath);
        return JsonSerializer.Deserialize<List<T>>(json) 
            ?? Enumerable.Empty<T>();
    }
}

public class UserJsonDataSource : JsonFileDataSource<User>
{
    protected override string FilePath => "TestData/users.json";
}
```

### 4. Document Generic Type Parameters

```csharp
/// <summary>
/// Provides test data from a CSV file
/// </summary>
/// <typeparam name="T">The type to deserialize CSV rows into. 
/// Must have a parameterless constructor.</typeparam>
public class CsvDataSource<T> : TypedDataSourceAttribute<T> 
    where T : new()
{
    // Implementation
}
```

## Common Patterns

### Factory Pattern with Generics

```csharp
public class EntityFactory<T> where T : IEntity, new()
{
    public static IEnumerable<T> CreateTestEntities(int count)
    {
        for (int i = 0; i < count; i++)
        {
            yield return new T 
            { 
                Id = i,
                CreatedAt = DateTime.UtcNow
            };
        }
    }
}

public class FactoryDataSource<T> : TypedDataSourceAttribute<T>
    where T : IEntity, new()
{
    private readonly int _count;
    
    public FactoryDataSource(int count = 3)
    {
        _count = count;
    }
    
    public override IEnumerable<T> GetData()
    {
        return EntityFactory<T>.CreateTestEntities(_count);
    }
}

// Usage
[Test]
[FactoryDataSource<Product>(5)]
public async Task TestProductEntity(Product product)
{
    await Assert.That(product.Id).IsGreaterThanOrEqualTo(0);
}
```

### Builder Pattern with Generics

```csharp
public abstract class TestDataBuilder<T> : TypedDataSourceAttribute<T>
{
    protected abstract T BuildDefault();
    protected abstract T BuildInvalid();
    protected abstract T BuildEdgeCase();
    
    public override IEnumerable<T> GetData()
    {
        yield return BuildDefault();
        yield return BuildInvalid();
        yield return BuildEdgeCase();
    }
}

public class UserDataBuilder : TestDataBuilder<User>
{
    protected override User BuildDefault() => 
        new User { Id = 1, Name = "John", Age = 30 };
        
    protected override User BuildInvalid() => 
        new User { Id = -1, Name = "", Age = -5 };
        
    protected override User BuildEdgeCase() => 
        new User { Id = int.MaxValue, Name = new string('a', 1000), Age = 150 };
}
```

## Summary

Generic attributes in TUnit provide:
- **Type Safety**: Compile-time checking prevents runtime errors
- **Better IDE Support**: Refactoring and navigation work correctly
- **Cleaner Code**: No magic strings or typeof expressions
- **AOT Compatibility**: Work well with ahead-of-time compilation
- **Reusability**: Easy to create generic base attributes for common patterns

Use generic attributes whenever possible to improve code quality and maintainability in your test suites.

---

## Matrix Tests


The Matrix data source is a way to specify different arguments per parameter, and then generate every possible combination of all of those arguments.

:::warning
As your number of arguments and/or parameters increase, the number of test cases will grow exponentially.  
For example, 3 parameters with 10 values each will generate 1,000 test cases (10 × 10 × 10).  
Use with caution to avoid very large test suites.
:::

For our arguments, we'll add a `[Matrix]` attribute. Instead of this being added to the test method, it's added to the parameters themselves.

And for the test method, we'll add a `[MatrixDataSource]` attribute which contains the logic to extract out all the data from those parameter Matrix attributes.

Here's an example:

```csharp
using TUnit.Assertions;
using TUnit.Assertions.Extensions;
using TUnit.Assertions.Extensions.Is;
using TUnit.Core;

namespace MyTestProject;

public class MyTestClass
{
    [Test]
    [MatrixDataSource]
    public async Task MyTest(
        [Matrix(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)] int value1,
        [Matrix(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)] int value2
        )
    {
        var result = Add(value1, value2);

        await Assert.That(result).IsPositive();
    }

    private int Add(int x, int y)
    {
        return x + y;
    }
}
```

That will generate 100 test cases. 10 different values for value1, and 10 different values for value2. 10\*10 is 100.

## Matrix Range

You can also use the `[MatrixRange<T>]` for numerical types. It will generated a range between the minimum and maximum, with an optional step parameter to define how far to step between each value. By default, this is 1.

```csharp
using TUnit.Assertions;
using TUnit.Assertions.Extensions;
using TUnit.Assertions.Extensions.Is;
using TUnit.Core;

namespace MyTestProject;

public class MyTestClass
{
    [Test]
    [MatrixDataSource]
    public async Task MyTest(
        [MatrixRange<int>(1, 10)] int value1,
        [MatrixRange<int>(1, 10)] int value2
        )
    {
        var result = Add(value1, value2);

        await Assert.That(result).IsPositive();
    }

    private int Add(int x, int y)
    {
        return x + y;
    }
}
```

## Matrix Method

You can also specify a method that will return an `IEnumerable<T>` of values.

```csharp
using TUnit.Assertions;
using TUnit.Assertions.Extensions;
using TUnit.Assertions.Extensions.Is;
using TUnit.Core;

namespace MyTestProject;

public class MyTestClass
{
    [Test]
    [MatrixDataSource]
    public async Task MyTest(
        [MatrixRange<int>(1, 10)] int value1,
        [MatrixMethod<MyTestClass>(nameof(Numbers))] int value2
        )
    {
        var result = Add(value1, value2);

        await Assert.That(result).IsPositive();
    }

    private int Add(int x, int y)
    {
        return x + y;
    }

    private IEnumerable<int> Numbers()
    {
        yield return 1;
        yield return 2;
        yield return 3;
        yield return 4;
        yield return 5;
        yield return 6;
        yield return 7;
        yield return 8;
        yield return 9;
        yield return 10;
    }
}
```

## Matrix Exclusions

You can also add a `[MatrixExclusion(...)]` attribute to your tests.
This works similar to the `[Arguments(...)]` attribute, and if objects match a generated matrix test case, it'll be ignored.

This helps you exclude specific one-off scenarios without having to complicate your tests with `if` conditions.

:::info
Use exclusions to keep your test matrix manageable and avoid unnecessary or invalid test cases.
:::

```csharp
using TUnit.Assertions;
using TUnit.Assertions.Extensions;
using TUnit.Assertions.Extensions.Is;
using TUnit.Core;

namespace MyTestProject;

public class MyTestClass
{
    [Test]
    [MatrixDataSource]
    [MatrixExclusion(1, 1)]
    [MatrixExclusion(2, 2)]
    [MatrixExclusion(3, 3)]
    public async Task MyTest(
        [MatrixRange<int>(1, 3)] int value1,
        [MatrixRange<int>(1, 3)] int value2
        )
    {
        ...
    }
}
```

Whereas the above Matrix would usually generate: 
- 1, 1
- 1, 2
- 1, 3
- 2, 1
- 2, 2
- 2, 3
- 3, 1
- 3, 2
- 3, 3

Because of the exclusion attributes, it'll only generate:
- 1, 2
- 1, 3
- 2, 1
- 2, 3
- 3, 1
- 3, 2

---

## Method Data Sources


A limitation of passing data in with `[Arguments(...)]` is that the data must be `constant` values. For example, we can't new up an object and pass it into this attribute as an argument. This is a constraint of the language and we can't change that.

If we want test data represented in the form of objects, or just to use something that isn't a constant, we can declare a test data source.

## AOT-Compatible Method Data Sources

TUnit's AOT-only mode requires **static** method data sources for compile-time safety and performance. Methods must be static and use compile-time resolvable patterns.

`MethodDataSource` has two options:
- If you pass in one argument, this is the method name containing your data. TUnit will assume this is in the current test class.
- If you pass in two arguments, the first should be the `Type` of the class containing your test source data method, and the second should be the name of the method.

:::warning AOT Requirement
Method data sources **must be static** for AOT compatibility. Instance methods will generate compile-time errors in AOT mode.
:::

For reference types, methods should return a `Func<T>` rather than just a `T`, and make sure that `Func<>` returns a `new T()` - This ensures each test has its own instance of that object and tests aren't sharing objects which could lead to unintended side effects.

:::info
Returning a `Func<T>` ensures that each test gets a fresh object.  
If you return a reference to the same object, tests may interfere with each other.
:::

Here's an example returning a simple object:

```csharp
using TUnit.Assertions;
using TUnit.Assertions.Extensions;
using TUnit.Core;

namespace MyTestProject;

public record AdditionTestData(int Value1, int Value2, int ExpectedResult);

public static class MyTestDataSources
{
    public static Func<AdditionTestData> AdditionTestData()
    {
        return () => new AdditionTestData(1, 2, 3);
    }
}

public class MyTestClass
{
    [Test]
    [MethodDataSource(typeof(MyTestDataSources), nameof(MyTestDataSources.AdditionTestData))]
    public async Task MyTest(AdditionTestData additionTestData)
    {
        var result = Add(additionTestData.Value1, additionTestData.Value2);

        await Assert.That(result).IsEqualTo(additionTestData.ExpectedResult);
    }

    private int Add(int x, int y)
    {
        return x + y;
    }
}
```

This can also accept tuples if you don't want to create lots of new types within your test assembly:

```csharp
using TUnit.Assertions;
using TUnit.Assertions.Extensions;
using TUnit.Core;

namespace MyTestProject;

public static class MyTestDataSources
{
    public static Func<(int, int, int)> AdditionTestData()
    {
        return () => (1, 2, 3);
    }
}

public class MyTestClass
{
    [Test]
    [MethodDataSource(typeof(MyTestDataSources), nameof(MyTestDataSources.AdditionTestData))]
    public async Task MyTest(int value1, int value2, int expectedResult)
    {
        var result = Add(value1, value2);

        await Assert.That(result).IsEqualTo(expectedResult);
    }

    private int Add(int x, int y)
    {
        return x + y;
    }
}
```

This attribute can also accept `IEnumerable<>`. For each item returned, a new test will be created with that item passed in to the parameters. Again, if using a reference type, return an `IEnumerable<Func<T>>` and make sure each `Func<>` returns a `new T()`

Here's an example where the test would be invoked 3 times:

```csharp
using TUnit.Assertions;
using TUnit.Assertions.Extensions;
using TUnit.Core;

namespace MyTestProject;

public record AdditionTestData(int Value1, int Value2, int ExpectedResult);

public static class MyTestDataSources
{
    public static IEnumerable<Func<AdditionTestData>> AdditionTestData()
    {
        yield return () => new AdditionTestData(1, 2, 3);
        yield return () => new AdditionTestData(2, 2, 4);
        yield return () => new AdditionTestData(5, 5, 10);
    }
}

public class MyTestClass
{
    [Test]
    [MethodDataSource(typeof(MyTestDataSources), nameof(MyTestDataSources.AdditionTestData))]
    public async Task MyTest(AdditionTestData additionTestData)
    {
        var result = Add(additionTestData.Value1, additionTestData.Value2);

        await Assert.That(result).IsEqualTo(additionTestData.ExpectedResult);
    }

    private int Add(int x, int y)
    {
        return x + y;
    }
}
```

This can also accept tuples if you don't want to create lots of new types within your test assembly:

```csharp
using TUnit.Assertions;
using TUnit.Assertions.Extensions;
using TUnit.Core;

namespace MyTestProject;

public static class MyTestDataSources
{
    public static IEnumerable<Func<(int, int, int)>> AdditionTestData()
    {
        yield return () => (1, 2, 3);
        yield return () => (2, 2, 4);
        yield return () => (5, 5, 10);
    }
}

public class MyTestClass
{
    [Test]
    [MethodDataSource(typeof(MyTestDataSources), nameof(MyTestDataSources.AdditionTestData))]
    public async Task MyTest(int value1, int value2, int expectedResult)
    {
        var result = Add(value1, value2);

        await Assert.That(result).IsEqualTo(expectedResult);
    }

    private int Add(int x, int y)
    {
        return x + y;
    }
}
```

## Async Data Sources (AOT-Compatible)

TUnit's AOT mode supports async data sources with `IAsyncEnumerable<T>` for scenarios requiring asynchronous data loading:

```csharp
using TUnit.Assertions;
using TUnit.Assertions.Extensions;
using TUnit.Core;
using System.Runtime.CompilerServices;

namespace MyTestProject;

public record AsyncTestData(int Id, string Name, DateTime CreatedAt);

public static class AsyncTestDataSources
{
    // AOT-compatible async data source with cancellation support
    public static async IAsyncEnumerable<Func<AsyncTestData>> GetAsyncTestData(
        [EnumeratorCancellation] CancellationToken ct = default)
    {
        for (int i = 1; i <= 3; i++)
        {
            ct.ThrowIfCancellationRequested();
            
            // Simulate async data loading (database, API, etc.)
            await Task.Delay(10, ct);
            
            yield return () => new AsyncTestData(
                Id: i, 
                Name: $"Item_{i}", 
                CreatedAt: DateTime.UtcNow.AddDays(-i)
            );
        }
    }

    // Simple async enumerable returning tuples
    public static async IAsyncEnumerable<(int, string)> GetSimpleAsyncData(
        [EnumeratorCancellation] CancellationToken ct = default)
    {
        await Task.Delay(1, ct); // Simulate async work
        yield return (1, "first");
        yield return (2, "second");
        yield return (3, "third");
    }
}

public class AsyncDataSourceTests
{
    [Test]
    [MethodDataSource(typeof(AsyncTestDataSources), nameof(AsyncTestDataSources.GetAsyncTestData))]
    public async Task TestWithAsyncComplexData(AsyncTestData testData)
    {
        await Assert.That(testData.Id).IsGreaterThan(0);
        await Assert.That(testData.Name).StartsWith("Item_");
        await Assert.That(testData.CreatedAt).IsLessThan(DateTime.UtcNow);
    }

    [Test]
    [MethodDataSource(typeof(AsyncTestDataSources), nameof(AsyncTestDataSources.GetSimpleAsyncData))]
    public async Task TestWithAsyncSimpleData(int id, string name)
    {
        await Assert.That(id).IsBetween(1, 3);
        await Assert.That(name).IsNotEmpty();
    }
}
```

:::tip Performance Note
Async data sources are generated with strongly-typed delegates in AOT mode, providing excellent performance while maintaining full async/await support and cancellation token handling.
:::

## Instance Method Data Sources

In addition to static `MethodDataSource`, TUnit supports `InstanceMethodDataSource` for accessing instance members:

```csharp
public class MyTests
{
    private IEnumerable<int> TestData => new[] { 1, 2, 3 };

    [Test]
    [InstanceMethodDataSource(nameof(TestData))]
    public async Task MyTest(int value)
    {
        await Assert.That(value).IsGreaterThan(0);
    }
}
```

### Discovery Phase Considerations

`InstanceMethodDataSource` is evaluated during **test discovery** (before test execution). If the instance property depends on async initialization via `IAsyncInitializer`, that initialization has **not yet run** during discovery, potentially resulting in empty data and no tests being generated.

**Solutions:**

1. **Preferred:** Return predefined values that don't require initialization
2. **Alternative:** Use `IAsyncDiscoveryInitializer` if you need discovery-time initialization

See [Property Injection - Discovery Phase Initialization](../test-lifecycle/property-injection.md#discovery-phase-initialization) for detailed guidance and examples.
EOF < /dev/null

---

## Mocking


TUnit is a testing framework focused on test execution and does not include any built-in mocking capabilities. This gives you the freedom to choose whichever mocking library best suits your needs and preferences.

You can use any .NET mocking library with TUnit, such as NSubstitute, Moq, FakeItEasy, or any other mocking framework that works with .NET.

---

## Nested Data Sources with Initialization


When writing integration tests, you often need complex test fixtures that depend on other initialized resources. TUnit's nested data source initialization feature makes this elegant and automatic.

## The Problem

Traditional integration test setup often requires:
- Starting test containers (databases, message queues, etc.)
- Initializing WebApplicationFactory with custom services
- Ensuring proper initialization order
- Managing resource lifecycle

This typically leads to complex setup code with manual initialization chains.

## The Solution

TUnit automatically initializes nested data sources in the correct order using any data source attribute that implements `IDataSourceAttribute` (such as `[ClassDataSource<T>]`).

## Basic Example

Here's a complete example of setting up integration tests with Redis and WebApplicationFactory:

```csharp
using Testcontainers.Redis;
using TUnit.Core;
using Microsoft.AspNetCore.Mvc.Testing;
using StackExchange.Redis;

// 1. Define a test container that needs initialization
public class RedisTestContainer : IAsyncInitializer, IAsyncDisposable
{
    private readonly RedisContainer _container;
    
    public string ConnectionString => _container.GetConnectionString();
    
    public RedisTestContainer()
    {
        _container = new RedisBuilder()
            .WithImage("redis:7-alpine")
            .Build();
    }
    
    public async Task InitializeAsync()
    {
        await _container.StartAsync();
    }
    
    public async ValueTask DisposeAsync()
    {
        await _container.DisposeAsync();
    }
}

// 2. Create a test application that depends on Redis
public class TestApplication : IAsyncInitializer, IAsyncDisposable
{
    private WebApplicationFactory<Program>? _factory;
    
    // This property will be initialized BEFORE InitializeAsync is called
    [ClassDataSource<RedisTestContainer>]
    public required RedisTestContainer Redis { get; init; }
    
    public HttpClient Client { get; private set; } = null!;
    
    public async Task InitializeAsync()
    {
        // At this point, Redis is already started and ready!
        _factory = new WebApplicationFactory<Program>()
            .WithWebHostBuilder(builder =>
            {
                builder.ConfigureServices(services =>
                {
                    // Replace production Redis with our test container
                    services.AddSingleton<IConnectionMultiplexer>(_ => 
                        ConnectionMultiplexer.Connect(Redis.ConnectionString));
                });
            });
        
        Client = _factory.CreateClient();
    }
    
    public async ValueTask DisposeAsync()
    {
        Client?.Dispose();
        if (_factory != null) await _factory.DisposeAsync();
    }
}

// 3. Use in tests - TUnit automatically handles nested initialization
public class UserApiTests
{
    [Test]
    [ClassDataSource<TestApplication>(Shared = SharedType.PerClass)]
    public async Task CreateUser_Should_Cache_In_Redis(TestApplication app)
    {
        // Arrange
        var user = new { Name = "John", Email = "john@example.com" };
        
        // Act
        var response = await app.Client.PostAsJsonAsync("/api/users", user);
        
        // Assert
        response.EnsureSuccessStatusCode();
        
        // Verify the user was cached in Redis
        var services = app.Client.Services;
        var redis = services.GetRequiredService<IConnectionMultiplexer>();
        var cached = await redis.GetDatabase().StringGetAsync("user:john@example.com");
        
        Assert.That(cached.HasValue).IsTrue();
    }
}
```

## Multiple Dependencies

You can have multiple nested dependencies, and TUnit will initialize them in the correct order:

```csharp
public class CompleteTestEnvironment : IAsyncInitializer, IAsyncDisposable
{
    private WebApplicationFactory<Program>? _factory;
    
    // All of these will be initialized before InitializeAsync
    [ClassDataSource<RedisTestContainer>]
    public required RedisTestContainer Redis { get; init; }
    
    [ClassDataSource<PostgresTestContainer>]
    public required PostgresTestContainer Database { get; init; }
    
    [ClassDataSource<LocalStackContainer>]
    public required LocalStackContainer LocalStack { get; init; }
    
    public HttpClient Client { get; private set; } = null!;
    
    public async Task InitializeAsync()
    {
        // All containers are running at this point
        _factory = new WebApplicationFactory<Program>()
            .WithWebHostBuilder(builder =>
            {
                builder.ConfigureServices(services =>
                {
                    // Wire up all test services
                    ConfigureRedis(services);
                    ConfigureDatabase(services);
                    ConfigureAwsServices(services);
                });
            });
        
        Client = _factory.CreateClient();
        
        // Run any post-initialization setup
        await SeedTestData();
    }
    
    // ... configuration methods
}
```

## Sharing Resources

Expensive resources like test containers should be shared across tests using the `Shared` parameter:

```csharp
public class OrderApiTests
{
    [Test]
    [ClassDataSource<TestApplication>(Shared = SharedType.PerClass)]
    public async Task Test1(TestApplication app)
    {
        // First test - creates new instance
    }

    [Test]
    [ClassDataSource<TestApplication>(Shared = SharedType.PerClass)]
    public async Task Test2(TestApplication app)
    {
        // Reuses the same instance as Test1
    }
}

// Or share with a specific key for fine-grained control across multiple test classes
public class UserApiTests
{
    [Test]
    [ClassDataSource<TestApplication>(Shared = SharedType.Keyed, Key = "integration-tests")]
    public async Task CreateUser(TestApplication app) { /* ... */ }
}

public class ProductApiTests
{
    [Test]
    [ClassDataSource<TestApplication>(Shared = SharedType.Keyed, Key = "integration-tests")]
    public async Task CreateProduct(TestApplication app)
    {
        // Shares the same TestApplication instance with UserApiTests.CreateUser
    }
}
```

## How It Works

1. TUnit detects properties marked with data source attributes (like `[ClassDataSource<T>]`)
2. It builds a dependency graph and initializes in the correct order
3. Each object's `InitializeAsync` is called after its dependencies are ready
4. Disposal happens in reverse order automatically

## Best Practices

1. **Implement IAsyncInitializer**: For any class that needs async initialization
2. **Use Data Source Attributes**: Use attributes like `[ClassDataSource<T>]` to declare dependencies that must be initialized first
3. **Share Expensive Resources**: Use `SharedType` attributes to avoid creating multiple containers
4. **Dispose Properly**: Implement `IAsyncDisposable` for cleanup
5. **Keep Initialization Fast**: Do only essential setup in `InitializeAsync`

## Common Patterns

### Database Migrations
```csharp
public async Task InitializeAsync()
{
    await _container.StartAsync();
    
    // Run migrations after container starts
    using var connection = new NpgsqlConnection(ConnectionString);
    await connection.ExecuteAsync(@"
        CREATE TABLE IF NOT EXISTS users (
            id SERIAL PRIMARY KEY,
            email VARCHAR(255) UNIQUE NOT NULL
        )");
}
```

### Seeding Test Data
```csharp
public async Task InitializeAsync()
{
    // ... create WebApplicationFactory
    
    // Seed data after app starts
    using var scope = _factory.Services.CreateScope();
    var seeder = scope.ServiceProvider.GetRequiredService<ITestDataSeeder>();
    await seeder.SeedAsync();
}
```

### Health Checks
```csharp
public async Task InitializeAsync()
{
    // ... create client
    
    // Wait for app to be healthy
    var healthCheck = await Client.GetAsync("/health");
    healthCheck.EnsureSuccessStatusCode();
}
```

## Summary

Nested data source initialization in TUnit:
- ✅ Eliminates manual initialization chains
- ✅ Ensures correct initialization order
- ✅ Supports complex dependency graphs
- ✅ Works seamlessly with async operations
- ✅ Provides automatic cleanup

This makes integration testing with complex dependencies simple and maintainable.

---

## Ordering Tests


:::warning

It is recommended to use [DependsOn(...)] as it provides more flexibility and doesn't sacrifice parallelisation.

:::

By default, TUnit tests will run in parallel. This means there is no order and it doesn't make sense to be able to control that.

However, if tests aren't running in parallel, they can absolutely be ordered, and this is necessary for some systems.

To control ordering, there is an `Order` property on the `[NotInParallel]` attribute.

Orders will execute from smallest to largest. So 1 first, then 2, then 3, etc.

```csharp
using TUnit.Core;

namespace MyTestProject;

public class MyTestClass
{
    [Test]
    [NotInParallel(Order = 1)]
    public async Task MyTest()
    {
        
    }

    [Test]
    [NotInParallel(Order = 2)]
    public async Task MyTest2()
    {
        
    }
}
```

---

## Skipping Tests


If you want to simply skip a test, just place a `[Skip(reason)]` attribute on your test with an explanation of why you're skipping it.

```csharp
using TUnit.Core;

namespace MyTestProject;

public class MyTestClass
{
    [Test, Skip("There's a bug! See issue #1")]
    public async Task MyTest()
    {
        ...
    }
}
```

## Custom Logic

The `SkipAttribute` can be inherited and custom logic plugged into it, so it only skips the test if it meets certain criteria.

As an example, this could be used to skip tests on certain operating systems.

```csharp
public class WindowsOnlyAttribute() : SkipAttribute("This test is only supported on Windows")
{
    public override Task<bool> ShouldSkip(TestRegisteredContext context)
    {
        return Task.FromResult(!RuntimeInformation.IsOSPlatform(OSPlatform.Windows));
    }
}
```

```csharp
using TUnit.Core;

namespace MyTestProject;

public class MyTestClass
{
    [Test, WindowsOnly]
    public async Task MyTest()
    {
        ...
    }
}
```

## Global Skipping

In case you want to skip all tests in a project, you can add the attribute on the assembly level.

```csharp
[assembly: Skip("Skipping all tests in this assembly")]
```

Or you can skip all the tests in a class like this:

```csharp
[Skip("Skipping all tests in this class")]
public class MyTestClass
{
}
```

## Dynamic Skipping at Runtime

Sometimes you need to determine whether to skip a test at runtime based on conditions that aren't known until the test executes. For this, you can use the static `Skip.Test(reason)` method.

### Skip.Test()

The `Skip.Test(reason)` method allows you to dynamically skip a test from within the test method or hooks. When called, it throws a `SkipTestException` that the test framework catches and marks the test as skipped.

```csharp
using TUnit.Core;

namespace MyTestProject;

public class MyTestClass
{
    [Test]
    public async Task MyTest()
    {
        var apiAvailable = await CheckApiAvailability();
        
        if (!apiAvailable)
        {
            Skip.Test("API is not available");
        }
        
        // Test continues only if API is available
        await CallApi();
    }
}
```

### Skipping from Hooks

You can also use `Skip.Test()` in test hooks to skip tests based on setup conditions:

```csharp
using TUnit.Core;

namespace MyTestProject;

public class MyTestClass
{
    [Before(Test)]
    public void BeforeEachTest()
    {
        var databaseAvailable = CheckDatabaseConnection();
        
        if (!databaseAvailable)
        {
            Skip.Test("Database is not available");
        }
    }

    [Test]
    public void Test1()
    {
        // This test will be skipped if database is unavailable
    }

    [Test]
    public void Test2()
    {
        // This test will also be skipped if database is unavailable
    }
}
```

You can skip all tests in a class from a `Before(Class)` hook:

```csharp
using TUnit.Core;

namespace MyTestProject;

public class MyTestClass
{
    [Before(Class)]
    public static void BeforeAllTests()
    {
        var serviceAvailable = CheckExternalService();
        
        if (!serviceAvailable)
        {
            Skip.Test("External service is not available");
        }
    }

    [Test]
    public void Test1()
    {
        // All tests in this class will be skipped if service is unavailable
    }
}
```

### When to Use Dynamic Skipping

Use `Skip.Test()` and its variants when:
- The skip condition depends on runtime state (external services, environment variables, etc.)
- You need to perform some logic or API calls to determine if a test should run
- The skip decision is based on test setup or initialization results

Use `[Skip]` attribute when:
- The skip condition is known at compile time or discovery time
- You want to skip tests based on static configuration or platform checks
- You need custom skip logic in a reusable attribute

---

## Test Data Row Metadata


When using data sources like `[MethodDataSource]` or `[ClassDataSource]`, you may want to customize individual test cases with specific display names, skip reasons, or categories. TUnit provides the `TestDataRow<T>` wrapper type for this purpose.

## Basic Usage

Wrap your test data in `TestDataRow<T>` to add metadata:

```csharp
using TUnit.Core;

public static class LoginTestData
{
    public static IEnumerable<TestDataRow<(string Username, string Password)>> GetCredentials()
    {
        yield return new(("admin", "secret123"), DisplayName: "Admin login");
        yield return new(("guest", "guest"), DisplayName: "Guest login");
        yield return new(("", ""), DisplayName: "Empty credentials", Skip: "Not implemented yet");
    }
}

public class LoginTests
{
    [Test]
    [MethodDataSource(typeof(LoginTestData), nameof(LoginTestData.GetCredentials))]
    public async Task TestLogin(string username, string password)
    {
        // Test implementation
    }
}
```

## Available Properties

`TestDataRow<T>` provides these optional properties:

| Property | Type | Description |
|----------|------|-------------|
| `DisplayName` | `string?` | Custom name shown in test output and IDE |
| `Skip` | `string?` | Skip reason; when set, the test is skipped |
| `Categories` | `string[]?` | Categories for filtering tests |

## Display Name Substitution

Display names support parameter substitution using `$paramName` or positional `$arg1`, `$arg2` syntax:

```csharp
public static IEnumerable<TestDataRow<(int A, int B, int Expected)>> GetMathData()
{
    yield return new((2, 3, 5), DisplayName: "Adding $A + $B = $Expected");
    yield return new((10, 5, 15), DisplayName: "$arg1 plus $arg2 equals $arg3");
}
```

The placeholders are replaced with the actual argument values at test discovery time.

## Working with Complex Types

For complex objects, wrap the entire object:

```csharp
public record UserTestCase(string Email, bool IsAdmin, string ExpectedRole);

public static class UserTestData
{
    public static IEnumerable<TestDataRow<UserTestCase>> GetUserCases()
    {
        yield return new(
            new UserTestCase("admin@test.com", true, "Administrator"),
            DisplayName: "Admin user gets admin role",
            Categories: ["Admin", "Roles"]
        );

        yield return new(
            new UserTestCase("user@test.com", false, "Standard"),
            DisplayName: "Regular user gets standard role"
        );
    }
}

public class UserRoleTests
{
    [Test]
    [MethodDataSource(typeof(UserTestData), nameof(UserTestData.GetUserCases))]
    public async Task TestUserRole(UserTestCase testCase)
    {
        // testCase.Email, testCase.IsAdmin, testCase.ExpectedRole
    }
}
```

## With Func\<T\> for Reference Types

When returning reference types, combine with `Func<T>` to ensure fresh instances:

```csharp
public static IEnumerable<TestDataRow<Func<HttpClient>>> GetHttpClients()
{
    yield return new(
        () => new HttpClient { BaseAddress = new Uri("https://api.example.com") },
        DisplayName: "Production API client"
    );

    yield return new(
        () => new HttpClient { BaseAddress = new Uri("https://staging.example.com") },
        DisplayName: "Staging API client"
    );
}
```

## Skipping Individual Test Cases

Use the `Skip` property to skip specific test cases while keeping others active:

```csharp
public static IEnumerable<TestDataRow<(string Browser, string Version)>> GetBrowsers()
{
    yield return new(("Chrome", "120"), DisplayName: "Chrome latest");
    yield return new(("Firefox", "121"), DisplayName: "Firefox latest");
    yield return new(("Safari", "17"), DisplayName: "Safari", Skip: "Safari not installed on CI");
    yield return new(("Edge", "120"), DisplayName: "Edge latest");
}
```

## Categorizing Test Cases

Apply categories to individual test cases for filtering:

```csharp
public static IEnumerable<TestDataRow<(string Endpoint, string Method)>> GetApiEndpoints()
{
    yield return new(
        ("/users", "GET"),
        DisplayName: "List users",
        Categories: ["API", "Users", "ReadOnly"]
    );

    yield return new(
        ("/users", "POST"),
        DisplayName: "Create user",
        Categories: ["API", "Users", "Write"]
    );

    yield return new(
        ("/admin/config", "PUT"),
        DisplayName: "Update config",
        Categories: ["API", "Admin", "Write"]
    );
}
```

Run only specific categories:
```bash
dotnet run -- --filter "Category=Admin"
```

## With ClassDataSource

`TestDataRow<T>` works with `[ClassDataSource]` too:

```csharp
public class DatabaseTestData : IEnumerable<TestDataRow<(string ConnectionString, string DbName)>>
{
    public IEnumerator<TestDataRow<(string ConnectionString, string DbName)>> GetEnumerator()
    {
        yield return new(
            ("Server=localhost;Database=TestDb1", "TestDb1"),
            DisplayName: "Local database"
        );
        yield return new(
            ("Server=remote;Database=TestDb2", "TestDb2"),
            DisplayName: "Remote database",
            Skip: "Remote server unavailable"
        );
    }

    IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();
}

public class DatabaseTests
{
    [Test]
    [ClassDataSource<DatabaseTestData>]
    public async Task TestDatabaseConnection(string connectionString, string dbName)
    {
        // Test implementation
    }
}
```

## Universal Data Source Support

`TestDataRow<T>` works with any data source that implements `IDataSourceAttribute`, including custom data source attributes. TUnit automatically detects and unwraps `TestDataRow<T>` instances, extracting the metadata regardless of the data source type.

## See Also

- [Arguments Attribute](./arguments.md) - For compile-time constant data with inline metadata
- [Method Data Sources](./method-data-source.md) - For dynamic test data generation
- [Class Data Sources](./class-data-source.md) - For class-based test data
- [Display Names](../customization-extensibility/display-names.md) - For global display name formatting

---

## Things to know


TUnit has made some decisions by design. You may need to know about them:

## Parallelisation

Tests are run in parallel by design. If you have operations you can't do in parallel, you'll need to add a `[NotInParallel]` attribute to your test. That attribute can also take an `Order` property, so you can control the ordering of your not in parallel tests.

## Test Classes and Instance Data

Classes are `new`ed up for each test within their class. 

This is by design because tests should be stateless and side effect free. 

By doing this it enables parallelisation (for speed and throughput), and reduces bugs and side effects when there is stale data left over from previous tests. This is something I've experienced with NUnit before. I've seen test suites that were all green, and they were actually broken, because they were asserting against instance data that had been left over from previous tests.

So if you have:

```csharp
public class MyTests
{
    [Test]
    public void MyTest1() { ... }

    [Test]
    public void MyTest2() { ... }
}
```

Then `MyTest1` and `MyTest2` will have a different instance of `MyTests`.

This isn't that important unless you're storing state.

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

<Tabs>
  <TabItem value="bad" label="❌ Bad - Will Fail" default>

```csharp
public class MyTests
{
    private int _value;

    [Test, NotInParallel]
    public void MyTest1() { _value = 99; }

    [Test, NotInParallel]
    public async Task MyTest2()
    {
        // This will FAIL because _value is 0
        // Different test instance = different _value
        await Assert.That(_value).IsEqualTo(99);
    }
}
```

**Why this fails:** Each test gets a new instance of `MyTests`, so `_value` in `MyTest2` is a different field than in `MyTest1`.

  </TabItem>
  <TabItem value="good" label="✅ Good - Use Static">

```csharp
public class MyTests
{
    private static int _value;

    [Test, NotInParallel]
    public void MyTest1() { _value = 99; }

    [Test, NotInParallel]
    public async Task MyTest2()
    {
        // This works because _value is static
        await Assert.That(_value).IsEqualTo(99);
    }
}
```

**Why this works:** The `static` keyword makes the field persist across instances, making it clear that data is shared.

  </TabItem>
</Tabs>

---

## Test Artifacts


Test artifacts are files (screenshots, logs, videos, JSON dumps, etc.) that you can attach to your tests. They are invaluable for debugging test failures, especially in integration tests and end-to-end tests.

TUnit supports attaching artifacts at two levels:
- **Test-level artifacts**: Attached to individual tests
- **Session-level artifacts**: Attached to the entire test session

## Test-Level Artifacts

Attach files to individual tests using `TestContext.Current.Output.AttachArtifact()`.

### Basic Usage

The simplest way to attach an artifact is by providing just the file path:

```csharp
[Test]
public async Task MyIntegrationTest()
{
    // Perform your test logic
    var result = await PerformOperation();

    // Attach an artifact using the simple overload
    TestContext.Current!.Output.AttachArtifact("path/to/logfile.log");

    // Or with a custom display name and description
    TestContext.Current!.Output.AttachArtifact(
        "path/to/logfile.log",
        displayName: "Application Logs",
        description: "Logs captured during test execution"
    );

    await Assert.That(result).IsEqualTo(expected);
}
```

For more control, you can create an `Artifact` object directly:

```csharp
[Test]
public async Task MyIntegrationTest()
{
    // Attach an artifact using the full Artifact object
    TestContext.Current!.Output.AttachArtifact(new Artifact
    {
        File = new FileInfo("path/to/logfile.log"),
        DisplayName = "Application Logs",
        Description = "Logs captured during test execution"
    });
}
```

### Attaching Screenshots on Failure

A common pattern is to capture a screenshot when a test fails:

```csharp
public class MyTests
{
    [After(HookType.Test)]
    public async Task TakeScreenshotOnFailure()
    {
        var testContext = TestContext.Current;
        
        if (testContext?.Result?.State == TestState.Failed)
        {
            // Capture screenshot
            var screenshotPath = await CaptureScreenshot();
            
            testContext.Output.AttachArtifact(new Artifact
            {
                File = new FileInfo(screenshotPath),
                DisplayName = "Failure Screenshot",
                Description = $"Screenshot captured when test '{testContext.TestDetails.TestName}' failed"
            });
        }
    }
    
    private async Task<string> CaptureScreenshot()
    {
        // Your screenshot capture logic
        var path = $"screenshots/test-{Guid.NewGuid()}.png";
        // ... capture screenshot to path ...
        return path;
    }
}
```

### Attaching Multiple Artifacts

You can attach multiple artifacts to a single test:

```csharp
[Test]
public async Task ComplexIntegrationTest()
{
    // Test logic that generates multiple outputs
    var httpLog = await ExecuteHttpRequests();
    var dbLog = await QueryDatabase();
    var traceLog = await CollectTraces();
    
    // Attach all artifacts
    TestContext.Current!.Output.AttachArtifact(new Artifact
    {
        File = new FileInfo(httpLog),
        DisplayName = "HTTP Requests",
        Description = "All HTTP requests and responses"
    });
    
    TestContext.Current.Output.AttachArtifact(new Artifact
    {
        File = new FileInfo(dbLog),
        DisplayName = "Database Queries",
        Description = "All database queries executed"
    });
    
    TestContext.Current.Output.AttachArtifact(new Artifact
    {
        File = new FileInfo(traceLog),
        DisplayName = "Trace Logs",
        Description = "Application trace logs"
    });
}
```

## Session-Level Artifacts

Attach files to the entire test session using `TestSessionContext.Current.AddArtifact()`. This is useful for artifacts that span multiple tests or provide context for the entire test run.

### Basic Usage

```csharp
[Before(HookType.TestSession)]
public static void SetupTestSession()
{
    // Start capturing session-wide logs
    var sessionLogPath = "test-session-log.txt";
    StartLogging(sessionLogPath);
    
    // This artifact is available to the entire test session
    TestSessionContext.Current!.AddArtifact(new Artifact
    {
        File = new FileInfo(sessionLogPath),
        DisplayName = "Test Session Log",
        Description = "Log file for the entire test session"
    });
}
```

### Configuration Files

Attach configuration files to document the test environment:

```csharp
[Before(HookType.TestSession)]
public static void DocumentTestEnvironment()
{
    // Attach environment configuration
    TestSessionContext.Current!.AddArtifact(new Artifact
    {
        File = new FileInfo("appsettings.test.json"),
        DisplayName = "Test Configuration",
        Description = "Application configuration used for this test run"
    });
    
    // Attach environment info
    var envInfo = CollectEnvironmentInfo();
    File.WriteAllText("environment-info.json", envInfo);
    
    TestSessionContext.Current.AddArtifact(new Artifact
    {
        File = new FileInfo("environment-info.json"),
        DisplayName = "Environment Information",
        Description = "System and runtime environment details"
    });
}
```

### Performance Reports

Generate and attach performance reports for the entire test session:

```csharp
[After(HookType.TestSession)]
public static void GeneratePerformanceReport()
{
    // Generate performance report after all tests complete
    var reportPath = "performance-report.html";
    GenerateReport(reportPath);
    
    TestSessionContext.Current!.AddArtifact(new Artifact
    {
        File = new FileInfo(reportPath),
        DisplayName = "Performance Report",
        Description = "Performance metrics for all tests in this session"
    });
}
```

## Artifact Class

The `Artifact` class has the following properties:

```csharp
public class Artifact
{
    public required FileInfo File { get; init; }          // The file to attach
    public required string DisplayName { get; init; }     // Human-readable name
    public string? Description { get; init; }             // Optional description
}
```

- **File**: A `FileInfo` object pointing to the file. The file must exist at the time of attachment.
- **DisplayName**: A short, descriptive name for the artifact (e.g., "Screenshot", "Logs", "Configuration").
- **Description**: An optional longer description providing more context about the artifact.

## Best Practices

### 1. Clean Up Artifacts

Consider cleaning up temporary artifact files after test execution to avoid accumulating files:

```csharp
[After(HookType.TestSession)]
public static void CleanupArtifacts()
{
    var artifactDir = "test-artifacts";
    if (Directory.Exists(artifactDir))
    {
        Directory.Delete(artifactDir, recursive: true);
    }
}
```

### 2. Organize Artifacts by Test

Create a unique directory for each test's artifacts:

```csharp
[Before(HookType.Test)]
public void SetupTestArtifactDirectory()
{
    var testName = TestContext.Current!.TestDetails.TestName;
    var sanitizedName = string.Concat(testName.Split(Path.GetInvalidFileNameChars()));
    var artifactDir = Path.Combine("test-artifacts", sanitizedName);
    Directory.CreateDirectory(artifactDir);
    
    TestContext.Current.StateBag["ArtifactDir"] = artifactDir;
}

[Test]
public void MyTest()
{
    var artifactDir = (string)TestContext.Current!.StateBag["ArtifactDir"];
    var logPath = Path.Combine(artifactDir, "test.log");
    
    // ... test logic ...
    
    TestContext.Current.Output.AttachArtifact(new Artifact
    {
        File = new FileInfo(logPath),
        DisplayName = "Test Log"
    });
}
```

### 3. Only Attach on Failure

For large artifacts (videos, extensive logs), consider only attaching them when tests fail:

```csharp
[After(HookType.Test)]
public async Task ConditionalArtifactAttachment()
{
    var testContext = TestContext.Current;
    
    if (testContext?.Result?.State is TestState.Failed or TestState.TimedOut)
    {
        // Only attach expensive artifacts on failure
        var videoPath = await StopRecording();
        
        testContext.Output.AttachArtifact(new Artifact
        {
            File = new FileInfo(videoPath),
            DisplayName = "Test Recording",
            Description = "Video recording of the failed test"
        });
    }
}
```

### 4. Use Descriptive Names

Provide clear, descriptive names and descriptions for your artifacts:

```csharp
// ❌ Not descriptive
TestContext.Current!.Output.AttachArtifact(new Artifact
{
    File = new FileInfo("log.txt"),
    DisplayName = "Log"
});

// ✅ Descriptive and helpful
TestContext.Current!.Output.AttachArtifact(new Artifact
{
    File = new FileInfo("http-trace.log"),
    DisplayName = "HTTP Request Trace",
    Description = "Complete trace of all HTTP requests including headers and response bodies"
});
```

### 5. Verify Files Exist

Always ensure the file exists before attaching:

```csharp
var logPath = "path/to/logfile.log";

if (File.Exists(logPath))
{
    TestContext.Current!.Output.AttachArtifact(new Artifact
    {
        File = new FileInfo(logPath),
        DisplayName = "Application Log"
    });
}
else
{
    TestContext.Current!.Output.WriteLine($"Warning: Log file not found at {logPath}");
}
```

## Common Use Cases

### Browser Testing with Playwright

```csharp
[After(HookType.Test)]
public async Task CapturePlaywrightArtifacts()
{
    var testContext = TestContext.Current;
    
    if (testContext?.Result?.State != TestState.Passed)
    {
        // Capture screenshot
        var screenshotPath = $"artifacts/screenshot-{testContext.Id}.png";
        await _page.ScreenshotAsync(new() { Path = screenshotPath });
        
        testContext.Output.AttachArtifact(new Artifact
        {
            File = new FileInfo(screenshotPath),
            DisplayName = "Browser Screenshot"
        });
        
        // Capture video if enabled
        if (_browserContext.Options?.RecordVideo != null)
        {
            await _page.CloseAsync();
            var videoPath = await _page.Video!.PathAsync();
            
            testContext.Output.AttachArtifact(new Artifact
            {
                File = new FileInfo(videoPath),
                DisplayName = "Browser Recording"
            });
        }
    }
}
```

### API Testing

```csharp
[Test]
public async Task ApiIntegrationTest()
{
    var requestLog = new StringBuilder();
    var responseLog = new StringBuilder();
    
    // Make API calls while logging
    var response = await _httpClient.GetAsync("/api/endpoint");
    requestLog.AppendLine($"GET /api/endpoint");
    responseLog.AppendLine(await response.Content.ReadAsStringAsync());
    
    // Save and attach logs
    var requestPath = "api-request.txt";
    var responsePath = "api-response.txt";
    
    await File.WriteAllTextAsync(requestPath, requestLog.ToString());
    await File.WriteAllTextAsync(responsePath, responseLog.ToString());
    
    TestContext.Current!.Output.AttachArtifact(new Artifact
    {
        File = new FileInfo(requestPath),
        DisplayName = "API Request"
    });
    
    TestContext.Current.Output.AttachArtifact(new Artifact
    {
        File = new FileInfo(responsePath),
        DisplayName = "API Response"
    });
}
```

### Database Testing

```csharp
[Test]
public async Task DatabaseIntegrationTest()
{
    var queryLog = new List<string>();
    
    // Execute queries while logging
    foreach (var query in _queries)
    {
        await _connection.ExecuteAsync(query);
        queryLog.Add(query);
    }
    
    // Save query log
    var logPath = "database-queries.sql";
    await File.WriteAllLinesAsync(logPath, queryLog);
    
    TestContext.Current!.Output.AttachArtifact(new Artifact
    {
        File = new FileInfo(logPath),
        DisplayName = "Database Queries",
        Description = "All SQL queries executed during test"
    });
}
```

## Integration with Test Runners

Artifacts attached using TUnit are automatically forwarded to the underlying Microsoft.Testing.Platform infrastructure, which makes them available to:

- Test result files (TRX, etc.)
- CI/CD systems (GitHub Actions, Azure DevOps, etc.)
- Test explorers in IDEs (Visual Studio, Rider, VS Code)

The exact behavior depends on your test runner configuration and CI/CD platform.

## See Also

- [Test Context](./test-context.md) - Overview of TestContext
- [Test Lifecycle Hooks](./setup.md) - Using Before/After hooks
- [CI/CD Reporting](../execution/ci-cd-reporting.md) - Integrating with CI systems

---

## Class Constructor Helpers


Some test suites might be more complex than others, and a user may want control over 'newing' up their test classes.
This control is given to you by the `[ClassConstructorAttribute<T>]` - Where `T` is a class that implements `IClassConstructor`.

This interface simply requires you to generate a `T` object - How you do that is up to you!

You can also add [event-subscribing interfaces](test-lifecycle/event-subscribing.md) to get notified for things like when the test has finished. This functionality can be used to dispose objects afterwards, etc.

These attributes are new'd up per test, so you can store state within them.

---

## Test Clean Ups


TUnit supports having your test class implement `IDisposable` or `IAsyncDisposable`. These will be called after your test has finished executing. However, using the attributes below offers better support for running multiple methods, and without having to implement your own try/catch logic. Every `[After]` method will be run, and any exceptions will be lazily thrown afterwards.

You can also declare a method with an `[After(...)]` or an `[AfterEvery(...)]` attribute.

## Hook Method Signatures

Hook methods can be either synchronous or asynchronous:

```csharp
[After(Test)]
public void SynchronousCleanup()  // ✅ Valid - synchronous hook
{
    _resource?.Dispose();
}

[After(Test)]
public async Task AsyncCleanup()  // ✅ Valid - asynchronous hook
{
    await new HttpClient().GetAsync("https://localhost/test-finished-notifier");
}
```

**Important Notes:**
- Hooks can be `void` (synchronous) or `async Task` (asynchronous)
- Use async hooks when you need to perform async operations (HTTP calls, database queries, etc.)
- Use synchronous hooks for simple cleanup (disposing objects, resetting state, etc.)
- `async void` hooks are **not allowed** and will cause a compiler error

### Hook Parameters

Hooks can optionally accept parameters for accessing context information and cancellation tokens:

```csharp
[After(Test)]
public async Task Cleanup(TestContext context, CancellationToken cancellationToken)
{
    // Access test results via context
    if (context.Execution.Result?.State == TestState.Failed)
    {
        await CaptureScreenshot(cancellationToken);
    }
}

[After(Class)]
public static async Task ClassCleanup(ClassHookContext context, CancellationToken cancellationToken)
{
    // Use cancellation token for timeout-aware cleanup operations
    await DisposeResources(cancellationToken);
}

[After(Test)]
public async Task CleanupWithToken(CancellationToken cancellationToken)
{
    // Can use CancellationToken without context
    await FlushBuffers(cancellationToken);
}

[After(Test)]
public async Task CleanupWithContext(TestContext context)
{
    // Can use context without CancellationToken
    Console.WriteLine($"Test {context.Metadata.TestName} completed");
}
```

**Valid Parameter Combinations:**
- No parameters: `public void Hook() { }`
- Context only: `public void Hook(TestContext context) { }`
- CancellationToken only: `public async Task Hook(CancellationToken ct) { }`
- Both: `public async Task Hook(TestContext context, CancellationToken ct) { }`

**Context Types by Hook Level:**

| Hook Level | Context Type | Example |
|------------|-------------|---------|
| `[After(Test)]` | `TestContext` | Access test results, output writer |
| `[After(Class)]` | `ClassHookContext` | Access class information |
| `[After(Assembly)]` | `AssemblyHookContext` | Access assembly information |
| `[After(TestSession)]` | `TestSessionContext` | Access test session information |
| `[After(TestDiscovery)]` | `TestDiscoveryContext` | Access discovery results |

## [After(HookType)]

### [After(Test)]
Must be an instance method. Will be executed after each test in the class it's defined in.
Methods will be executed top-down, so the current class clean ups will execute first, then the base classes' last.

### [After(Class)]
Must be a static method. Will run once after the last test in the class it's defined it finishes.

### [After(Assembly)]
Must be a static method. Will run once after the last test in the assembly it's defined it finishes.

### [After(TestSession)]
Must be a static method. Will run once after the last test in the test session finishes.

### [After(TestDiscovery)]
Must be a static method. Will run once after tests are discovered.

## [AfterEvery(HookType)]
All [AfterEvery(...)] methods must be static - And should ideally be placed in their own file that's easy to find, as they can globally affect the test suite, so it should be easy for developers to locate this behaviour.
e.g. `GlobalHooks.cs` at the root of the test project.

:::info
Use `[AfterEvery(...)]` for global clean-up logic that should run after every test/class/assembly/session, regardless of where the test is defined.
:::

### [AfterEvery(Test)]
Will be executed after every test that will run in the test session.

### [AfterEvery(Class)]
Will be executed after the last test of every class that will run in the test session.

### [AfterEvery(Assembly)]
Will be executed after the last test of every assembly that will run in the test session.

### [AfterEvery(TestSession)]
The same as [After(TestSession)]

### [AfterEvery(TestDiscovery)]
The same as [After(TestDiscovery)]

```csharp
using TUnit.Core;

namespace MyTestProject;

public class MyTestClass
{
    private int _value;
    private static HttpResponseMessage? _pingResponse;

    [After(Class)]
    public static async Task KillChromedrivers()
    {
        await Task.CompletedTask;

        foreach (var process in Process.GetProcessesByName("chromedriver.exe"))
        {
            process.Kill();
        }
    }
    
    [After(Test)]
    public async Task AfterEachTest()
    {
        await new HttpClient().GetAsync($"https://localhost/test-finished-notifier?testName={TestContext.Current.Metadata.TestName}");
    }

    [Test]
    public async Task MyTest()
    {
        // Do something
    }
}
```

---

## Dependency Injection


Dependency Injection can be set up by leveraging the power of the Data Source Generators.

TUnit provides you an abstract class to handle most of the logic for you, you need to simply provide the implementation on how to create a DI Scope, and then how to get or create an object when given its type.

So create a new class that inherits from `DependencyInjectionDataSourceAttribute<TScope>` and pass through the Scope type as the generic argument.

Here's an example of that using the Microsoft.Extensions.DependencyInjection library:

```csharp
using TUnit.Core;

namespace MyTestProject;

public class MicrosoftDependencyInjectionDataSourceAttribute : DependencyInjectionDataSourceAttribute<IServiceScope>
{
    private static readonly IServiceProvider ServiceProvider = CreateSharedServiceProvider();

    public override IServiceScope CreateScope(DataGeneratorMetadata dataGeneratorMetadata)
    {
        return ServiceProvider.CreateScope();
    }

    public override object? Create(IServiceScope scope, Type type)
    {
        return scope.ServiceProvider.GetService(type);
    }
    
    private static IServiceProvider CreateSharedServiceProvider()
    {
        return new ServiceCollection()
            .AddSingleton<SomeClass1>()
            .AddSingleton<SomeClass2>()
            .AddTransient<SomeClass3>()
            .BuildServiceProvider();
    }
}

[MicrosoftDependencyInjectionDataSource]
public class MyTestClass(SomeClass1 someClass1, SomeClass2 someClass2, SomeClass3 someClass3)
{
    [Test]
    public async Task Test()
    {
        // ...
    }
}
```

---

## Event Subscribing


Objects associated with your tests have the ability to subscribe to lifecycle events generated by TUnit.

Objects associated with your tests can mean:
- The test class itself
- A custom class constructor
- Injected class parameter arguments
- Injected method parameter arguments
- Injected properties
- Associated attributes

The interfaces they can implement are:
- ITestRegisteredEventReceiver
- ITestStartEventReceiver
- ITestEndEventReceiver
- ILastTestInClassEventReceiver
- ILastTestInAssemblyEventReceiver
- ILastTestInTestSessionEventReceiver

This can be useful especially when generating data that you need to track and maybe dispose later. By hooking into these events, we can do things like track and dispose our objects when we need.

## Execution Stage Control

> **Note**: This feature is available on .NET 8.0+ only due to default interface member requirements.

For `ITestStartEventReceiver` and `ITestEndEventReceiver`, you can control when your event receivers execute relative to instance-level hooks (`[Before(Test)]` and `[After(Test)]`) by setting the `Stage` property.

### EventReceiverStage Options

- **`EventReceiverStage.Early`**: Executes before instance-level hooks
  - Test start receivers run before `[Before(Test)]` hooks
  - Test end receivers run before `[After(Test)]` hooks

- **`EventReceiverStage.Late`** (default): Executes after instance-level hooks
  - Test start receivers run after `[Before(Test)]` hooks
  - Test end receivers run after `[After(Test)]` hooks

### When to Use Early Stage

Use `EventReceiverStage.Early` when your event receiver needs to:
- Initialize resources that instance-level hooks depend on
- Set up test context or environment before any test-specific setup runs
- Capture test state before any modifications from hooks

### When to Use Late Stage

Use `EventReceiverStage.Late` (the default) when your event receiver needs to:
- Access resources initialized by instance-level hooks
- Clean up after all test-specific teardown completes
- Log or report on final test state after all hooks have run

### Example: Early Stage Event Receiver

```csharp
public class DatabaseConnectionAttribute : Attribute, ITestStartEventReceiver
{
    private IDbConnection? _connection;

    // Execute before [Before(Test)] hooks so the connection is available to them
    public EventReceiverStage Stage => EventReceiverStage.Early;

    public async ValueTask OnTestStart(TestContext context)
    {
        _connection = new SqlConnection(connectionString);
        await _connection.OpenAsync();

        // Store connection in test context for use by hooks and test
        context.StateBag.GetOrAdd("DbConnection", _ => _connection);
    }
}

public class MyTests
{
    [Test]
    [DatabaseConnection] // Runs BEFORE BeforeTest hook
    public async Task TestWithDatabase()
    {
        // Database connection is already open and available
        TestContext.Current!.StateBag.TryGetValue<IDbConnection>("DbConnection", out var connection);
        // ... test logic
    }

    [Before(Test)]
    public void BeforeTest()
    {
        // Database connection is already available here
        TestContext.Current!.StateBag.TryGetValue<IDbConnection>("DbConnection", out var connection);
        // ... setup that needs the database
    }
}
```

### Example: Late Stage Event Receiver (Default)

```csharp
public class TestMetricsAttribute : Attribute, ITestEndEventReceiver
{
    // Late stage is the default, so this property is optional
    public EventReceiverStage Stage => EventReceiverStage.Late;

    public async ValueTask OnTestEnd(TestContext context)
    {
        // This runs AFTER all [After(Test)] hooks have completed
        // So we can capture the final test metrics including cleanup time
        await LogMetrics(context);
    }
}
```

### .NET Framework / .NET Standard 2.0 Behavior

On older frameworks that don't support default interface members (.NET Framework, .NET Standard 2.0), the `Stage` property is not available. All event receivers will execute at the `Late` stage (after instance-level hooks), which matches the historical behavior.

Each attribute will be new'd up for each test, so you are able to store state within the fields of your attribute class.

The `[ClassDataSource<T>]` uses these events to do the following:
- On Test Register > Increment Counts for Various Types (Global, Keyed, etc.)
- On Test Start > Initialise any objects if they have the `IAsyncInitializer` interface
- On Test End > If the object isn't shared, dispose it. Otherwise, decrement the count for the type.
- On Last Test for Class > Dispose the object being used to inject into that specific class
- On Last Test for Assembly > Dispose the object being used to inject into that specific assembly

Here's a simple Dependency Injection Class Constructor class subscribing to the TestEnd event in order to dispose the service scope when the test is finished:

```csharp
public class DependencyInjectionClassConstructor : IClassConstructor, ITestEndEventReceiver
{
    private readonly IServiceProvider _serviceProvider = CreateServiceProvider();
    private AsyncServiceScope _scope;

    public Task<object> Create([DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicConstructors)] Type type, ClassConstructorMetadata classConstructorMetadata)
    {
        _scope = _serviceProvider.CreateAsyncScope();

        var instance = ActivatorUtilities.GetServiceOrCreateInstance(_scope.ServiceProvider, type);
        return Task.FromResult(instance);
    }

    public ValueTask OnTestEnd(TestContext testContext)
    {
        return _scope.DisposeAsync();
    }

    private static IServiceProvider CreateServiceProvider()
    {
        return new ServiceCollection()
            .AddTransient<Class1>()
            .AddTransient<Class2>()
            .AddTransient<Class3>()
            ...
            .BuildServiceProvider();
    }
}
```

---

## Test Lifecycle Overview


Understanding TUnit's complete test lifecycle helps you write effective tests and place setup/cleanup logic in the right place. TUnit provides multiple mechanisms for hooking into the lifecycle:

1. **Hook Attributes** (`[Before]`, `[After]`, etc.) - Method-based hooks
2. **Event Receivers** (interfaces like `ITestStartEventReceiver`) - Object-based event subscriptions
3. **Initialization Interfaces** (`IAsyncInitializer`, `IAsyncDiscoveryInitializer`) - Async object setup
4. **Disposal Interfaces** (`IDisposable`, `IAsyncDisposable`) - Resource cleanup

This page provides a complete visual overview of when each mechanism executes.

## Complete Lifecycle Diagram

```mermaid
flowchart TB
    subgraph Discovery["1. Discovery Phase"]
        direction TB
        D1["[Before(TestDiscovery)]"]
        D2["Scan assemblies for [Test] methods"]
        D3["Create data sources & resolve property values"]
        D3a["IAsyncDiscoveryInitializer.InitializeAsync()"]
        D4["[After(TestDiscovery)]"]
        D5["ITestRegisteredEventReceiver.OnTestRegistered()"]
        D1 --> D2 --> D3 --> D3a --> D4 --> D5
    end

    subgraph Session["2. Test Session Execution"]
        direction TB
        S1["[Before(TestSession)]"]
        S1a["IFirstTestInTestSessionEventReceiver"]

        subgraph Assembly["Per Assembly"]
            direction TB
            A1["[BeforeEvery(Assembly)] / [Before(Assembly)]"]
            A1a["IFirstTestInAssemblyEventReceiver"]

            subgraph Class["Per Class"]
                direction TB
                C1["[BeforeEvery(Class)] / [Before(Class)]"]
                C1a["IFirstTestInClassEventReceiver"]

                subgraph Test["Per Test Execution"]
                    direction TB
                    T0["Create test class instance (constructor)"]
                    T0a["Set injected property values on instance"]
                    T0b["IAsyncInitializer.InitializeAsync()"]
                    T1["[BeforeEvery(Test)]"]
                    T1a["ITestStartEventReceiver (Early)"]
                    T2["[Before(Test)]"]
                    T2a["ITestStartEventReceiver (Late)"]
                    T3["Test Body"]
                    T3a["ITestEndEventReceiver (Early)"]
                    T4["[After(Test)]"]
                    T4a["ITestEndEventReceiver (Late)"]
                    T5["[AfterEvery(Test)]"]
                    T6["IDisposable / IAsyncDisposable"]
                    T7["Cleanup tracked objects"]

                    T0 --> T0a --> T0b --> T1
                    T1 --> T1a --> T2 --> T2a --> T3
                    T3 --> T3a --> T4 --> T4a --> T5 --> T6 --> T7
                end

                C2a["ILastTestInClassEventReceiver"]
                C2["[After(Class)] / [AfterEvery(Class)]"]
                C1 --> C1a --> Test --> C2a --> C2
            end

            A2a["ILastTestInAssemblyEventReceiver"]
            A2["[After(Assembly)] / [AfterEvery(Assembly)]"]
            A1 --> A1a --> Class --> A2a --> A2
        end

        S2a["ILastTestInTestSessionEventReceiver"]
        S2["[After(TestSession)]"]
        S1 --> S1a --> Assembly --> S2a --> S2
    end

    Discovery --> Session

    style D2 fill:#e1f5fe
    style D3a fill:#fff3e0
    style T0b fill:#fff3e0
    style T3 fill:#c8e6c9
    style T6 fill:#ffcdd2
```

## Phase 1: Test Discovery

Before any tests execute, TUnit discovers all tests and prepares data sources.

```mermaid
sequenceDiagram
    participant Engine as TUnit Engine
    participant Hooks as Hook Attributes
    participant Data as Data Sources
    participant Events as Event Receivers

    Engine->>Hooks: [Before(TestDiscovery)]
    Engine->>Engine: Scan assemblies for [Test] methods

    loop For each data source
        Engine->>Data: Create data source instance
        Engine->>Data: Inject properties (resolve values)
        Engine->>Data: IAsyncDiscoveryInitializer.InitializeAsync()
    end

    Engine->>Hooks: [After(TestDiscovery)]

    loop For each discovered test
        Engine->>Events: ITestRegisteredEventReceiver.OnTestRegistered()
    end
```

### Discovery Phase Details

| Step | What Happens |
|------|-------------|
| `[Before(TestDiscovery)]` | Hook runs once before discovery begins |
| **Scan Assemblies** | Find all methods with `[Test]` attribute |
| **Create Data Sources** | Instantiate `ClassDataSource<T>`, resolve `MethodDataSource`, etc. |
| **Property Injection** | Resolve and cache property values for data sources |
| `IAsyncDiscoveryInitializer` | Initialize objects that need to be ready during discovery |
| `[After(TestDiscovery)]` | Hook runs once after discovery completes |
| `OnTestRegistered` | Event fires for each test after registration |

:::warning Discovery vs Execution
`IAsyncInitializer` does **NOT** run during discovery. Only `IAsyncDiscoveryInitializer` runs at discovery time.

Use `IAsyncDiscoveryInitializer` when your data source needs async initialization to generate test cases (e.g., loading test data from a database).
:::

## Phase 2: Test Execution

### Per-Test Execution Flow

```mermaid
sequenceDiagram
    participant Engine as TUnit Engine
    participant Instance as Test Instance
    participant Init as Initializers
    participant Hooks as Hook Attributes
    participant Events as Event Receivers
    participant Dispose as Disposal

    Note over Engine: After BeforeClass hooks...

    Engine->>Instance: Create test class instance (constructor)
    Engine->>Instance: Set cached property values on instance
    Engine->>Init: IAsyncInitializer.InitializeAsync() for all tracked objects

    Engine->>Hooks: [BeforeEvery(Test)]
    Engine->>Events: ITestStartEventReceiver (Early)
    Engine->>Hooks: [Before(Test)]
    Engine->>Events: ITestStartEventReceiver (Late)

    Engine->>Instance: Execute Test Body

    Engine->>Events: ITestEndEventReceiver (Early)
    Engine->>Hooks: [After(Test)]
    Engine->>Events: ITestEndEventReceiver (Late)
    Engine->>Hooks: [AfterEvery(Test)]

    Engine->>Dispose: IAsyncDisposable.DisposeAsync() / IDisposable.Dispose()
    Engine->>Engine: Cleanup tracked objects (decrement ref counts, dispose if 0)
```

### Complete Test Execution Order

Here's the exact order of operations for a single test:

| Order | What Happens | Type |
|-------|-------------|------|
| 1 | `[Before(TestSession)]` | Hook (once per session) |
| 2 | `IFirstTestInTestSessionEventReceiver` | Event (once per session) |
| 3 | `[BeforeEvery(Assembly)]` / `[Before(Assembly)]` | Hooks (once per assembly) |
| 4 | `IFirstTestInAssemblyEventReceiver` | Event (once per assembly) |
| 5 | `[BeforeEvery(Class)]` / `[Before(Class)]` | Hooks (once per class) |
| 6 | `IFirstTestInClassEventReceiver` | Event (once per class) |
| 7 | **Create test class instance** | Constructor runs |
| 8 | **Set property values on instance** | Cached values applied |
| 9 | **`IAsyncInitializer.InitializeAsync()`** | All tracked objects initialized |
| 10 | `[BeforeEvery(Test)]` | Hook |
| 11 | `ITestStartEventReceiver` (Early) | Event |
| 12 | `[Before(Test)]` | Hook (instance method) |
| 13 | `ITestStartEventReceiver` (Late) | Event |
| 14 | **Test Body Execution** | Your test code runs |
| 15 | `ITestEndEventReceiver` (Early) | Event |
| 16 | `[After(Test)]` | Hook (instance method) |
| 17 | `ITestEndEventReceiver` (Late) | Event |
| 18 | `[AfterEvery(Test)]` | Hook |
| 19 | **`IAsyncDisposable` / `IDisposable`** | Test instance disposed |
| 20 | **Cleanup tracked objects** | Ref count decremented, dispose if 0 |
| 21 | `ILastTestInClassEventReceiver` | Event (after last test in class) |
| 22 | `[After(Class)]` / `[AfterEvery(Class)]` | Hooks (after last test in class) |
| 23 | `ILastTestInAssemblyEventReceiver` | Event (after last test in assembly) |
| 24 | `[After(Assembly)]` / `[AfterEvery(Assembly)]` | Hooks (after last test in assembly) |
| 25 | `ILastTestInTestSessionEventReceiver` | Event (after last test in session) |
| 26 | `[After(TestSession)]` | Hook (once per session) |

## Initialization Interfaces

### IAsyncInitializer vs IAsyncDiscoveryInitializer

```mermaid
flowchart LR
    subgraph Discovery["Discovery Phase"]
        D1["IAsyncDiscoveryInitializer.InitializeAsync()"]
    end

    subgraph Execution["Execution Phase (after BeforeClass)"]
        E1["IAsyncInitializer.InitializeAsync()"]
    end

    D1 -.->|"Test cases generated"| Execution
```

| Interface | When It Runs | Use Case |
|-----------|-------------|----------|
| `IAsyncDiscoveryInitializer` | During test discovery | Loading data for test case generation |
| `IAsyncInitializer` | During test execution (after `[Before(Class)]`) | Starting containers, DB connections |

### Initialization Order

Objects are initialized **depth-first** (deepest nested objects first):

```mermaid
flowchart TB
    subgraph Init["Initialization Order"]
        direction TB
        I1["1. Deepest nested properties first"]
        I2["2. Then their parent objects"]
        I3["3. Finally the test class itself"]
    end
```

```csharp
// If TestClass has PropertyA, and PropertyA has PropertyB...
// Initialization order: PropertyB → PropertyA → TestClass
```

## Disposal Interfaces

### When Disposal Happens

```mermaid
flowchart LR
    subgraph AfterTest["After Each Test"]
        A1["[After(Test)]"]
        A2["[AfterEvery(Test)]"]
        A3["Test Instance: IAsyncDisposable / IDisposable"]
    end

    subgraph AfterScope["After Scope Ends"]
        B1["Tracked objects with ref count = 0"]
        B2["SharedType.PerClass objects after last test in class"]
        B3["SharedType.PerAssembly objects after last test in assembly"]
        B4["SharedType.PerTestSession objects after session"]
    end

    A1 --> A2 --> A3 --> B1
```

### Disposal by Sharing Type

| SharedType | When Disposed |
|------------|--------------|
| `None` (default) | After each test |
| `PerClass` | After last test in the class |
| `PerAssembly` | After last test in the assembly |
| `PerTestSession` | After test session ends |
| `Keyed` | When all tests using that key complete |

## Property Injection Lifecycle

```mermaid
sequenceDiagram
    participant Discovery as Discovery Phase
    participant Registration as Test Registration
    participant Execution as Test Execution

    Discovery->>Registration: Resolve property values
    Registration->>Registration: Cache property values in test metadata
    Registration->>Registration: Track objects for lifecycle management

    Note over Execution: For each test execution...

    Execution->>Execution: Create new test class instance
    Execution->>Execution: Set cached property values on instance
    Execution->>Execution: IAsyncInitializer.InitializeAsync()
    Execution->>Execution: Run test
    Execution->>Execution: Decrement ref counts, dispose if needed
```

### Key Points

1. **Property values are resolved once** during test registration
2. **Shared objects** (`PerClass`, `PerAssembly`, etc.) are created once and reused
3. **Each test gets a new instance** of the test class
4. **Cached values are set** on each new test instance
5. **`IAsyncInitializer`** runs after `[Before(Class)]` hooks

## Event Receiver Interfaces

### All Event Receiver Interfaces

| Interface | When Fired | Context |
|-----------|------------|---------|
| `ITestRegisteredEventReceiver` | After test discovered | `TestRegisteredContext` |
| `IFirstTestInTestSessionEventReceiver` | Before first test in session | `TestSessionContext` |
| `IFirstTestInAssemblyEventReceiver` | Before first test in assembly | `AssemblyHookContext` |
| `IFirstTestInClassEventReceiver` | Before first test in class | `ClassHookContext` |
| `ITestStartEventReceiver` | When test begins | `TestContext` |
| `ITestEndEventReceiver` | When test completes | `TestContext` |
| `ITestSkippedEventReceiver` | When test is skipped | `TestContext` |
| `ILastTestInClassEventReceiver` | After last test in class | `ClassHookContext` |
| `ILastTestInAssemblyEventReceiver` | After last test in assembly | `AssemblyHookContext` |
| `ILastTestInTestSessionEventReceiver` | After last test in session | `TestSessionContext` |

### Early vs Late Stage

For `ITestStartEventReceiver` and `ITestEndEventReceiver`:

```mermaid
flowchart LR
    subgraph TestStart["Test Start"]
        A1["[BeforeEvery(Test)]"]
        A2["ITestStartEventReceiver (Early)"]
        A3["[Before(Test)]"]
        A4["ITestStartEventReceiver (Late)"]
    end

    subgraph TestEnd["Test End"]
        B1["ITestEndEventReceiver (Early)"]
        B2["[After(Test)]"]
        B3["ITestEndEventReceiver (Late)"]
        B4["[AfterEvery(Test)]"]
    end

    TestStart --> TestEnd
```

```csharp
public class MyAttribute : Attribute, ITestStartEventReceiver
{
    // Early = runs BEFORE [Before(Test)]
    // Late (default) = runs AFTER [Before(Test)]
    public EventReceiverStage Stage => EventReceiverStage.Early;

    public ValueTask OnTestStart(TestContext context) => ValueTask.CompletedTask;
}
```

## Hook Attributes Reference

### All Hook Types

| Level | Before | After | Method Type |
|-------|--------|-------|-------------|
| Test Discovery | `[Before(TestDiscovery)]` | `[After(TestDiscovery)]` | Static |
| Test Session | `[Before(TestSession)]` | `[After(TestSession)]` | Static |
| Assembly | `[Before(Assembly)]` | `[After(Assembly)]` | Static |
| Class | `[Before(Class)]` | `[After(Class)]` | Static |
| Test | `[Before(Test)]` | `[After(Test)]` | **Instance** |

### Before vs BeforeEvery

| Attribute | Scope |
|-----------|-------|
| `[Before(Class)]` | Once for **this class only** |
| `[BeforeEvery(Class)]` | Before **every class** in session |
| `[Before(Test)]` | Before **each test in this class** |
| `[BeforeEvery(Test)]` | Before **every test** in session |

## Quick Reference

```
┌─ DISCOVERY ──────────────────────────────────────────────────────┐
│ [Before(TestDiscovery)]                                          │
│ → Scan assemblies for [Test] methods                             │
│ → Create data sources, inject properties                         │
│ → IAsyncDiscoveryInitializer.InitializeAsync()                   │
│ [After(TestDiscovery)]                                           │
│ → ITestRegisteredEventReceiver.OnTestRegistered (per test)       │
└──────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─ TEST SESSION ───────────────────────────────────────────────────┐
│ [Before(TestSession)] → IFirstTestInTestSessionEventReceiver     │
│   │                                                               │
│   ├─ [Before(Assembly)] → IFirstTestInAssemblyEventReceiver      │
│   │   │                                                           │
│   │   ├─ [Before(Class)] → IFirstTestInClassEventReceiver        │
│   │   │   │                                                       │
│   │   │   │  ┌─ PER TEST ─────────────────────────────────────┐  │
│   │   │   │  │ Create instance (constructor)                   │  │
│   │   │   │  │ Set property values                             │  │
│   │   │   │  │ IAsyncInitializer.InitializeAsync()             │  │
│   │   │   │  │ [BeforeEvery(Test)]                             │  │
│   │   │   │  │ ITestStartEventReceiver (Early)                 │  │
│   │   │   │  │ [Before(Test)]                                  │  │
│   │   │   │  │ ITestStartEventReceiver (Late)                  │  │
│   │   │   │  │ ─────────── TEST BODY ───────────               │  │
│   │   │   │  │ ITestEndEventReceiver (Early)                   │  │
│   │   │   │  │ [After(Test)]                                   │  │
│   │   │   │  │ ITestEndEventReceiver (Late)                    │  │
│   │   │   │  │ [AfterEvery(Test)]                              │  │
│   │   │   │  │ IAsyncDisposable / IDisposable                  │  │
│   │   │   │  │ Cleanup tracked objects                         │  │
│   │   │   │  └─────────────────────────────────────────────────┘  │
│   │   │   │                                                       │
│   │   │   ├─ ILastTestInClassEventReceiver → [After(Class)]      │
│   │   │                                                           │
│   │   ├─ ILastTestInAssemblyEventReceiver → [After(Assembly)]    │
│   │                                                               │
│   ├─ ILastTestInTestSessionEventReceiver → [After(TestSession)]  │
└───────────────────────────────────────────────────────────────────┘
```

## Exception Handling

:::tip Cleanup Always Runs
All `[After]` hooks, `ITestEndEventReceiver` events, and disposal methods run even if earlier ones fail. Exceptions are collected and thrown together.
:::

| Phase | Behavior |
|-------|----------|
| Before hooks | Fail fast (exception stops execution) |
| After hooks | Run all, collect exceptions |
| Disposal | Always runs, exceptions collected |

## Related Pages

- [Test Set Ups](setup.md) - Detailed guide to `[Before]` hooks
- [Test Clean Ups](cleanup.md) - Detailed guide to `[After]` hooks
- [Event Subscribing](event-subscribing.md) - Event receiver interfaces
- [Property Injection](property-injection.md) - Property injection and `IAsyncInitializer`
- [Dependency Injection](dependency-injection.md) - DI integration
- [Test Context](test-context.md) - Accessing test information

---

## Properties


Custom properties can be added to a test using the `[PropertyAttribute]`.

Custom properties can be used for test filtering: `dotnet run --treenode-filter /*/*/*/*[PropertyName=PropertyValue]`

Custom properties can also be viewed in the `TestContext` - Which can be used in logic during setups or cleanups.

This can be used on base classes and inherited to affect all tests in sub-classes.

```csharp
using TUnit.Core;

namespace MyTestProject;

public class MyTestClass
{
    [Test]
    [Property("PropertyName", "PropertyValue")]
    public async Task MyTest(CancellationToken cancellationToken)
    {
        
    }
}
```

---

## Property Injection


TUnit's AOT-compatible property injection system makes it easy to initialize properties on your test class with compile-time safety and excellent performance.

Your properties must be marked with the `required` keyword and then simply place a data attribute on it.
The required keyword keeps your code clean and correct. If a property isn't passed in, you'll get a compiler warning, so you know something has gone wrong. It also gets rid of any pesky nullability warnings.

## AOT-Compatible Property Attributes

Supported attributes for properties in AOT mode:
- **MethodDataSource** - Data sources via calling a method
- **`ClassDataSource<T>`** - A data source that injects in T
- **DataSourceGeneratorAttribute** - Source-generated data (first item only)

For dependency injection with service providers, inherit from `DependencyInjectionDataSourceAttribute<TScope>` to create custom attributes. See [Dependency Injection](./dependency-injection.md) documentation for details.

The AOT system generates strongly-typed property setters at compile time, eliminating reflection overhead and ensuring Native AOT compatibility.

## Async Property Initialization

Properties can implement `IAsyncInitializer` for complex setup scenarios with automatic lifecycle management:

:::warning Discovery Phase vs Execution Phase
`IAsyncInitializer` runs during **test execution**, not during **test discovery**.

Test discovery happens when:
- Your IDE loads/reloads the project
- You run `dotnet run --list-tests`
- CI/CD systems enumerate tests before running them

During discovery, `IAsyncInitializer` has **not yet run**, so properties will be uninitialized. If you use `InstanceMethodDataSource` or similar features that access instance properties during discovery, you may get empty data or no tests generated.

**When you need discovery-time initialization**, use `IAsyncDiscoveryInitializer` instead (see [Discovery Phase Initialization](#discovery-phase-initialization) below).
:::

```csharp
using TUnit.Core;

namespace MyTestProject;

public class AsyncPropertyExample : IAsyncInitializer, IAsyncDisposable
{
    public bool IsInitialized { get; private set; }
    public string? ConnectionString { get; private set; }

    public async Task InitializeAsync()
    {
        await Task.Delay(10); // Simulate async setup
        ConnectionString = "Server=localhost;Database=test";
        IsInitialized = true;
    }

    public async ValueTask DisposeAsync()
    {
        await Task.Delay(1); // Cleanup
        IsInitialized = false;
        ConnectionString = null;
    }
}
```

## Discovery Phase Initialization

### When Discovery Initialization is Needed

Most tests don't need discovery-time initialization. Discovery-time initialization is only required when:

1. You use `InstanceMethodDataSource` and the data source method returns **dynamically loaded data** (not predefined values)
2. The test case enumeration depends on async-loaded data (e.g., querying a database for test cases)

**Performance Note:** Discovery happens frequently (IDE reloads, project switches, `--list-tests`), so discovery-time initialization runs more often than test execution. Avoid expensive operations in `IAsyncDiscoveryInitializer` when possible.

### Using IAsyncDiscoveryInitializer

When you need data available during discovery, implement `IAsyncDiscoveryInitializer` instead of `IAsyncInitializer`:

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

<Tabs>
  <TabItem value="wrong" label="❌ Wrong - Data not available during discovery" default>

```csharp
// This fixture's data won't be available during discovery
public class TestDataFixture : IAsyncInitializer, IAsyncDisposable
{
    private List<string> _testCases = [];

    public async Task InitializeAsync()
    {
        // This runs during EXECUTION, not DISCOVERY
        _testCases = await LoadTestCasesFromDatabaseAsync();
    }

    // This will return empty list during discovery!
    public IEnumerable<string> GetTestCases() => _testCases;

    public async ValueTask DisposeAsync()
    {
        _testCases.Clear();
    }
}

public class MyTests
{
    [ClassDataSource<TestDataFixture>(Shared = SharedType.PerClass)]
    public required TestDataFixture Fixture { get; init; }

    // During discovery, Fixture.GetTestCases() returns empty list
    // Result: No tests are generated!
    public IEnumerable<string> TestCases => Fixture.GetTestCases();

    [Test]
    [InstanceMethodDataSource(nameof(TestCases))]
    public async Task MyTest(string testCase)
    {
        // This test is never created because TestCases was empty during discovery
        await Assert.That(testCase).IsNotNullOrEmpty();
    }
}
```

  </TabItem>
  <TabItem value="correct" label="✅ Correct - Uses IAsyncDiscoveryInitializer">

```csharp
// This fixture's data IS available during discovery
public class TestDataFixture : IAsyncDiscoveryInitializer, IAsyncDisposable
{
    private List<string> _testCases = [];

    public async Task InitializeAsync()
    {
        // This runs during DISCOVERY, before test enumeration
        _testCases = await LoadTestCasesFromDatabaseAsync();
    }

    // This returns populated list during discovery!
    public IEnumerable<string> GetTestCases() => _testCases;

    public async ValueTask DisposeAsync()
    {
        _testCases.Clear();
    }
}

public class MyTests
{
    [ClassDataSource<TestDataFixture>(Shared = SharedType.PerClass)]
    public required TestDataFixture Fixture { get; init; }

    // During discovery, Fixture is already initialized
    // Result: Tests are generated successfully!
    public IEnumerable<string> TestCases => Fixture.GetTestCases();

    [Test]
    [InstanceMethodDataSource(nameof(TestCases))]
    public async Task MyTest(string testCase)
    {
        // This test IS created with each test case from the fixture
        await Assert.That(testCase).IsNotNullOrEmpty();
    }
}
```

  </TabItem>
  <TabItem value="best" label="✅ Best - Predefined data without discovery initialization">

```csharp
// Best approach: Predefined test case IDs, expensive initialization during execution only
public class TestDataFixture : IAsyncInitializer, IAsyncDisposable
{
    // Test case IDs are predefined - no initialization needed for discovery
    private static readonly string[] PredefinedTestCases = ["Case1", "Case2", "Case3"];

    private DockerContainer? _container;

    public async Task InitializeAsync()
    {
        // Expensive initialization runs during EXECUTION only
        _container = await StartDockerContainerAsync();
    }

    // Returns predefined IDs - works during discovery without initialization
    public IEnumerable<string> GetTestCaseIds() => PredefinedTestCases;

    public async ValueTask DisposeAsync()
    {
        if (_container != null)
            await _container.DisposeAsync();
    }
}

public class MyTests
{
    [ClassDataSource<TestDataFixture>(Shared = SharedType.PerClass)]
    public required TestDataFixture Fixture { get; init; }

    // Returns predefined IDs - no initialization required during discovery
    public IEnumerable<string> TestCases => Fixture.GetTestCaseIds();

    [Test]
    [InstanceMethodDataSource(nameof(TestCases))]
    public async Task MyTest(string testCaseId)
    {
        // Fixture IS initialized by the time the test runs
        // Can now use the expensive resources (Docker container, etc.)
        await Assert.That(testCaseId).IsNotNullOrEmpty();
    }
}
```

  </TabItem>
</Tabs>

**Recommendation:** Prefer the "predefined data" approach when possible. This avoids expensive initialization during discovery, which happens frequently (IDE reloads, `--list-tests`, etc.).

For more troubleshooting, see [Test Discovery Issues](../troubleshooting.md#test-discovery-issues).

## Basic Property Injection Examples

```csharp
using TUnit.Core;

namespace MyTestProject;

public class PropertySetterTests
{
    // Static method data source injection
    [MethodDataSource(nameof(GetMethodData))]
    public required string Property2 { get; init; }

    // Class-based data source injection
    [ClassDataSource<InnerModel>]
    public required InnerModel Property3 { get; init; }

    // Globally shared data source
    [ClassDataSource<InnerModel>(Shared = SharedType.PerTestSession)]
    public required InnerModel Property4 { get; init; }

    // Class-scoped shared data source
    [ClassDataSource<InnerModel>(Shared = SharedType.PerClass)]
    public required InnerModel Property5 { get; init; }

    // Keyed shared data source
    [ClassDataSource<InnerModel>(Shared = SharedType.Keyed, Key = "Key")]
    public required InnerModel Property6 { get; init; }

    // Source-generated data injection
    [DataSourceGeneratorTests.AutoFixtureGenerator<string>]
    public required string Property7 { get; init; }

    // Async initialization example (IAsyncInitializer)
    [ClassDataSource<AsyncPropertyExample>]
    public required AsyncPropertyExample AsyncService { get; init; }

    [Test]
    public async Task Test()
    {
        // All properties are automatically initialized before this test runs
        await Assert.That(Property2).IsNotNull();
        await Assert.That(Property3).IsNotNull();
        await Assert.That(AsyncService.IsInitialized).IsTrue();

        Console.WriteLine($"Property7: {Property7}");
    }

    // Static data source method for Property2 - returns a single value for property injection
    public static string GetMethodData() => "method_data_value";
}

// Example model for ClassDataSource
public class InnerModel
{
    public string Name { get; set; } = "";
    public int Value { get; set; }
}
```

## Nested Property Injection

One of TUnit's most powerful features is nested property injection with automatic initialization. This allows you to inject objects into other objects created via data sources, enabling advanced test orchestration with relatively simple code. TUnit handles all the complex aspects like initialization order and object lifetimes.

### How It Works

When you use property injection with data source attributes, those injected objects can themselves have injected properties. TUnit will:
1. Resolve the entire dependency graph
2. Create objects in the correct order
3. Initialize them (if they implement `IAsyncInitializer`)
4. Inject them into parent objects
5. Dispose of them when appropriate (if they implement `IAsyncDisposable`)

### Example: Complex Test Infrastructure

Here's a comprehensive example showing how to orchestrate multiple test containers and a web application:

```csharp
// In-memory SQL container that auto-starts and stops
public class InMemorySql : IAsyncInitializer, IAsyncDisposable
{
    private TestcontainersContainer? _container;

    public TestcontainersContainer Container => _container
        ?? throw new InvalidOperationException("Container not initialized");

    public async Task InitializeAsync()
    {
        _container = new TestcontainersBuilder<TestcontainersContainer>()
            .WithImage("postgres:latest")
            .WithEnvironment("POSTGRES_PASSWORD", "password")
            .Build();

        await _container.StartAsync();
    }

    public async ValueTask DisposeAsync()
    {
        if (_container != null)
        {
            await _container.DisposeAsync();
        }
    }
}

// Redis container with similar pattern
public class InMemoryRedis : IAsyncInitializer, IAsyncDisposable
{
    private TestcontainersContainer? _container;

    public TestcontainersContainer Container => _container
        ?? throw new InvalidOperationException("Container not initialized");

    public async Task InitializeAsync()
    {
        _container = new TestcontainersBuilder<TestcontainersContainer>()
            .WithImage("redis:latest")
            .Build();

        await _container.StartAsync();
    }

    public async ValueTask DisposeAsync()
    {
        if (_container != null)
        {
            await _container.DisposeAsync();
        }
    }
}

// Message bus container
public class InMemoryMessageBus : IAsyncInitializer, IAsyncDisposable
{
    private TestcontainersContainer? _container;

    public TestcontainersContainer Container => _container
        ?? throw new InvalidOperationException("Container not initialized");

    public async Task InitializeAsync()
    {
        _container = new TestcontainersBuilder<TestcontainersContainer>()
            .WithImage("rabbitmq:3-management")
            .Build();

        await _container.StartAsync();
    }

    public async ValueTask DisposeAsync()
    {
        if (_container != null)
        {
            await _container.DisposeAsync();
        }
    }
}

// UI component that depends on the message bus
public class MessageBusUserInterface : IAsyncInitializer, IAsyncDisposable
{
    private TestcontainersContainer? _container;

    // Inject the message bus dependency - shared per test session
    [ClassDataSource<InMemoryMessageBus>(Shared = SharedType.PerTestSession)]
    public required InMemoryMessageBus MessageBus { get; init; }

    public TestcontainersContainer Container => _container
        ?? throw new InvalidOperationException("Container not initialized");

    public async Task InitializeAsync()
    {
        // The MessageBus property is already initialized when this runs!
        _container = new MessageBusUIContainerBuilder()
            .WithConnectionString(MessageBus.Container.GetConnectionString())
            .Build();

        await _container.StartAsync();
    }

    public async ValueTask DisposeAsync()
    {
        if (_container != null)
        {
            await _container.DisposeAsync();
        }
    }
}

// Web application factory that depends on multiple services
public class InMemoryWebApplicationFactory : WebApplicationFactory<Program>, IAsyncInitializer
{
    // Inject all required infrastructure - all shared per test session
    [ClassDataSource<InMemorySql>(Shared = SharedType.PerTestSession)]
    public required InMemorySql Sql { get; init; }

    [ClassDataSource<InMemoryRedis>(Shared = SharedType.PerTestSession)]
    public required InMemoryRedis Redis { get; init; }

    [ClassDataSource<InMemoryMessageBus>(Shared = SharedType.PerTestSession)]
    public required InMemoryMessageBus MessageBus { get; init; }

    public Task InitializeAsync()
    {
        // Force server creation to validate configuration
        _ = Server;
        return Task.CompletedTask;
    }

    protected override void ConfigureWebHost(IWebHostBuilder builder)
    {
        builder.ConfigureAppConfiguration((context, configBuilder) =>
        {
            // All injected properties are already initialized!
            configBuilder.AddInMemoryCollection(new Dictionary<string, string?>
            {
                { "MessageBus:ConnectionString", MessageBus.Container.GetConnectionString() },
                { "Redis:ConnectionString", Redis.Container.GetConnectionString() },
                { "PostgreSql:ConnectionString", Sql.Container.GetConnectionString() }
            });
        });
    }
}

// Your test class - clean and simple!
public class IntegrationTests
{
    // Just inject what you need - TUnit handles the entire dependency graph
    [ClassDataSource<InMemoryWebApplicationFactory>]
    public required InMemoryWebApplicationFactory WebApplicationFactory { get; init; }

    [ClassDataSource<MessageBusUserInterface>]
    public required MessageBusUserInterface MessageBusUI { get; init; }

    [Test]
    public async Task Full_Integration_Test()
    {
        // Everything is initialized in the correct order!
        var client = WebApplicationFactory.CreateClient();

        // Test your application with all infrastructure running
        var response = await client.GetAsync("/api/products");
        await Assert.That(response.IsSuccessStatusCode).IsTrue();

        // The MessageBusUI shares the same MessageBus instance as the WebApplicationFactory
        // because they both use SharedType.PerTestSession
    }
}
```

### Benefits of Nested Property Injection

1. **Simplified Test Setup**: You only need to declare what you need; TUnit handles the complex orchestration
2. **Automatic Lifecycle Management**: Objects are initialized in dependency order and disposed in reverse order
3. **Shared Resources**: Use `SharedType` to control object lifetime and reuse expensive resources
4. **Type Safety**: Everything is strongly typed with compile-time checking
5. **Clean Test Code**: Your tests focus on testing, not on infrastructure setup

### Sharing Strategies

When using nested property injection, the `Shared` parameter becomes crucial:

- **`SharedType.PerTestSession`**: Single instance for the entire test run - ideal for expensive resources like containers
- **`SharedType.PerAssembly`**: Single instance shared for every test in the same assembly as itself.
- **`SharedType.PerClass`**: One instance per test class
- **`SharedType.Keyed`**: Share instances based on a key value
- **`SharedType.None`**: New instance for each injection point (default)

### Best Practices

1. **Use Appropriate Sharing**: Share expensive resources like test containers using `PerTestSession`
2. **Implement IAsyncInitializer**: For complex setup that requires async operations
3. **Implement IAsyncDisposable**: Ensure proper cleanup of resources
4. **Order Independence**: Don't rely on initialization order between sibling properties
5. **Error Handling**: Initialization failures will fail the test with clear error messages

### Advanced Scenarios

#### Conditional Initialization

```csharp
public class ConditionalService : IAsyncInitializer
{
    [ClassDataSource<DatabaseService>(Shared = SharedType.PerTestSession)]
    public required DatabaseService Database { get; init; }

    public async Task InitializeAsync()
    {
        if (await Database.RequiresMigration())
        {
            await Database.MigrateAsync();
        }
    }
}
```

#### Circular Dependencies

TUnit will detect and report circular dependencies:

```csharp
public class ServiceA : IAsyncInitializer
{
    [ClassDataSource<ServiceB>]
    public required ServiceB B { get; init; } // This will fail!
}

public class ServiceB : IAsyncInitializer
{
    [ClassDataSource<ServiceA>]
    public required ServiceA A { get; init; } // Circular dependency!
}
```

This powerful feature makes complex test orchestration simple and maintainable, allowing you to focus on writing tests rather than managing test infrastructure!

---

## Test Set Ups


Most setup for a test can be performed in the constructor (think setting up mocks, assigning fields.)

However some scenarios require further setup that could be an asynchronous operation.
E.g. pinging a service to wake it up in preparation for the tests.

For this, we can declare a method with a `[Before(...)]` or a `[BeforeEvery(...)]` attribute.

## Hook Method Signatures

Hook methods can be either synchronous or asynchronous:

```csharp
[Before(Test)]
public void SynchronousSetup()  // ✅ Valid - synchronous hook
{
    _value = 99;
}

[Before(Test)]
public async Task AsyncSetup()  // ✅ Valid - asynchronous hook
{
    _response = await new HttpClient().GetAsync("https://localhost/ping");
}
```

**Important Notes:**
- Hooks can be `void` (synchronous) or `async Task` (asynchronous)
- Use async hooks when you need to perform async operations (HTTP calls, database queries, etc.)
- Use synchronous hooks for simple setup (setting fields, initializing values, etc.)
- `async void` hooks are **not allowed** and will cause a compiler error

### Hook Parameters

Hooks can optionally accept parameters for accessing context information and cancellation tokens:

```csharp
[Before(Test)]
public async Task Setup(TestContext context, CancellationToken cancellationToken)
{
    // Access test information via context
    Console.WriteLine($"Setting up test: {context.Metadata.TestName}");

    // Use cancellation token for timeout-aware operations
    await SomeLongRunningOperation(cancellationToken);
}

[Before(Class)]
public static async Task ClassSetup(ClassHookContext context, CancellationToken cancellationToken)
{
    // Both context and cancellation token available for class-level hooks
    await InitializeResources(cancellationToken);
}

[Before(Test)]
public async Task SetupWithToken(CancellationToken cancellationToken)
{
    // Can use CancellationToken without context
    await Task.Delay(100, cancellationToken);
}

[Before(Test)]
public async Task SetupWithContext(TestContext context)
{
    // Can use context without CancellationToken
    Console.WriteLine(context.Metadata.TestName);
}
```

**Valid Parameter Combinations:**
- No parameters: `public void Hook() { }`
- Context only: `public void Hook(TestContext context) { }`
- CancellationToken only: `public async Task Hook(CancellationToken ct) { }`
- Both: `public async Task Hook(TestContext context, CancellationToken ct) { }`

**Context Types by Hook Level:**

| Hook Level | Context Type | Example |
|------------|-------------|---------|
| `[Before(Test)]` | `TestContext` | Access test details, output writer |
| `[Before(Class)]` | `ClassHookContext` | Access class information |
| `[Before(Assembly)]` | `AssemblyHookContext` | Access assembly information |
| `[Before(TestSession)]` | `TestSessionContext` | Access test session information |
| `[Before(TestDiscovery)]` | `BeforeTestDiscoveryContext` | Access discovery context |

## [Before(HookType)]

### [Before(Test)]
Must be an instance method. Will be executed before each test in the class it's defined in.
Methods will be executed bottom-up, so the base class set ups will execute first and then the inheriting classes.

### [Before(Class)]
Must be a static method. Will run once before the first test in the class it's defined in starts.

### [Before(Assembly)]
Must be a static method. Will run once before the first test in the assembly it's defined in starts.

### [Before(TestSession)]
Must be a static method. Will run once before the first test in the test session starts.

### [Before(TestDiscovery)]
Must be a static method. Will run once before any tests are discovered.

## [BeforeEvery(HookType)]
All [BeforeEvery(...)] methods must be static - And should ideally be placed in their own file that's easy to find, as they can globally affect the test suite, so it should be easy for developers to locate this behaviour.
e.g. `GlobalHooks.cs` at the root of the test project.

### [BeforeEvery(Test)]
Will be executed before every test that will run in the test session.

### [BeforeEvery(Class)]
Will be executed before the first test of every class that will run in the test session.

### [BeforeEvery(Assembly)]
Will be executed before the first test of every assembly that will run in the test session.

### [BeforeEvery(TestSession)]
The same as [Before(TestSession)]

### [BeforeEvery(TestDiscovery)]
The same as [Before(TestDiscovery)]

```csharp
using TUnit.Core;

namespace MyTestProject;

public class MyTestClass
{
    private int _value;
    private static HttpResponseMessage? _pingResponse;

    [Before(Class)]
    public static async Task Ping()
    {
        _pingResponse = await new HttpClient().GetAsync("https://localhost/ping");
    }
    
    [Before(Test)]
    public async Task Setup()
    {
        await Task.CompletedTask;
        
        _value = 99;
    }

    [Test]
    public async Task MyTest()
    {
        await Assert.That(_value).IsEqualTo(99);
        await Assert.That(_pingResponse?.StatusCode)
            .IsNotNull()
            .And.IsEqualTo(HttpStatusCode.OK);
    }
}
```
## Common Mistakes & Best Practices

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

### Confusing Instance vs Static Hooks

<Tabs>
  <TabItem value="bad" label="❌ Bad - Wrong Hook Scope" default>

```csharp
public class DatabaseTests
{
    // ❌ Won't compile - Class-level hooks must be static
    [Before(Class)]
    public async Task SetupDatabase()
    {
        await InitializeDatabaseAsync();
    }

    // ❌ Won't compile - Test hooks cannot be static
    [Before(Test)]
    public static void SetupTest()
    {
        // Cannot access instance fields
    }
}
```

**Problem:** Hook scope (instance/static) must match the hook level.

  </TabItem>
  <TabItem value="good" label="✅ Good - Correct Hook Scopes">

```csharp
public class DatabaseTests
{
    // ✅ Class hooks must be static
    [Before(Class)]
    public static async Task SetupDatabase()
    {
        await InitializeDatabaseAsync();
    }

    // ✅ Test hooks must be instance methods
    [Before(Test)]
    public void SetupTest()
    {
        _testData = CreateTestData();
    }
}
```

**Why:** Class-level hooks run once and cannot access instance state. Test-level hooks run per test and can access instance fields.

  </TabItem>
</Tabs>

### Mixing Sync and Async Incorrectly

<Tabs>
  <TabItem value="bad" label="❌ Bad - Async Void">

```csharp
// ❌ Won't compile - async void is not allowed
[Before(Test)]
public async void SetupAsync()
{
    await Task.Delay(100);
}

// ❌ Blocking on async code
[Before(Test)]
public void Setup()
{
    SomeAsyncMethod().Wait(); // Can cause deadlocks
}
```

**Problem:** Async void can't be awaited and blocking async code can cause deadlocks.

  </TabItem>
  <TabItem value="good" label="✅ Good - Proper Async">

```csharp
// ✅ Use async Task for asynchronous operations
[Before(Test)]
public async Task SetupAsync()
{
    await Task.Delay(100);
}

// ✅ Use synchronous method for synchronous work
[Before(Test)]
public void Setup()
{
    _value = 42;
}
```

**Why:** `async Task` allows proper awaiting and error handling. Synchronous hooks are fine for non-async work.

  </TabItem>
</Tabs>

### Expensive Setup at Wrong Level

<Tabs>
  <TabItem value="bad" label="❌ Bad - Repeated Expensive Setup">

```csharp
public class ApiTests
{
    private HttpClient _client;

    // ❌ Creates new client for EVERY test
    [Before(Test)]
    public void Setup()
    {
        _client = new HttpClient
        {
            BaseAddress = new Uri("https://api.example.com")
        };
    }

    [Test]
    public async Task Test1() { /* ... */ }

    [Test]
    public async Task Test2() { /* ... */ }
    // Client created 2 times unnecessarily
}
```

**Problem:** Creating expensive resources per test wastes time and resources.

  </TabItem>
  <TabItem value="good" label="✅ Good - Shared Setup">

```csharp
public class ApiTests
{
    private static HttpClient _client;

    // ✅ Creates client once for all tests
    [Before(Class)]
    public static void SetupOnce()
    {
        _client = new HttpClient
        {
            BaseAddress = new Uri("https://api.example.com")
        };
    }

    [After(Class)]
    public static void CleanupOnce()
    {
        _client?.Dispose();
    }

    [Test]
    public async Task Test1() { /* ... */ }

    [Test]
    public async Task Test2() { /* ... */ }
    // Client created only once
}
```

**Why:** Class-level setup runs once, sharing expensive resources across tests. Much faster!

  </TabItem>
</Tabs>

## AsyncLocal

If you are wanting to set AsyncLocal values within your `[Before(...)]` hooks, this is supported.

But to propagate the values into the test framework, you must call `context.AddAsyncLocalValues()` - Where `context` is the relevant context object injected into your hook method.

E.g.

```csharp
    [BeforeEvery(Class)]
    public static void BeforeClass(ClassHookContext context)
    {
        _myAsyncLocal.Value = "Some Value";
        context.AddAsyncLocalValues();
    }
```

---

## Test Context


All tests have a `TestContext` object available to them.

This can be accessed statically via `TestContext.Current`.

Here you can see information about the test, including things like the test name, containing class, custom properties, categories, etc.

This can be useful if you want something like a generic `AfterEachTest` for all tests, but with logic to execute for only certain tests.

e.g.
```csharp
if (TestContext.Current?.Metadata.TestDetails.CustomProperties.ContainsKey("SomeProperty") == true)
{
    // Do something
}
```

The context also has a `Results` object. You'll notice this is nullable. This will be null until you're in the context of a `AfterEachTest` method. That's because the `Results` can only be set after a test has finished.

These results can be handy when you're cleaning up, but maybe only want to do something if a test failed.

e.g.
```csharp
if (TestContext.Current?.Result?.State == TestState.Failed)
{
    // Take a screenshot?
}
```

## Test Output and Artifacts

The `TestContext` provides multiple ways to write output and attach artifacts:

```csharp
// Write to standard output (modern interface-based approach)
TestContext.Current!.Output.WriteLine("Debug information");

// Alternative: Direct TextWriter access (also valid)
TestContext.Current!.OutputWriter.WriteLine("Debug information");

// Write to error output
TestContext.Current.Output.WriteError("Warning: something unexpected happened");

// Attach an artifact (file, screenshot, log, etc.)
TestContext.Current.Output.AttachArtifact(new Artifact
{
    File = new FileInfo("path/to/logfile.log"),
    DisplayName = "Application Logs",
    Description = "Logs captured during test execution"
});
```

Both `Output.WriteLine()` and `OutputWriter.WriteLine()` are valid - the `Output` property provides a convenient interface-based API, while `OutputWriter` gives direct access to the underlying TextWriter.

Artifacts are particularly useful for debugging test failures, especially in integration tests. You can attach screenshots, logs, videos, configuration files, or any other files that help diagnose issues.

For complete information about working with test artifacts, including session-level artifacts, best practices, and common use cases, see the [Test Artifacts](./artifacts.md) guide.

## Test Isolation

The `TestContext` provides built-in helpers for creating isolated resource names, ensuring parallel tests don't interfere with each other. Access them via `TestContext.Current!.Isolation`:

```csharp
// Get a unique ID for this test instance
var id = TestContext.Current!.Isolation.UniqueId;  // e.g. 42

// Create isolated resource names
var tableName = TestContext.Current!.Isolation.GetIsolatedName("todos");  // "Test_42_todos"
var topicName = TestContext.Current!.Isolation.GetIsolatedName("orders"); // "Test_42_orders"

// Create isolated key prefixes
var prefix = TestContext.Current!.Isolation.GetIsolatedPrefix();       // "test_42_"
var dotPrefix = TestContext.Current!.Isolation.GetIsolatedPrefix("."); // "test.42."
```

These are useful for any test that needs unique resource names — database tables, message queue topics, cache keys, blob storage paths, etc. — without requiring a specific base class.

:::tip ASP.NET Core Tests
If you're using `TUnit.AspNetCore`, the `WebApplicationTest` base class provides the same helpers as `protected` methods (`GetIsolatedName`, `GetIsolatedPrefix`). Both share the same underlying counter, so IDs are unique across all test types.
:::

## Dependency Injection

**Note**: `TestContext` does NOT provide direct access to dependency injection services. The internal service provider in `TestContext` is exclusively for TUnit framework services and is not meant for user-provided dependencies.

If you need dependency injection in your tests, use the `DependencyInjectionDataSourceAttribute<TScope>` helper class to set up your own DI container. See the [Dependency Injection guide](./dependency-injection.md) for complete details and examples.

## TestBuilderContext

In addition to `TestContext`, TUnit also provides `TestBuilderContext` which is available during the test discovery and building phase. This is particularly useful when you need context information in data generators or other scenarios that run before test execution.

### When to Use TestBuilderContext vs TestContext

**Use `TestBuilderContext.Current` when:**
- Writing data generators that need test information
- During test discovery phase
- In scenarios that run before `TestContext` is available
- When you need to pass data from discovery time to execution time

**Use `TestContext.Current` when:**
- During test execution
- In test methods, Before/After hooks
- When you need test results or execution-specific information
- When accessing test output writers

### Accessing TestBuilderContext

```csharp
public static IEnumerable<object[]> MyDataGenerator()
{
    var context = TestBuilderContext.Current;
    if (context != null)
    {
        // Access test information during data generation
        Console.WriteLine($"Generating data for: {context.TestMethodName}");
        Console.WriteLine($"Test class: {context.ClassInformation?.Type.Name}");
        Console.WriteLine($"Assembly: {context.ClassInformation?.Assembly.Name}");
        
        // Store data for later use during test execution
        context.StateBag["GenerationTime"] = DateTime.Now;
    }
    
    yield return new object[] { 1, 2, 3 };
}
```

### Sharing Data Between Discovery and Execution

The `StateBag` property on `TestBuilderContext` is carried forward to `TestContext`, allowing you to pass data from discovery time to execution time:

```csharp
// In your data generator
public static IEnumerable<object[]> TestData()
{
    var builderContext = TestBuilderContext.Current;
    if (builderContext != null)
    {
        builderContext.StateBag["DataGeneratedAt"] = DateTime.Now;
        builderContext.StateBag["GeneratorVersion"] = "1.0";
    }
    
    yield return new object[] { "test" };
}

// In your test
[Test]
[MethodDataSource(nameof(TestData))]
public void MyTest(string value)
{
    // Access the data stored during generation
    var generatedAt = TestContext.Current.StateBag["DataGeneratedAt"];
    var version = TestContext.Current.StateBag["GeneratorVersion"];
    
    Console.WriteLine($"Data was generated at: {generatedAt}");
}
```

### Available Properties

`TestBuilderContext` provides:
- `TestMethodName` - The name of the test method being built
- `ClassInformation` - Full information about the test class including:
  - `Type` - The test class type
  - `Assembly` - Assembly information
  - `Namespace` - The namespace
  - Properties, parameters, and more
- `MethodInformation` - Full information about the test method
- `StateBag` - A dictionary for storing custom data
- `Events` - Test events that can be subscribed to

Note: `TestBuilderContext.Current` will be `null` if accessed outside of test discovery/building phase.

---

## Troubleshooting & FAQ


This guide covers common questions and issues you might encounter when using TUnit.

## Frequently Asked Questions

These are conceptual questions about TUnit's design and capabilities.

### Why do I have to await all assertions? Can I use synchronous assertions?

All TUnit assertions must be awaited. There's no synchronous alternative.

**Important:** Test methods themselves can be either synchronous (`void`) or asynchronous (`async Task`). However, if your test uses TUnit's assertion library (`Assert.That(...)`), the test method **must** be `async Task` because assertions return awaitable objects that must be awaited to execute. Tests without assertions can remain synchronous. See [Test Method Signatures](getting-started/writing-your-first-test.md#test-method-signatures) for examples.

**Why this design?**

TUnit's assertion library uses the awaitable pattern (custom objects with `GetAwaiter()` methods). This means:
- Assertions don't execute until they're awaited - this is when the actual verification happens
- All assertions work consistently, whether they're simple value checks or complex async operations
- Custom assertions can perform async work (like database queries or HTTP calls)
- No sync-over-async patterns that cause deadlocks
- Assertions can be chained fluently before execution

**What this means when migrating:**

You need to convert your tests to `async Task` and add `await` before assertions.

Before (xUnit/NUnit/MSTest):
```csharp
[Test]
public void MyTest()
{
    var result = Calculate(2, 3);
    Assert.Equal(5, result);
}
```

After (TUnit):
```csharp
[Test]
public async Task MyTest()
{
    var result = Calculate(2, 3);
    await Assert.That(result).IsEqualTo(5);
}
```

**Automated migration**

TUnit includes code fixers that handle most of this conversion for you:

```bash
# For xUnit
dotnet format analyzers --severity info --diagnostics TUXU0001

# For NUnit
dotnet format analyzers --severity info --diagnostics TUNU0001

# For MSTest
dotnet format analyzers --severity info --diagnostics TUMS0001
```

The code fixer converts test methods to async, adds await to assertions, and updates attribute names. It handles most common cases automatically, though you may need to adjust complex scenarios manually.

See the migration guides for step-by-step instructions:
- [xUnit migration](migration/xunit.md#automated-migration-with-code-fixers)
- [NUnit migration](migration/nunit.md#automated-migration-with-code-fixers)
- [MSTest migration](migration/mstest.md#automated-migration-with-code-fixers)

**What you gain**

Async assertions enable patterns that aren't possible with synchronous assertions:

```csharp
[Test]
public async Task AsyncAssertion_Example()
{
    // Await async operations in assertions
    await Assert.That(async () => await GetUserAsync(123))
        .Throws<UserNotFoundException>();

    // Chain assertions naturally
    var user = await GetUserAsync(456);
    await Assert.That(user.Email)
        .IsNotNull()
        .And.Contains("@example.com");
}
```

**Watch out for missing awaits**

The most common mistake is forgetting `await`. The compiler warns you, but the test will pass without actually running the assertion:

```csharp
// Wrong - test passes without checking anything
Assert.That(result).IsEqualTo(5);  // Returns an awaitable object that's never executed

// Correct
await Assert.That(result).IsEqualTo(5);  // The await triggers the actual assertion execution
```

### Does TUnit work with Coverlet for code coverage?

**No.** Coverlet (`coverlet.collector` or `coverlet.msbuild`) is **not compatible** with TUnit.

**Why?** TUnit uses the modern `Microsoft.Testing.Platform` instead of the legacy VSTest platform. Coverlet only works with VSTest.

**Solution:** Use `Microsoft.Testing.Extensions.CodeCoverage` instead, which is:
- ✅ **Automatically included** with the TUnit meta package
- ✅ Provides the same functionality as Coverlet
- ✅ Outputs Cobertura and XML formats
- ✅ Works with all major CI/CD systems

See the [Code Coverage section](#code-coverage-issues) below for usage instructions.

### What code coverage tool should I use with TUnit?

Use **Microsoft.Testing.Extensions.CodeCoverage**, which is:
- ✅ **Already included** with the TUnit package (no manual installation)
- ✅ Built and maintained by Microsoft
- ✅ Works seamlessly with Microsoft.Testing.Platform
- ✅ Outputs industry-standard formats (Cobertura, XML)
- ✅ Compatible with all major CI/CD systems and coverage viewers

**Do not use:**
- ❌ Coverlet (incompatible with Microsoft.Testing.Platform)

---

## Common Problems & Solutions

This section provides symptom-based troubleshooting for specific issues.

## Test Discovery Issues

### Tests Not Being Discovered

**Symptoms:**
- No tests appear in test explorer
- `dotnet test` reports 0 tests
- IDE doesn't show test indicators

**Common Error Messages:**
- `[Microsoft.Testing.Platform] No test found`
- `0 Tests Passed, 0 Tests Failed, 0 Tests Skipped`

**Common Causes and Solutions:**

#### 1. Missing TUnit Package
```xml
<!-- Ensure TUnit is installed -->
<PackageReference Include="TUnit" Version="*" />
```

#### 2. Microsoft.NET.Test.Sdk Conflict
```xml
<!-- Remove this package - it conflicts with TUnit -->
<!-- <PackageReference Include="Microsoft.NET.Test.Sdk" /> -->
```

**Error Message:** `Program has more than one entry point defined`

#### 3. Missing Test Attribute
```csharp
// ❌ Won't be discovered
public void MyTest() { }

// ✅ Will be discovered
[Test]
public void MyTest() { }
```

#### 4. Non-Public Test Methods
```csharp
// ❌ Private methods won't be discovered
[Test]
private void MyTest() { }

// ✅ Public methods will be discovered
[Test]
public void MyTest() { }
```

#### 5. Static Test Methods
```csharp
// ❌ Static methods aren't supported
[Test]
public static void MyTest() { }

// ✅ Instance methods are supported
[Test]
public void MyTest() { }
```

#### 6. Wrong OutputType in Project File

**Error Message:** `A fatal error occurred. The required library hostfxr.dll could not be found.`

```xml
<!-- ❌ Wrong output type -->
<OutputType>Library</OutputType>

<!-- ✅ Correct output type -->
<OutputType>Exe</OutputType>
```

### AOT Compilation Errors

**Symptoms:**
- Build errors mentioning "trim warnings"
- Runtime errors about missing metadata
- "Source generator did not generate" errors

**Solutions:**

#### 1. Enable AOT-Compatible Mode
```xml
<PropertyGroup>
    <IsAotCompatible>true</IsAotCompatible>
    <EnableTrimAnalyzer>true</EnableTrimAnalyzer>
</PropertyGroup>
```

#### 2. Use AOT-Compatible Data Sources
```csharp
// ❌ Reflection-based (may cause AOT issues)
[MethodDataSource(typeof(DataClass), "GetData")]

// ✅ AOT-friendly generic version
[MethodDataSource<DataClass>(nameof(DataClass.GetData))]
```

### Tests Not Generated When Using InstanceMethodDataSource

**Symptom:** When using `InstanceMethodDataSource` with a property from a `ClassDataSource` fixture, no tests appear in the test explorer or `--list-tests` output.

**Cause:** The fixture implements `IAsyncInitializer`, which runs during test **execution**, not during test **discovery**. When TUnit enumerates test cases during discovery, the fixture hasn't been initialized yet, so the data source returns empty data.

**Solution 1 (Recommended):** Return predefined test case identifiers that don't require initialization:

```csharp
public class Fixture : IAsyncInitializer  // ✅ Stays as IAsyncInitializer
{
    // Predefined IDs - available without initialization
    private static readonly string[] TestCaseIds = ["Case1", "Case2", "Case3"];

    public async Task InitializeAsync()
    {
        // Expensive setup runs during execution only
        await StartDockerContainerAsync();
    }

    // Returns predefined IDs - works during discovery
    public IEnumerable<string> GetTestCaseIds() => TestCaseIds;
}
```

**Solution 2:** Use `IAsyncDiscoveryInitializer` if you truly need data loaded during discovery:

```csharp
public class Fixture : IAsyncDiscoveryInitializer  // Changed from IAsyncInitializer
{
    private List<string> _testCases = [];

    public async Task InitializeAsync()
    {
        // Now runs during discovery
        _testCases = await LoadTestCasesAsync();
    }

    public IEnumerable<string> GetTestCases() => _testCases;
}
```

**Performance note:** Solution 1 is preferred because discovery happens frequently (IDE reloads, project switches, `--list-tests`), and you want to avoid expensive operations during discovery when possible.

For detailed examples, see [Property Injection - Discovery Phase Initialization](test-lifecycle/property-injection.md#discovery-phase-initialization).

## Test Execution Issues

### Tests Hanging or Deadlocking

**Symptoms:**
- Tests never complete
- IDE becomes unresponsive during test runs
- Timeout errors

**Common Causes and Solutions:**

#### 1. Async Deadlocks
```csharp
// ❌ Can cause deadlock
[Test]
public void BadAsyncTest()
{
    var result = AsyncMethod().Result; // Blocking on async
}

// ✅ Proper async handling
[Test]
public async Task GoodAsyncTest()
{
    var result = await AsyncMethod();
}
```

#### 2. Parallel Execution Conflicts
```csharp
// If tests access shared resources, prevent parallel execution
[NotInParallel("SharedResource")]
public class DatabaseTests
{
    // Tests in this class won't run in parallel with others
    // that have the same constraint
}
```

#### 3. Circular Dependencies
```csharp
// ❌ Circular dependency causes deadlock
[Test, DependsOn(nameof(Test2))]
public void Test1() { }

[Test, DependsOn(nameof(Test1))]
public void Test2() { }

// ✅ Linear dependencies
[Test]
public void Test1() { }

[Test, DependsOn(nameof(Test1))]
public void Test2() { }
```

### Timeout Exceptions

**Symptoms:**
- `TimeoutException` thrown
- Tests fail after specific duration
- "Test execution timed out" messages

**Common Error Messages:**
- `System.TimeoutException: The operation has timed out`
- `Test execution exceeded timeout of 30000ms`

**Solutions:**

#### 1. Increase Timeout
```csharp
[Test]
[Timeout(30000)] // 30 seconds
public async Task LongRunningTest()
{
    await LongOperation();
}
```

#### 2. Global Timeout Configuration
```bash
dotnet test -- --timeout 60s
```

#### 3. Check for Infinite Loops
```csharp
// Review your test logic for potential infinite loops
[Test]
public async Task PotentiallyInfiniteTest()
{
    while (condition) // Ensure condition can become false
    {
        await Task.Delay(100);
    }
}
```

## Assertion Failures

### Confusing Assertion Messages

**Symptoms:**
- Assertion messages don't clearly indicate the problem
- Expected vs actual values are unclear

**Solutions:**

#### 1. Use Descriptive Assertions
```csharp
// ❌ Generic assertion
await Assert.That(result).IsTrue();

// ✅ Specific assertion with context
await Assert.That(user.IsActive)
    .IsTrue()
    .Because("User should be active after registration");
```

#### 2. Multiple Assertions
```csharp
// Group related assertions for better error reporting
using (Assert.Multiple())
{
    await Assert.That(user.Name).IsEqualTo("John");
    await Assert.That(user.Email).Contains("@");
    await Assert.That(user.Age).IsGreaterThan(0);
}
```

### Floating Point Comparison Issues

**Symptoms:**
- Tests fail due to floating point precision
- Decimal comparisons unexpectedly fail

**Solution:**
```csharp
// ❌ Direct comparison can fail
await Assert.That(0.1 + 0.2).IsEqualTo(0.3);

// ✅ Use tolerance
await Assert.That(0.1 + 0.2).IsEqualTo(0.3).Within(0.0001);
```

### Assertion Not Awaited (Test Passes Without Checking)

**Symptoms:**
- Test passes but assertion never executes
- Compiler warning: "This async method lacks 'await' operators"
- Test passes when it should fail

**Common Error Messages:**
- `CS4014: Because this call is not awaited, execution of the current method continues before the call is completed`

**Root Cause:**

Forgetting to `await` an assertion means it returns a `Task` that's never executed. The test completes immediately without checking anything.

**Example:**

```csharp
[Test]
public async Task BadTest()
{
    var result = Calculate(2, 2);

    // Wrong - missing await
    Assert.That(result).IsEqualTo(5);  // Returns Task, never awaited

    // Test passes because assertion never runs
}
```

**Solution:**

Always await assertions:

```csharp
[Test]
public async Task GoodTest()
{
    var result = Calculate(2, 2);
    await Assert.That(result).IsEqualTo(4);
}
```

**Prevention:**

The compiler warns you about this (CS4014: "Because this call is not awaited..."). To catch these at build time, enable treating warnings as errors:

```xml
<PropertyGroup>
  <TreatWarningsAsErrors>true</TreatWarningsAsErrors>
</PropertyGroup>
```

### Array and Collection Comparison Issues

**Symptoms:**
- "IsEqualTo doesn't work for arrays"
- Arrays with same values fail equality check
- Error messages about reference equality vs value equality

**Root Cause:**

Arrays use reference equality by default. You need to use collection-specific assertion methods.

#### Comparing Arrays

```csharp
var expected = new[] { 1, 2, 3 };
var actual = new[] { 1, 2, 3 };

// Wrong - compares references, not values
await Assert.That(actual).IsEqualTo(expected);  // Fails

// Correct - use IsEquivalentTo for collections
await Assert.That(actual).IsEquivalentTo(expected);  // Passes
```

Note that `IsEquivalentTo` ignores order by default. If order matters, use `CollectionOrdering.Matching`:

```csharp
// Order doesn't matter (default)
await Assert.That(actual).IsEquivalentTo(expected);  // Passes even if order differs

// Order must match exactly
await Assert.That(actual).IsEquivalentTo(expected, CollectionOrdering.Matching);
```

Or assert on elements individually:

```csharp
await Assert.That(actual).Count().IsEqualTo(expected.Length);
for (int i = 0; i < expected.Length; i++)
{
    await Assert.That(actual[i]).IsEqualTo(expected[i]);
}
```

#### Arrays of Complex Types

```csharp
var expected = new[]
{
    new User { Id = 1, Name = "Alice" },
    new User { Id = 2, Name = "Bob" }
};

// May not work without custom equality implementation
await Assert.That(actual).IsEquivalentTo(expected);

// More reliable - assert on properties
await Assert.That(actual).Count().IsEqualTo(2);
await Assert.That(actual[0].Name).IsEqualTo("Alice");
await Assert.That(actual[1].Name).IsEqualTo("Bob");

// Or compare projected values
await Assert.That(actual.Select(u => u.Name))
    .IsEquivalentTo(new[] { "Alice", "Bob" });
```

#### Arrays of Tuples (Known Limitation)

```csharp
var expected = new[] { (1, "a"), (2, "b") };
var actual = new[] { (1, "a"), (2, "b") };

// Current limitation - may not work as expected
// await Assert.That(actual).IsEquivalentTo(expected);

// Workaround - assert individual elements
await Assert.That(actual).Count().IsEqualTo(2);
await Assert.That(actual[0]).IsEqualTo((1, "a"));
await Assert.That(actual[1]).IsEqualTo((2, "b"));
```

#### Lists and Other Collections

```csharp
var list = new List<int> { 1, 2, 3 };

// Works for IEnumerable types
await Assert.That(list).IsEquivalentTo(new[] { 1, 2, 3 });

// Check specific properties
await Assert.That(list).Count().IsEqualTo(3);
await Assert.That(list).Contains(2);
await Assert.That(list).DoesNotContain(5);
```

**General Approach:**
- Use `IsEquivalentTo` for unordered collection comparison (default)
- Use `IsEquivalentTo(expected, CollectionOrdering.Matching)` for ordered comparison
- Iterate and assert elements individually for complex ordered comparisons
- Assert on key properties for complex types
- Consider implementing `IEquatable<T>` on your types for cleaner assertions

### Assertion on Wrong Type

**Symptoms:**
- Compiler error: "Cannot convert from 'X' to 'Y'"
- Assertion method not available for type
- IntelliSense doesn't show expected assertions

#### String vs Object Assertions

```csharp
object value = "hello";

// Doesn't compile - object doesn't have string-specific assertions
// await Assert.That(value).StartsWith("h");

// Cast to the correct type
await Assert.That((string)value).StartsWith("h");

// Or check the type first
await Assert.That(value).IsTypeOf<string>();
await Assert.That((string)value).StartsWith("h");
```

#### Nullable Values

```csharp
int? nullableInt = 5;

// Option 1: Check for null, then access value
await Assert.That(nullableInt).IsNotNull();
await Assert.That(nullableInt!.Value).IsEqualTo(5);

// Option 2: Use HasValue pattern
await Assert.That(nullableInt.HasValue).IsTrue();
await Assert.That(nullableInt.GetValueOrDefault()).IsEqualTo(5);
```

## Common Migration Pitfalls (from xUnit/NUnit/MSTest)

If you're migrating from another testing framework, these are the most common issues you'll encounter.

### Understanding the Platform Change

**The Core Shift:** TUnit uses `Microsoft.Testing.Platform` instead of the legacy `VSTest` platform. This fundamental change affects several aspects of your testing workflow.

**What This Means:**

1. **Different Test Runners**
   - VSTest used `vstest.console.exe` and `Microsoft.NET.Test.Sdk`
   - TUnit uses the modern `Microsoft.Testing.Platform`
   - They are **mutually exclusive** - you cannot use both

2. **Different Commands**
   ```bash
   # Old (VSTest)
   dotnet test --collect:"XPlat Code Coverage"

   # New (TUnit)
   dotnet run --configuration Release --coverage
   ```

3. **Different Package Requirements**
   ```xml
   <!-- Old (VSTest) -->
   <PackageReference Include="Microsoft.NET.Test.Sdk" Version="*" />
   <PackageReference Include="coverlet.collector" Version="*" />

   <!-- New (TUnit) -->
   <PackageReference Include="TUnit" Version="*" />
   <!-- Coverage is included automatically -->
   ```

### Tests Don't Appear in IDE Test Explorer

**Symptoms:**
- Tests worked in xUnit/NUnit but don't show in Visual Studio/Rider
- Test Explorer is empty
- "Run Test" gutter icons don't appear

**Root Cause:** IDE needs to be configured for Microsoft.Testing.Platform support.

**Solutions:**

**Visual Studio:**
1. Go to Tools > Options > Preview Features
2. Enable "Use testing platform server mode"
3. Restart Visual Studio
4. Rebuild your solution

**Rider:**
1. Go to Settings > Build, Execution, Deployment > Unit Testing > Testing Platform
2. Enable "Testing Platform support"
3. Restart Rider
4. Rebuild your solution

**VS Code:**
1. Install C# Dev Kit extension
2. Go to extension settings
3. Enable "Dotnet > Test Window > Use Testing Platform Protocol"
4. Reload window

### Command Line Differences

**Old Way (VSTest):**
```bash
dotnet test
dotnet test --filter "Category=Integration"
dotnet test --logger "trx;LogFileName=results.trx"
```

**New Way (TUnit):**
```bash
dotnet run
dotnet run -- --treenode-filter "/*/*/*/*[Category=Integration]"
dotnet run -- --report-trx --report-trx-filename results.trx
```

**Key Differences:**
- Use `dotnet run` instead of `dotnet test` for best experience
- Arguments after `--` are passed to the test application
- Filter syntax is different (tree-node based)
- Reporting flags have different names

### .runsettings File Migration

**Old (.runsettings for VSTest):**
```xml
<RunConfiguration>
  <MaxCpuCount>4</MaxCpuCount>
  <ResultsDirectory>./TestResults</ResultsDirectory>
</RunConfiguration>
```

**New (TUnit configuration):**

TUnit uses command-line flags, `testconfig.json`, or programmatic configuration instead of `.runsettings`:

```bash
# Parallel execution
dotnet run -- --parallel

# Custom results directory
dotnet run -- --results-directory ./TestResults
```

For more complex configuration, use the programmatic API in your test setup.

## Testing with External Dependencies

Real-world tests often interact with databases, APIs, and file systems. Here's how to handle these effectively.

### Database Testing

**Strategy 1: In-Memory Providers**

Best for unit tests that need a database but don't test database-specific behavior.

```csharp
public class UserRepositoryTests
{
    private DbContext _context;

    [Before(Test)]
    public void Setup()
    {
        var options = new DbContextOptionsBuilder<AppDbContext>()
            .UseInMemoryDatabase(databaseName: Guid.NewGuid().ToString())
            .Options;

        _context = new AppDbContext(options);
    }

    [Test]
    public async Task CanSaveAndRetrieveUser()
    {
        // Arrange
        var user = new User { Name = "Alice", Email = "alice@example.com" };
        _context.Users.Add(user);
        await _context.SaveChangesAsync();

        // Act
        var retrieved = await _context.Users.FirstOrDefaultAsync(u => u.Email == "alice@example.com");

        // Assert
        await Assert.That(retrieved).IsNotNull();
        await Assert.That(retrieved!.Name).IsEqualTo("Alice");
    }

    [After(Test)]
    public void Cleanup()
    {
        _context.Dispose();
    }
}
```

**Strategy 2: Test Containers (Testcontainers)**

Best for integration tests that need real database behavior.

```csharp
public class DatabaseIntegrationTests : IAsyncInitializer, IAsyncDisposable
{
    private PostgreSqlContainer _container;
    private DbContext _context;

    public async Task InitializeAsync()
    {
        _container = new PostgreSqlBuilder()
            .WithDatabase("testdb")
            .WithUsername("test")
            .WithPassword("test")
            .Build();

        await _container.StartAsync();

        var options = new DbContextOptionsBuilder<AppDbContext>()
            .UseNpgsql(_container.GetConnectionString())
            .Options;

        _context = new AppDbContext(options);
        await _context.Database.MigrateAsync();
    }

    [Test]
    public async Task DatabaseTransactionTest()
    {
        // Test with real database
        var user = new User { Name = "Bob" };
        _context.Users.Add(user);
        await _context.SaveChangesAsync();

        await Assert.That(user.Id).IsGreaterThan(0);
    }

    public async ValueTask DisposeAsync()
    {
        _context?.Dispose();
        if (_container != null)
            await _container.DisposeAsync();
    }
}
```

**Strategy 3: Shared Database Fixture**

For multiple tests sharing the same database setup:

```csharp
[NotInParallel("SharedDatabase")]
public class SharedDatabaseTests
{
    private static DbContext _sharedContext;

    [Before(HookType.Class)]
    public static async Task ClassSetup()
    {
        _sharedContext = await SetupDatabaseAsync();
    }

    [Before(HookType.Test)]
    public async Task TestSetup()
    {
        // Clear data between tests
        _sharedContext.Users.RemoveRange(_sharedContext.Users);
        await _sharedContext.SaveChangesAsync();
    }

    [Test]
    public async Task Test1()
    {
        // Use _sharedContext
    }

    [After(HookType.Class)]
    public static async Task ClassCleanup()
    {
        _sharedContext?.Dispose();
    }
}
```

### Mocking HTTP Calls and External APIs

**Strategy 1: Using Moq with HttpClient**

```csharp
public class WeatherServiceTests
{
    [Test]
    public async Task GetWeather_ReturnsTemperature()
    {
        // Arrange
        var mockHandler = new Mock<HttpMessageHandler>();
        mockHandler.Protected()
            .Setup<Task<HttpResponseMessage>>(
                "SendAsync",
                ItExpr.IsAny<HttpRequestMessage>(),
                ItExpr.IsAny<CancellationToken>())
            .ReturnsAsync(new HttpResponseMessage
            {
                StatusCode = HttpStatusCode.OK,
                Content = new StringContent("{\"temperature\": 22.5}")
            });

        var httpClient = new HttpClient(mockHandler.Object);
        var service = new WeatherService(httpClient);

        // Act
        var weather = await service.GetWeatherAsync("London");

        // Assert
        await Assert.That(weather.Temperature).IsEqualTo(22.5);
    }
}
```

**Strategy 2: WireMock for Integration Tests**

```csharp
public class ApiIntegrationTests : IAsyncInitializer, IAsyncDisposable
{
    private WireMockServer _mockServer;
    private HttpClient _httpClient;

    public async Task InitializeAsync()
    {
        _mockServer = WireMockServer.Start();
        _httpClient = new HttpClient { BaseAddress = new Uri(_mockServer.Urls[0]) };

        await Task.CompletedTask;
    }

    [Test]
    public async Task ApiCall_HandlesSuccessResponse()
    {
        // Setup mock response
        _mockServer
            .Given(Request.Create().WithPath("/api/users").UsingGet())
            .RespondWith(Response.Create()
                .WithStatusCode(200)
                .WithHeader("Content-Type", "application/json")
                .WithBody("[{\"id\": 1, \"name\": \"Alice\"}]"));

        // Act
        var response = await _httpClient.GetStringAsync("/api/users");

        // Assert
        await Assert.That(response).Contains("Alice");
    }

    public async ValueTask DisposeAsync()
    {
        _httpClient?.Dispose();
        _mockServer?.Stop();
        await Task.CompletedTask;
    }
}
```

### File System Testing

**Best Practices:**

1. **Use Temporary Directories**
2. **Clean Up After Tests**
3. **Use Path.Combine for Cross-Platform Compatibility**

```csharp
public class FileProcessorTests
{
    private string _testDirectory;

    [Before(Test)]
    public void Setup()
    {
        _testDirectory = Path.Combine(Path.GetTempPath(), Guid.NewGuid().ToString());
        Directory.CreateDirectory(_testDirectory);
    }

    [Test]
    public async Task ProcessFile_CreatesOutputFile()
    {
        // Arrange
        var inputFile = Path.Combine(_testDirectory, "input.txt");
        var outputFile = Path.Combine(_testDirectory, "output.txt");

        await File.WriteAllTextAsync(inputFile, "test content");

        var processor = new FileProcessor();

        // Act
        await processor.ProcessFileAsync(inputFile, outputFile);

        // Assert
        await Assert.That(File.Exists(outputFile)).IsTrue();
        var content = await File.ReadAllTextAsync(outputFile);
        await Assert.That(content).Contains("processed");
    }

    [After(Test)]
    public void Cleanup()
    {
        if (Directory.Exists(_testDirectory))
        {
            Directory.Delete(_testDirectory, recursive: true);
        }
    }
}
```

**Using IFileSystem Abstraction (Recommended):**

```csharp
// Production code uses IFileSystem interface
public class DocumentService
{
    private readonly IFileSystem _fileSystem;

    public DocumentService(IFileSystem fileSystem)
    {
        _fileSystem = fileSystem;
    }

    public async Task SaveDocumentAsync(string path, string content)
    {
        await _fileSystem.File.WriteAllTextAsync(path, content);
    }
}

// Test with mock file system
public class DocumentServiceTests
{
    [Test]
    public async Task SaveDocument_WritesToFile()
    {
        // Arrange
        var mockFileSystem = new MockFileSystem();
        var service = new DocumentService(mockFileSystem);

        // Act
        await service.SaveDocumentAsync("/docs/test.txt", "content");

        // Assert
        await Assert.That(mockFileSystem.File.Exists("/docs/test.txt")).IsTrue();
        var content = await mockFileSystem.File.ReadAllTextAsync("/docs/test.txt");
        await Assert.That(content).IsEqualTo("content");
    }
}
```

## Configuration and Secrets Management

One of the most common challenges in testing is loading configuration from `appsettings.json`, environment variables, or user secrets.

### Configuration File Not Found

**Symptoms:**
- `FileNotFoundException: Could not find file 'appsettings.json'`
- Configuration values are null or default
- "The configuration file 'appsettings.json' was not found"

**Common Error Messages:**
- `System.IO.FileNotFoundException: Could not find file 'C:\...\bin\Debug\net8.0\appsettings.json'`

**Root Cause:**

Test projects run from the `bin/Debug/net8.0` directory, but your `appsettings.json` file is in the project root. The file isn't being copied to the output directory.

**Solution:**

#### 1. Configure CopyToOutputDirectory in .csproj

```xml
<ItemGroup>
  <None Update="appsettings.json">
    <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
  </None>
  <None Update="appsettings.Development.json">
    <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
  </None>
</ItemGroup>
```

**Options:**
- `PreserveNewest` - Copy only if the file is newer (recommended)
- `Always` - Always copy the file (slower builds)

### Loading IConfiguration in Tests

**Recommended Pattern:**

```csharp
public class ConfigurationTests
{
    private static IConfiguration _configuration;

    [Before(HookType.Class)]
    public static void SetupConfiguration()
    {
        _configuration = new ConfigurationBuilder()
            .SetBasePath(Directory.GetCurrentDirectory())
            .AddJsonFile("appsettings.json", optional: false)
            .AddJsonFile("appsettings.Development.json", optional: true)
            .AddEnvironmentVariables()
            .Build();
    }

    [Test]
    public async Task CanLoadConfiguration()
    {
        var connectionString = _configuration.GetConnectionString("Default");
        await Assert.That(connectionString).IsNotNull();
    }
}
```

### Environment-Specific Configuration

**Problem:** Need different settings for Development, CI, Production testing.

**Solution:**

#### 1. Use Environment-Specific Files

```csharp
[Before(HookType.Class)]
public static void SetupConfiguration()
{
    var environment = Environment.GetEnvironmentVariable("ASPNETCORE_ENVIRONMENT") ?? "Development";

    _configuration = new ConfigurationBuilder()
        .SetBasePath(Directory.GetCurrentDirectory())
        .AddJsonFile("appsettings.json", optional: false)
        .AddJsonFile($"appsettings.{environment}.json", optional: true)
        .AddEnvironmentVariables()
        .Build();
}
```

**In .csproj:**
```xml
<ItemGroup>
  <None Update="appsettings*.json">
    <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
  </None>
</ItemGroup>
```

#### 2. Set Environment in CI/CD

**GitHub Actions:**
```yaml
- name: Run tests
  env:
    ASPNETCORE_ENVIRONMENT: CI
  run: dotnet run --project tests/MyProject.Tests
```

**Azure Pipelines:**
```yaml
- task: DotNetCoreCLI@2
  env:
    ASPNETCORE_ENVIRONMENT: CI
  inputs:
    command: 'run'
    projects: 'tests/**/*.csproj'
```

### User Secrets in Tests

**Problem:** Need to test with secrets (API keys, passwords) without committing them.

**Solution:**

#### 1. Initialize User Secrets (One Time)

```bash
cd MyProject.Tests
dotnet user-secrets init
```

This adds a `UserSecretsId` to your `.csproj`:
```xml
<PropertyGroup>
  <UserSecretsId>your-unique-guid</UserSecretsId>
</PropertyGroup>
```

#### 2. Add Secrets

```bash
dotnet user-secrets set "ApiKey" "my-secret-key"
dotnet user-secrets set "ConnectionStrings:Database" "Server=localhost;..."
```

#### 3. Load Secrets in Tests

```csharp
[Before(HookType.Class)]
public static void SetupConfiguration()
{
    _configuration = new ConfigurationBuilder()
        .SetBasePath(Directory.GetCurrentDirectory())
        .AddJsonFile("appsettings.json", optional: false)
        .AddUserSecrets<ConfigurationTests>() // Load user secrets
        .AddEnvironmentVariables()
        .Build();
}
```

**Install Package:**
```xml
<PackageReference Include="Microsoft.Extensions.Configuration.UserSecrets" Version="*" />
```

### Configuration from Environment Variables

**Recommended for CI/CD:**

```csharp
[Before(HookType.Class)]
public static void SetupConfiguration()
{
    _configuration = new ConfigurationBuilder()
        .AddEnvironmentVariables("MYAPP_") // Prefix optional
        .Build();
}

[Test]
public async Task UsesEnvironmentVariable()
{
    var apiKey = _configuration["ApiKey"]; // Reads MYAPP_ApiKey
    await Assert.That(apiKey).IsNotNull();
}
```

**Setting Environment Variables:**

**Windows (PowerShell):**
```powershell
$env:MYAPP_ApiKey = "secret-key"
dotnet run --project tests/MyProject.Tests
```

**Linux/macOS:**
```bash
export MYAPP_ApiKey="secret-key"
dotnet run --project tests/MyProject.Tests
```

**Inline:**
```bash
MYAPP_ApiKey="secret-key" dotnet run --project tests/MyProject.Tests
```

### Strongly-Typed Configuration

**Recommended Pattern:**

```csharp
// Configuration class
public class AppSettings
{
    public string ApiUrl { get; set; }
    public int Timeout { get; set; }
    public ConnectionStrings ConnectionStrings { get; set; }
}

public class ConnectionStrings
{
    public string Default { get; set; }
}

// In tests
public class ConfigurationTests
{
    private static AppSettings _settings;

    [Before(HookType.Class)]
    public static void SetupConfiguration()
    {
        var config = new ConfigurationBuilder()
            .AddJsonFile("appsettings.json")
            .Build();

        _settings = config.Get<AppSettings>();
    }

    [Test]
    public async Task CanAccessTypedConfiguration()
    {
        await Assert.That(_settings.ApiUrl).IsNotNull();
        await Assert.That(_settings.Timeout).IsGreaterThan(0);
    }
}
```

### Common Configuration Patterns

#### Pattern 1: Shared Configuration for All Tests

```csharp
public class TestBase
{
    protected static IConfiguration Configuration { get; private set; }

    [Before(HookType.Assembly)]
    public static void SetupSharedConfiguration()
    {
        Configuration = new ConfigurationBuilder()
            .SetBasePath(Directory.GetCurrentDirectory())
            .AddJsonFile("appsettings.json")
            .AddEnvironmentVariables()
            .Build();
    }
}

// In your tests
public class MyTests : TestBase
{
    [Test]
    public async Task UsesSharedConfiguration()
    {
        var value = Configuration["Setting"];
        await Assert.That(value).IsNotNull();
    }
}
```

#### Pattern 2: Per-Test Configuration

```csharp
public class PerTestConfigTests
{
    private IConfiguration _configuration;

    [Before(Test)]
    public void SetupTestConfiguration()
    {
        _configuration = new ConfigurationBuilder()
            .AddInMemoryCollection(new Dictionary<string, string>
            {
                ["TestSetting"] = "test-value"
            })
            .Build();
    }

    [Test]
    public async Task UsesTestSpecificConfiguration()
    {
        await Assert.That(_configuration["TestSetting"]).IsEqualTo("test-value");
    }
}
```

### Troubleshooting Configuration Issues

#### Issue: Configuration is null after loading

**Check:**
1. Is the file being copied? Check `bin/Debug/net8.0/` for `appsettings.json`
2. Is the file path correct? Use `SetBasePath(Directory.GetCurrentDirectory())`
3. Is the file marked as `Content` or `None` with `CopyToOutputDirectory`?

**Debug:**
```csharp
[Before(HookType.Class)]
public static void SetupConfiguration()
{
    var currentDir = Directory.GetCurrentDirectory();
    TestContext.Current?.WriteLine($"Current directory: {currentDir}");

    var files = Directory.GetFiles(currentDir, "*.json");
    TestContext.Current?.WriteLine($"JSON files: {string.Join(", ", files)}");

    _configuration = new ConfigurationBuilder()
        .SetBasePath(currentDir)
        .AddJsonFile("appsettings.json", optional: false)
        .Build();
}
```

#### Issue: Configuration values are wrong

**Check binding:**
```csharp
[Test]
public void DebugConfiguration()
{
    var allConfig = _configuration.AsEnumerable();
    foreach (var kvp in allConfig)
    {
        TestContext.Current?.WriteLine($"{kvp.Key} = {kvp.Value}");
    }
}
```

#### Issue: Secrets not loading in CI/CD

**Solution:** User secrets only work locally. In CI/CD, use environment variables:

```yaml
# GitHub Actions
- name: Run tests
  env:
    ApiKey: ${{ secrets.API_KEY }}
  run: dotnet run --project tests/MyProject.Tests
```

## Test Filtering and Grouping Issues

When you have hundreds or thousands of tests, filtering becomes critical for running the right subset.

### Filter Not Selecting Expected Tests

**Symptoms:**
- `--filter` command selects no tests or wrong tests
- All tests run when you expected a subset
- Category filters don't work

**Common Error Messages:**
- `No tests matched the specified filter`
- `0 tests discovered`

**Root Cause:**

TUnit uses a **tree-node filter syntax**, not the legacy VSTest filter syntax.

### Tree-Node Filter Syntax

**Pattern:** `/Assembly/Namespace/Class/Method[Property=Value]`

**Examples:**

```bash
# Run all tests in a specific class
dotnet run -- --treenode-filter "/*/*/MyTestClass/*"

# Run a specific test method
dotnet run -- --treenode-filter "/*/*/MyTestClass/MyTestMethod"

# Run tests with a specific category
dotnet run -- --treenode-filter "/*/*/*/*[Category=Integration]"

# Run tests NOT in a category
dotnet run -- --treenode-filter "/*/*/*/*[Category!=Performance]"

# Multiple filters (OR)
dotnet run -- --treenode-filter "/*/*/ClassA/*|/*/*/ClassB/*"

# Combine filters (AND)
dotnet run -- --treenode-filter "/*/*/*/*[Category=Integration][Priority=High]"
```

### Common Filter Patterns

#### Run All Tests in Namespace

```bash
dotnet run -- --treenode-filter "/*/MyNamespace.*/*"
```

#### Run Tests by Category

```csharp
[Test]
[Category("Integration")]
public async Task DatabaseTest() { }

[Test]
[Category("Unit")]
public async Task CalculationTest() { }
```

```bash
# Run integration tests
dotnet run -- --treenode-filter "/*/*/*/*[Category=Integration]"

# Run unit tests
dotnet run -- --treenode-filter "/*/*/*/*[Category=Unit]"

# Run everything except performance tests
dotnet run -- --treenode-filter "/*/*/*/*[Category!=Performance]"
```

#### Run Tests by Property

```csharp
[Test]
[Property("Owner", "TeamA")]
public async Task FeatureTest() { }
```

```bash
dotnet run -- --treenode-filter "/*/*/*/*[Owner=TeamA]"
```

### Categories Not Being Applied

**Symptoms:**
- Category filter returns no tests
- Tests don't appear with expected category

**Common Causes:**

#### 1. Category Attribute on Class vs Method

```csharp
// ✅ Category on test method
[Test]
[Category("Integration")]
public async Task MyTest() { }

// ✅ Category on class (applies to all tests in class)
[Category("Integration")]
public class IntegrationTests
{
    [Test]
    public async Task Test1() { }

    [Test]
    public async Task Test2() { }
}
```

#### 2. Typo in Category Name

```csharp
[Test]
[Category("Intergration")] // ❌ Typo!
public async Task MyTest() { }
```

```bash
# Won't find the test
dotnet run -- --treenode-filter "/*/*/*/*[Category=Integration]"
```

**Solution:** Use constants to avoid typos:

```csharp
public static class TestCategories
{
    public const string Integration = nameof(Integration);
    public const string Unit = nameof(Unit);
    public const string Performance = nameof(Performance);
}

[Test]
[Category(TestCategories.Integration)]
public async Task MyTest() { }
```

### Combining Filters in CI/CD

**Problem:** Need different test suites for different CI stages.

**Solution:**

#### GitHub Actions Example

```yaml
jobs:
  unit-tests:
    runs-on: ubuntu-latest
    steps:
      - name: Run unit tests
        run: dotnet run --project tests/MyProject.Tests -- --treenode-filter "/*/*/*/*[Category=Unit]"

  integration-tests:
    runs-on: ubuntu-latest
    needs: unit-tests
    steps:
      - name: Run integration tests
        run: dotnet run --project tests/MyProject.Tests -- --treenode-filter "/*/*/*/*[Category=Integration]"

  smoke-tests:
    runs-on: ubuntu-latest
    steps:
      - name: Run smoke tests only
        run: dotnet run --project tests/MyProject.Tests -- --treenode-filter "/*/*/*/*[Category=Smoke]"
```

#### Azure Pipelines Example

```yaml
- task: DotNetCoreCLI@2
  displayName: 'Unit Tests'
  inputs:
    command: 'run'
    projects: 'tests/**/*.csproj'
    arguments: '-- --treenode-filter "/*/*/*/*[Category=Unit]"'

- task: DotNetCoreCLI@2
  displayName: 'Integration Tests'
  inputs:
    command: 'run'
    projects: 'tests/**/*.csproj'
    arguments: '-- --treenode-filter "/*/*/*/*[Category=Integration]"'
```

### Excluding Tests from Runs

**Problem:** Some tests should never run in CI (e.g., manual tests, local-only tests).

**Solution:**

#### 1. Use Explicit Attribute

```csharp
[Test]
[Explicit] // Won't run unless explicitly requested
public async Task ManualTest() { }
```

#### 2. Use Custom Category

```csharp
[Test]
[Category("ManualOnly")]
public async Task InteractiveTest() { }
```

```bash
# CI runs everything except manual tests
dotnet run -- --treenode-filter "/*/*/*/*[Category!=ManualOnly]"
```

### Multiple Categories on Same Test

```csharp
[Test]
[Category("Integration")]
[Category("Database")]
[Category("Slow")]
public async Task ComplexTest() { }
```

```bash
# Run tests that are BOTH Integration AND Database
dotnet run -- --treenode-filter "/*/*/*/*[Category=Integration][Category=Database]"

# Run tests that are Integration OR Unit
dotnet run -- --treenode-filter "/*/*/*/*[Category=Integration]|/*/*/*/*[Category=Unit]"
```

### Debugging Filter Issues

**Enable Diagnostic Output:**

```bash
dotnet run -- --treenode-filter "your-filter" --diagnostic
```

This shows which tests are discovered and why they were included/excluded.

**List All Tests Without Running:**

```bash
# Use --list-tests flag if available, or run with dry-run
dotnet run -- --help
```

**Verify Test Discovery:**

```bash
# Run without filter to see all tests
dotnet run

# Count tests discovered
dotnet run | grep "Test Passed"
```

### Best Practices for Test Organization

**1. Use Hierarchical Categories**

```csharp
public static class TestCategories
{
    public const string Unit = "Unit";
    public const string Integration = "Integration";

    public static class Integration
    {
        public const string Database = "Integration.Database";
        public const string Api = "Integration.Api";
        public const string FileSystem = "Integration.FileSystem";
    }
}
```

**2. Consistent Naming**

```csharp
// ✅ Good: Clear, consistent
[Category("Integration")]
[Category("Database")]

// ❌ Bad: Inconsistent
[Category("integration")] // lowercase
[Category("DB")] // abbreviation
```

**3. Document Your Categories**

Create a `TestCategories.md` in your test project:

```markdown
# Test Categories

- `Unit` - Fast, isolated unit tests
- `Integration` - Tests with external dependencies
- `Integration.Database` - Database integration tests
- `Integration.Api` - API integration tests
- `Performance` - Performance/load tests (excluded from CI)
- `Smoke` - Critical path smoke tests (run first in CI)
```

## Diagnosing Flaky Tests

Flaky tests pass or fail inconsistently. They're one of the most frustrating issues in test suites.

### Common Causes

#### 1. Race Conditions in Parallel Tests

**Symptom:** Test passes when run alone but fails when run with other tests.

```csharp
// ❌ Flaky - tests modify shared state
public class CounterTests
{
    private static int _counter = 0;

    [Test]
    public async Task IncrementCounter()
    {
        _counter++;
        await Assert.That(_counter).IsEqualTo(1); // Fails in parallel
    }
}

// ✅ Fixed - use NotInParallel or instance state
[NotInParallel("Counter")]
public class CounterTests
{
    private int _counter = 0; // Instance variable, not static

    [Test]
    public async Task IncrementCounter()
    {
        _counter++;
        await Assert.That(_counter).IsEqualTo(1); // Always passes
    }
}
```

#### 2. Un-Awaited Async Operations

**Symptom:** Test sometimes passes, sometimes times out or fails.

```csharp
// ❌ Flaky - not waiting for background work
[Test]
public async Task ProcessData()
{
    var processor = new DataProcessor();
    processor.StartBackgroundWork(); // Fire-and-forget

    await Assert.That(processor.IsComplete).IsTrue(); // Race condition!
}

// ✅ Fixed - properly await async work
[Test]
public async Task ProcessData()
{
    var processor = new DataProcessor();
    await processor.ProcessAsync(); // Wait for completion

    await Assert.That(processor.IsComplete).IsTrue();
}
```

#### 3. System Time Dependencies

**Symptom:** Test fails at different times of day or in different time zones.

```csharp
// ❌ Flaky - depends on current time
[Test]
public async Task IsBusinessHours()
{
    var service = new BusinessHoursService();
    var result = service.IsBusinessHours(); // Uses DateTime.Now

    await Assert.That(result).IsTrue(); // Fails at night!
}

// ✅ Fixed - inject time provider
[Test]
public async Task IsBusinessHours()
{
    var mockTime = new Mock<ITimeProvider>();
    mockTime.Setup(t => t.Now).Returns(new DateTime(2024, 1, 15, 10, 0, 0)); // Monday 10 AM

    var service = new BusinessHoursService(mockTime.Object);
    var result = service.IsBusinessHours();

    await Assert.That(result).IsTrue(); // Always passes
}
```

#### 4. External Service Dependencies

**Symptom:** Test fails when network is slow or service is down.

```csharp
// ❌ Flaky - depends on external API
[Test]
public async Task FetchUserData()
{
    var client = new HttpClient();
    var response = await client.GetStringAsync("https://api.example.com/users/1");

    await Assert.That(response).Contains("username"); // Fails if API is down
}

// ✅ Fixed - mock the HTTP call
[Test]
public async Task FetchUserData()
{
    var mockHandler = new Mock<HttpMessageHandler>();
    mockHandler.Protected()
        .Setup<Task<HttpResponseMessage>>("SendAsync",
            ItExpr.IsAny<HttpRequestMessage>(),
            ItExpr.IsAny<CancellationToken>())
        .ReturnsAsync(new HttpResponseMessage
        {
            Content = new StringContent("{\"username\": \"alice\"}")
        });

    var client = new HttpClient(mockHandler.Object);
    var response = await client.GetStringAsync("https://api.example.com/users/1");

    await Assert.That(response).Contains("username"); // Always passes
}
```

### Strategies for Reproducing Flaky Tests

1. **Run Tests Multiple Times**
   ```bash
   # Run test 100 times to expose flakiness
   for i in {1..100}; do dotnet run -- --treenode-filter "/*/*/*/FlakyTest"; done
   ```

2. **Run with Maximum Parallelism**
   ```bash
   dotnet run -- --parallel --max-parallel-threads 8
   ```

3. **Add Delays to Expose Race Conditions**
   ```csharp
   [Test]
   public async Task TestWithDelay()
   {
       await Task.Delay(Random.Shared.Next(0, 100)); // Random delay
       // Test logic
   }
   ```

4. **Enable Detailed Logging**
   ```csharp
   [Test]
   public async Task TestWithLogging()
   {
       TestContext.Current?.WriteLine($"Starting test at {DateTime.Now:O}");
       // Test logic
       TestContext.Current?.WriteLine($"Completed test at {DateTime.Now:O}");
   }
   ```

## Dependency Injection Issues

### Services Not Available

**Symptoms:**
- `GetRequiredService` throws exceptions
- Null reference exceptions in tests
- "No service registered" errors

**Common Error Messages:**
- `InvalidOperationException: No service for type 'IMyService' has been registered`

**Solutions:**

#### 1. Ensure Services Are Registered
```csharp
// In your test setup or configuration
[Before(HookType.Assembly)]
public static void ConfigureServices()
{
    var services = new ServiceCollection();
    services.AddSingleton<IMyService, MyService>();
    // Register services...
}
```

#### 2. Check Service Lifetime
```csharp
[Test]
public void ServiceLifetimeTest()
{
    // Scoped services need proper scope handling
    using var scope = ServiceProvider.CreateScope();
    var service = scope.ServiceProvider.GetRequiredService<IScopedService>();
}
```

## Data-Driven Test Issues

### Data Source Timeout

**Symptoms:**
- "Data source timed out" errors
- Tests fail before execution
- Discovery phase hangs

**Solutions:**

#### 1. Optimize Data Generation
```csharp
// ❌ Slow data generation
public static IEnumerable<User> GetUsers()
{
    return DatabaseQuery.GetAllUsers(); // Expensive operation
}

// ✅ Lightweight data generation
public static IEnumerable<User> GetUsers()
{
    yield return new User { Id = 1, Name = "Test1" };
    yield return new User { Id = 2, Name = "Test2" };
}
```

#### 2. Increase Data Source Timeout
```csharp
// Configure in test assembly attributes or configuration
[assembly: DataSourceTimeout(30000)] // 30 seconds
```

### Matrix Test Explosion

**Symptoms:**
- Thousands of test combinations generated
- Test discovery takes forever
- Out of memory errors

**Solution:**
```csharp
// ❌ Explosive combination
[Test]
[MatrixDataSource]
public void Test(
    [Matrix(1, 2, 3, 4, 5)] int x,
    [Matrix("a", "b", "c", "d", "e")] string y,
    [Matrix(true, false)] bool z)
// Creates 5 × 5 × 2 = 50 combinations!

// ✅ Use specific combinations instead
[Test]
[Arguments(1, "a", true)]
[Arguments(2, "b", false)]
[Arguments(3, "c", true)]
public void Test(int x, string y, bool z)
// Only 3 specific test cases
```

## Memory and Performance Issues

### High Memory Usage

**Symptoms:**
- Out of memory exceptions
- Slow test execution
- System becomes unresponsive

**Common Error Messages:**
- `OutOfMemoryException: Insufficient memory to continue the execution`

**Solutions:**

#### 1. Dispose Resources Properly
```csharp
[Test]
public async Task ResourceIntensiveTest()
{
    using var largeResource = new LargeResource();
    // Test logic
    // Resource automatically disposed
}
```

#### 2. Limit Parallel Execution
```csharp
[ParallelLimiter<Conservative>]
public class MemoryIntensiveTests
{
    // Limit concurrent execution
}

public class Conservative : IParallelLimit
{
    public int Limit => 2; // Max 2 tests in parallel
}
```

#### 3. Clear Test Data Between Runs
```csharp
[After(HookType.Test)]
public void Cleanup()
{
    GC.Collect(); // Force garbage collection if needed
    _testData.Clear();
}
```

## Hook and Lifecycle Issues

### Hooks Not Executing

**Symptoms:**
- Setup/cleanup code not running
- Database not initialized
- Resources not cleaned up

**Solutions:**

#### 1. Check Hook Scope
```csharp
// ❌ Instance method for class-level hook
[Before(HookType.Class)]
public void ClassSetup() { } // Won't work!

// ✅ Static method for class-level hook
[Before(HookType.Class)]
public static void ClassSetup() { } // Works!
```

#### 2. Verify Hook Order
```csharp
// Hooks execute in this order:
// 1. Assembly Before
// 2. Class Before
// 3. Test Before
// 4. TEST EXECUTION
// 5. Test After
// 6. Class After (after all tests in class)
// 7. Assembly After (after all tests)
```

### Async Initialization Issues

**Symptoms:**
- "Cannot await in constructor" errors
- Resources not ready when test starts

**Solution:**
```csharp
public class DatabaseTests : IAsyncInitializer
{
    private DatabaseConnection _connection;

    // Async initialization
    public async Task InitializeAsync()
    {
        _connection = await DatabaseConnection.CreateAsync();
    }

    [Test]
    public async Task TestDatabase()
    {
        // _connection is guaranteed to be initialized
    }
}
```

## IDE Integration Issues

### Visual Studio Test Explorer Issues

**Symptoms:**
- Tests not showing in Test Explorer
- "Run Test" option missing
- Test status not updating

**Solutions:**

1. **Enable Testing Platform Support**
   - Tools > Options > Preview Features
   - Enable "Use testing platform server mode"
   - Restart Visual Studio

2. **Clean and Rebuild**
   ```bash
   dotnet clean
   dotnet build
   ```

3. **Clear Test Cache**
   - Close Visual Studio
   - Delete `.vs` folder
   - Reopen and rebuild

### Rider Test Explorer Issues

**Solutions:**

1. **Enable Testing Platform Support**
   - Settings > Build, Execution, Deployment > Unit Testing > Testing Platform
   - Enable "Testing Platform support"
   - Restart Rider

2. **Invalidate Caches**
   - File > Invalidate Caches / Restart
   - Choose "Invalidate and Restart"

### VS Code Test Explorer Issues

**Solutions:**

1. **Install C# Dev Kit**
   - Ensure latest version is installed
   - Install from Extensions marketplace

2. **Configure Test Settings**
   ```json
   {
     "dotnet.testWindow.useTestingPlatformProtocol": true
   }
   ```

3. **Reload Window**
   - Ctrl+Shift+P > "Developer: Reload Window"

## Platform-Specific Issues

### Linux/macOS File Path Issues

**Symptoms:**
- Tests fail on Linux/macOS but pass on Windows
- "File not found" errors

**Solution:**
```csharp
// ❌ Windows-specific paths
var path = @"C:\TestData\file.txt";

// ✅ Cross-platform paths
var path = Path.Combine("TestData", "file.txt");
```

### Line Ending Issues

**Solution:**
```csharp
// ❌ Hard-coded line endings
var expected = "Line1\r\nLine2";

// ✅ Platform-agnostic
var expected = $"Line1{Environment.NewLine}Line2";
```

## Code Coverage Issues

### Coverage Files Not Generated

**Symptoms:**
- No coverage files in TestResults folder
- `--coverage` flag has no effect
- Coverage reports empty or missing

**Common Error Messages:**
- `No coverage data collected`
- `Coverage tool initialization failed`

**Common Causes and Solutions:**

#### 1. Using TUnit.Engine Without Extensions
```xml
<!-- ❌ Missing coverage extension -->
<PackageReference Include="TUnit.Engine" Version="*" />

<!-- ✅ Includes coverage automatically -->
<PackageReference Include="TUnit" Version="*" />
```

**Fix:** Use the TUnit meta package, or manually add the coverage extension if using TUnit.Engine directly:
```xml
<PackageReference Include="TUnit.Engine" Version="*" />
<PackageReference Include="Microsoft.Testing.Extensions.CodeCoverage" Version="*" />
```

#### 2. Configuration Not Set to Release
```bash
# It's generally better to run coverage in Release configuration
dotnet run --configuration Release --coverage
```

#### 3. Basic Coverage Commands
```bash
# Basic usage
dotnet run --configuration Release --coverage

# With output location
dotnet run --configuration Release --coverage --coverage-output ./coverage/

# Specify format (cobertura, xml, etc.)
dotnet run --configuration Release --coverage --coverage-output-format cobertura
```

### Coverlet Still Installed

**Symptoms:**
- Coverage stopped working after migrating to TUnit
- Conflicts between coverage tools
- "Could not load file or assembly" errors related to coverage

**Common Error Messages:**
- `System.IO.FileNotFoundException: Could not load file or assembly 'Coverlet.Core'`

**Root Cause:** Coverlet is **not compatible** with TUnit because:
- Coverlet requires VSTest platform
- TUnit uses Microsoft.Testing.Platform
- These platforms are mutually exclusive

**Solution:**

1. **Remove Coverlet packages** from your `.csproj`:
```xml
<!-- Remove these lines -->
<PackageReference Include="coverlet.collector" Version="*" />
<PackageReference Include="coverlet.msbuild" Version="*" />
```

2. **Ensure TUnit meta package is installed**:
```xml
<PackageReference Include="TUnit" Version="*" />
```

3. **Update coverage commands**:
```bash
# Old (VSTest + Coverlet)
dotnet test --collect:"XPlat Code Coverage"

# New (TUnit + Microsoft Coverage)
dotnet run --configuration Release --coverage
```

### Missing Coverage for Some Assemblies

**Symptoms:**
- Coverage reports show 0% for some projects
- Some assemblies excluded from coverage
- Unexpected gaps in coverage

**Solutions:**

#### 1. Create a `testconfig.json` File
```json
{
  "codeCoverage": {
    "Configuration": {
      "CodeCoverage": {
        "ModulePaths": {
          "Include": [".*\\.dll$", ".*MyProject\\.dll$"],
          "Exclude": [".*tests?\\.dll$", ".*TestHelpers\\.dll$"]
        }
      }
    }
  }
}
```

#### 2. Place the File in Your Test Project Directory
The `testconfig.json` file is picked up automatically. Alternatively, you can use an XML coverage settings file:
```bash
dotnet run --configuration Release --coverage --coverage-settings coverage.config
```

### Coverage Format Not Recognized by CI/CD

**Symptoms:**
- CI/CD doesn't display coverage results
- Coverage upload fails
- "Unsupported format" errors

**Solutions:**

#### 1. Check Output Format
```bash
# Default is Cobertura (widely supported)
dotnet run --configuration Release --coverage --coverage-output-format cobertura

# For Visual Studio
dotnet run --configuration Release --coverage --coverage-output-format xml

# Multiple formats
dotnet run --configuration Release --coverage \
  --coverage-output-format cobertura \
  --coverage-output-format xml
```

#### 2. Verify Output Location
```bash
# Coverage files generated in TestResults by default
ls TestResults/

# Expected files:
# - coverage.cobertura.xml
# - <guid>/coverage.xml
```

#### 3. Common CI/CD Configurations

**GitHub Actions:**
```yaml
- name: Run tests with coverage
  run: dotnet run --project tests/MyProject.Tests --configuration Release --coverage

- name: Upload coverage to Codecov
  uses: codecov/codecov-action@v3
  with:
    files: ./tests/MyProject.Tests/TestResults/**/coverage.cobertura.xml
```

**Azure Pipelines:**
```yaml
- task: DotNetCoreCLI@2
  inputs:
    command: 'run'
    projects: 'tests/**/*.csproj'
    arguments: '--configuration Release --coverage --coverage-output $(Agent.TempDirectory)/coverage/'

- task: PublishCodeCoverageResults@2
  inputs:
    summaryFileLocation: '$(Agent.TempDirectory)/coverage/**/coverage.cobertura.xml'
```

### Coverage Percentage Seems Wrong

**Symptoms:**
- Coverage percentage doesn't match expectations
- Test code included in coverage
- Dependencies inflating coverage numbers

**Solutions:**

#### 1. Exclude Test Projects

In your `testconfig.json`:
```json
{
  "codeCoverage": {
    "Configuration": {
      "CodeCoverage": {
        "ModulePaths": {
          "Exclude": [".*tests?\\.dll$", ".*\\.Tests\\.dll$"]
        }
      }
    }
  }
}
```

#### 2. Exclude Generated Code

In your `testconfig.json`:
```json
{
  "codeCoverage": {
    "Configuration": {
      "CodeCoverage": {
        "Sources": {
          "Exclude": [".*\\.g\\.cs$", ".*\\.Designer\\.cs$"]
        }
      }
    }
  }
}
```

#### 3. Include Only Production Code

In your `testconfig.json`:
```json
{
  "codeCoverage": {
    "Configuration": {
      "CodeCoverage": {
        "ModulePaths": {
          "Include": [".*MyCompany\\.MyProduct\\..*\\.dll$"],
          "Exclude": [".*tests?\\.dll$"]
        }
      }
    }
  }
}
```

## Debugging Tips

### Enable Diagnostic Logging

```bash
# Run with diagnostic output
dotnet test --logger "console;verbosity=detailed"

# Enable TUnit diagnostics
dotnet run -- --diagnostic
```

### Attach Debugger to Test

```csharp
[Test]
public void DebuggableTest()
{
    #if DEBUG
    Debugger.Launch(); // Prompts to attach debugger
    #endif

    // Test logic
}
```

### Capture Test Output

```csharp
[Test]
public async Task TestWithOutput()
{
    TestContext.Current?.WriteLine("Debug: Starting test");

    var result = await Operation();

    TestContext.Current?.WriteLine($"Debug: Result = {result}");

    await Assert.That(result).IsNotNull();
}
```

## Getting Help

If you're still experiencing issues:

1. **Check the Documentation**: Review relevant sections of the TUnit documentation
2. **Search Issues**: Check [GitHub Issues](https://github.com/thomhurst/TUnit/issues) for similar problems
3. **Enable Diagnostics**: Run with `--diagnostic` flag for detailed logs
4. **Create Minimal Reproduction**: Isolate the issue in a small test project
5. **Report Issue**: If it's a bug, report it with:
   - TUnit version
   - .NET version
   - Minimal code to reproduce
   - Full error messages and stack traces

Remember to check for updates - many issues are resolved in newer versions of TUnit.
