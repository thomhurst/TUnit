namespace TUnit.Core;

/// <summary>
/// Builds TestDefinition instances from StaticTestDefinition at runtime.
/// This class is AOT and trimming compatible as it uses only pre-compiled delegates
/// and direct type references generated by the source generator.
/// </summary>
public class StaticTestBuilder : ITestDefinitionBuilder
{
    /// <summary>
    /// Builds all test definitions from the given test descriptor.
    /// </summary>
    public async Task<IEnumerable<TestDefinition>> BuildTestDefinitionsAsync(ITestDescriptor testDescriptor, CancellationToken cancellationToken = default)
    {
        if (testDescriptor is not StaticTestDefinition staticDef)
        {
            throw new ArgumentException($"StaticTestBuilder can only process StaticTestDefinition, not {testDescriptor.GetType().Name}");
        }
        
        return await BuildTestsFromStaticDefinitionAsync(staticDef, cancellationToken);
    }
    
    /// <summary>
    /// Builds all test definitions from the given static definition.
    /// All delegates and types are pre-compiled by the source generator.
    /// </summary>
    private async Task<IEnumerable<TestDefinition>> BuildTestsFromStaticDefinitionAsync(
        StaticTestDefinition staticDef, 
        CancellationToken cancellationToken = default)
    {
        var testDefinitions = new List<TestDefinition>();
        
        // Get all test data combinations from data providers
        var classArgsList = (await staticDef.ClassDataProvider.GetData()).ToList();
        var methodArgsList = (await staticDef.MethodDataProvider.GetData()).ToList();
        var propertyValuesList = staticDef.PropertyValuesProvider().ToList();
        
        // Default to single iteration if no data
        if (!propertyValuesList.Any()) propertyValuesList.Add(new Dictionary<string, object?>());
        
        var testIndex = 0;
        
        // Generate test definitions for all combinations
        foreach (var classArgs in classArgsList)
        {
            foreach (var methodArgs in methodArgsList)
            {
                foreach (var propertyValues in propertyValuesList)
                {
                    for (var repeatIndex = 0; repeatIndex < staticDef.RepeatCount; repeatIndex++)
                    {
                        var testDefinition = BuildSingleTestDefinition(
                            staticDef, 
                            classArgs, 
                            methodArgs, 
                            propertyValues,
                            testIndex,
                            repeatIndex);
                        
                        testDefinitions.Add(testDefinition);
                        testIndex++;
                        
                        // Check cancellation periodically
                        if (testIndex % 100 == 0)
                        {
                            cancellationToken.ThrowIfCancellationRequested();
                        }
                    }
                }
            }
        }
        
        return await Task.FromResult(testDefinitions);
    }
    
    private TestDefinition BuildSingleTestDefinition(
        StaticTestDefinition staticDef,
        object?[] classArgs,
        object?[] methodArgs,
        IDictionary<string, object?> propertyValues,
        int testIndex,
        int repeatIndex)
    {
        // Build test ID from template
        var testId = staticDef.TestId
            .Replace("{TestIndex}", testIndex.ToString())
            .Replace("{RepeatIndex}", repeatIndex.ToString());
        
        // Build display name
        var displayName = BuildDisplayName(staticDef.DisplayName, methodArgs);
        
        // Create test class factory
        Func<object> testClassFactory = () =>
        {
            // Use the pre-compiled factory from source generator
            var instance = staticDef.ClassFactory(classArgs);
            
            // TODO: Handle property setting if needed
            
            return instance!;
        };
        
        // Use the pre-compiled method invoker
        Func<object, CancellationToken, ValueTask> testMethodInvoker = 
            async (instance, ct) => await staticDef.MethodInvoker(instance, methodArgs);
        
        // Create metadata for the test method
        var methodMetadata = CreateMethodMetadata(staticDef);
        
        return new TestDefinition
        {
            TestId = testId,
            MethodMetadata = methodMetadata,
            TestFilePath = staticDef.TestFilePath,
            TestLineNumber = staticDef.TestLineNumber,
            TestClassFactory = testClassFactory,
            TestMethodInvoker = testMethodInvoker,
            PropertiesProvider = () => propertyValues,
            ClassDataProvider = new SingleArgumentsDataProvider(classArgs),
            MethodDataProvider = new SingleArgumentsDataProvider(methodArgs)
        };
    }
    
    private static string BuildDisplayName(string template, object?[] args)
    {
        if (args.Length == 0)
        {
            return template;
        }
        
        try
        {
            var formattedArgs = args.Select(FormatArgumentValue).ToArray();
            return string.Format(template, formattedArgs);
        }
        catch
        {
            // If formatting fails, return the template as-is
            return template;
        }
    }
    
    private static string FormatArgumentValue(object? arg)
    {
        return arg switch
        {
            null => "null",
            string s => $"\"{s}\"",
            char c => $"'{c}'",
            bool b => b.ToString().ToLowerInvariant(),
            _ => arg.ToString() ?? "null"
        };
    }
    
    private static MethodMetadata CreateMethodMetadata(StaticTestDefinition staticDef)
    {
        return new MethodMetadata
        {
            Name = staticDef.TestMethodInfo.Name,
            ReflectionInformation = staticDef.TestMethodInfo,
            Parameters = Array.Empty<ParameterMetadata>(),
            GenericTypeCount = 0,
            Class = new ClassMetadata 
            { 
                Type = staticDef.TestClassType,
                Name = staticDef.TestClassType.Name,
                Namespace = staticDef.TestClassType.Namespace ?? string.Empty,
                TypeReference = TypeReference.CreateConcrete(staticDef.TestClassType.AssemblyQualifiedName!),
                Assembly = new AssemblyMetadata
                {
                    Name = staticDef.TestClassType.Assembly.GetName().Name ?? string.Empty,
                    Attributes = Array.Empty<AttributeMetadata>()
                },
                Parameters = Array.Empty<ParameterMetadata>(),
                Properties = Array.Empty<PropertyMetadata>(),
                Parent = null,
                Attributes = Array.Empty<AttributeMetadata>()
            },
            ReturnTypeReference = TypeReference.CreateConcrete(staticDef.TestMethodInfo.ReturnType.AssemblyQualifiedName!),
            ReturnType = staticDef.TestMethodInfo.ReturnType,
            TypeReference = TypeReference.CreateConcrete(staticDef.TestClassType.AssemblyQualifiedName!),
            Type = staticDef.TestClassType,
            Attributes = Array.Empty<AttributeMetadata>()
        };
    }
}