using System.Text;
using TUnit.Core.Extensions;
using TUnit.Core.Interfaces;

namespace TUnit.Core.Services;

/// <summary>
/// Enhances existing source generators with dual-mode AOT-safe capabilities.
/// This class provides utilities to augment TUnit's source generation with AOT safety.
/// </summary>
public class SourceGeneratorEnhancer
{
    private readonly AotTestFactoryGenerator _factoryGenerator;
    private readonly ICompileTimeDataResolver _dataResolver;
    private readonly CompileTimeSafetyAnalyzer _safetyAnalyzer;

    public SourceGeneratorEnhancer(
        AotTestFactoryGenerator factoryGenerator,
        ICompileTimeDataResolver dataResolver,
        CompileTimeSafetyAnalyzer safetyAnalyzer)
    {
        _factoryGenerator = factoryGenerator;
        _dataResolver = dataResolver;
        _safetyAnalyzer = safetyAnalyzer;
    }

    /// <summary>
    /// Generates complete AOT-safe source code for a test class.
    /// This method creates all necessary factories, invokers, and registration code.
    /// </summary>
    /// <param name="classMetadata">The test class metadata</param>
    /// <param name="testMethods">The test methods in the class</param>
    /// <returns>Complete source code for AOT-safe test execution</returns>
#pragma warning disable CS1998 // Async method lacks await
    public async Task<string> GenerateAotSafeTestClassAsync(
        ClassMetadata classMetadata, 
        IEnumerable<MethodMetadata> testMethods)
    {
        var code = new StringBuilder();
        
        // Generate file header
        code.AppendLine("// <auto-generated />");
        code.AppendLine("// Generated by TUnit Source Generator with AOT safety enhancements");
        code.AppendLine();
        
        // Add necessary using statements
        code.AppendLine("using System;");
        code.AppendLine("using System.Threading.Tasks;");
        code.AppendLine("using TUnit.Core.Models;");
        code.AppendLine("using TUnit.Core.Services;");
        code.AppendLine();

        var namespaceName = classMetadata.Type.Namespace ?? "Global";
        code.AppendLine($"namespace {namespaceName}");
        code.AppendLine("{");

        // Generate class factory
        try
        {
            var classFactory = _factoryGenerator.GenerateClassFactory(classMetadata);
            code.AppendLine(IndentCode(classFactory, 1));
            code.AppendLine();
        }
        catch (Exception ex)
        {
            code.AppendLine($"    // Error generating class factory: {ex.Message}");
            code.AppendLine();
        }

        // Generate method invokers for each test method
        foreach (var method in testMethods)
        {
            try
            {
                var methodInvoker = _factoryGenerator.GenerateMethodInvoker(method);
                code.AppendLine(IndentCode(methodInvoker, 1));
                code.AppendLine();
            }
            catch (Exception ex)
            {
                code.AppendLine($"    // Error generating method invoker for {method.Name}: {ex.Message}");
                code.AppendLine();
            }
        }

        // Generate MethodDataSource factories if any test methods use them
        try
        {
            var methodDataSourceFactories = _factoryGenerator.GenerateMethodDataSourceFactories(classMetadata, testMethods);
            if (!string.IsNullOrWhiteSpace(methodDataSourceFactories))
            {
                code.AppendLine(IndentCode(methodDataSourceFactories, 1));
                code.AppendLine();
            }
        }
        catch (Exception ex)
        {
            code.AppendLine($"    // Error generating MethodDataSource factories: {ex.Message}");
            code.AppendLine();
        }

        // Generate AsyncDataSource factories if any test methods use them
        try
        {
            var asyncDataSourceFactories = _factoryGenerator.GenerateAsyncDataSourceFactories(classMetadata, testMethods);
            if (!string.IsNullOrWhiteSpace(asyncDataSourceFactories))
            {
                code.AppendLine(IndentCode(asyncDataSourceFactories, 1));
                code.AppendLine();
            }
        }
        catch (Exception ex)
        {
            code.AppendLine($"    // Error generating AsyncDataSource factories: {ex.Message}");
            code.AppendLine();
        }

        // Generate property setters for injectable properties
        var injectableProperties = GetInjectableProperties(classMetadata);
        foreach (var property in injectableProperties)
        {
            try
            {
                var propertySetter = _factoryGenerator.GeneratePropertySetter(classMetadata, property.Name);
                code.AppendLine(IndentCode(propertySetter, 1));
                code.AppendLine();
            }
            catch (Exception ex)
            {
                code.AppendLine($"    // Error generating property setter for {property.Name}: {ex.Message}");
                code.AppendLine();
            }
        }

        // Generate registration class
        code.AppendLine(GenerateRegistrationClass(classMetadata, testMethods));

        code.AppendLine("}");
        return code.ToString();
    }

    /// <summary>
    /// Generates data resolution code for compile-time data sources.
    /// </summary>
    /// <param name="classMetadata">The test class metadata</param>
    /// <param name="methodMetadata">The test method metadata</param>
    /// <returns>Generated data resolution code</returns>
    public async Task<string> GenerateDataResolutionAsync(
        ClassMetadata classMetadata, 
        MethodMetadata methodMetadata)
    {
        var code = new StringBuilder();
        
        try
        {
            var resolvedData = await _dataResolver.ResolveClassDataAsync(classMetadata);
            var methodData = await _dataResolver.ResolveMethodDataAsync(methodMetadata);
            var propertyData = await _dataResolver.ResolvePropertyDataAsync(classMetadata);

            var className = classMetadata.Type.Name;
            var methodName = methodMetadata.Name;

            code.AppendLine($"// Generated data resolution for {className}.{methodName}");
            code.AppendLine($"public static class {className}_{methodName}_Data");
            code.AppendLine("{");

            // Generate class data
            if (resolvedData.Any())
            {
                code.AppendLine("    public static readonly object?[][] ClassData = new object?[][]");
                code.AppendLine("    {");
                foreach (var data in resolvedData)
                {
                    var dataString = string.Join(", ", data.Select(FormatDataValue));
                    code.AppendLine($"        new object?[] {{ {dataString} }},");
                }
                code.AppendLine("    };");
                code.AppendLine();
            }

            // Generate method data
            if (methodData.Any())
            {
                code.AppendLine("    public static readonly object?[][] MethodData = new object?[][]");
                code.AppendLine("    {");
                foreach (var data in methodData)
                {
                    var dataString = string.Join(", ", data.Select(FormatDataValue));
                    code.AppendLine($"        new object?[] {{ {dataString} }},");
                }
                code.AppendLine("    };");
                code.AppendLine();
            }

            // Generate property data
            if (propertyData.Any())
            {
                code.AppendLine("    public static readonly System.Collections.Generic.Dictionary<string, object?> PropertyData = new()");
                code.AppendLine("    {");
                foreach (var (key, value) in propertyData)
                {
                    code.AppendLine($"        {{ \"{key}\", {FormatDataValue(value)} }},");
                }
                code.AppendLine("    };");
            }

            code.AppendLine("}");
        }
        catch (Exception ex)
        {
            code.AppendLine($"// Error generating data resolution: {ex.Message}");
        }

        return code.ToString();
    }

    /// <summary>
    /// Generates safety analysis comments for source code.
    /// </summary>
    /// <param name="classMetadata">The test class metadata</param>
    /// <param name="methodMetadata">The test method metadata</param>
    /// <returns>Generated safety analysis comments</returns>
    public string GenerateSafetyAnalysis(ClassMetadata classMetadata, MethodMetadata methodMetadata)
    {
        var code = new StringBuilder();
        
        try
        {
            var classAnalysis = _safetyAnalyzer.AnalyzeClass(classMetadata);
            var methodAnalysis = _safetyAnalyzer.AnalyzeMethod(methodMetadata);

            code.AppendLine("// AOT Safety Analysis:");
            code.AppendLine($"// Class {classMetadata.Type.Name}: {(classAnalysis.IsSafe ? "SAFE" : "UNSAFE")}");
            code.AppendLine($"// Method {methodMetadata.Name}: {(methodAnalysis.IsSafe ? "SAFE" : "UNSAFE")}");

            if (!classAnalysis.IsSafe || !methodAnalysis.IsSafe)
            {
                code.AppendLine("// Issues found:");
                foreach (var issue in classAnalysis.Issues.Concat(methodAnalysis.Issues))
                {
                    code.AppendLine($"//   {issue.Severity}: {issue.Message}");
                }

                code.AppendLine("// Recommendations:");
                foreach (var recommendation in classAnalysis.Recommendations.Concat(methodAnalysis.Recommendations))
                {
                    code.AppendLine($"//   - {recommendation}");
                }
            }
        }
        catch (Exception ex)
        {
            code.AppendLine($"// Error during safety analysis: {ex.Message}");
        }

        return code.ToString();
    }

    /// <summary>
    /// Generates a registration class that registers all factories and invokers.
    /// </summary>
    private string GenerateRegistrationClass(ClassMetadata classMetadata, IEnumerable<MethodMetadata> testMethods)
    {
        var code = new StringBuilder();
        var className = classMetadata.Type.Name;

        code.AppendLine($"    // Registration class for {className}");
        code.AppendLine($"    [System.Runtime.CompilerServices.ModuleInitializer]");
        code.AppendLine($"    public static class {className}_Registration");
        code.AppendLine("    {");
        code.AppendLine("        public static void Initialize()");
        code.AppendLine("        {");

        foreach (var method in testMethods)
        {
            var testId = $"{classMetadata.Type.FullName}.{method.Name}"; // Simplified test ID generation
            try
            {
                var registrationCode = _factoryGenerator.GenerateRegistrationCode(testId, classMetadata, method);
                code.AppendLine(IndentCode(registrationCode, 3));
            }
            catch (Exception ex)
            {
                code.AppendLine($"            // Error generating registration for {method.Name}: {ex.Message}");
            }
        }

        code.AppendLine("        }");
        code.AppendLine("    }");

        return code.ToString();
    }

    /// <summary>
    /// Gets properties that are eligible for dependency injection.
    /// </summary>
    private static IEnumerable<System.Reflection.PropertyInfo> GetInjectableProperties(ClassMetadata classMetadata)
    {
        return classMetadata.Type.GetProperties()
            .Where(p => p.CanWrite && HasPropertyInjectionAttribute(p));
    }

    /// <summary>
    /// Checks if a property has dependency injection attributes.
    /// </summary>
    private static bool HasPropertyInjectionAttribute(System.Reflection.PropertyInfo property)
    {
        return property.GetCustomAttributes(true).Any(attr => 
            attr.GetType().Name.Contains("Inject") || 
            attr.GetType().Name.Contains("Property"));
    }

    /// <summary>
    /// Formats a data value for code generation.
    /// </summary>
    private static string FormatDataValue(object? value)
    {
        return value switch
        {
            null => "null",
            string s => $"\"{s.Replace("\"", "\\\"")}\"",
            char c => $"'{c}'",
            bool b => b.ToString().ToLowerInvariant(),
            byte or sbyte or short or ushort or int or uint => value.ToString() ?? "0",
            long l => $"{l}L",
            ulong ul => $"{ul}UL",
            float f => $"{f}F",
            double d => $"{d}D",
            decimal m => $"{m}M",
            _ => $"/* {value.GetType().Name} */ null"
        };
    }

    /// <summary>
    /// Indents code by the specified number of levels.
    /// </summary>
    private static string IndentCode(string code, int indentLevel)
    {
        var indent = new string(' ', indentLevel * 4);
        var lines = code.Split(new[] { '\n' }, StringSplitOptions.None);
        return string.Join('\n', lines.Select(line => 
            string.IsNullOrWhiteSpace(line) ? line : indent + line));
    }
}

/// <summary>
/// Configuration for source generator enhancement.
/// </summary>
public sealed class SourceGeneratorEnhancementConfig
{
    /// <summary>
    /// Whether to generate AOT-safe factories.
    /// </summary>
    public bool GenerateAotFactories { get; init; } = true;

    /// <summary>
    /// Whether to include safety analysis comments.
    /// </summary>
    public bool IncludeSafetyAnalysis { get; init; } = true;

    /// <summary>
    /// Whether to resolve data sources at compile-time.
    /// </summary>
    public bool ResolveDataAtCompileTime { get; init; } = true;

    /// <summary>
    /// Whether to generate registration code.
    /// </summary>
    public bool GenerateRegistration { get; init; } = true;

    /// <summary>
    /// Minimum safety level required for code generation.
    /// </summary>
    public SafetyIssueSeverity MinimumSafetyLevel { get; init; } = SafetyIssueSeverity.Warning;
}