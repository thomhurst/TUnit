using System.Collections.Concurrent;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;

namespace TUnit.Core;

[DebuggerDisplay("{Type}")]
public record ClassMetadata : IMemberMetadata
{
    private static readonly ConcurrentDictionary<string, ClassMetadata> Cache = [];

    public static ClassMetadata GetOrAdd(string name, Func<ClassMetadata> factory)
    {
        // First try to get existing value
        if (Cache.TryGetValue(name, out var existing))
        {
            // If Parameters is empty but we're trying to add one with parameters,
            // update the cache with the new value
            var newValue = factory();
            if (existing.Parameters.Length == 0 && newValue.Parameters.Length > 0)
            {
                Cache.TryUpdate(name, newValue, existing);
                return newValue;
            }
            return existing;
        }
        
        // Otherwise add new value
        return Cache.GetOrAdd(name, _ => factory());
    }

    public virtual bool Equals(ClassMetadata? other)
    {
        return Type == other?.Type;
    }

    public override int GetHashCode()
    {
        return Type.GetHashCode();
    }

    public required TypeInfo TypeInfo { get; init; }

    [DynamicallyAccessedMembers(
        DynamicallyAccessedMemberTypes.PublicConstructors
        | DynamicallyAccessedMemberTypes.NonPublicConstructors
        | DynamicallyAccessedMemberTypes.PublicMethods
        | DynamicallyAccessedMemberTypes.PublicProperties)]
    public required Type Type { get; init; }

    public required string Name { get; init; }

    public required string? Namespace { get; init; }
    public required AssemblyMetadata Assembly { get; init; }
    public required ParameterMetadata[] Parameters { get; init; }

    public required PropertyMetadata[] Properties { get; init; }
    public required ClassMetadata? Parent { get; init; }

    // AOT-friendly properties added by source generator
    // These eliminate need for reflection at runtime

    /// <summary>
    /// Factory delegate to create instances without reflection.
    /// Populated by source generator for AOT scenarios.
    /// </summary>
    public Func<object?[], object>? ConstructorFactory { get; init; }

    /// <summary>
    /// Factory for parameterless constructor if available.
    /// Faster path when no arguments needed.
    /// </summary>
    public Func<object>? ParameterlessFactory { get; init; }

    /// <summary>
    /// Index of the constructor marked with [TestConstructor] in Parameters array.
    /// -1 if none found.
    /// </summary>
    public int TestConstructorIndex { get; init; } = -1;

    /// <summary>
    /// Delegate to initialize required properties.
    /// Generated by source generator for types with required members.
    /// </summary>
    public Action<object>? InitializeRequiredProperties { get; init; }

    /// <summary>
    /// Quick check if type has required properties.
    /// Avoids reflection-based property scanning.
    /// </summary>
    public bool HasRequiredProperties { get; init; }

    /// <summary>
    /// Cached interface types to avoid GetInterfaces() call.
    /// </summary>
    public Type[]? ImplementedInterfaces { get; init; }
}
