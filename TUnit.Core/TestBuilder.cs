using System.Reflection;
using TUnit.Core.Helpers;
using TUnit.Core.Interfaces;

namespace TUnit.Core;

/// <summary>
/// Builds TestDefinition instances from TestMetadata at runtime.
/// This class contains all the complex logic for expanding data sources, unwrapping tuples,
/// and creating test instances that was previously generated by the source generator.
/// </summary>
public class TestBuilder
{
    /// <summary>
    /// Builds all test definitions from the given metadata.
    /// Handles all data source combinations, tuple unwrapping, and property initialization.
    /// </summary>
    public async Task<IEnumerable<TestDefinition>> BuildTestsAsync(TestMetadata metadata, CancellationToken cancellationToken = default)
    {
        var testDefinitions = new List<TestDefinition>();
        
        // Get all combinations of class and method data
        var testCombinations = await GetTestCombinationsAsync(metadata, cancellationToken);
        
        var testIndex = 0;
        foreach (var combination in testCombinations)
        {
            // Handle repeat count
            for (var repeatIndex = 0; repeatIndex < metadata.RepeatCount; repeatIndex++)
            {
                var testDefinition = await BuildSingleTestDefinitionAsync(
                    metadata, 
                    combination, 
                    testIndex, 
                    repeatIndex,
                    cancellationToken);
                
                if (testDefinition != null)
                {
                    testDefinitions.Add(testDefinition);
                }
                
                testIndex++;
            }
        }
        
        return testDefinitions;
    }
    
    private async Task<List<TestCombination>> GetTestCombinationsAsync(
        TestMetadata metadata, 
        CancellationToken cancellationToken)
    {
        var combinations = new List<TestCombination>();
        
        // Get all class data combinations
        var classDataSets = await GetDataSetsAsync(metadata.ClassDataSources, cancellationToken);
        
        // Get all method data combinations
        var methodDataSets = await GetDataSetsAsync(metadata.MethodDataSources, cancellationToken);
        
        // Get all property data combinations
        var propertyDataSets = new Dictionary<PropertyInfo, List<object?[]>>();
        foreach (var (property, dataSource) in metadata.PropertyDataSources)
        {
            var dataSets = await GetDataSetsAsync(new[] { dataSource }, cancellationToken);
            propertyDataSets[property] = dataSets;
        }
        
        // Generate all combinations
        if (!classDataSets.Any())
            classDataSets.Add(Array.Empty<object?>());
        if (!methodDataSets.Any())
            methodDataSets.Add(Array.Empty<object?>());
        
        foreach (var classData in classDataSets)
        {
            foreach (var methodData in methodDataSets)
            {
                var propertyValues = new Dictionary<PropertyInfo, object?>();
                
                // For each property, we need to handle its data
                foreach (var (property, dataSets) in propertyDataSets)
                {
                    // For now, take the first value. This might need to be expanded
                    // based on how property data sources should combine with test data
                    if (dataSets.Any())
                    {
                        var data = dataSets.First();
                        if (data.Length > 0)
                        {
                            propertyValues[property] = data[0];
                        }
                    }
                }
                
                combinations.Add(new TestCombination
                {
                    ClassArguments = classData,
                    MethodArguments = methodData,
                    PropertyValues = propertyValues
                });
            }
        }
        
        return combinations;
    }
    
    private async Task<List<object?[]>> GetDataSetsAsync(
        IEnumerable<IDataSourceProvider> dataSourceProviders, 
        CancellationToken cancellationToken)
    {
        var allDataSets = new List<object?[]>();
        
        foreach (var provider in dataSourceProviders)
        {
            if (provider.IsAsync)
            {
                await foreach (var data in provider.GetDataAsync().WithCancellation(cancellationToken))
                {
                    allDataSets.Add(data);
                }
            }
            else
            {
                foreach (var data in provider.GetData())
                {
                    allDataSets.Add(data);
                }
            }
        }
        
        return allDataSets;
    }
    
    private async Task<TestDefinition?> BuildSingleTestDefinitionAsync(
        TestMetadata metadata,
        TestCombination combination,
        int testIndex,
        int repeatIndex,
        CancellationToken cancellationToken)
    {
        try
        {
            // Build test ID from template
            var testId = BuildTestId(metadata.TestIdTemplate, testIndex, repeatIndex);
            
            // Unwrap tuples if necessary
            var unwrappedClassArgs = UnwrapTuples(combination.ClassArguments, metadata.TestClassType);
            var unwrappedMethodArgs = UnwrapTuples(combination.MethodArguments, metadata.TestMethod);
            
            // Create factories that capture the current combination
            var classFactory = CreateClassFactory(metadata, unwrappedClassArgs, combination.PropertyValues);
            var methodInvoker = CreateMethodInvoker(metadata, unwrappedMethodArgs);
            var propertiesProvider = CreatePropertiesProvider(combination.PropertyValues);
            
            return new TestDefinition
            {
                TestId = testId,
                MethodMetadata = metadata.MethodMetadata,
                TestFilePath = metadata.TestFilePath,
                TestLineNumber = metadata.TestLineNumber,
                TestClassFactory = classFactory,
                TestMethodInvoker = methodInvoker,
                ClassArgumentsProvider = () => unwrappedClassArgs,
                MethodArgumentsProvider = () => unwrappedMethodArgs,
                PropertiesProvider = propertiesProvider
            };
        }
        catch (Exception ex)
        {
            // Log error and skip this test combination
            // In real implementation, this would use proper logging
            Console.WriteLine($"Failed to build test definition: {ex.Message}");
            return null;
        }
    }
    
    private string BuildTestId(string template, int testIndex, int repeatIndex)
    {
        // Replace placeholders in template
        return template
            .Replace("{TestIndex}", testIndex.ToString())
            .Replace("{RepeatIndex}", repeatIndex.ToString());
    }
    
    private object?[] UnwrapTuples(object?[] arguments, MemberInfo member)
    {
        // If we have a single tuple argument that needs to be unwrapped
        if (arguments.Length == 1 && arguments[0] != null)
        {
            var argType = arguments[0].GetType();
            if (IsTupleType(argType))
            {
                return UnwrapTuple(arguments[0]);
            }
        }
        
        return arguments;
    }
    
    private bool IsTupleType(Type type)
    {
        return type.IsGenericType && 
               type.FullName?.StartsWith("System.ValueTuple`") == true;
    }
    
    private object?[] UnwrapTuple(object tuple)
    {
        var tupleType = tuple.GetType();
        var fields = tupleType.GetFields();
        var values = new List<object?>();
        
        foreach (var field in fields.Where(f => f.Name.StartsWith("Item")))
        {
            var value = field.GetValue(tuple);
            
            // Handle nested tuples for > 7 items
            if (field.Name == "Rest" && value != null && IsTupleType(value.GetType()))
            {
                values.AddRange(UnwrapTuple(value));
            }
            else
            {
                values.Add(value);
            }
        }
        
        return values.ToArray();
    }
    
    private Func<object> CreateClassFactory(
        TestMetadata metadata, 
        object?[] classArgs,
        Dictionary<PropertyInfo, object?> propertyValues)
    {
        return () =>
        {
            var instance = metadata.TestClassFactory(classArgs);
            if (instance == null)
            {
                throw new InvalidOperationException($"Failed to create instance of {metadata.TestClassType.Name}");
            }
            
            // Initialize properties
            foreach (var (property, value) in propertyValues)
            {
                try
                {
                    // Handle async initialization if needed
                    if (value is IAsyncInitializer asyncInitializer)
                    {
                        // Note: This is sync-over-async which isn't ideal, but matches current behavior
                        // In a future iteration, we could make the entire factory async
                        Task.Run(async () => await ObjectInitializer.InitializeAsync(asyncInitializer)).GetAwaiter().GetResult();
                    }
                    
                    property.SetValue(instance, value);
                }
                catch (Exception ex)
                {
                    throw new InvalidOperationException(
                        $"Failed to set property {property.Name} on {metadata.TestClassType.Name}", ex);
                }
            }
            
            return instance;
        };
    }
    
    private Func<object, CancellationToken, ValueTask> CreateMethodInvoker(
        TestMetadata metadata, 
        object?[] methodArgs)
    {
        return async (instance, cancellationToken) =>
        {
            var result = metadata.TestMethod.Invoke(instance, methodArgs);
            
            if (result is Task task)
            {
                await task;
            }
            else if (result is ValueTask valueTask)
            {
                await valueTask;
            }
            // For sync methods, nothing to await
        };
    }
    
    private Func<IDictionary<string, object?>> CreatePropertiesProvider(
        Dictionary<PropertyInfo, object?> propertyValues)
    {
        return () =>
        {
            var properties = new Dictionary<string, object?>();
            
            foreach (var (property, value) in propertyValues)
            {
                properties[property.Name] = value;
            }
            
            return properties;
        };
    }
    
    private class TestCombination
    {
        public required object?[] ClassArguments { get; init; }
        public required object?[] MethodArguments { get; init; }
        public required Dictionary<PropertyInfo, object?> PropertyValues { get; init; }
    }
}