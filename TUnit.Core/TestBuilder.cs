using System.Collections.Concurrent;
using System.Diagnostics;
using System.Linq.Expressions;
using System.Reflection;
using TUnit.Core.Configuration;
using TUnit.Core.Helpers;
using TUnit.Core.Interfaces;

namespace TUnit.Core;

/// <summary>
/// Builds TestDefinition instances from TestMetadata at runtime.
/// This class contains all the complex logic for expanding data sources, unwrapping tuples,
/// and creating test instances that was previously generated by the source generator.
/// Includes performance optimizations with expression compilation and caching.
/// </summary>
public class TestBuilder
{
    // Caches for reflection operations - thread-safe for concurrent test discovery
    private static readonly ConcurrentDictionary<Type, ConstructorInfo?> ConstructorCache = new();
    private static readonly ConcurrentDictionary<(Type, string), PropertyInfo?> PropertyCache = new();
    private static readonly ConcurrentDictionary<Type, bool> TupleTypeCache = new();
    private static readonly ConcurrentDictionary<MethodInfo, Func<object?, object?[], object?>> MethodInvokerCache = new();
    private static readonly ConcurrentDictionary<PropertyInfo, Action<object, object?>> PropertySetterCache = new();
    private static readonly ConcurrentDictionary<Type, Func<object?[], object>> ConstructorInvokerCache = new();
    
    /// <summary>
    /// Builds all test definitions from the given metadata.
    /// Handles all data source combinations, tuple unwrapping, and property initialization.
    /// </summary>
    public async Task<IEnumerable<TestDefinition>> BuildTestsAsync(TestMetadata metadata, CancellationToken cancellationToken = default)
    {
        var stopwatch = TUnitConfiguration.EnableDiagnostics ? Stopwatch.StartNew() : null;
        
        if (TUnitConfiguration.EnableDiagnostics)
        {
            Console.WriteLine($"[TestBuilder] Building tests for {metadata.TestClassType.Name}.{metadata.TestMethod.Name}");
        }
        
        var testDefinitions = new List<TestDefinition>();
        
        // Pre-compile delegates for this metadata for better performance
        var compiledFactories = CompileFactories(metadata);
        
        // Get all combinations of class and method data
        var testCombinations = await GetTestCombinationsAsync(metadata, cancellationToken);
        
        if (TUnitConfiguration.EnableDiagnostics)
        {
            Console.WriteLine($"[TestBuilder] Found {testCombinations.Count} test combinations");
        }
        
        var testIndex = 0;
        foreach (var combination in testCombinations)
        {
            // Handle repeat count
            for (var repeatIndex = 0; repeatIndex < metadata.RepeatCount; repeatIndex++)
            {
                var testDefinition = await BuildSingleTestDefinitionAsync(
                    metadata, 
                    combination, 
                    testIndex, 
                    repeatIndex,
                    compiledFactories,
                    cancellationToken);
                
                if (testDefinition != null)
                {
                    testDefinitions.Add(testDefinition);
                }
                
                testIndex++;
            }
        }
        
        if (TUnitConfiguration.EnableDiagnostics && stopwatch != null)
        {
            stopwatch.Stop();
            Console.WriteLine($"[TestBuilder] Built {testDefinitions.Count} tests in {stopwatch.ElapsedMilliseconds}ms");
        }
        
        return testDefinitions;
    }
    
    private CompiledFactories CompileFactories(TestMetadata metadata)
    {
        return new CompiledFactories
        {
            ClassFactory = GetOrCompileConstructor(metadata.TestClassType),
            MethodInvoker = GetOrCompileMethodInvoker(metadata.TestMethod),
            PropertySetters = metadata.PropertyDataSources.Keys
                .ToDictionary(p => p, GetOrCompilePropertySetter)
        };
    }
    
    private Func<object?[], object> GetOrCompileConstructor(Type type)
    {
        return ConstructorInvokerCache.GetOrAdd(type, t =>
        {
            var ctor = ConstructorCache.GetOrAdd(t, type =>
                type.GetConstructors()
                    .OrderBy(c => c.GetParameters().Length)
                    .FirstOrDefault());
            
            if (ctor == null)
            {
                return args => throw new InvalidOperationException($"No accessible constructor found for {type.Name}");
            }
            
            // Compile expression for faster invocation
            var parameters = Expression.Parameter(typeof(object?[]), "args");
            var ctorParams = ctor.GetParameters();
            
            var arguments = new Expression[ctorParams.Length];
            for (int i = 0; i < ctorParams.Length; i++)
            {
                var index = Expression.Constant(i);
                var paramType = ctorParams[i].ParameterType;
                var argument = Expression.ArrayIndex(parameters, index);
                arguments[i] = Expression.Convert(argument, paramType);
            }
            
            var newExpr = Expression.New(ctor, arguments);
            var lambda = Expression.Lambda<Func<object?[], object>>(
                Expression.Convert(newExpr, typeof(object)),
                parameters);
            
            return lambda.Compile();
        });
    }
    
    private Func<object?, object?[], object?> GetOrCompileMethodInvoker(MethodInfo method)
    {
        return MethodInvokerCache.GetOrAdd(method, m =>
        {
            // Compile expression for method invocation
            var instanceParam = Expression.Parameter(typeof(object), "instance");
            var argsParam = Expression.Parameter(typeof(object?[]), "args");
            
            var methodParams = m.GetParameters();
            var arguments = new Expression[methodParams.Length];
            
            for (int i = 0; i < methodParams.Length; i++)
            {
                var index = Expression.Constant(i);
                var paramType = methodParams[i].ParameterType;
                var argument = Expression.ArrayIndex(argsParam, index);
                arguments[i] = Expression.Convert(argument, paramType);
            }
            
            var instanceCast = m.IsStatic ? null : Expression.Convert(instanceParam, m.DeclaringType!);
            var methodCall = m.IsStatic 
                ? Expression.Call(m, arguments)
                : Expression.Call(instanceCast!, m, arguments);
            
            // Handle void methods
            Expression body;
            if (m.ReturnType == typeof(void))
            {
                body = Expression.Block(methodCall, Expression.Constant(null, typeof(object)));
            }
            else
            {
                body = Expression.Convert(methodCall, typeof(object));
            }
            
            var lambda = Expression.Lambda<Func<object?, object?[], object?>>(
                body,
                instanceParam,
                argsParam);
            
            return lambda.Compile();
        });
    }
    
    private Action<object, object?> GetOrCompilePropertySetter(PropertyInfo property)
    {
        return PropertySetterCache.GetOrAdd(property, p =>
        {
            if (!p.CanWrite)
            {
                return (obj, value) => throw new InvalidOperationException($"Property {p.Name} is read-only");
            }
            
            // Compile expression for property setter
            var instanceParam = Expression.Parameter(typeof(object), "instance");
            var valueParam = Expression.Parameter(typeof(object), "value");
            
            var instanceCast = Expression.Convert(instanceParam, p.DeclaringType!);
            var valueCast = Expression.Convert(valueParam, p.PropertyType);
            
            var propertyAccess = Expression.Property(instanceCast, p);
            var assignment = Expression.Assign(propertyAccess, valueCast);
            
            var lambda = Expression.Lambda<Action<object, object?>>(
                assignment,
                instanceParam,
                valueParam);
            
            return lambda.Compile();
        });
    }
    
    private async Task<List<TestCombination>> GetTestCombinationsAsync(
        TestMetadata metadata, 
        CancellationToken cancellationToken)
    {
        var combinations = new List<TestCombination>();
        
        // Get all data sets in parallel for better performance
        var classDataTask = GetDataSetsAsync(metadata.ClassDataSources, cancellationToken);
        var methodDataTask = GetDataSetsAsync(metadata.MethodDataSources, cancellationToken);
        
        var classDataSets = await classDataTask;
        var methodDataSets = await methodDataTask;
        
        // Get property data sets
        var propertyDataTasks = metadata.PropertyDataSources
            .Select(async kvp => (kvp.Key, await GetDataSetsAsync(new[] { kvp.Value }, cancellationToken)))
            .ToArray();
        
        var propertyDataResults = await Task.WhenAll(propertyDataTasks);
        var propertyDataSets = propertyDataResults.ToDictionary(r => r.Key, r => r.Item2);
        
        // Generate all combinations
        if (!classDataSets.Any())
            classDataSets.Add(Array.Empty<object?>());
        if (!methodDataSets.Any())
            methodDataSets.Add(Array.Empty<object?>());
        
        foreach (var classData in classDataSets)
        {
            foreach (var methodData in methodDataSets)
            {
                var propertyData = new Dictionary<PropertyInfo, object?>();
                
                // Get property values for this combination
                foreach (var (property, dataSets) in propertyDataSets)
                {
                    if (dataSets.Any())
                    {
                        // For now, take the first value - could be enhanced to create more combinations
                        propertyData[property] = dataSets.First().FirstOrDefault();
                    }
                }
                
                combinations.Add(new TestCombination
                {
                    ClassArguments = classData,
                    MethodArguments = methodData,
                    PropertyValues = propertyData
                });
            }
        }
        
        return combinations;
    }
    
    private async Task<List<object?[]>> GetDataSetsAsync(
        IEnumerable<IDataSourceProvider> dataSourceProviders, 
        CancellationToken cancellationToken)
    {
        var allDataSets = new List<object?[]>();
        
        // Process data sources in parallel for better performance
        var tasks = dataSourceProviders.Select(async provider =>
        {
            var data = await provider.GetDataAsync(cancellationToken);
            return data.ToList();
        }).ToArray();
        
        var results = await Task.WhenAll(tasks);
        
        foreach (var dataSet in results.SelectMany(r => r))
        {
            allDataSets.Add(dataSet);
        }
        
        return allDataSets;
    }
    
    private async Task<TestDefinition?> BuildSingleTestDefinitionAsync(
        TestMetadata metadata,
        TestCombination combination,
        int testIndex,
        int repeatIndex,
        CompiledFactories factories,
        CancellationToken cancellationToken)
    {
        // Create unique test ID
        var testId = metadata.TestIdTemplate
            .Replace("{TestIndex}", testIndex.ToString())
            .Replace("{RepeatIndex}", repeatIndex.ToString());
        
        // Build display name
        var displayName = BuildDisplayName(metadata.DisplayNameTemplate, combination.MethodArguments);
        
        // Create test class factory
        Func<object?> testClassFactory = () =>
        {
            return factories.ClassFactory(combination.ClassArguments);
        };
        
        // Create test method invoker
        Func<object, object?[], object?> testMethodInvoker = (instance, args) =>
        {
            return factories.MethodInvoker(instance, args);
        };
        
        // Create property setter
        Func<Dictionary<string, object?>> propertiesProvider = () =>
        {
            var props = new Dictionary<string, object?>();
            foreach (var (property, value) in combination.PropertyValues)
            {
                props[property.Name] = value;
            }
            return props;
        };
        
        // Handle tuple unwrapping for method arguments
        var unwrappedMethodArgs = await UnwrapTuplesAsync(combination.MethodArguments, cancellationToken);
        
        return new TestDefinition
        {
            TestId = testId,
            MethodMetadata = metadata.MethodMetadata,
            TestFilePath = metadata.TestFilePath,
            TestLineNumber = metadata.TestLineNumber,
            TestClassFactory = testClassFactory,
            TestMethodInvoker = testMethodInvoker,
            ClassArgumentsProvider = () => combination.ClassArguments,
            MethodArgumentsProvider = () => unwrappedMethodArgs,
            PropertiesProvider = propertiesProvider,
            PropertySetters = factories.PropertySetters,
            TestCombination = combination,
            DisplayName = displayName,
            Timeout = metadata.Timeout,
            IsSkipped = metadata.IsSkipped,
            SkipReason = metadata.SkipReason
        };
    }
    
    private string BuildDisplayName(string template, object?[] methodArguments)
    {
        var displayName = template;
        
        // Replace placeholders with actual values
        for (int i = 0; i < methodArguments.Length; i++)
        {
            var value = methodArguments[i];
            var formattedValue = FormatArgumentValue(value);
            displayName = displayName.Replace($"{{{i}}}", formattedValue);
        }
        
        return displayName;
    }
    
    private string FormatArgumentValue(object? value)
    {
        if (value == null)
            return "null";
        
        if (value is string str)
            return $"\"{str}\"";
        
        if (value is char ch)
            return $"'{ch}'";
        
        if (value is bool b)
            return b.ToString().ToLower();
        
        if (value.GetType().IsArray)
        {
            var array = (Array)value;
            var elements = new List<string>();
            foreach (var element in array)
            {
                elements.Add(FormatArgumentValue(element));
            }
            return $"[{string.Join(", ", elements)}]";
        }
        
        return value.ToString() ?? "null";
    }
    
    private async Task<object?[]> UnwrapTuplesAsync(object?[] arguments, CancellationToken cancellationToken)
    {
        if (arguments.Length != 1)
            return arguments;
        
        var singleArg = arguments[0];
        if (singleArg == null)
            return arguments;
        
        var argType = singleArg.GetType();
        if (!IsTupleType(argType))
            return arguments;
        
        // Unwrap tuple into individual values
        var tupleValues = new List<object?>();
        var fields = argType.GetFields();
        
        foreach (var field in fields.Where(f => f.Name.StartsWith("Item")))
        {
            var value = field.GetValue(singleArg);
            tupleValues.Add(value);
        }
        
        return tupleValues.ToArray();
    }
    
    private bool IsTupleType(Type type)
    {
        return TupleTypeCache.GetOrAdd(type, t =>
        {
            if (!t.IsGenericType)
                return false;
            
            var genericTypeDef = t.GetGenericTypeDefinition();
            return genericTypeDef == typeof(ValueTuple<>) ||
                   genericTypeDef == typeof(ValueTuple<,>) ||
                   genericTypeDef == typeof(ValueTuple<,,>) ||
                   genericTypeDef == typeof(ValueTuple<,,,>) ||
                   genericTypeDef == typeof(ValueTuple<,,,,>) ||
                   genericTypeDef == typeof(ValueTuple<,,,,,>) ||
                   genericTypeDef == typeof(ValueTuple<,,,,,,>) ||
                   genericTypeDef == typeof(ValueTuple<,,,,,,,>) ||
                   genericTypeDef == typeof(Tuple<>) ||
                   genericTypeDef == typeof(Tuple<,>) ||
                   genericTypeDef == typeof(Tuple<,,>) ||
                   genericTypeDef == typeof(Tuple<,,,>) ||
                   genericTypeDef == typeof(Tuple<,,,,>) ||
                   genericTypeDef == typeof(Tuple<,,,,,>) ||
                   genericTypeDef == typeof(Tuple<,,,,,,>) ||
                   genericTypeDef == typeof(Tuple<,,,,,,,>);
        });
    }
    
    private class TestCombination
    {
        public object?[] ClassArguments { get; set; } = Array.Empty<object?>();
        public object?[] MethodArguments { get; set; } = Array.Empty<object?>();
        public Dictionary<PropertyInfo, object?> PropertyValues { get; set; } = new();
    }
    
    private class CompiledFactories
    {
        public Func<object?[], object> ClassFactory { get; set; } = null!;
        public Func<object?, object?[], object?> MethodInvoker { get; set; } = null!;
        public Dictionary<PropertyInfo, Action<object, object?>> PropertySetters { get; set; } = new();
    }
}

// Extension to support existing TestDefinition
public static class TestDefinitionExtensions
{
    public static void SetPropertyValues(this TestDefinition testDefinition, object instance)
    {
        if (testDefinition.PropertySetters == null)
            return;
        
        var propertyValues = testDefinition.PropertiesProvider();
        foreach (var (property, setter) in testDefinition.PropertySetters)
        {
            if (propertyValues.TryGetValue(property.Name, out var value))
            {
                setter(instance, value);
            }
        }
    }
}

// Update TestDefinition to include new fields if needed
public partial class TestDefinition
{
    internal Dictionary<PropertyInfo, Action<object, object?>>? PropertySetters { get; set; }
    internal object? TestCombination { get; set; }
    internal string? DisplayName { get; set; }
    internal bool IsSkipped { get; set; }
    internal string? SkipReason { get; set; }
    internal TimeSpan? Timeout { get; set; }
}